// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = function print(x) {
    process['stdout'].write(x + '\n');
  };
  if (!Module['printErr']) Module['printErr'] = function printErr(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function read(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) { return Module['read'](filename, true) };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  } else {
    Module['thisProgram'] = 'unknown-program';
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  this['Module'] = Module;

}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.log(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WEB) {
    window['Module'] = Module;
  } else {
    Module['load'] = importScripts;
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
if (!Module['thisProgram']) {
  Module['thisProgram'] = './this.program';
}

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in: 
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at: 
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  setTempRet0: function (value) {
    tempRet0 = value;
  },
  getTempRet0: function () {
    return tempRet0;
  },
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  STACK_ALIGN: 16,
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [null,null,null,null,null,null,null,null],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  getAsmConst: function (code, numArgs) {
    // code is a constant string on the heap, so we can cache these
    if (!Runtime.asmConstCache) Runtime.asmConstCache = {};
    var func = Runtime.asmConstCache[code];
    if (func) return func;
    var args = [];
    for (var i = 0; i < numArgs; i++) {
      args.push(String.fromCharCode(36) + i); // $0, $1 etc
    }
    var source = Pointer_stringify(code);
    if (source[0] === '"') {
      // tolerate EM_ASM("..code..") even though EM_ASM(..code..) is correct
      if (source.indexOf('"', 1) === source.length-1) {
        source = source.substr(1, source.length-2);
      } else {
        // something invalid happened, e.g. EM_ASM("..code($0)..", input)
        abort('invalid EM_ASM input |' + source + '|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)');
      }
    }
    try {
      // Module is the only 'upvar', which we provide directly. We also provide FS for legacy support.
      var evalled = eval('(function(Module, FS) { return function(' + args.join(',') + '){ ' + source + ' } })')(Module, typeof FS !== 'undefined' ? FS : null);
    } catch(e) {
      Module.printErr('error in executing inline EM_ASM code: ' + e + ' on: \n\n' + source + '\n\nwith args |' + args + '| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)');
      throw e;
    }
    return Runtime.asmConstCache[code] = evalled;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[sig]) {
      Runtime.funcWrappers[sig] = {};
    }
    var sigCache = Runtime.funcWrappers[sig];
    if (!sigCache[func]) {
      sigCache[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return sigCache[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xFF;

      if (buffer.length == 0) {
        if ((code & 0x80) == 0x00) {        // 0xxxxxxx
          return String.fromCharCode(code);
        }
        buffer.push(code);
        if ((code & 0xE0) == 0xC0) {        // 110xxxxx
          needed = 1;
        } else if ((code & 0xF0) == 0xE0) { // 1110xxxx
          needed = 2;
        } else {                            // 11110xxx
          needed = 3;
        }
        return '';
      }

      if (needed) {
        buffer.push(code);
        needed--;
        if (needed > 0) return '';
      }

      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var c4 = buffer[3];
      var ret;
      if (buffer.length == 2) {
        ret = String.fromCharCode(((c1 & 0x1F) << 6)  | (c2 & 0x3F));
      } else if (buffer.length == 3) {
        ret = String.fromCharCode(((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6)  | (c3 & 0x3F));
      } else {
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var codePoint = ((c1 & 0x07) << 18) | ((c2 & 0x3F) << 12) |
                        ((c3 & 0x3F) << 6)  | (c4 & 0x3F);
        ret = String.fromCharCode(
          (((codePoint - 0x10000) / 0x400)|0) + 0xD800,
          (codePoint - 0x10000) % 0x400 + 0xDC00);
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function processJSString(string) {
      /* TODO: use TextEncoder when present,
        var encoder = new TextEncoder();
        encoder['encoding'] = "utf-8";
        var utf8Array = encoder['encode'](aMsg.data);
      */
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*(+4294967296))) : ((+((low>>>0)))+((+((high|0)))*(+4294967296)))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}


Module['Runtime'] = Runtime;

function jsCall() {
  var args = Array.prototype.slice.call(arguments);
  return Runtime.functionPointers[args[0]].apply(null, args.slice(1));
}








//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD, tempDouble, tempFloat;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  if (!func) {
    try {
      func = eval('_' + ident); // explicit lookup
    } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var stack = 0;
  var JSfuncs = {
    'stackSave' : function() {
      stack = Runtime.stackSave();
    },
    'stackRestore' : function() {
      Runtime.stackRestore(stack);
    },
    // type conversion from js to c
    'arrayToC' : function(arr) {
      var ret = Runtime.stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        ret = Runtime.stackAlloc((str.length << 2) + 1);
        writeStringToMemory(str, ret);
      }
      return ret;
    }
  };
  // For fast lookup of conversion functions
  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

  // C calling interface. 
  ccall = function ccallFunc(ident, returnType, argTypes, args) {
    var func = getCFunc(ident);
    var cArgs = [];
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) stack = Runtime.stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);
    if (stack !== 0) JSfuncs['stackRestore']();
    return ret;
  }

  var sourceRegex = /^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
  function parseJSFunc(jsfunc) {
    // Match the body and the return value of a javascript function source
    var parsed = jsfunc.toString().match(sourceRegex).slice(1);
    return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}
  }
  var JSsource = {};
  for (var fun in JSfuncs) {
    if (JSfuncs.hasOwnProperty(fun)) {
      // Elements of toCsource are arrays of three items:
      // the code, and the return value
      JSsource[fun] = parseJSFunc(JSfuncs[fun]);
    }
  }

  
  cwrap = function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident);
    // When the function takes numbers and returns a number, we can just return
    // the original function
    var numericArgs = argTypes.every(function(type){ return type === 'number'});
    var numericRet = (returnType !== 'string');
    if ( numericRet && numericArgs) {
      return cfunc;
    }
    // Creation of the arguments list (["$1","$2",...,"$nargs"])
    var argNames = argTypes.map(function(x,i){return '$'+i});
    var funcstr = "(function(" + argNames.join(',') + ") {";
    var nargs = argTypes.length;
    if (!numericArgs) {
      // Generate the code needed to convert the arguments from javascript
      // values to pointers
      funcstr += JSsource['stackSave'].body + ';';
      for (var i = 0; i < nargs; i++) {
        var arg = argNames[i], type = argTypes[i];
        if (type === 'number') continue;
        var convertCode = JSsource[type + 'ToC']; // [code, return]
        funcstr += 'var ' + convertCode.arguments + ' = ' + arg + ';';
        funcstr += convertCode.body + ';';
        funcstr += arg + '=' + convertCode.returnValue + ';';
      }
    }

    // When the code is compressed, the name of cfunc is not literally 'cfunc' anymore
    var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;
    // Call the function
    funcstr += 'var ret = ' + cfuncname + '(' + argNames.join(',') + ');';
    if (!numericRet) { // Return type can only by 'string' or 'number'
      // Convert the result to a string
      var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;
      funcstr += 'ret = ' + strgfy + '(ret);';
    }
    if (!numericArgs) {
      // If we had a stack, restore it
      funcstr += JSsource['stackRestore'].body + ';';
    }
    funcstr += 'return ret})';
    return eval(funcstr);
  };
})();
Module["cwrap"] = cwrap;
Module["ccall"] = ccall;


function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;


function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = false;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    if (t >= 128) hasUtf = true;
    else if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (!hasUtf) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }

  var utf8 = new Runtime.UTF8Processor();
  for (i = 0; i < length; i++) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    ret += utf8.processCChar(t);
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}
Module['UTF16ToString'] = UTF16ToString;


function stringToUTF16(str, outPtr) {
  for(var i = 0; i < str.length; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[(((outPtr)+(i*2))>>1)]=codeUnit;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[(((outPtr)+(str.length*2))>>1)]=0;
}
Module['stringToUTF16'] = stringToUTF16;


function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}
Module['UTF32ToString'] = UTF32ToString;


function stringToUTF32(str, outPtr) {
  var iChar = 0;
  for(var iCodeUnit = 0; iCodeUnit < str.length; ++iCodeUnit) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    var codeUnit = str.charCodeAt(iCodeUnit); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++iCodeUnit);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[(((outPtr)+(iChar*4))>>2)]=codeUnit;
    ++iChar;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[(((outPtr)+(iChar*4))>>2)]=0;
}
Module['stringToUTF32'] = stringToUTF32;

function demangle(func) {
  var hasLibcxxabi = !!Module['___cxa_demangle'];
  if (hasLibcxxabi) {
    try {
      var buf = _malloc(func.length);
      writeStringToMemory(func.substr(1), buf);
      var status = _malloc(4);
      var ret = Module['___cxa_demangle'](buf, 0, 0, status);
      if (getValue(status, 'i32') === 0 && ret) {
        return Pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed, we can try ours which may return a partial result
    } catch(e) {
      // failure when using libcxxabi, we can try ours which may return a partial result
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
  }
  var i = 3;
  // params, etc.
  var basicTypes = {
    'v': 'void',
    'b': 'bool',
    'c': 'char',
    's': 'short',
    'i': 'int',
    'l': 'long',
    'f': 'float',
    'd': 'double',
    'w': 'wchar_t',
    'a': 'signed char',
    'h': 'unsigned char',
    't': 'unsigned short',
    'j': 'unsigned int',
    'm': 'unsigned long',
    'x': 'long long',
    'y': 'unsigned long long',
    'z': '...'
  };
  var subs = [];
  var first = true;
  function dump(x) {
    //return;
    if (x) Module.print(x);
    Module.print(func);
    var pre = '';
    for (var a = 0; a < i; a++) pre += ' ';
    Module.print (pre + '^');
  }
  function parseNested() {
    i++;
    if (func[i] === 'K') i++; // ignore const
    var parts = [];
    while (func[i] !== 'E') {
      if (func[i] === 'S') { // substitution
        i++;
        var next = func.indexOf('_', i);
        var num = func.substring(i, next) || 0;
        parts.push(subs[num] || '?');
        i = next+1;
        continue;
      }
      if (func[i] === 'C') { // constructor
        parts.push(parts[parts.length-1]);
        i += 2;
        continue;
      }
      var size = parseInt(func.substr(i));
      var pre = size.toString().length;
      if (!size || !pre) { i--; break; } // counter i++ below us
      var curr = func.substr(i + pre, size);
      parts.push(curr);
      subs.push(curr);
      i += pre + size;
    }
    i++; // skip E
    return parts;
  }
  function parse(rawList, limit, allowVoid) { // main parser
    limit = limit || Infinity;
    var ret = '', list = [];
    function flushList() {
      return '(' + list.join(', ') + ')';
    }
    var name;
    if (func[i] === 'N') {
      // namespaced N-E
      name = parseNested().join('::');
      limit--;
      if (limit === 0) return rawList ? [name] : name;
    } else {
      // not namespaced
      if (func[i] === 'K' || (first && func[i] === 'L')) i++; // ignore const and first 'L'
      var size = parseInt(func.substr(i));
      if (size) {
        var pre = size.toString().length;
        name = func.substr(i + pre, size);
        i += pre + size;
      }
    }
    first = false;
    if (func[i] === 'I') {
      i++;
      var iList = parse(true);
      var iRet = parse(true, 1, true);
      ret += iRet[0] + ' ' + name + '<' + iList.join(', ') + '>';
    } else {
      ret = name;
    }
    paramLoop: while (i < func.length && limit-- > 0) {
      //dump('paramLoop');
      var c = func[i++];
      if (c in basicTypes) {
        list.push(basicTypes[c]);
      } else {
        switch (c) {
          case 'P': list.push(parse(true, 1, true)[0] + '*'); break; // pointer
          case 'R': list.push(parse(true, 1, true)[0] + '&'); break; // reference
          case 'L': { // literal
            i++; // skip basic type
            var end = func.indexOf('E', i);
            var size = end - i;
            list.push(func.substr(i, size));
            i += size + 2; // size + 'EE'
            break;
          }
          case 'A': { // array
            var size = parseInt(func.substr(i));
            i += size.toString().length;
            if (func[i] !== '_') throw '?';
            i++; // skip _
            list.push(parse(true, 1, true)[0] + ' [' + size + ']');
            break;
          }
          case 'E': break paramLoop;
          default: ret += '?' + c; break paramLoop;
        }
      }
    }
    if (!allowVoid && list.length === 1 && list[0] === 'void') list = []; // avoid (void)
    if (rawList) {
      if (ret) {
        list.push(ret + '?');
      }
      return list;
    } else {
      return ret + flushList();
    }
  }
  var final = func;
  try {
    // Special-case the entry point, since its name differs from other name mangling.
    if (func == 'Object._main' || func == '_main') {
      return 'main()';
    }
    if (typeof func === 'number') func = Pointer_stringify(func);
    if (func[0] !== '_') return func;
    if (func[1] !== '_') return func; // C function
    if (func[2] !== 'Z') return func;
    switch (func[3]) {
      case 'n': return 'operator new()';
      case 'd': return 'operator delete()';
    }
    final = parse();
  } catch(e) {
    final += '?';
  }
  if (final.indexOf('?') >= 0 && !hasLibcxxabi) {
    Runtime.warnOnce('warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  }
  return final;
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  return demangleAll(jsStackTrace());
}
Module['stackTrace'] = stackTrace;

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return (x+4095)&-4096;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk

function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 134217728;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

var totalMemory = 64*1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be compliant with the asm.js spec');
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'JS engine does not provide full typed array support');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['buffer'] = buffer;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;

function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;

// Tools


function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))>>0)]=chr;
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))>>0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; i++) {
    HEAP8[(((buffer)+(i))>>0)]=str.charCodeAt(i);
  }
  if (!dontAddNull) HEAP8[(((buffer)+(str.length))>>0)]=0;
}
Module['writeAsciiToMemory'] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;

// === Body ===





STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 13248;
  /* global initializers */ __ATINIT__.push();
  

/* memory initializer */ allocate([0,0,0,0,0,96,127,64,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37,115,10,0,0,0,0,0,115,116,97,99,107,32,116,114,97,99,101,98,97,99,107,58,0,0,0,0,0,0,0,0,10,9,46,46,46,0,0,0,83,108,110,116,0,0,0,0,10,9,37,115,58,0,0,0,37,100,58,0,0,0,0,0,32,105,110,32,0,0,0,0,10,9,40,46,46,46,116,97,105,108,32,99,97,108,108,115,46,46,46,41,0,0,0,0,98,97,100,32,97,114,103,117,109,101,110,116,32,35,37,100,32,40,37,115,41,0,0,0,110,0,0,0,0,0,0,0,109,101,116,104,111,100,0,0,99,97,108,108,105,110,103,32,39,37,115,39,32,111,110,32,98,97,100,32,115,101,108,102,32,40,37,115,41,0,0,0,63,0,0,0,0,0,0,0,98,97,100,32,97,114,103,117,109,101,110,116,32,35,37,100,32,116,111,32,39,37,115,39,32,40,37,115,41,0,0,0,83,108,0,0,0,0,0,0,37,115,58,37,100,58,32,0,0,0,0,0,0,0,0,0,37,115,58,32,37,115,0,0,101,120,105,116,0,0,0,0,105,110,118,97,108,105,100,32,111,112,116,105,111,110,32,39,37,115,39,0,0,0,0,0,115,116,97,99,107,32,111,118,101,114,102,108,111,119,32,40,37,115,41,0,0,0,0,0,115,116,97,99,107,32,111,118,101,114,102,108,111,119,0,0,118,97,108,117,101,32,101,120,112,101,99,116,101,100,0,0,98,117,102,102,101,114,32,116,111,111,32,108,97,114,103,101,0,0,0,0,0,0,0,0,61,115,116,100,105,110,0,0,64,37,115,0,0,0,0,0,114,0,0,0,0,0,0,0,111,112,101,110,0,0,0,0,114,98,0,0,0,0,0,0,114,101,111,112,101,110,0,0,114,101,97,100,0,0,0,0,111,98,106,101,99,116,32,108,101,110,103,116,104,32,105,115,32,110,111,116,32,97,32,110,117,109,98,101,114,0,0,0,95,95,116,111,115,116,114,105,110,103,0,0,0,0,0,0,116,114,117,101,0,0,0,0,102,97,108,115,101,0,0,0,110,105,108,0,0,0,0,0,37,115,58,32,37,112,0,0,95,76,79,65,68,69,68,0,110,97,109,101,32,99,111,110,102,108,105,99,116,32,102,111,114,32,109,111,100,117,108,101,32,39,37,115,39,0,0,0,116,111,111,32,109,97,110,121,32,117,112,118,97,108,117,101,115,0,0,0,0,0,0,0,109,117,108,116,105,112,108,101,32,76,117,97,32,86,77,115,32,100,101,116,101,99,116,101,100,0,0,0,0,0,0,0,118,101,114,115,105,111,110,32,109,105,115,109,97,116,99,104,58,32,97,112,112,46,32,110,101,101,100,115,32,37,102,44,32,76,117,97,32,99,111,114,101,32,112,114,111,118,105,100,101,115,32,37,102,0,0,0,98,97,100,32,99,111,110,118,101,114,115,105,111,110,32,110,117,109,98,101,114,45,62,105,110,116,59,32,109,117,115,116,32,114,101,99,111,109,112,105,108,101,32,76,117,97,32,119,105,116,104,32,112,114,111,112,101,114,32,115,101,116,116,105,110,103,115,0,0,0,0,0,80,65,78,73,67,58,32,117,110,112,114,111,116,101,99,116,101,100,32,101,114,114,111,114,32,105,110,32,99,97,108,108,32,116,111,32,76,117,97,32,65,80,73,32,40,37,115,41,10,0,0,0,0,0,0,0,239,187,191,0,0,0,0,0,99,97,110,110,111,116,32,37,115,32,37,115,58,32,37,115,0,0,0,0,0,0,0,0,37,115,32,101,120,112,101,99,116,101,100,44,32,103,111,116,32,37,115,0,0,0,0,0,102,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,102,117,110,99,116,105,111,110,32,39,37,115,39,0,0,0,109,97,105,110,32,99,104,117,110,107,0,0,0,0,0,0,102,117,110,99,116,105,111,110,32,60,37,115,58,37,100,62,0,0,0,0,0,0,0,0,95,71,0,0,0,0,0,0,128,4,0,0,18,0,0,0,136,4,0,0,19,0,0,0,152,4,0,0,20,0,0,0,160,4,0,0,21,0,0,0,168,4,0,0,22,0,0,0,184,4,0,0,23,0,0,0,192,4,0,0,24,0,0,0,208,4,0,0,25,0,0,0,216,4,0,0,25,0,0,0,232,4,0,0,26,0,0,0,240,4,0,0,27,0,0,0,248,4,0,0,28,0,0,0,0,5,0,0,29,0,0,0,8,5,0,0,30,0,0,0,24,5,0,0,31,0,0,0,32,5,0,0,32,0,0,0,40,5,0,0,33,0,0,0,48,5,0,0,34,0,0,0,56,5,0,0,35,0,0,0,72,5,0,0,36,0,0,0,88,5,0,0,37,0,0,0,104,5,0,0,38,0,0,0,112,5,0,0,39,0,0,0,0,0,0,0,0,0,0,0,76,117,97,32,53,46,50,0,95,86,69,82,83,73,79,78,0,0,0,0,0,0,0,0,97,115,115,101,114,116,0,0,99,111,108,108,101,99,116,103,97,114,98,97,103,101,0,0,100,111,102,105,108,101,0,0,101,114,114,111,114,0,0,0,103,101,116,109,101,116,97,116,97,98,108,101,0,0,0,0,105,112,97,105,114,115,0,0,108,111,97,100,102,105,108,101,0,0,0,0,0,0,0,0,108,111,97,100,0,0,0,0,108,111,97,100,115,116,114,105,110,103,0,0,0,0,0,0,110,101,120,116,0,0,0,0,112,97,105,114,115,0,0,0,112,99,97,108,108,0,0,0,112,114,105,110,116,0,0,0,114,97,119,101,113,117,97,108,0,0,0,0,0,0,0,0,114,97,119,108,101,110,0,0,114,97,119,103,101,116,0,0,114,97,119,115,101,116,0,0,115,101,108,101,99,116,0,0,115,101,116,109,101,116,97,116,97,98,108,101,0,0,0,0,116,111,110,117,109,98,101,114,0,0,0,0,0,0,0,0,116,111,115,116,114,105,110,103,0,0,0,0,0,0,0,0,116,121,112,101,0,0,0,0,120,112,99,97,108,108,0,0,118,97,108,117,101,32,101,120,112,101,99,116,101,100,0,0,115,116,97,99,107,32,111,118,101,114,102,108,111,119,0,0,98,97,115,101,32,111,117,116,32,111,102,32,114,97,110,103,101,0,0,0,0,0,0,0,32,12,10,13,9,11,0,0,110,105,108,32,111,114,32,116,97,98,108,101,32,101,120,112,101,99,116,101,100,0,0,0,95,95,109,101,116,97,116,97,98,108,101,0,0,0,0,0,99,97,110,110,111,116,32,99,104,97,110,103,101,32,97,32,112,114,111,116,101,99,116,101,100,32,109,101,116,97,116,97,98,108,101,0,0,0,0,0,105,110,100,101,120,32,111,117,116,32,111,102,32,114,97,110,103,101,0,0,0,0,0,0,116,97,98,108,101,32,111,114,32,115,116,114,105,110,103,32,101,120,112,101,99,116,101,100,0,0,0,0,0,0,0,0,39,116,111,115,116,114,105,110,103,39,32,109,117,115,116,32,114,101,116,117,114,110,32,97,32,115,116,114,105,110,103,32,116,111,32,39,112,114,105,110,116,39,0,0,0,0,0,0,95,95,112,97,105,114,115,0,98,116,0,0,0,0,0,0,61,40,108,111,97,100,41,0,116,111,111,32,109,97,110,121,32,110,101,115,116,101,100,32,102,117,110,99,116,105,111,110,115,0,0,0,0,0,0,0,114,101,97,100,101,114,32,102,117,110,99,116,105,111,110,32,109,117,115,116,32,114,101,116,117,114,110,32,97,32,115,116,114,105,110,103,0,0,0,0,95,95,105,112,97,105,114,115,0,0,0,0,0,0,0,0,16,7,0,0,24,7,0,0,32,7,0,0,40,7,0,0,48,7,0,0,56,7,0,0,72,7,0,0,88,7,0,0,104,7,0,0,120,7,0,0,136,7,0,0,0,0,0,0,115,116,111,112,0,0,0,0,114,101,115,116,97,114,116,0,99,111,108,108,101,99,116,0,99,111,117,110,116,0,0,0,115,116,101,112,0,0,0,0,115,101,116,112,97,117,115,101,0,0,0,0,0,0,0,0,115,101,116,115,116,101,112,109,117,108,0,0,0,0,0,0,115,101,116,109,97,106,111,114,105,110,99,0,0,0,0,0,105,115,114,117,110,110,105,110,103,0,0,0,0,0,0,0,103,101,110,101,114,97,116,105,111,110,97,108,0,0,0,0,105,110,99,114,101,109,101,110,116,97,108,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,0,0,0,0,37,115,0,0,0,0,0,0,97,115,115,101,114,116,105,111,110,32,102,97,105,108,101,100,33,0,0,0,0,0,0,0,80,8,0,0,40,0,0,0,88,8,0,0,41,0,0,0,96,8,0,0,42,0,0,0,104,8,0,0,43,0,0,0,112,8,0,0,44,0,0,0,120,8,0,0,45,0,0,0,128,8,0,0,46,0,0,0,136,8,0,0,47,0,0,0,144,8,0,0,48,0,0,0,152,8,0,0,49,0,0,0,160,8,0,0,50,0,0,0,168,8,0,0,51,0,0,0,0,0,0,0,0,0,0,0,97,114,115,104,105,102,116,0,98,97,110,100,0,0,0,0,98,110,111,116,0,0,0,0,98,111,114,0,0,0,0,0,98,120,111,114,0,0,0,0,98,116,101,115,116,0,0,0,101,120,116,114,97,99,116,0,108,114,111,116,97,116,101,0,108,115,104,105,102,116,0,0,114,101,112,108,97,99,101,0,114,114,111,116,97,116,101,0,114,115,104,105,102,116,0,0,102,105,101,108,100,32,99,97,110,110,111,116,32,98,101,32,110,101,103,97,116,105,118,101,0,0,0,0,0,0,0,0,119,105,100,116,104,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101,0,0,116,114,121,105,110,103,32,116,111,32,97,99,99,101,115,115,32,110,111,110,45,101,120,105,115,116,101,110,116,32,98,105,116,115,0,0,0,0,0,0,102,117,110,99,116,105,111,110,32,111,114,32,101,120,112,114,101,115,115,105,111,110,32,116,111,111,32,99,111,109,112,108,101,120,0,0,0,0,0,0,99,111,110,115,116,114,117,99,116,111,114,32,116,111,111,32,108,111,110,103,0,0,0,0,99,111,110,115,116,97,110,116,115,0,0,0,0,0,0,0,111,112,99,111,100,101,115,0,99,111,110,116,114,111,108,32,115,116,114,117,99,116,117,114,101,32,116,111,111,32,108,111,110,103,0,0,0,0,0,0,192,9,0,0,52,0,0,0,200,9,0,0,53,0,0,0,208,9,0,0,54,0,0,0,216,9,0,0,55,0,0,0,224,9,0,0,56,0,0,0,232,9,0,0,57,0,0,0,0,0,0,0,0,0,0,0,99,114,101,97,116,101,0,0,114,101,115,117,109,101,0,0,114,117,110,110,105,110,103,0,115,116,97,116,117,115,0,0,119,114,97,112,0,0,0,0,121,105,101,108,100,0,0,0,116,111,111,32,109,97,110,121,32,97,114,103,117,109,101,110,116,115,32,116,111,32,114,101,115,117,109,101,0,0,0,0,99,97,110,110,111,116,32,114,101,115,117,109,101,32,100,101,97,100,32,99,111,114,111,117,116,105,110,101,0,0,0,0,116,111,111,32,109,97,110,121,32,114,101,115,117,108,116,115,32,116,111,32,114,101,115,117,109,101,0,0,0,0,0,0,99,111,114,111,117,116,105,110,101,32,101,120,112,101,99,116,101,100,0,0,0,0,0,0,115,117,115,112,101,110,100,101,100,0,0,0,0,0,0,0,110,111,114,109,97,108,0,0,100,101,97,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,22,22,22,22,22,22,22,22,22,22,4,4,4,4,4,4,4,21,21,21,21,21,21,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,5,4,21,21,21,21,21,21,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,12,0,0,58,0,0,0,32,12,0,0,59,0,0,0,48,12,0,0,60,0,0,0,56,12,0,0,61,0,0,0,64,12,0,0,62,0,0,0,80,12,0,0,63,0,0,0,96,12,0,0,64,0,0,0,112,12,0,0,65,0,0,0,128,12,0,0,66,0,0,0,144,12,0,0,67,0,0,0,160,12,0,0,68,0,0,0,176,12,0,0,69,0,0,0,184,12,0,0,70,0,0,0,200,12,0,0,71,0,0,0,216,12,0,0,72,0,0,0,232,12,0,0,73,0,0,0,0,0,0,0,0,0,0,0,100,101,98,117,103,0,0,0,103,101,116,117,115,101,114,118,97,108,117,101,0,0,0,0,103,101,116,104,111,111,107,0,103,101,116,105,110,102,111,0,103,101,116,108,111,99,97,108,0,0,0,0,0,0,0,0,103,101,116,114,101,103,105,115,116,114,121,0,0,0,0,0,103,101,116,109,101,116,97,116,97,98,108,101,0,0,0,0,103,101,116,117,112,118,97,108,117,101,0,0,0,0,0,0,117,112,118,97,108,117,101,106,111,105,110,0,0,0,0,0,117,112,118,97,108,117,101,105,100,0,0,0,0,0,0,0,115,101,116,117,115,101,114,118,97,108,117,101,0,0,0,0,115,101,116,104,111,111,107,0,115,101,116,108,111,99,97,108,0,0,0,0,0,0,0,0,115,101,116,109,101,116,97,116,97,98,108,101,0,0,0,0,115,101,116,117,112,118,97,108,117,101,0,0,0,0,0,0,116,114,97,99,101,98,97,99,107,0,0,0,0,0,0,0,110,105,108,32,111,114,32,116,97,98,108,101,32,101,120,112,101,99,116,101,100,0,0,0,108,101,118,101,108,32,111,117,116,32,111,102,32,114,97,110,103,101,0,0,0,0,0,0,95,72,75,69,89,0,0,0,107,0,0,0,0,0,0,0,95,95,109,111,100,101,0,0,88,13,0,0,96,13,0,0,104,13,0,0,112,13,0,0,120,13,0,0,0,0,0,0,99,97,108,108,0,0,0,0,114,101,116,117,114,110,0,0,108,105,110,101,0,0,0,0,99,111,117,110,116,0,0,0,116,97,105,108,32,99,97,108,108,0,0,0,0,0,0,0,102,117,108,108,32,117,115,101,114,100,97,116,97,32,101,120,112,101,99,116,101,100,44,32,103,111,116,32,108,105,103,104,116,32,117,115,101,114,100,97,116,97,0,0,0,0,0,0,62,117,0,0,0,0,0,0,105,110,118,97,108,105,100,32,117,112,118,97,108,117,101,32,105,110,100,101,120,0,0,0,76,117,97,32,102,117,110,99,116,105,111,110,32,101,120,112,101,99,116,101,100,0,0,0,102,108,110,83,116,117,0,0,62,37,115,0,0,0,0,0,102,117,110,99,116,105,111,110,32,111,114,32,108,101,118,101,108,32,101,120,112,101,99,116,101,100,0,0,0,0,0,0,105,110,118,97,108,105,100,32,111,112,116,105,111,110,0,0,115,111,117,114,99,101,0,0,115,104,111,114,116,95,115,114,99,0,0,0,0,0,0,0,108,105,110,101,100,101,102,105,110,101,100,0,0,0,0,0,108,97,115,116,108,105,110,101,100,101,102,105,110,101,100,0,119,104,97,116,0,0,0,0,99,117,114,114,101,110,116,108,105,110,101,0,0,0,0,0,110,117,112,115,0,0,0,0,110,112,97,114,97,109,115,0,105,115,118,97,114,97,114,103,0,0,0,0,0,0,0,0,110,97,109,101,0,0,0,0,110,97,109,101,119,104,97,116,0,0,0,0,0,0,0,0,105,115,116,97,105,108,99,97,108,108,0,0,0,0,0,0,97,99,116,105,118,101,108,105,110,101,115,0,0,0,0,0,102,117,110,99,0,0,0,0,101,120,116,101,114,110,97,108,32,104,111,111,107,0,0,0,108,117,97,95,100,101,98,117,103,62,32,0,0,0,0,0,99,111,110,116,10,0,0,0,61,40,100,101,98,117,103,32,99,111,109,109,97,110,100,41,0,0,0,0,0,0,0,0,37,115,10,0,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,37,115,32,37,115,32,39,37,115,39,32,40,97,32,37,115,32,118,97,108,117,101,41,0,0,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,37,115,32,97,32,37,115,32,118,97,108,117,101,0,0,0,0,0,0,0,0,99,111,110,99,97,116,101,110,97,116,101,0,0,0,0,0,112,101,114,102,111,114,109,32,97,114,105,116,104,109,101,116,105,99,32,111,110,0,0,0,97,116,116,101,109,112,116,32,116,111,32,99,111,109,112,97,114,101,32,116,119,111,32,37,115,32,118,97,108,117,101,115,0,0,0,0,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,99,111,109,112,97,114,101,32,37,115,32,119,105,116,104,32,37,115,0,0,0,37,115,58,37,100,58,32,37,115,0,0,0,0,0,0,0,108,111,99,97,108,0,0,0,95,69,78,86,0,0,0,0,103,108,111,98,97,108,0,0,102,105,101,108,100,0,0,0,117,112,118,97,108,117,101,0,99,111,110,115,116,97,110,116,0,0,0,0,0,0,0,0,109,101,116,104,111,100,0,0,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,102,111,114,32,105,116,101,114,97,116,111,114,0,0,0,0,109,101,116,97,109,101,116,104,111,100,0,0,0,0,0,0,61,91,67,93,0,0,0,0,67,0,0,0,0,0,0,0,61,63,0,0,0,0,0,0,109,97,105,110,0,0,0,0,76,117,97,0,0,0,0,0,40,42,116,101,109,112,111,114,97,114,121,41,0,0,0,0,40,42,118,97,114,97,114,103,41,0,0,0,0,0,0,0,115,116,97,99,107,32,111,118,101,114,102,108,111,119,0,0,67,32,115,116,97,99,107,32,111,118,101,114,102,108,111,119,0,0,0,0,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,121,105,101,108,100,32,97,99,114,111,115,115,32,97,32,67,45,99,97,108,108,32,98,111,117,110,100,97,114,121,0,0,0,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,121,105,101,108,100,32,102,114,111,109,32,111,117,116,115,105,100,101,32,97,32,99,111,114,111,117,116,105,110,101,0,0,0,0,0,0,0,98,105,110,97,114,121,0,0,116,101,120,116,0,0,0,0,97,116,116,101,109,112,116,32,116,111,32,108,111,97,100,32,97,32,37,115,32,99,104,117,110,107,32,40,109,111,100,101,32,105,115,32,39,37,115,39,41,0,0,0,0,0,0,0,101,114,114,111,114,32,105,110,32,101,114,114,111,114,32,104,97,110,100,108,105,110,103,0,99,97,110,110,111,116,32,114,101,115,117,109,101,32,110,111,110,45,115,117,115,112,101,110,100,101,100,32,99,111,114,111,117,116,105,110,101,0,0,0,99,97,110,110,111,116,32,114,101,115,117,109,101,32,100,101,97,100,32,99,111,114,111,117,116,105,110,101,0,0,0,0,99,97,108,108,0,0,0,0,110,111,32,109,101,115,115,97,103,101,0,0,0,0,0,0,101,114,114,111,114,32,105,110,32,95,95,103,99,32,109,101,116,97,109,101,116,104,111,100,32,40,37,115,41,0,0,0,95,80,82,69,76,79,65,68,0,0,0,0,0,0,0,0,95,71,0,0,0,0,0,0,112,97,99,107,97,103,101,0,99,111,114,111,117,116,105,110,101,0,0,0,0,0,0,0,116,97,98,108,101,0,0,0,105,111,0,0,0,0,0,0,111,115,0,0,0,0,0,0,115,116,114,105,110,103,0,0,98,105,116,51,50,0,0,0,109,97,116,104,0,0,0,0,100,101,98,117,103,0,0,0,136,19,0,0,74,0,0,0,144,19,0,0,75,0,0,0,40,21,0,0,76,0,0,0,152,19,0,0,77,0,0,0,48,21,0,0,78,0,0,0,56,21,0,0,79,0,0,0,64,21,0,0,80,0,0,0,160,19,0,0,81,0,0,0,72,21,0,0,82,0,0,0,80,21,0,0,83,0,0,0,184,19,0,0,84,0,0,0,0,0,0,0,0,0,0,0,95,73,79,95,105,110,112,117,116,0,0,0,0,0,0,0,115,116,100,105,110,0,0,0,95,73,79,95,111,117,116,112,117,116,0,0,0,0,0,0,115,116,100,111,117,116,0,0,115,116,100,101,114,114,0,0,70,73,76,69,42,0,0,0,99,97,110,110,111,116,32,99,108,111,115,101,32,115,116,97,110,100,97,114,100,32,102,105,108,101,0,0,0,0,0,0,95,95,105,110,100,101,120,0,136,19,0,0,74,0,0,0,144,19,0,0,85,0,0,0,152,19,0,0,86,0,0,0,160,19,0,0,87,0,0,0,168,19,0,0,88,0,0,0,176,19,0,0,89,0,0,0,184,19,0,0,90,0,0,0,192,19,0,0,91,0,0,0,200,19,0,0,92,0,0,0,0,0,0,0,0,0,0,0,99,108,111,115,101,0,0,0,102,108,117,115,104,0,0,0,108,105,110,101,115,0,0,0,114,101,97,100,0,0,0,0,115,101,101,107,0,0,0,0,115,101,116,118,98,117,102,0,119,114,105,116,101,0,0,0,95,95,103,99,0,0,0,0,95,95,116,111,115,116,114,105,110,103,0,0,0,0,0,0,102,105,108,101,32,40,99,108,111,115,101,100,41,0,0,0,102,105,108,101,32,40,37,112,41,0,0,0,0,0,0,0,37,46,49,52,103,0,0,0,97,116,116,101,109,112,116,32,116,111,32,117,115,101,32,97,32,99,108,111,115,101,100,32,102,105,108,101,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,64,20,0,0,72,20,0,0,80,20,0,0,0,0,0,0,110,111,0,0,0,0,0,0,102,117,108,108,0,0,0,0,108,105,110,101,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,120,20,0,0,128,20,0,0,136,20,0,0,0,0,0,0,115,101,116,0,0,0,0,0,99,117,114,0,0,0,0,0,101,110,100,0,0,0,0,0,110,111,116,32,97,110,32,105,110,116,101,103,101,114,32,105,110,32,112,114,111,112,101,114,32,114,97,110,103,101,0,0,116,111,111,32,109,97,110,121,32,97,114,103,117,109,101,110,116,115,0,0,0,0,0,0,105,110,118,97,108,105,100,32,111,112,116,105,111,110,0,0,105,110,118,97,108,105,100,32,102,111,114,109,97,116,0,0,37,108,102,0,0,0,0,0,116,111,111,32,109,97,110,121,32,111,112,116,105,111,110,115,0,0,0,0,0,0,0,0,102,105,108,101,32,105,115,32,97,108,114,101,97,100,121,32,99,108,111,115,101,100,0,0,37,115,0,0,0,0,0,0,105,110,112,117,116,0,0,0,111,112,101,110,0,0,0,0,111,117,116,112,117,116,0,0,112,111,112,101,110,0,0,0,116,109,112,102,105,108,101,0,116,121,112,101,0,0,0,0,115,116,97,110,100,97,114,100,32,37,115,32,102,105,108,101,32,105,115,32,99,108,111,115,101,100,0,0,0,0,0,0,99,108,111,115,101,100,32,102,105,108,101,0,0,0,0,0,102,105,108,101,0,0,0,0,114,0,0,0,0,0,0,0,39,112,111,112,101,110,39,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,0,0,119,0,0,0,0,0,0,0,99,97,110,110,111,116,32,111,112,101,110,32,102,105,108,101,32,39,37,115,39,32,40,37,115,41,0,0,0,0,0,0,114,119,97,0,0,0,0,0,105,110,118,97,108,105,100,32,109,111,100,101,0,0,0,0,0,24,0,0,8,24,0,0,16,24,0,0,24,24,0,0,32,24,0,0,40,24,0,0,48,24,0,0,56,24,0,0,64,24,0,0,80,24,0,0,88,24,0,0,96,24,0,0,104,24,0,0,112,24,0,0,120,24,0,0,128,24,0,0,136,24,0,0,144,24,0,0,152,24,0,0,160,24,0,0,168,24,0,0,176,24,0,0,184,24,0,0,192,24,0,0,200,24,0,0,208,24,0,0,216,24,0,0,224,24,0,0,232,24,0,0,240,24,0,0,248,24,0,0,8,25,0,0,16,25,0,0,0,0,0,0,39,37,99,39,0,0,0,0,99,104,97,114,40,37,100,41,0,0,0,0,0,0,0,0,39,37,115,39,0,0,0,0,95,69,78,86,0,0,0,0,105,110,118,97,108,105,100,32,108,111,110,103,32,115,116,114,105,110,103,32,100,101,108,105,109,105,116,101,114,0,0,0,46,0,0,0,0,0,0,0,69,101,0,0,0,0,0,0,88,120,0,0,0,0,0,0,80,112,0,0,0,0,0,0,43,45,0,0,0,0,0,0,109,97,108,102,111,114,109,101,100,32,110,117,109,98,101,114,0,0,0,0,0,0,0,0,108,101,120,105,99,97,108,32,101,108,101,109,101,110,116,32,116,111,111,32,108,111,110,103,0,0,0,0,0,0,0,0,117,110,102,105,110,105,115,104,101,100,32,115,116,114,105,110,103,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,101,115,99,97,112,101,32,115,101,113,117,101,110,99,101,0,100,101,99,105,109,97,108,32,101,115,99,97,112,101,32,116,111,111,32,108,97,114,103,101,0,0,0,0,0,0,0,0,104,101,120,97,100,101,99,105,109,97,108,32,100,105,103,105,116,32,101,120,112,101,99,116,101,100,0,0,0,0,0,0,117,110,102,105,110,105,115,104,101,100,32,108,111,110,103,32,115,116,114,105,110,103,0,0,117,110,102,105,110,105,115,104,101,100,32,108,111,110,103,32,99,111,109,109,101,110,116,0,99,104,117,110,107,32,104,97,115,32,116,111,111,32,109,97,110,121,32,108,105,110,101,115,0,0,0,0,0,0,0,0,37,115,58,37,100,58,32,37,115,0,0,0,0,0,0,0,37,115,32,110,101,97,114,32,37,115,0,0,0,0,0,0,97,110,100,0,0,0,0,0,98,114,101,97,107,0,0,0,100,111,0,0,0,0,0,0,101,108,115,101,0,0,0,0,101,108,115,101,105,102,0,0,101,110,100,0,0,0,0,0,102,97,108,115,101,0,0,0,102,111,114,0,0,0,0,0,102,117,110,99,116,105,111,110,0,0,0,0,0,0,0,0,103,111,116,111,0,0,0,0,105,102,0,0,0,0,0,0,105,110,0,0,0,0,0,0,108,111,99,97,108,0,0,0,110,105,108,0,0,0,0,0,110,111,116,0,0,0,0,0,111,114,0,0,0,0,0,0,114,101,112,101,97,116,0,0,114,101,116,117,114,110,0,0,116,104,101,110,0,0,0,0,116,114,117,101,0,0,0,0,117,110,116,105,108,0,0,0,119,104,105,108,101,0,0,0,46,46,0,0,0,0,0,0,46,46,46,0,0,0,0,0,61,61,0,0,0,0,0,0,62,61,0,0,0,0,0,0,60,61,0,0,0,0,0,0,126,61,0,0,0,0,0,0,58,58,0,0,0,0,0,0,60,101,111,102,62,0,0,0,60,110,117,109,98,101,114,62,0,0,0,0,0,0,0,0,60,110,97,109,101,62,0,0,60,115,116,114,105,110,103,62,0,0,0,0,0,0,0,0,24,26,0,0,93,0,0,0,32,26,0,0,94,0,0,0,40,26,0,0,95,0,0,0,48,26,0,0,96,0,0,0,56,26,0,0,97,0,0,0,64,26,0,0,98,0,0,0,72,26,0,0,99,0,0,0,80,26,0,0,100,0,0,0,88,26,0,0,101,0,0,0,96,26,0,0,102,0,0,0,104,26,0,0,103,0,0,0,112,26,0,0,104,0,0,0,120,26,0,0,105,0,0,0,128,26,0,0,106,0,0,0,136,26,0,0,107,0,0,0,144,26,0,0,108,0,0,0,152,26,0,0,109,0,0,0,160,26,0,0,110,0,0,0,168,26,0,0,111,0,0,0,176,26,0,0,112,0,0,0,184,26,0,0,113,0,0,0,192,26,0,0,114,0,0,0,200,26,0,0,115,0,0,0,216,26,0,0,116,0,0,0,224,26,0,0,117,0,0,0,232,26,0,0,118,0,0,0,240,26,0,0,119,0,0,0,248,26,0,0,120,0,0,0,0,0,0,0,0,0,0,0,112,105,0,0,0,0,0,0,104,117,103,101,0,0,0,0,97,98,115,0,0,0,0,0,97,99,111,115,0,0,0,0,97,115,105,110,0,0,0,0,97,116,97,110,50,0,0,0,97,116,97,110,0,0,0,0,99,101,105,108,0,0,0,0,99,111,115,104,0,0,0,0,99,111,115,0,0,0,0,0,100,101,103,0,0,0,0,0,101,120,112,0,0,0,0,0,102,108,111,111,114,0,0,0,102,109,111,100,0,0,0,0,102,114,101,120,112,0,0,0,108,100,101,120,112,0,0,0,108,111,103,49,48,0,0,0,108,111,103,0,0,0,0,0,109,97,120,0,0,0,0,0,109,105,110,0,0,0,0,0,109,111,100,102,0,0,0,0,112,111,119,0,0,0,0,0,114,97,100,0,0,0,0,0,114,97,110,100,111,109,0,0,114,97,110,100,111,109,115,101,101,100,0,0,0,0,0,0,115,105,110,104,0,0,0,0,115,105,110,0,0,0,0,0,115,113,114,116,0,0,0,0,116,97,110,104,0,0,0,0,116,97,110,0,0,0,0,0,105,110,116,101,114,118,97,108,32,105,115,32,101,109,112,116,121,0,0,0,0,0,0,0,119,114,111,110,103,32,110,117,109,98,101,114,32,111,102,32,97,114,103,117,109,101,110,116,115,0,0,0,0,0,0,0,116,111,111,32,109,97,110,121,32,37,115,32,40,108,105,109,105,116,32,105,115,32,37,100,41,0,0,0,0,0,0,0,109,101,109,111,114,121,32,97,108,108,111,99,97,116,105,111,110,32,101,114,114,111,114,58,32,98,108,111,99,107,32,116,111,111,32,98,105,103,0,0,95,67,76,73,66,83,0,0,95,95,103,99,0,0,0,0,56,31,0,0,121,0,0,0,64,31,0,0,122,0,0,0,80,31,0,0,123,0,0,0,0,0,0,0,0,0,0,0,108,111,97,100,101,114,115,0,115,101,97,114,99,104,101,114,115,0,0,0,0,0,0,0,112,97,116,104,0,0,0,0,76,85,65,95,80,65,84,72,95,53,95,50,0,0,0,0,76,85,65,95,80,65,84,72,0,0,0,0,0,0,0,0,47,117,115,114,47,108,111,99,97,108,47,115,104,97,114,101,47,108,117,97,47,53,46,50,47,63,46,108,117,97,59,47,117,115,114,47,108,111,99,97,108,47,115,104,97,114,101,47,108,117,97,47,53,46,50,47,63,47,105,110,105,116,46,108,117,97,59,47,117,115,114,47,108,111,99,97,108,47,108,105,98,47,108,117,97,47,53,46,50,47,63,46,108,117,97,59,47,117,115,114,47,108,111,99,97,108,47,108,105,98,47,108,117,97,47,53,46,50,47,63,47,105,110,105,116,46,108,117,97,59,46,47,63,46,108,117,97,0,0,0,0,0,0,0,99,112,97,116,104,0,0,0,76,85,65,95,67,80,65,84,72,95,53,95,50,0,0,0,76,85,65,95,67,80,65,84,72,0,0,0,0,0,0,0,47,117,115,114,47,108,111,99,97,108,47,108,105,98,47,108,117,97,47,53,46,50,47,63,46,115,111,59,47,117,115,114,47,108,111,99,97,108,47,108,105,98,47,108,117,97,47,53,46,50,47,108,111,97,100,97,108,108,46,115,111,59,46,47,63,46,115,111,0,0,0,0,47,10,59,10,63,10,33,10,45,10,0,0,0,0,0,0,99,111,110,102,105,103,0,0,95,76,79,65,68,69,68,0,108,111,97,100,101,100,0,0,95,80,82,69,76,79,65,68,0,0,0,0,0,0,0,0,112,114,101,108,111,97,100,0,72,29,0,0,124,0,0,0,80,29,0,0,125,0,0,0,0,0,0,0,0,0,0,0,109,111,100,117,108,101,0,0,114,101,113,117,105,114,101,0,39,112,97,99,107,97,103,101,46,115,101,97,114,99,104,101,114,115,39,32,109,117,115,116,32,98,101,32,97,32,116,97,98,108,101,0,0,0,0,0,109,111,100,117,108,101,32,39,37,115,39,32,110,111,116,32,102,111,117,110,100,58,37,115,0,0,0,0,0,0,0,0,95,78,65,77,69,0,0,0,102,0,0,0,0,0,0,0,39,109,111,100,117,108,101,39,32,110,111,116,32,99,97,108,108,101,100,32,102,114,111,109,32,97,32,76,117,97,32,102,117,110,99,116,105,111,110,0,95,77,0,0,0,0,0,0,95,80,65,67,75,65,71,69,0,0,0,0,0,0,0,0,59,59,0,0,0,0,0,0,59,1,59,0,0,0,0,0,1,0,0,0,0,0,0,0,76,85,65,95,78,79,69,78,86,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,10,9,110,111,32,109,111,100,117,108,101,32,39,37,115,39,32,105,110,32,102,105,108,101,32,39,37,115,39,0,0,0,101,114,114,111,114,32,108,111,97,100,105,110,103,32,109,111,100,117,108,101,32,39,37,115,39,32,102,114,111,109,32,102,105,108,101,32,39,37,115,39,58,10,9,37,115,0,0,0,46,0,0,0,0,0,0,0,95,0,0,0,0,0,0,0,108,117,97,111,112,101,110,95,37,115,0,0,0,0,0,0,100,121,110,97,109,105,99,32,108,105,98,114,97,114,105,101,115,32,110,111,116,32,101,110,97,98,108,101,100,59,32,99,104,101,99,107,32,121,111,117,114,32,76,117,97,32,105,110,115,116,97,108,108,97,116,105,111,110,0,0,0,0,0,0,39,112,97,99,107,97,103,101,46,37,115,39,32,109,117,115,116,32,98,101,32,97,32,115,116,114,105,110,103,0,0,0,63,0,0,0,0,0,0,0,10,9,110,111,32,102,105,108,101,32,39,37,115,39,0,0,114,0,0,0,0,0,0,0,10,9,110,111,32,102,105,101,108,100,32,112,97,99,107,97,103,101,46,112,114,101,108,111,97,100,91,39,37,115,39,93,0,0,0,0,0,0,0,0,108,111,97,100,108,105,98,0,115,101,97,114,99,104,112,97,116,104,0,0,0,0,0,0,115,101,101,97,108,108,0,0,95,95,105,110,100,101,120,0,97,98,115,101,110,116,0,0,105,110,105,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,110,78,0,0,0,0,0,0,120,88,0,0,0,0,0,0,40,110,117,108,108,41,0,0,37,112,0,0,0,0,0,0,37,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,111,112,116,105,111,110,32,39,37,37,37,99,39,32,116,111,32,39,108,117,97,95,112,117,115,104,102,115,116,114,105,110,103,39,0,0,0,0,0,0,46,46,46,0,0,0,0,0,91,115,116,114,105,110,103,32,34,0,0,0,0,0,0,0,34,93,0,0,0,0,0,0,96,113,65,84,80,80,92,108,60,16,60,84,108,124,124,124,124,124,124,96,96,96,104,34,188,188,188,132,228,84,84,16,98,98,4,98,20,81,80,23,128,33,0,0,126,0,0,0,136,33,0,0,127,0,0,0,144,33,0,0,128,0,0,0,160,33,0,0,129,0,0,0,168,33,0,0,130,0,0,0,176,33,0,0,131,0,0,0,184,33,0,0,132,0,0,0,192,33,0,0,133,0,0,0,200,33,0,0,134,0,0,0,216,33,0,0,135,0,0,0,224,33,0,0,136,0,0,0,0,0,0,0,0,0,0,0,99,108,111,99,107,0,0,0,100,97,116,101,0,0,0,0,100,105,102,102,116,105,109,101,0,0,0,0,0,0,0,0,101,120,101,99,117,116,101,0,101,120,105,116,0,0,0,0,103,101,116,101,110,118,0,0,114,101,109,111,118,101,0,0,114,101,110,97,109,101,0,0,115,101,116,108,111,99,97,108,101,0,0,0,0,0,0,0,116,105,109,101,0,0,0,0,116,109,112,110,97,109,101,0,117,110,97,98,108,101,32,116,111,32,103,101,110,101,114,97,116,101,32,97,32,117,110,105,113,117,101,32,102,105,108,101,110,97,109,101,0,0,0,0,115,101,99,0,0,0,0,0,109,105,110,0,0,0,0,0,104,111,117,114,0,0,0,0,100,97,121,0,0,0,0,0,109,111,110,116,104,0,0,0,121,101,97,114,0,0,0,0,105,115,100,115,116,0,0,0,102,105,101,108,100,32,39,37,115,39,32,109,105,115,115,105,110,103,32,105,110,32,100,97,116,101,32,116,97,98,108,101,0,0,0,0,0,0,0,0,6,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,1,0,0,0,2,0,0,0,168,34,0,0,176,34,0,0,184,34,0,0,192,34,0,0,208,34,0,0,216,33,0,0,0,0,0,0,0,0,0,0,97,108,108,0,0,0,0,0,99,111,108,108,97,116,101,0,99,116,121,112,101,0,0,0,109,111,110,101,116,97,114,121,0,0,0,0,0,0,0,0,110,117,109,101,114,105,99,0,37,99,0,0,0,0,0,0,42,116,0,0,0,0,0,0,119,100,97,121,0,0,0,0,121,100,97,121,0,0,0,0,97,65,98,66,99,100,72,73,106,109,77,112,83,85,119,87,120,88,121,89,122,37,0,0,105,110,118,97,108,105,100,32,99,111,110,118,101,114,115,105,111,110,32,115,112,101,99,105,102,105,101,114,32,39,37,37,37,115,39,0,0,0,0,0,60,37,115,62,32,97,116,32,108,105,110,101,32,37,100,32,110,111,116,32,105,110,115,105,100,101,32,97,32,108,111,111,112,0,0,0,0,0,0,0,110,111,32,118,105,115,105,98,108,101,32,108,97,98,101,108,32,39,37,115,39,32,102,111,114,32,60,103,111,116,111,62,32,97,116,32,108,105,110,101,32,37,100,0,0,0,0,0,60,103,111,116,111,32,37,115,62,32,97,116,32,108,105,110,101,32,37,100,32,106,117,109,112,115,32,105,110,116,111,32,116,104,101,32,115,99,111,112,101,32,111,102,32,108,111,99,97,108,32,39,37,115,39,0,98,114,101,97,107,0,0,0,108,97,98,101,108,115,47,103,111,116,111,115,0,0,0,0,37,115,32,101,120,112,101,99,116,101,100,0,0,0,0,0,115,121,110,116,97,120,32,101,114,114,111,114,0,0,0,0,67,32,108,101,118,101,108,115,0,0,0,0,0,0,0,0,6,6,6,6,7,7,7,7,7,7,10,9,5,4,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,1,0,0,99,97,110,110,111,116,32,117,115,101,32,39,46,46,46,39,32,111,117,116,115,105,100,101,32,97,32,118,97,114,97,114,103,32,102,117,110,99,116,105,111,110,0,0,0,0,0,0,115,101,108,102,0,0,0,0,60,110,97,109,101,62,32,111,114,32,39,46,46,46,39,32,101,120,112,101,99,116,101,100,0,0,0,0,0,0,0,0,108,111,99,97,108,32,118,97,114,105,97,98,108,101,115,0,102,117,110,99,116,105,111,110,115,0,0,0,0,0,0,0,105,116,101,109,115,32,105,110,32,97,32,99,111,110,115,116,114,117,99,116,111,114,0,0,109,97,105,110,32,102,117,110,99,116,105,111,110,0,0,0,102,117,110,99,116,105,111,110,32,97,116,32,108,105,110,101,32,37,100,0,0,0,0,0,116,111,111,32,109,97,110,121,32,37,115,32,40,108,105,109,105,116,32,105,115,32,37,100,41,32,105,110,32,37,115,0,102,117,110,99,116,105,111,110,32,97,114,103,117,109,101,110,116,115,32,101,120,112,101,99,116,101,100,0,0,0,0,0,117,110,101,120,112,101,99,116,101,100,32,115,121,109,98,111,108,0,0,0,0,0,0,0,108,97,98,101,108,32,39,37,115,39,32,97,108,114,101,97,100,121,32,100,101,102,105,110,101,100,32,111,110,32,108,105,110,101,32,37,100,0,0,0,39,61,39,32,111,114,32,39,105,110,39,32,101,120,112,101,99,116,101,100,0,0,0,0,40,102,111,114,32,103,101,110,101,114,97,116,111,114,41,0,40,102,111,114,32,115,116,97,116,101,41,0,0,0,0,0,40,102,111,114,32,99,111,110,116,114,111,108,41,0,0,0,40,102,111,114,32,105,110,100,101,120,41,0,0,0,0,0,40,102,111,114,32,108,105,109,105,116,41,0,0,0,0,0,40,102,111,114,32,115,116,101,112,41,0,0,0,0,0,0,37,115,32,101,120,112,101,99,116,101,100,32,40,116,111,32,99,108,111,115,101,32,37,115,32,97,116,32,108,105,110,101,32,37,100,41,0,0,0,0,117,112,118,97,108,117,101,115,0,0,0,0,0,0,0,0,110,111,116,32,101,110,111,117,103,104,32,109,101,109,111,114,121,0,0,0,0,0,0,0,184,38,0,0,137,0,0,0,192,38,0,0,138,0,0,0,200,38,0,0,139,0,0,0,208,38,0,0,140,0,0,0,216,38,0,0,141,0,0,0,224,38,0,0,142,0,0,0,232,38,0,0,143,0,0,0,240,38,0,0,144,0,0,0,248,38,0,0,145,0,0,0,0,39,0,0,146,0,0,0,8,39,0,0,147,0,0,0,16,39,0,0,148,0,0,0,24,39,0,0,149,0,0,0,32,39,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,95,95,105,110,100,101,120,0,98,121,116,101,0,0,0,0,99,104,97,114,0,0,0,0,100,117,109,112,0,0,0,0,102,105,110,100,0,0,0,0,102,111,114,109,97,116,0,0,103,109,97,116,99,104,0,0,103,115,117,98,0,0,0,0,108,101,110,0,0,0,0,0,108,111,119,101,114,0,0,0,109,97,116,99,104,0,0,0,114,101,112,0,0,0,0,0,114,101,118,101,114,115,101,0,115,117,98,0,0,0,0,0,117,112,112,101,114,0,0,0,114,101,115,117,108,116,105,110,103,32,115,116,114,105,110,103,32,116,111,111,32,108,97,114,103,101,0,0,0,0,0,0,116,111,111,32,109,97,110,121,32,99,97,112,116,117,114,101,115,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,99,97,112,116,117,114,101,32,105,110,100,101,120,0,0,0,117,110,102,105,110,105,115,104,101,100,32,99,97,112,116,117,114,101,0,0,0,0,0,0,112,97,116,116,101,114,110,32,116,111,111,32,99,111,109,112,108,101,120,0,0,0,0,0,109,105,115,115,105,110,103,32,39,91,39,32,97,102,116,101,114,32,39,37,37,102,39,32,105,110,32,112,97,116,116,101,114,110,0,0,0,0,0,0,105,110,118,97,108,105,100,32,99,97,112,116,117,114,101,32,105,110,100,101,120,32,37,37,37,100,0,0,0,0,0,0,109,97,108,102,111,114,109,101,100,32,112,97,116,116,101,114,110,32,40,101,110,100,115,32,119,105,116,104,32,39,37,37,39,41,0,0,0,0,0,0,109,97,108,102,111,114,109,101,100,32,112,97,116,116,101,114,110,32,40,109,105,115,115,105,110,103,32,39,93,39,41,0,109,97,108,102,111,114,109,101,100,32,112,97,116,116,101,114,110,32,40,109,105,115,115,105,110,103,32,97,114,103,117,109,101,110,116,115,32,116,111,32,39,37,37,98,39,41,0,0,105,110,118,97,108,105,100,32,112,97,116,116,101,114,110,32,99,97,112,116,117,114,101,0,94,36,42,43,63,46,40,91,37,45,0,0,0,0,0,0,115,116,114,105,110,103,47,102,117,110,99,116,105,111,110,47,116,97,98,108,101,32,101,120,112,101,99,116,101,100,0,0,105,110,118,97,108,105,100,32,114,101,112,108,97,99,101,109,101,110,116,32,118,97,108,117,101,32,40,97,32,37,115,41,0,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,117,115,101,32,111,102,32,39,37,99,39,32,105,110,32,114,101,112,108,97,99,101,109,101,110,116,32,115,116,114,105,110,103,0,0,0,0,0,0,0,110,111,32,118,97,108,117,101,0,0,0,0,0,0,0,0,110,111,116,32,97,32,110,117,109,98,101,114,32,105,110,32,112,114,111,112,101,114,32,114,97,110,103,101,0,0,0,0,110,111,116,32,97,32,110,111,110,45,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,32,105,110,32,112,114,111,112,101,114,32,114,97,110,103,101,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,111,112,116,105,111,110,32,39,37,37,37,99,39,32,116,111,32,39,102,111,114,109,97,116,39,0,0,0,0,0,0,0,92,37,100,0,0,0,0,0,92,37,48,51,100,0,0,0,45,43,32,35,48,0,0,0,105,110,118,97,108,105,100,32,102,111,114,109,97,116,32,40,114,101,112,101,97,116,101,100,32,102,108,97,103,115,41,0,105,110,118,97,108,105,100,32,102,111,114,109,97,116,32,40,119,105,100,116,104,32,111,114,32,112,114,101,99,105,115,105,111,110,32,116,111,111,32,108,111,110,103,41,0,0,0,0,117,110,97,98,108,101,32,116,111,32,100,117,109,112,32,103,105,118,101,110,32,102,117,110,99,116,105,111,110,0,0,0,118,97,108,117,101,32,111,117,116,32,111,102,32,114,97,110,103,101,0,0,0,0,0,0,115,116,114,105,110,103,32,115,108,105,99,101,32,116,111,111,32,108,111,110,103,0,0,0,116,97,98,108,101,32,105,110,100,101,120,32,105,115,32,110,105,108,0,0,0,0,0,0,116,97,98,108,101,32,105,110,100,101,120,32,105,115,32,78,97,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,116,97,98,108,101,32,111,118,101,114,102,108,111,119,0,0,105,110,118,97,108,105,100,32,107,101,121,32,116,111,32,39,110,101,120,116,39,0,0,0,8,43,0,0,151,0,0,0,16,43,0,0,152,0,0,0,24,43,0,0,153,0,0,0,32,43,0,0,154,0,0,0,0,43,0,0,155,0,0,0,40,43,0,0,156,0,0,0,48,43,0,0,157,0,0,0,0,0,0,0,0,0,0,0,117,110,112,97,99,107,0,0,99,111,110,99,97,116,0,0,109,97,120,110,0,0,0,0,105,110,115,101,114,116,0,0,112,97,99,107,0,0,0,0,114,101,109,111,118,101,0,0,115,111,114,116,0,0,0,0,0,0,0,0,0,0,0,0,105,110,118,97,108,105,100,32,111,114,100,101,114,32,102,117,110,99,116,105,111,110,32,102,111,114,32,115,111,114,116,105,110,103,0,0,0,0,0,0,112,111,115,105,116,105,111,110,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,0,116,111,111,32,109,97,110,121,32,114,101,115,117,108,116,115,32,116,111,32,117,110,112,97,99,107,0,0,0,0,0,0,110,0,0,0,0,0,0,0,119,114,111,110,103,32,110,117,109,98,101,114,32,111,102,32,97,114,103,117,109,101,110,116,115,32,116,111,32,39,105,110,115,101,114,116,39,0,0,0,105,110,118,97,108,105,100,32,118,97,108,117,101,32,40,37,115,41,32,97,116,32,105,110,100,101,120,32,37,100,32,105,110,32,116,97,98,108,101,32,102,111,114,32,39,99,111,110,99,97,116,39,0,0,0,0,110,111,32,118,97,108,117,101,0,0,0,0,0,0,0,0,110,105,108,0,0,0,0,0,98,111,111,108,101,97,110,0,117,115,101,114,100,97,116,97,0,0,0,0,0,0,0,0,110,117,109,98,101,114,0,0,115,116,114,105,110,103,0,0,116,97,98,108,101,0,0,0,102,117,110,99,116,105,111,110,0,0,0,0,0,0,0,0,116,104,114,101,97,100,0,0,112,114,111,116,111,0,0,0,117,112,118,97,108,0,0,0,8,44,0,0,24,44,0,0,32,44,0,0,40,44,0,0,56,44,0,0,64,44,0,0,72,44,0,0,80,44,0,0,40,44,0,0,96,44,0,0,104,44,0,0,112,44,0,0,240,44,0,0,248,44,0,0,8,45,0,0,16,45,0,0,24,45,0,0,32,45,0,0,40,45,0,0,48,45,0,0,56,45,0,0,64,45,0,0,72,45,0,0,80,45,0,0,88,45,0,0,96,45,0,0,104,45,0,0,112,45,0,0,128,45,0,0,0,0,0,0,95,95,105,110,100,101,120,0,95,95,110,101,119,105,110,100,101,120,0,0,0,0,0,0,95,95,103,99,0,0,0,0,95,95,109,111,100,101,0,0,95,95,108,101,110,0,0,0,95,95,101,113,0,0,0,0,95,95,97,100,100,0,0,0,95,95,115,117,98,0,0,0,95,95,109,117,108,0,0,0,95,95,100,105,118,0,0,0,95,95,109,111,100,0,0,0,95,95,112,111,119,0,0,0,95,95,117,110,109,0,0,0,95,95,108,116,0,0,0,0,95,95,108,101,0,0,0,0,95,95,99,111,110,99,97,116,0,0,0,0,0,0,0,0,95,95,99,97,108,108,0,0,98,105,110,97,114,121,32,115,116,114,105,110,103,0,0,0,25,147,13,10,26,10,0,0,116,114,117,110,99,97,116,101,100,0,0,0,0,0,0,0,37,115,58,32,37,115,32,112,114,101,99,111,109,112,105,108,101,100,32,99,104,117,110,107,0,0,0,0,0,0,0,0,99,111,114,114,117,112,116,101,100,0,0,0,0,0,0,0,110,111,116,32,97,0,0,0,118,101,114,115,105,111,110,32,109,105,115,109,97,116,99,104,32,105,110,0,0,0,0,0,105,110,99,111,109,112,97,116,105,98,108,101,0,0,0,0,37,46,49,52,103,0,0,0,105,110,100,101,120,0,0,0,108,111,111,112,32,105,110,32,103,101,116,116,97,98,108,101,0,0,0,0,0,0,0,0,108,111,111,112,32,105,110,32,115,101,116,116,97,98,108,101,0,0,0,0,0,0,0,0,115,116,114,105,110,103,32,108,101,110,103,116,104,32,111,118,101,114,102,108,111,119,0,0,103,101,116,32,108,101,110,103,116,104,32,111,102,0,0,0,39,102,111,114,39,32,105,110,105,116,105,97,108,32,118,97,108,117,101,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0,0,0,0,39,102,111,114,39,32,108,105,109,105,116,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0,0,0,0,39,102,111,114,39,32,115,116,101,112,32,109,117,115,116,32,98,101,32,97,32,110,117,109,98,101,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,110,102,105,110,105,116,121,0,0,0,0,0,0,0,0,110,97,110,0,0,0,0,0,95,112,137,0,255,9,47,15,10,0,0,0,100,0,0,0,232,3,0,0,16,39,0,0,160,134,1,0,64,66,15,0,128,150,152,0,0,225,245,5,0,0,0,0,0,0,0,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,45,43,32,32,32,48,88,48,120,0,0,0,0,0,0,0,40,110,117,108,108,41,0,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,0,0,0,0,0,105,110,102,0,0,0,0,0,73,78,70,0,0,0,0,0,110,97,110,0,0,0,0,0,78,65,78,0,0,0,0,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);




var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);

assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}


  
  
  
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
  
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
  
  
  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value;
      return value;
    }
  
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          if (stream.tty.output.length) {
            stream.tty.ops.put_char(stream.tty, 10);
          }
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              result = process['stdin']['read']();
              if (!result) {
                if (process['stdin']['_readableState'] && process['stdin']['_readableState']['ended']) {
                  return null;  // EOF
                }
                return undefined;  // no data available
              }
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function (node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function (node, newCapacity) {
  
        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file
        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }
  
        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity); // Allocate new storage.
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
          return;
        }
        // Not using a typed array to back the file storage. Use a standard JS array instead.
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },resizeFileStorage:function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
  
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else
          {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) { // Can we just reuse the buffer we are given?
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          node.usedBytes = Math.max(node.usedBytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        }}};
  
  var IDBFS={dbs:{},indexedDB:function () {
        if (typeof indexedDB !== 'undefined') return indexedDB;
        var ret = null;
        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
  
          var fileStore;
  
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
  
          fileStore.createIndex('timestamp', 'timestamp', { unique: false });
        };
        req.onsuccess = function() {
          db = req.result;
  
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function() {
          callback(this.error);
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
  
          entries[path] = { timestamp: stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};
  
        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function() { callback(this.error); };
  
          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');
  
          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;
  
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }
  
            entries[cursor.primaryKey] = { timestamp: cursor.key };
  
            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;
  
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }
  
          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
  
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function() { callback(this.error); };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function() { callback(this.error); };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function() { callback(this.error); };
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        transaction.onerror = function() { done(this.error); };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};
  
  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so 
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          return flags;
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
  
          return position;
        }}};
  
  var _stdin=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stdout=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stderr=allocate(1, "i32*", ALLOC_STATIC);
  
  function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
      // we don't currently perform any user-space buffering of data
    }var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
              
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
  
          FS.FSNode.prototype = {};
  
          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;
  
          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); },
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); },
            },
          });
        }
  
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 2097155;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0;
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 2097155) !== 0 ||  // opening for write
              (flags & 512)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },getStreamFromPtr:function (ptr) {
        return FS.streams[ptr - 1];
      },getPtrForStream:function (stream) {
        return stream ? stream.fd + 1 : 0;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            callback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = '';
          var utf8 = new Runtime.UTF8Processor();
          for (var i = 0; i < length; i++) {
            ret += utf8.processCChar(buf[i]);
          }
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var utf8 = new Runtime.UTF8Processor();
          var buf = new Uint8Array(utf8.processJSString(data));
          FS.write(stream, buf, 0, buf.length, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else if (ENVIRONMENT_IS_NODE) {
          // for nodejs
          random_device = function() { return require('crypto').randomBytes(1)[0]; };
        } else {
          // default for ES5 platforms
          random_device = function() { return (Math.random()*256)|0; };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=FS.getPtrForStream(stdin);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=FS.getPtrForStream(stdout);
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=FS.getPtrForStream(stderr);
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperty(node, "usedBytes", {
            get: function() { return this.contents.length; }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  
  
  
  
  
  function _mkport() { throw 'TODO' }var SOCKFS={mount:function (mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = function(event, callback) {
  	    if ('function' === typeof callback) {
  		  this._callbacks[event] = callback;
          }
  	    return this;
        };
  
        Module['websocket'].emit = function(event, param) {
  	    if ('function' === typeof this._callbacks[event]) {
  		  this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;
  
          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The regex trims the string (removes spaces at the beginning and end, then splits the string by
              // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
              subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
              // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
              var opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
  
              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }
  
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer
  
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = ERRNO_CODES.EHOSTUNREACH; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};function _recv(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _read(fd, buf, len);
    }
  
  function _pread(fildes, buf, nbyte, offset) {
      // ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _read(fildes, buf, nbyte) {
      // ssize_t read(int fildes, void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fread(ptr, size, nitems, stream) {
      // size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fread.html
      var bytesToRead = nitems * size;
      if (bytesToRead == 0) {
        return 0;
      }
      var bytesRead = 0;
      var streamObj = FS.getStreamFromPtr(stream);
      if (!streamObj) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return 0;
      }
      while (streamObj.ungotten.length && bytesToRead > 0) {
        HEAP8[((ptr++)>>0)]=streamObj.ungotten.pop();
        bytesToRead--;
        bytesRead++;
      }
      var err = _read(streamObj.fd, ptr, bytesToRead);
      if (err == -1) {
        if (streamObj) streamObj.error = true;
        return 0;
      }
      bytesRead += err;
      if (bytesRead < bytesToRead) streamObj.eof = true;
      return (bytesRead / size)|0;
    }function _fgetc(stream) {
      // int fgetc(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fgetc.html
      var streamObj = FS.getStreamFromPtr(stream);
      if (!streamObj) return -1;
      if (streamObj.eof || streamObj.error) return -1;
      var ret = _fread(_fgetc.ret, 1, 1, stream);
      if (ret == 0) {
        return -1;
      } else if (ret == -1) {
        streamObj.error = true;
        return -1;
      } else {
        return HEAPU8[((_fgetc.ret)>>0)];
      }
    }function _getc() {
  return _fgetc.apply(null, arguments)
  }

   
  Module["_i64Subtract"] = _i64Subtract;

   
  Module["_i64Add"] = _i64Add;

  
  var LOCALE={curr:0,check:function (locale) {
        if (locale) locale = Pointer_stringify(locale);
        return locale === 'C' || locale === 'POSIX' || !locale;
      }};function _setlocale(category, locale) {
      if (LOCALE.check(locale)) {
        if (!_setlocale.ret) _setlocale.ret = allocate(intArrayFromString('C'), 'i8', ALLOC_NORMAL);
        return _setlocale.ret;
      }
      return 0;
    }

  
  function _close(fildes) {
      // int close(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/close.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        FS.close(stream);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _fsync(fildes) {
      // int fsync(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fsync.html
      var stream = FS.getStream(fildes);
      if (stream) {
        // We write directly to the file system, so there's nothing to do here.
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }
  
  function _fileno(stream) {
      // int fileno(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fileno.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) return -1;
      return stream.fd;
    }function _fclose(stream) {
      // int fclose(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fclose.html
      var fd = _fileno(stream);
      _fsync(fd);
      return _close(fd);
    }

  
  function _tmpnam(s, dir, prefix) {
      // char *tmpnam(char *s);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/tmpnam.html
      // NOTE: The dir and prefix arguments are for internal use only.
      dir = dir || '/tmp';
      var folder = FS.findObject(dir);
      if (!folder || !folder.isFolder) {
        dir = '/tmp';
        folder = FS.findObject(dir);
        if (!folder || !folder.isFolder) return 0;
      }
      var name = prefix || 'file';
      do {
        name += String.fromCharCode(65 + (Math.random() * 25)|0);
      } while (name in folder.contents);
      var result = dir + '/' + name;
      if (!_tmpnam.buffer) _tmpnam.buffer = _malloc(256);
      if (!s) s = _tmpnam.buffer;
      assert(result.length <= 255);
      writeAsciiToMemory(result, s);
      return s;
    }
  
  
  function _open(path, oflag, varargs) {
      // int open(const char *path, int oflag, ...);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html
      var mode = HEAP32[((varargs)>>2)];
      path = Pointer_stringify(path);
      try {
        var stream = FS.open(path, oflag, mode);
        return stream.fd;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fopen(filename, mode) {
      // FILE *fopen(const char *restrict filename, const char *restrict mode);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fopen.html
      var flags;
      mode = Pointer_stringify(mode);
      if (mode[0] == 'r') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 0;
        }
      } else if (mode[0] == 'w') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 64;
        flags |= 512;
      } else if (mode[0] == 'a') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 64;
        flags |= 1024;
      } else {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return 0;
      }
      var fd = _open(filename, flags, allocate([0x1FF, 0, 0, 0], 'i32', ALLOC_STACK));  // All creation permissions.
      return fd === -1 ? 0 : FS.getPtrForStream(FS.getStream(fd));
    }function _tmpfile() {
      // FILE *tmpfile(void);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/tmpfile.html
      // TODO: Delete the created file on closing.
      if (!_tmpfile.mode) {
        _tmpfile.mode = allocate(intArrayFromString('w+'), 'i8', ALLOC_NORMAL);
      }
      return _fopen(_tmpnam(0), _tmpfile.mode);
    }

  function _freopen(filename, mode, stream) {
      // FILE *freopen(const char *restrict filename, const char *restrict mode, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/freopen.html
      if (!filename) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (!streamObj) {
          ___setErrNo(ERRNO_CODES.EBADF);
          return 0;
        }
        if (_freopen.buffer) _free(_freopen.buffer);
        filename = intArrayFromString(streamObj.path);
        filename = allocate(filename, 'i8', ALLOC_NORMAL);
      }
      _fclose(stream);
      return _fopen(filename, mode);
    }



  var _emscripten_check_longjmp=true;

  
  
  function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[((_fputc.ret)>>0)]=chr;
      var fd = _fileno(stream);
      var ret = _write(fd, _fputc.ret, 1);
      if (ret == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return -1;
      } else {
        return chr;
      }
    }

  var _log=Math_log;

  var _emscripten_postinvoke=true;

  function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var fd = _fileno(stream);
      var bytesWritten = _write(fd, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return (bytesWritten / size)|0;
      }
    }

  function _system(command) {
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      ___setErrNo(ERRNO_CODES.EAGAIN);
      return -1;
    }

  
  function _putchar(c) {
      // int putchar(int c);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/putchar.html
      return _fputc(c, HEAP32[((_stdout)>>2)]);
    } 
  Module["_saveSetjmp"] = _saveSetjmp;

  
  
  var _tzname=allocate(8, "i32*", ALLOC_STATIC);
  
  var _daylight=allocate(1, "i32*", ALLOC_STATIC);
  
  var _timezone=allocate(1, "i32*", ALLOC_STATIC);function _tzset() {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      HEAP32[((_timezone)>>2)]=-(new Date()).getTimezoneOffset() * 60;
  
      var winter = new Date(2000, 0, 1);
      var summer = new Date(2000, 6, 1);
      HEAP32[((_daylight)>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);
      var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);
      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        // Northern hemisphere
        HEAP32[((_tzname)>>2)]=winterNamePtr;
        HEAP32[(((_tzname)+(4))>>2)]=summerNamePtr;
      } else {
        HEAP32[((_tzname)>>2)]=summerNamePtr;
        HEAP32[(((_tzname)+(4))>>2)]=winterNamePtr;
      }
    }function _mktime(tmPtr) {
      _tzset();
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        HEAP32[(((tmPtr)+(32))>>2)]=Number(winterOffset != guessedOffset);
      } else if ((dst > 0) != (winterOffset != guessedOffset)) {
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var trueOffset = dst > 0 ? summerOffset : winterOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
  
      return (date.getTime() / 1000)|0;
    }


  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }

  function _log10(x) {
      return Math.log(x) / Math.LN10;
    }

  
  var ___tm_current=allocate(44, "i8", ALLOC_STATIC);
  
  
  var ___tm_timezone=allocate(intArrayFromString("GMT"), "i8", ALLOC_STATIC);function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);
  
      // DST is in December in South
      var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)]=dst;
  
      var zonePtr = HEAP32[(((_tzname)+(dst ? Runtime.QUANTUM_SIZE : 0))>>2)];
      HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;
  
      return tmPtr;
    }function _localtime(time) {
      return _localtime_r(time, ___tm_current);
    }

   
  Module["_bitshift64Lshr"] = _bitshift64Lshr;

   
  Module["_memset"] = _memset;

  var _emscripten_prep_setjmp=true;

  var _BDtoIHigh=true;

  
  
   
  Module["_testSetjmp"] = _testSetjmp;function _longjmp(env, value) {
      asm['setThrew'](env, value || 1);
      throw 'longjmp';
    }function _emscripten_longjmp(env, value) {
      _longjmp(env, value);
    }

  var _ceil=Math_ceil;

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    } 
  Module["_memcpy"] = _memcpy;

  var _llvm_pow_f64=Math_pow;

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }

  
  
  function __getFloat(text) {
      return /^[+-]?[0-9]*\.?[0-9]+([eE][+-]?[0-9]+)?/.exec(text);
    }function __scanString(format, get, unget, varargs) {
      if (!__scanString.whiteSpace) {
        __scanString.whiteSpace = {};
        __scanString.whiteSpace[32] = 1;
        __scanString.whiteSpace[9] = 1;
        __scanString.whiteSpace[10] = 1;
        __scanString.whiteSpace[11] = 1;
        __scanString.whiteSpace[12] = 1;
        __scanString.whiteSpace[13] = 1;
      }
      // Supports %x, %4x, %d.%d, %lld, %s, %f, %lf.
      // TODO: Support all format specifiers.
      format = Pointer_stringify(format);
      var soFar = 0;
      if (format.indexOf('%n') >= 0) {
        // need to track soFar
        var _get = get;
        get = function get() {
          soFar++;
          return _get();
        }
        var _unget = unget;
        unget = function unget() {
          soFar--;
          return _unget();
        }
      }
      var formatIndex = 0;
      var argsi = 0;
      var fields = 0;
      var argIndex = 0;
      var next;
  
      mainLoop:
      for (var formatIndex = 0; formatIndex < format.length;) {
        if (format[formatIndex] === '%' && format[formatIndex+1] == 'n') {
          var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += Runtime.getAlignSize('void*', null, true);
          HEAP32[((argPtr)>>2)]=soFar;
          formatIndex += 2;
          continue;
        }
  
        if (format[formatIndex] === '%') {
          var nextC = format.indexOf('c', formatIndex+1);
          if (nextC > 0) {
            var maxx = 1;
            if (nextC > formatIndex+1) {
              var sub = format.substring(formatIndex+1, nextC);
              maxx = parseInt(sub);
              if (maxx != sub) maxx = 0;
            }
            if (maxx) {
              var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
              argIndex += Runtime.getAlignSize('void*', null, true);
              fields++;
              for (var i = 0; i < maxx; i++) {
                next = get();
                HEAP8[((argPtr++)>>0)]=next;
                if (next === 0) return i > 0 ? fields : fields-1; // we failed to read the full length of this field
              }
              formatIndex += nextC - formatIndex + 1;
              continue;
            }
          }
        }
  
        // handle %[...]
        if (format[formatIndex] === '%' && format.indexOf('[', formatIndex+1) > 0) {
          var match = /\%([0-9]*)\[(\^)?(\]?[^\]]*)\]/.exec(format.substring(formatIndex));
          if (match) {
            var maxNumCharacters = parseInt(match[1]) || Infinity;
            var negateScanList = (match[2] === '^');
            var scanList = match[3];
  
            // expand "middle" dashs into character sets
            var middleDashMatch;
            while ((middleDashMatch = /([^\-])\-([^\-])/.exec(scanList))) {
              var rangeStartCharCode = middleDashMatch[1].charCodeAt(0);
              var rangeEndCharCode = middleDashMatch[2].charCodeAt(0);
              for (var expanded = ''; rangeStartCharCode <= rangeEndCharCode; expanded += String.fromCharCode(rangeStartCharCode++));
              scanList = scanList.replace(middleDashMatch[1] + '-' + middleDashMatch[2], expanded);
            }
  
            var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
            argIndex += Runtime.getAlignSize('void*', null, true);
            fields++;
  
            for (var i = 0; i < maxNumCharacters; i++) {
              next = get();
              if (negateScanList) {
                if (scanList.indexOf(String.fromCharCode(next)) < 0) {
                  HEAP8[((argPtr++)>>0)]=next;
                } else {
                  unget();
                  break;
                }
              } else {
                if (scanList.indexOf(String.fromCharCode(next)) >= 0) {
                  HEAP8[((argPtr++)>>0)]=next;
                } else {
                  unget();
                  break;
                }
              }
            }
  
            // write out null-terminating character
            HEAP8[((argPtr++)>>0)]=0;
            formatIndex += match[0].length;
            
            continue;
          }
        }      
        // remove whitespace
        while (1) {
          next = get();
          if (next == 0) return fields;
          if (!(next in __scanString.whiteSpace)) break;
        }
        unget();
  
        if (format[formatIndex] === '%') {
          formatIndex++;
          var suppressAssignment = false;
          if (format[formatIndex] == '*') {
            suppressAssignment = true;
            formatIndex++;
          }
          var maxSpecifierStart = formatIndex;
          while (format[formatIndex].charCodeAt(0) >= 48 &&
                 format[formatIndex].charCodeAt(0) <= 57) {
            formatIndex++;
          }
          var max_;
          if (formatIndex != maxSpecifierStart) {
            max_ = parseInt(format.slice(maxSpecifierStart, formatIndex), 10);
          }
          var long_ = false;
          var half = false;
          var quarter = false;
          var longLong = false;
          if (format[formatIndex] == 'l') {
            long_ = true;
            formatIndex++;
            if (format[formatIndex] == 'l') {
              longLong = true;
              formatIndex++;
            }
          } else if (format[formatIndex] == 'h') {
            half = true;
            formatIndex++;
            if (format[formatIndex] == 'h') {
              quarter = true;
              formatIndex++;
            }
          }
          var type = format[formatIndex];
          formatIndex++;
          var curr = 0;
          var buffer = [];
          // Read characters according to the format. floats are trickier, they may be in an unfloat state in the middle, then be a valid float later
          if (type == 'f' || type == 'e' || type == 'g' ||
              type == 'F' || type == 'E' || type == 'G') {
            next = get();
            while (next > 0 && (!(next in __scanString.whiteSpace)))  {
              buffer.push(String.fromCharCode(next));
              next = get();
            }
            var m = __getFloat(buffer.join(''));
            var last = m ? m[0].length : 0;
            for (var i = 0; i < buffer.length - last + 1; i++) {
              unget();
            }
            buffer.length = last;
          } else {
            next = get();
            var first = true;
            
            // Strip the optional 0x prefix for %x.
            if ((type == 'x' || type == 'X') && (next == 48)) {
              var peek = get();
              if (peek == 120 || peek == 88) {
                next = get();
              } else {
                unget();
              }
            }
            
            while ((curr < max_ || isNaN(max_)) && next > 0) {
              if (!(next in __scanString.whiteSpace) && // stop on whitespace
                  (type == 's' ||
                   ((type === 'd' || type == 'u' || type == 'i') && ((next >= 48 && next <= 57) ||
                                                                     (first && next == 45))) ||
                   ((type === 'x' || type === 'X') && (next >= 48 && next <= 57 ||
                                     next >= 97 && next <= 102 ||
                                     next >= 65 && next <= 70))) &&
                  (formatIndex >= format.length || next !== format[formatIndex].charCodeAt(0))) { // Stop when we read something that is coming up
                buffer.push(String.fromCharCode(next));
                next = get();
                curr++;
                first = false;
              } else {
                break;
              }
            }
            unget();
          }
          if (buffer.length === 0) return 0;  // Failure.
          if (suppressAssignment) continue;
  
          var text = buffer.join('');
          var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += Runtime.getAlignSize('void*', null, true);
          var base = 10;
          switch (type) {
            case 'X': case 'x':
              base = 16;
            case 'd': case 'u': case 'i':
              if (quarter) {
                HEAP8[((argPtr)>>0)]=parseInt(text, base);
              } else if (half) {
                HEAP16[((argPtr)>>1)]=parseInt(text, base);
              } else if (longLong) {
                (tempI64 = [parseInt(text, base)>>>0,(tempDouble=parseInt(text, base),(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((argPtr)>>2)]=tempI64[0],HEAP32[(((argPtr)+(4))>>2)]=tempI64[1]);
              } else {
                HEAP32[((argPtr)>>2)]=parseInt(text, base);
              }
              break;
            case 'F':
            case 'f':
            case 'E':
            case 'e':
            case 'G':
            case 'g':
            case 'E':
              // fallthrough intended
              if (long_) {
                HEAPF64[((argPtr)>>3)]=parseFloat(text);
              } else {
                HEAPF32[((argPtr)>>2)]=parseFloat(text);
              }
              break;
            case 's':
              var array = intArrayFromString(text);
              for (var j = 0; j < array.length; j++) {
                HEAP8[(((argPtr)+(j))>>0)]=array[j];
              }
              break;
          }
          fields++;
        } else if (format[formatIndex].charCodeAt(0) in __scanString.whiteSpace) {
          next = get();
          while (next in __scanString.whiteSpace) {
            if (next <= 0) break mainLoop;  // End of input.
            next = get();
          }
          unget(next);
          formatIndex++;
        } else {
          // Not a specifier.
          next = get();
          if (format[formatIndex].charCodeAt(0) !== next) {
            unget(next);
            break mainLoop;
          }
          formatIndex++;
        }
      }
      return fields;
    }
  
  function _ungetc(c, stream) {
      // int ungetc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ungetc.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) {
        return -1;
      }
      if (c === -1) {
        // do nothing for EOF character
        return c;
      }
      c = unSign(c & 0xFF);
      stream.ungotten.push(c);
      stream.eof = false;
      return c;
    }function _fscanf(stream, format, varargs) {
      // int fscanf(FILE *restrict stream, const char *restrict format, ... );
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/scanf.html
      var streamObj = FS.getStreamFromPtr(stream);
      if (!streamObj) {
        return -1;
      }
      var buffer = [];
      function get() {
        var c = _fgetc(stream);
        buffer.push(c);
        return c;
      };
      function unget() {
        _ungetc(buffer.pop(), stream);
      };
      return __scanString(format, get, unget, varargs);
    }

  function _localeconv() {
      // %struct.timeval = type { char* decimal point, other stuff... }
      // var indexes = Runtime.calculateStructAlignment({ fields: ['i32', 'i32'] });
      var me = _localeconv;
      if (!me.ret) {
      // These are defaults from the "C" locale
        me.ret = allocate([
          allocate(intArrayFromString('.'), 'i8', ALLOC_NORMAL),0,0,0, // decimal_point
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // thousands_sep
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // grouping
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // int_curr_symbol
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // currency_symbol
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // mon_decimal_point
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // mon_thousands_sep
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // mon_grouping
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0, // positive_sign
          allocate(intArrayFromString(''), 'i8', ALLOC_NORMAL),0,0,0 // negative_sign
        ], 'i8*', ALLOC_NORMAL); // Allocate strings in lconv, still don't allocate chars
      }
      return me.ret;
    }

  
  function _sinh(x) {
      var p = Math.pow(Math.E, x);
      return (p - (1 / p)) / 2;
    }
  
  function _cosh(x) {
      var p = Math.pow(Math.E, x);
      return (p + (1 / p)) / 2;
    }function _tanh(x) {
      return _sinh(x) / _cosh(x);
    }

  var _emscripten_preinvoke=true;

  var _BItoD=true;

  
  function _unlink(path) {
      // int unlink(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/unlink.html
      path = Pointer_stringify(path);
      try {
        FS.unlink(path);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _rmdir(path) {
      // int rmdir(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/rmdir.html
      path = Pointer_stringify(path);
      try {
        FS.rmdir(path);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _remove(path) {
      // int remove(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/remove.html
      var ret = _unlink(path);
      if (ret == -1) ret = _rmdir(path);
      return ret;
    }

  function _fmod(x, y) {
      return x % y;
    }


  function _rename(old_path, new_path) {
      // int rename(const char *old, const char *new);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/rename.html
      old_path = Pointer_stringify(old_path);
      new_path = Pointer_stringify(new_path);
      try {
        FS.rename(old_path, new_path);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 79:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function ___errno_location() {
      return ___errno_state;
    }


  var _BDtoILow=true;


   
  Module["_bitshift64Shl"] = _bitshift64Shl;

  function _abort() {
      Module['abort']();
    }

  
  
   
  Module["_strlen"] = _strlen;
  
  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = HEAPF64[(((varargs)+(argIndex))>>3)];
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
  
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[((textIndex)>>0)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)>>0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)>>0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)>>0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)>>0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)>>0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var origArg = currArg;
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (argSize == 8 && i64Math) {
                  if (origArg[1]) {
                    argText = (origArg[1]>>>0).toString(16);
                    var lower = (origArg[0]>>>0).toString(16);
                    while (lower.length < 8) lower = '0' + lower;
                    argText += lower;
                  } else {
                    argText = (origArg[0]>>>0).toString(16);
                  }
                } else
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)>>0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[((i)>>0)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }

  function _fgets(s, n, stream) {
      // char *fgets(char *restrict s, int n, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fgets.html
      var streamObj = FS.getStreamFromPtr(stream);
      if (!streamObj) return 0;
      if (streamObj.error || streamObj.eof) return 0;
      var byte_;
      for (var i = 0; i < n - 1 && byte_ != 10; i++) {
        byte_ = _fgetc(stream);
        if (byte_ == -1) {
          if (streamObj.error || (streamObj.eof && i == 0)) return 0;
          else if (streamObj.eof) break;
        }
        HEAP8[(((s)+(i))>>0)]=byte_;
      }
      HEAP8[(((s)+(i))>>0)]=0;
      return s;
    }

  var _tan=Math_tan;

  function _feof(stream) {
      // int feof(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/feof.html
      stream = FS.getStreamFromPtr(stream);
      return Number(stream && stream.eof);
    }

  var _asin=Math_asin;

  function _clearerr(stream) {
      // void clearerr(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/clearerr.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) {
        return;
      }
      stream.eof = false;
      stream.error = false;
    }

  var _fabs=Math_abs;

  function _clock() {
      if (_clock.start === undefined) _clock.start = Date.now();
      return ((Date.now() - _clock.start) * (1000000 / 1000))|0;
    }


  
  function _lseek(fildes, offset, whence) {
      // off_t lseek(int fildes, off_t offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/lseek.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        return FS.llseek(stream, offset, whence);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fseek(stream, offset, whence) {
      // int fseek(FILE *stream, long offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fseek.html
      var fd = _fileno(stream);
      var ret = _lseek(fd, offset, whence);
      if (ret == -1) {
        return -1;
      }
      stream = FS.getStreamFromPtr(stream);
      stream.eof = false;
      return 0;
    }

  var _sqrt=Math_sqrt;

  function _ftell(stream) {
      // long ftell(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ftell.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (FS.isChrdev(stream.node.mode)) {
        ___setErrNo(ERRNO_CODES.ESPIPE);
        return -1;
      } else {
        return stream.position;
      }
    }

  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          setTimeout(Browser.mainLoop.runner, value); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      }
      return 0;
    }function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg) {
      Module['noExitRuntime'] = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          Module.printErr('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(function() {
          if (typeof arg !== 'undefined') {
            Runtime.dynCall('vi', func, [arg]);
          } else {
            Runtime.dynCall('v', func);
          }
        });
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
      else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
      Browser.mainLoop.scheduler();
  
      if (simulateInfiniteLoop) {
        throw 'SimulateInfiniteLoop';
      }
    }var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function () {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function () {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function (func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        var canvas = Module['canvas'];
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas ||
                                document['msPointerLockElement'] === canvas;
        }
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
          
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && canvas.requestPointerLock) {
                canvas.requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          contextHandle = GL.createContext(canvas, contextAttributes);
          if (contextHandle) {
            ctx = GL.getContext(contextHandle).GLctx;
          }
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement'] ||
               document['msFullScreenElement'] || document['msFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'] ||
                                      document['msExitFullscreen'] ||
                                      document['exitFullscreen'] ||
                                      function() {};
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else {
            
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
            
            if (Browser.resizeCanvas) Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
          Browser.updateCanvasDimensions(canvas);
        }
  
        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
          document.addEventListener('MSFullscreenChange', fullScreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
        
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullScreen = canvasContainer['requestFullScreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvasContainer.requestFullScreen();
      },nextRAF:0,fakeRequestAnimationFrame:function (func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          Browser.fakeRequestAnimationFrame(func);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           Browser.fakeRequestAnimationFrame;
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (!ABORT) func();
        });
      },safeSetTimeout:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setTimeout(function() {
          if (!ABORT) func();
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setInterval(function() {
          if (!ABORT) func();
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll': 
            delta = event.detail;
            break;
          case 'mousewheel': 
            delta = event.wheelDelta;
            break;
          case 'wheel': 
            delta = event['deltaY'];
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          
          // check if SDL is available
          if (typeof SDL != "undefined") {
          	Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
          	Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// FIXME: ideally this should be clamped against the canvas size and zero
          	Browser.mouseX += Browser.mouseMovementX;
          	Browser.mouseY += Browser.mouseMovementY;
          }        
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
            
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              Browser.lastTouches[touch.identifier] = Browser.touches[touch.identifier];
              Browser.touches[touch.identifier] = { x: adjustedX, y: adjustedY };
            } 
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        // check if SDL is available   
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available       
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
             document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
             document['fullScreenElement'] || document['fullscreenElement'] ||
             document['msFullScreenElement'] || document['msFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function () {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};

  var _emscripten_get_longjmp_result=true;

  var _sin=Math_sin;

  function _fmodl() {
  return _fmod.apply(null, arguments)
  }


  function _modf(x, intpart) {
      HEAPF64[((intpart)>>3)]=(x < 0) ? Math.ceil(x) : Math.floor(x);
      return x - HEAPF64[((intpart)>>3)];
    }

  var _atan=Math_atan;

  function _ferror(stream) {
      // int ferror(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ferror.html
      stream = FS.getStreamFromPtr(stream);
      return Number(stream && stream.error);
    }

  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  
  function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
      HEAP32[(((tmPtr)+(36))>>2)]=0;
      HEAP32[(((tmPtr)+(32))>>2)]=0;
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;
  
      return tmPtr;
    }function _gmtime(time) {
      return _gmtime_r(time, ___tm_current);
    }


  
  function _strerror_r(errnum, strerrbuf, buflen) {
      if (errnum in ERRNO_MESSAGES) {
        if (ERRNO_MESSAGES[errnum].length > buflen - 1) {
          return ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          var msg = ERRNO_MESSAGES[errnum];
          writeAsciiToMemory(msg, strerrbuf);
          return 0;
        }
      } else {
        return ___setErrNo(ERRNO_CODES.EINVAL);
      }
    }function _strerror(errnum) {
      if (!_strerror.buffer) _strerror.buffer = _malloc(256);
      _strerror_r(errnum, _strerror.buffer, 256);
      return _strerror.buffer;
    }

  
  
  
  
  var _environ=allocate(1, "i32*", ALLOC_STATIC);var ___environ=_environ;function ___buildEnvironment(env) {
      // WARNING: Arbitrary limit!
      var MAX_ENV_VALUES = 64;
      var TOTAL_ENV_SIZE = 1024;
  
      // Statically allocate memory for the environment.
      var poolPtr;
      var envPtr;
      if (!___buildEnvironment.called) {
        ___buildEnvironment.called = true;
        // Set default values. Use string keys for Closure Compiler compatibility.
        ENV['USER'] = 'web_user';
        ENV['PATH'] = '/';
        ENV['PWD'] = '/';
        ENV['HOME'] = '/home/web_user';
        ENV['LANG'] = 'C';
        ENV['_'] = Module['thisProgram'];
        // Allocate memory.
        poolPtr = allocate(TOTAL_ENV_SIZE, 'i8', ALLOC_STATIC);
        envPtr = allocate(MAX_ENV_VALUES * 4,
                          'i8*', ALLOC_STATIC);
        HEAP32[((envPtr)>>2)]=poolPtr;
        HEAP32[((_environ)>>2)]=envPtr;
      } else {
        envPtr = HEAP32[((_environ)>>2)];
        poolPtr = HEAP32[((envPtr)>>2)];
      }
  
      // Collect key=value lines.
      var strings = [];
      var totalSize = 0;
      for (var key in env) {
        if (typeof env[key] === 'string') {
          var line = key + '=' + env[key];
          strings.push(line);
          totalSize += line.length;
        }
      }
      if (totalSize > TOTAL_ENV_SIZE) {
        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');
      }
  
      // Make new.
      var ptrSize = 4;
      for (var i = 0; i < strings.length; i++) {
        var line = strings[i];
        writeAsciiToMemory(line, poolPtr);
        HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;
        poolPtr += line.length + 1;
      }
      HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;
    }var ENV={};function _getenv(name) {
      // char *getenv(const char *name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html
      if (name === 0) return 0;
      name = Pointer_stringify(name);
      if (!ENV.hasOwnProperty(name)) return 0;
  
      if (_getenv.ret) _free(_getenv.ret);
      _getenv.ret = allocate(intArrayFromString(ENV[name]), 'i8', ALLOC_NORMAL);
      return _getenv.ret;
    }

  var _emscripten_setjmp=true;

  var _cos=Math_cos;

  function _difftime(time1, time0) {
      return time1 - time0;
    }

  var _floor=Math_floor;

  var _atan2=Math_atan2;

  function _setvbuf(stream, buf, type, size) {
      // int setvbuf(FILE *restrict stream, char *restrict buf, int type, size_t size);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/setvbuf.html
      // TODO: Implement custom buffering.
      return 0;
    }

  var _exp=Math_exp;

  
  function _copysign(a, b) {
      return __reallyNegative(a) === __reallyNegative(b) ? a : -a;
    }function _copysignl() {
  return _copysign.apply(null, arguments)
  }

  var _acos=Math_acos;

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]);
      return sum;
    }
  
  
  var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while(days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month 
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? Pointer_stringify(tm_zone) : ''
      };
  
      var pattern = Pointer_stringify(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate date representation
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value === 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      };
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      };
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        };
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      };
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      };
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else { 
            return thisDate.getFullYear()-1;
          }
      };
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year. 
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes 
          // January 4th, which is also the week that includes the first Thursday of the year, and 
          // is also the first week that contains at least four days in the year. 
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of 
          // the last week of the preceding year; thus, for Saturday 2nd January 1999, 
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th, 
          // or 31st is a Monday, it and any following days are part of week 1 of the following year. 
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
          
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          return leadingNulls(date.tm_hour < 13 ? date.tm_hour : date.tm_hour-12, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour > 0 && date.tm_hour < 13) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          var day = new Date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);
          return day.getDay() || 7;
        },
        '%U': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53]. 
          // The first Sunday of January is the first day of week 1; 
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year+1900, 0, 1);
          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7-janFirst.getDay());
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
          
          // is target date after the first Sunday?
          if (compareByDay(firstSunday, endDate) < 0) {
            // calculate difference in days between first Sunday and endDate
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstSundayUntilEndJanuary = 31-firstSunday.getDate();
            var days = firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
  
          return compareByDay(firstSunday, janFirst) === 0 ? '01': '00';
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week) 
          // as a decimal number [01,53]. If the week containing 1 January has four 
          // or more days in the new year, then it is considered week 1. 
          // Otherwise, it is the last week of the previous year, and the next week is week 1. 
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var janFourthThisYear = new Date(date.tm_year+1900, 0, 4);
          var janFourthNextYear = new Date(date.tm_year+1901, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          var endDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
            // if given date is before this years first week, then it belongs to the 53rd week of last year
            return '53';
          } 
  
          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
            // if given date is after next years first week, then it belongs to the 01th week of next year
            return '01';
          }
  
          // given date is in between CW 01..53 of this calendar year
          var daysDifference;
          if (firstWeekStartThisYear.getFullYear() < date.tm_year+1900) {
            // first CW of this year starts last year
            daysDifference = date.tm_yday+32-firstWeekStartThisYear.getDate()
          } else {
            // first CW of this year starts this year
            daysDifference = date.tm_yday+1-firstWeekStartThisYear.getDate();
          }
          return leadingNulls(Math.ceil(daysDifference/7), 2);
        },
        '%w': function(date) {
          var day = new Date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);
          return day.getDay();
        },
        '%W': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53]. 
          // The first Monday of January is the first day of week 1; 
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year, 0, 1);
          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7-janFirst.getDay()+1);
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first Monday?
          if (compareByDay(firstMonday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstMondayUntilEndJanuary = 31-firstMonday.getDate();
            var days = firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
          return compareByDay(firstMonday, janFirst) === 0 ? '01': '00';
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.indexOf(rule) >= 0) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      } 
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }



_fgetc.ret = allocate([0], "i8", ALLOC_STATIC);
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
__ATINIT__.unshift({ func: function() { TTY.init() } });__ATEXIT__.push({ func: function() { TTY.shutdown() } });TTY.utf8 = new Runtime.UTF8Processor();
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); NODEFS.staticInit(); }
__ATINIT__.push({ func: function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); } });
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas) { Browser.requestFullScreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
___buildEnvironment(ENV);
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");

 var ctlz_i8 = allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_DYNAMIC);
 var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_DYNAMIC);


function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  try {
    return Module["dynCall_iiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array };
Module.asmLibraryArg = { "abort": abort, "assert": assert, "min": Math_min, "jsCall": jsCall, "invoke_ii": invoke_ii, "invoke_iiii": invoke_iiii, "invoke_vii": invoke_vii, "invoke_iii": invoke_iii, "invoke_iiiii": invoke_iiiii, "_fabs": _fabs, "_exp": _exp, "_fread": _fread, "_fmodl": _fmodl, "_longjmp": _longjmp, "__addDays": __addDays, "_ftell": _ftell, "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing, "_sbrk": _sbrk, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_sinh": _sinh, "_sysconf": _sysconf, "_close": _close, "_ferror": _ferror, "_clock": _clock, "_cos": _cos, "_tanh": _tanh, "_write": _write, "__isLeapYear": __isLeapYear, "_fsync": _fsync, "_gmtime_r": _gmtime_r, "_tmpnam": _tmpnam, "_tmpfile": _tmpfile, "_send": _send, "_setvbuf": _setvbuf, "_atan2": _atan2, "_setlocale": _setlocale, "_modf": _modf, "_strerror_r": _strerror_r, "_gmtime": _gmtime, "_fscanf": _fscanf, "___setErrNo": ___setErrNo, "_unlink": _unlink, "_mktime": _mktime, "_putchar": _putchar, "___buildEnvironment": ___buildEnvironment, "_localeconv": _localeconv, "_fopen": _fopen, "_read": _read, "_fwrite": _fwrite, "_time": _time, "_fprintf": _fprintf, "_log10": _log10, "_exit": _exit, "_freopen": _freopen, "_llvm_pow_f64": _llvm_pow_f64, "_fgetc": _fgetc, "_fmod": _fmod, "_lseek": _lseek, "_rename": _rename, "_rmdir": _rmdir, "_asin": _asin, "_floor": _floor, "_pwrite": _pwrite, "_localtime_r": _localtime_r, "_tzset": _tzset, "_open": _open, "_remove": _remove, "___errno_location": ___errno_location, "_strftime": _strftime, "_fseek": _fseek, "_getenv": _getenv, "_fclose": _fclose, "_log": _log, "_recv": _recv, "_tan": _tan, "_clearerr": _clearerr, "__getFloat": __getFloat, "_abort": _abort, "_ceil": _ceil, "_localtime": _localtime, "_sin": _sin, "_acos": _acos, "_cosh": _cosh, "_difftime": _difftime, "_ungetc": _ungetc, "_system": _system, "_fflush": _fflush, "__reallyNegative": __reallyNegative, "_fileno": _fileno, "__exit": __exit, "__arraySum": __arraySum, "_fgets": _fgets, "_atan": _atan, "_pread": _pread, "_mkport": _mkport, "_getc": _getc, "_feof": _feof, "_emscripten_set_main_loop": _emscripten_set_main_loop, "__scanString": __scanString, "_copysign": _copysign, "_fputc": _fputc, "_copysignl": _copysignl, "_strerror": _strerror, "_emscripten_longjmp": _emscripten_longjmp, "__formatString": __formatString, "_sqrt": _sqrt, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8, "ctlz_i8": ctlz_i8, "NaN": NaN, "Infinity": Infinity, "_stderr": _stderr, "_stdin": _stdin, "_stdout": _stdout };
// EMSCRIPTEN_START_ASM
var asm = (function(global, env, buffer) {
  'use asm';
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var ctlz_i8=env.ctlz_i8|0;
  var _stderr=env._stderr|0;
  var _stdin=env._stdin|0;
  var _stdout=env._stdout|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = +env.NaN, inf = +env.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var abort=env.abort;
  var assert=env.assert;
  var Math_min=env.min;
  var jsCall=env.jsCall;
  var invoke_ii=env.invoke_ii;
  var invoke_iiii=env.invoke_iiii;
  var invoke_vii=env.invoke_vii;
  var invoke_iii=env.invoke_iii;
  var invoke_iiiii=env.invoke_iiiii;
  var _fabs=env._fabs;
  var _exp=env._exp;
  var _fread=env._fread;
  var _fmodl=env._fmodl;
  var _longjmp=env._longjmp;
  var __addDays=env.__addDays;
  var _ftell=env._ftell;
  var _emscripten_set_main_loop_timing=env._emscripten_set_main_loop_timing;
  var _sbrk=env._sbrk;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _sinh=env._sinh;
  var _sysconf=env._sysconf;
  var _close=env._close;
  var _ferror=env._ferror;
  var _clock=env._clock;
  var _cos=env._cos;
  var _tanh=env._tanh;
  var _write=env._write;
  var __isLeapYear=env.__isLeapYear;
  var _fsync=env._fsync;
  var _gmtime_r=env._gmtime_r;
  var _tmpnam=env._tmpnam;
  var _tmpfile=env._tmpfile;
  var _send=env._send;
  var _setvbuf=env._setvbuf;
  var _atan2=env._atan2;
  var _setlocale=env._setlocale;
  var _modf=env._modf;
  var _strerror_r=env._strerror_r;
  var _gmtime=env._gmtime;
  var _fscanf=env._fscanf;
  var ___setErrNo=env.___setErrNo;
  var _unlink=env._unlink;
  var _mktime=env._mktime;
  var _putchar=env._putchar;
  var ___buildEnvironment=env.___buildEnvironment;
  var _localeconv=env._localeconv;
  var _fopen=env._fopen;
  var _read=env._read;
  var _fwrite=env._fwrite;
  var _time=env._time;
  var _fprintf=env._fprintf;
  var _log10=env._log10;
  var _exit=env._exit;
  var _freopen=env._freopen;
  var _llvm_pow_f64=env._llvm_pow_f64;
  var _fgetc=env._fgetc;
  var _fmod=env._fmod;
  var _lseek=env._lseek;
  var _rename=env._rename;
  var _rmdir=env._rmdir;
  var _asin=env._asin;
  var _floor=env._floor;
  var _pwrite=env._pwrite;
  var _localtime_r=env._localtime_r;
  var _tzset=env._tzset;
  var _open=env._open;
  var _remove=env._remove;
  var ___errno_location=env.___errno_location;
  var _strftime=env._strftime;
  var _fseek=env._fseek;
  var _getenv=env._getenv;
  var _fclose=env._fclose;
  var _log=env._log;
  var _recv=env._recv;
  var _tan=env._tan;
  var _clearerr=env._clearerr;
  var __getFloat=env.__getFloat;
  var _abort=env._abort;
  var _ceil=env._ceil;
  var _localtime=env._localtime;
  var _sin=env._sin;
  var _acos=env._acos;
  var _cosh=env._cosh;
  var _difftime=env._difftime;
  var _ungetc=env._ungetc;
  var _system=env._system;
  var _fflush=env._fflush;
  var __reallyNegative=env.__reallyNegative;
  var _fileno=env._fileno;
  var __exit=env.__exit;
  var __arraySum=env.__arraySum;
  var _fgets=env._fgets;
  var _atan=env._atan;
  var _pread=env._pread;
  var _mkport=env._mkport;
  var _getc=env._getc;
  var _feof=env._feof;
  var _emscripten_set_main_loop=env._emscripten_set_main_loop;
  var __scanString=env.__scanString;
  var _copysign=env._copysign;
  var _fputc=env._fputc;
  var _copysignl=env._copysignl;
  var _strerror=env._strerror;
  var _emscripten_longjmp=env._emscripten_longjmp;
  var __formatString=env.__formatString;
  var _sqrt=env._sqrt;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function _printf_core($f, $fmt, $ap, $nl_arg, $nl_type) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 $nl_arg = $nl_arg | 0;
 $nl_type = $nl_type | 0;
 var $$$p$i = 0, $$0 = 0, $$0$lcssa$i = 0, $$0$lcssa$i$i = 0, $$0$lcssa$i103$i = 0, $$0$lcssa$i127$i = 0, $$0$lcssa$i142$i = 0, $$0$lcssa$i37 = 0, $$0$lcssa$i38$i = 0, $$0$lcssa$i43 = 0, $$0$lcssa$i45 = 0, $$0$lcssa$i45$i = 0, $$0$lcssa$i48$i = 0, $$0$lcssa$i52 = 0, $$0$lcssa$i55$i = 0, $$0$lcssa$i59 = 0, $$0$lcssa$i62$i = 0, $$0$lcssa$i66 = 0, $$0$lcssa$i68$i = 0, $$0$lcssa$i75$i = 0, $$0$lcssa$i76 = 0, $$0$lcssa$i84$i = 0, $$0$lcssa$i96$i = 0, $$01$i = 0, $$01$i$i = 0, $$01$i101$i = 0, $$01$i125$i = 0, $$01$i140$i = 0, $$01$i35 = 0, $$01$i36$i = 0, $$01$i43$i = 0, $$01$i50 = 0, $$01$i53$i = 0, $$01$i57 = 0, $$01$i60$i = 0, $$01$i64 = 0, $$01$i66$i = 0, $$01$i73$i = 0, $$01$i74 = 0, $$01$i94$i = 0, $$01$lcssa$off0$i = 0, $$01$lcssa$off0$i$i = 0, $$01$lcssa$off0$i85$i = 0, $$012$i = 0, $$013$i = 0, $$03$i40 = 0, $$05$i = 0, $$05$i$i = 0, $$05$i79$i = 0, $$07$i = 0.0, $$1$i = 0.0, $$1$lcssa$i$i = 0, $$1$lcssa$i112$i = 0, $$114$i = 0, $$12$i = 0, $$12$i$i = 0, $$12$i110$i = 0, $$12$i119$i = 0, $$12$i134$i = 0, $$12$i87$i = 0, $$2$i = 0.0, $$2$us$i = 0.0, $$2$us$us$i = 0.0, $$2$us159$i = 0.0, $$20$i = 0, $$20$us$i = 0, $$210$i = 0, $$22$i = 0.0, $$23$i = 0, $$25$i = 0, $$3$i = 0.0, $$31$i = 0, $$311$i = 0, $$4$i = 0.0, $$412$lcssa$i = 0, $$412175$i = 0, $$5193$i = 0, $$a$3$i = 0, $$a$3$us$i = 0, $$a$3$us323$i = 0, $$a$3325$i = 0, $$fl$4 = 0, $$lcssa300$i = 0, $$lcssa92 = 0, $$not$i = 0, $$p$5 = 0, $$p$i = 0, $$pn$i = 0, $$pr$i = 0, $$pr146$i = 0, $$pre319$i = 0, $$z$4$us$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1003 = 0, $1004 = 0, $1008 = 0, $1010 = 0, $1013 = 0, $1017 = 0, $1018 = 0, $102 = 0, $1022 = 0, $1024 = 0, $1027 = 0, $103 = 0, $1031 = 0, $1032 = 0, $1036 = 0.0, $1037 = 0.0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $11 = 0, $12 = 0, $124 = 0, $125 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $134 = 0, $135 = 0, $137 = 0, $139 = 0, $14 = 0, $141 = 0, $142 = 0, $147 = 0, $15 = 0, $150 = 0, $158 = 0, $159 = 0, $163 = 0, $165 = 0, $167 = 0, $170 = 0, $172 = 0, $179 = 0, $181 = 0, $188 = 0, $190 = 0.0, $194 = 0.0, $198 = 0, $199 = 0, $2 = 0, $206 = 0, $207 = 0, $21 = 0, $210 = 0, $218 = 0, $22 = 0, $225 = 0, $226 = 0, $229 = 0, $232 = 0, $239 = 0, $24 = 0, $249 = 0, $25 = 0, $252 = 0, $254 = 0, $257 = 0, $258 = 0, $269 = 0, $27 = 0, $274 = 0, $276 = 0, $277 = 0, $279 = 0, $284 = 0, $285 = 0, $286 = 0, $3 = 0, $30 = 0, $302 = 0, $308 = 0, $31 = 0, $311 = 0, $312 = 0, $317 = 0, $325 = 0, $335 = 0, $336 = 0, $338 = 0, $343 = 0, $345 = 0, $346 = 0, $350 = 0, $353 = 0, $355 = 0, $36 = 0, $361 = 0, $365 = 0, $369 = 0.0, $374 = 0, $378 = 0, $38 = 0, $385 = 0, $389 = 0, $39 = 0, $392 = 0, $393 = 0, $397 = 0, $4 = 0, $401 = 0, $405 = 0, $408 = 0.0, $409 = 0, $412 = 0, $414 = 0, $417 = 0, $432 = 0, $435 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $45 = 0, $457 = 0, $46 = 0, $469 = 0, $472 = 0, $473 = 0, $479 = 0, $488 = 0, $494 = 0, $5 = 0, $50 = 0, $503 = 0, $509 = 0, $516 = 0, $518 = 0, $524 = 0, $542 = 0, $543 = 0, $545 = 0, $546 = 0, $55 = 0, $550 = 0, $553 = 0, $557 = 0, $559 = 0, $561 = 0, $563 = 0, $568 = 0, $571 = 0, $575 = 0, $58 = 0, $580 = 0, $582 = 0, $583 = 0, $59 = 0, $591 = 0, $592 = 0, $595 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $605 = 0, $607 = 0, $611 = 0, $616 = 0, $618 = 0, $619 = 0, $620 = 0, $621 = 0, $640 = 0, $642 = 0, $645 = 0, $649 = 0, $65 = 0, $650 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $681 = 0, $685 = 0, $686 = 0, $689 = 0, $694 = 0, $696 = 0, $7 = 0, $703 = 0, $704 = 0, $705 = 0, $708 = 0, $709 = 0, $710 = 0, $717 = 0, $727 = 0, $730 = 0, $732 = 0, $734 = 0, $736 = 0, $741 = 0, $742 = 0, $745 = 0, $747 = 0, $749 = 0, $751 = 0, $765 = 0, $770 = 0, $779 = 0, $780 = 0, $784 = 0, $787 = 0, $790 = 0, $791 = 0, $793 = 0, $797 = 0, $8 = 0, $801 = 0, $802 = 0, $803 = 0, $819 = 0, $825 = 0, $835 = 0, $840 = 0, $841 = 0, $843 = 0, $844 = 0, $848 = 0, $85 = 0, $851 = 0, $855 = 0, $858 = 0, $863 = 0, $868 = 0, $879 = 0, $888 = 0, $89 = 0, $893 = 0, $9 = 0, $900 = 0, $905 = 0, $916 = 0, $918 = 0, $92 = 0, $921 = 0, $931 = 0, $936 = 0, $940 = 0, $944 = 0, $946 = 0, $948 = 0, $95 = 0, $950 = 0, $951 = 0, $955 = 0, $958 = 0, $962 = 0, $965 = 0, $969 = 0, $972 = 0, $976 = 0, $981 = 0, $983 = 0, $985 = 0, $986 = 0, $989 = 0, $993 = 0, $994 = 0, $998 = 0, $a$0 = 0, $a$1 = 0, $a$1$lcssa$i = 0, $a$1263$i = 0, $a$2 = 0, $a$2$ph$i = 0, $a$3$lcssa$i = 0, $a$3249$i = 0, $a$3249$us$i = 0, $a$5$lcssa$i = 0, $a$5223$i = 0, $a$6$i = 0, $a$7$i = 0, $a$8$ph$i = 0, $arglist_current = 0, $arglist_current11 = 0, $arglist_current14 = 0, $arglist_current17 = 0, $arglist_current2 = 0, $arglist_current20 = 0, $arglist_current23 = 0, $arglist_current26 = 0, $arglist_current29 = 0, $arglist_current32 = 0, $arglist_current35 = 0, $arglist_current38 = 0, $arglist_current41 = 0, $arglist_current44 = 0, $arglist_current47 = 0, $arglist_current5 = 0, $arglist_current50 = 0, $arglist_current53 = 0, $arglist_current56 = 0, $arglist_current59 = 0, $arglist_current62 = 0, $arglist_current8 = 0, $argpos$0 = 0, $big$i = 0, $buf = 0, $buf$i = 0, $carry$0255$i = 0, $carry3$0243$i = 0, $carry3$0243$us$i = 0, $cnt$0 = 0, $cnt$1 = 0, $d$0254$i = 0, $d$0256$i = 0, $d$1242$i = 0, $d$1242$us$i = 0, $d$2$lcssa$i = 0, $d$2222$i = 0, $d$3$i = 0, $d$4183$i = 0, $d$5174$i = 0, $d$6192$i = 0, $e$0238$i = 0, $e$1$i = 0, $e$2218$i = 0, $e$3$i = 0, $e$4$ph$i = 0, $e2$i = 0, $ebuf0$i = 0, $estr$0$i = 0, $estr$1$lcssa$i = 0, $estr$1$ph$i = 0, $estr$1200$i = 0, $estr$2$i = 0, $fl$0100 = 0, $fl$0104 = 0, $fl$1 = 0, $fl$1$ = 0, $fl$3 = 0, $fl$4 = 0, $fl$6 = 0, $i$0$lcssa = 0, $i$0166 = 0, $i$0168 = 0, $i$0237$i = 0, $i$03$i = 0, $i$03$i22 = 0, $i$1$lcssa$i = 0, $i$1174 = 0, $i$1230$i = 0, $i$2217$i = 0, $i$289 = 0, $i$3209$i = 0, $i$388 = 0, $isdigittmp = 0, $isdigittmp10 = 0, $isdigittmp8 = 0, $j$0229$i = 0, $j$0231$i = 0, $j$1210$i = 0, $j$2$i = 0, $l$0 = 0, $l$0$i = 0, $l$1$lcssa = 0, $l$1167 = 0, $l10n$0 = 0, $l10n$1 = 0, $l10n$2 = 0, $l10n$3 = 0, $mb = 0, $p$0 = 0, $p$1 = 0, $p$2 = 0, $p$4296 = 0, $p$5 = 0, $pad$i = 0, $pl$0 = 0, $pl$0$i = 0, $pl$1 = 0, $pl$1$i = 0, $pl$2 = 0, $prefix$0 = 0, $prefix$0$$i = 0, $prefix$0$i = 0, $prefix$1 = 0, $prefix$2 = 0, $r$0$a$8$i = 0, $re$0$i = 0, $re$1165$i = 0, $round$0164$i = 0.0, $round6$1$i = 0.0, $s$0$i = 0, $s$0$us$i = 0, $s$0$us$us$i = 0, $s$0$us158$i = 0, $s$1$i = 0, $s$1$lcssa$i = 0, $s$1$us$i = 0, $s$1$us$us$i = 0, $s$1$us160$i = 0, $s1$0$i = 0, $s7$0180$i = 0, $s7$1$i = 0, $s8$0$lcssa$i = 0, $s8$0169$i = 0, $s9$0$i = 0, $s9$1188$i = 0, $s9$2$i = 0, $small$0$i = 0.0, $small$1$i = 0.0, $st$0 = 0, $storemerge = 0, $storemerge12 = 0, $storemerge7103 = 0, $storemerge798 = 0, $t$0 = 0, $t$1 = 0, $w$0 = 0, $w$1 = 0, $w$2 = 0, $wc = 0, $ws$0169 = 0, $ws$1175 = 0, $y$03$i = 0, $y$03$i$i = 0, $y$03$i109$i = 0, $y$03$i118$i = 0, $y$03$i133$i = 0, $y$03$i86$i = 0, $z$0$i = 0, $z$0$lcssa = 0, $z$093 = 0, $z$1$lcssa$i = 0, $z$1262$i = 0, $z$2 = 0, $z$2$i = 0, $z$3$lcssa$i = 0, $z$3248$i = 0, $z$3248$us$i = 0, $z$4$i = 0, $z$4$us$i = 0, $z$5$i = 0, $z$6$$i = 0, $z$6$i = 0, $z$6$ph$i = 0, label = 0, sp = 0, $439$looptemp = 0, $801$looptemp = 0, $284$looptemp = 0;
 sp = STACKTOP; //@line 13676
 STACKTOP = STACKTOP + 864 | 0; //@line 13677
 $big$i = sp + 16 | 0; //@line 13678
 $e2$i = sp + 8 | 0; //@line 13679
 $buf$i = sp + 560 | 0; //@line 13680
 $0 = $buf$i; //@line 13681
 $ebuf0$i = sp + 840 | 0; //@line 13682
 $pad$i = sp + 584 | 0; //@line 13683
 $buf = sp + 520 | 0; //@line 13684
 $wc = sp; //@line 13685
 $mb = sp + 852 | 0; //@line 13686
 $1 = ($f | 0) != 0; //@line 13687
 $2 = $buf + 40 | 0; //@line 13688
 $3 = $2; //@line 13689
 $4 = $buf + 39 | 0; //@line 13690
 $5 = $wc + 4 | 0; //@line 13691
 $6 = $ebuf0$i + 12 | 0; //@line 13692
 $7 = $ebuf0$i + 11 | 0; //@line 13693
 $8 = $6; //@line 13694
 $9 = $8 - $0 | 0; //@line 13695
 $10 = -2 - $0 | 0; //@line 13696
 $11 = $8 + 2 | 0; //@line 13697
 $12 = $big$i + 288 | 0; //@line 13698
 $13 = $buf$i + 9 | 0; //@line 13699
 $14 = $13; //@line 13700
 $15 = $buf$i + 8 | 0; //@line 13701
 $1045 = 0; //@line 13702
 $1046 = 0; //@line 13702
 $22 = $fmt; //@line 13702
 $cnt$0 = 0; //@line 13702
 $l$0 = 0; //@line 13702
 $l10n$0 = 0; //@line 13702
 L1 : while (1) {
  do if (($cnt$0 | 0) > -1) if (($l$0 | 0) > (2147483647 - $cnt$0 | 0)) {
   HEAP32[(___errno_location() | 0) >> 2] = 75; //@line 13711
   $cnt$1 = -1; //@line 13712
   break;
  } else {
   $cnt$1 = $l$0 + $cnt$0 | 0; //@line 13716
   break;
  } else $cnt$1 = $cnt$0; //@line 13720
 while (0);
  $21 = HEAP8[$22 >> 0] | 0; //@line 13723
  if (!($21 << 24 >> 24)) {
   label = 344; //@line 13726
   break;
  } else {
   $1047 = $21; //@line 13729
   $25 = $22; //@line 13729
  }
  while (1) {
   if (!($1047 << 24 >> 24)) {
    $$lcssa92 = $25; //@line 13733
    $z$0$lcssa = $25; //@line 13733
    break;
   } else if ($1047 << 24 >> 24 == 37) {
    $27 = $25; //@line 13736
    $z$093 = $25; //@line 13736
    label = 9; //@line 13737
    break;
   }
   $24 = $25 + 1 | 0; //@line 13740
   $1047 = HEAP8[$24 >> 0] | 0; //@line 13742
   $25 = $24; //@line 13742
  }
  L12 : do if ((label | 0) == 9) while (1) {
   label = 0; //@line 13747
   if ((HEAP8[$27 + 1 >> 0] | 0) != 37) {
    $$lcssa92 = $27; //@line 13752
    $z$0$lcssa = $z$093; //@line 13752
    break L12;
   }
   $30 = $z$093 + 1 | 0; //@line 13755
   $31 = $27 + 2 | 0; //@line 13756
   if ((HEAP8[$31 >> 0] | 0) == 37) {
    $27 = $31; //@line 13760
    $z$093 = $30; //@line 13760
    label = 9; //@line 13761
   } else {
    $$lcssa92 = $31; //@line 13763
    $z$0$lcssa = $30; //@line 13763
    break;
   }
  } while (0);
  $36 = $z$0$lcssa - $22 | 0; //@line 13771
  if ($1) ___fwritex($22, $36, $f) | 0; //@line 13773
  if (($z$0$lcssa | 0) != ($22 | 0)) {
   $22 = $$lcssa92; //@line 13777
   $cnt$0 = $cnt$1; //@line 13777
   $l$0 = $36; //@line 13777
   continue;
  }
  $38 = $$lcssa92 + 1 | 0; //@line 13780
  $39 = HEAP8[$38 >> 0] | 0; //@line 13781
  $isdigittmp = ($39 << 24 >> 24) + -48 | 0; //@line 13783
  if ($isdigittmp >>> 0 < 10) if ((HEAP8[$$lcssa92 + 2 >> 0] | 0) == 36) {
   $44 = $$lcssa92 + 3 | 0; //@line 13790
   $46 = HEAP8[$44 >> 0] | 0; //@line 13792
   $argpos$0 = $isdigittmp; //@line 13792
   $l10n$1 = 1; //@line 13792
   $storemerge = $44; //@line 13792
  } else {
   $46 = $39; //@line 13794
   $argpos$0 = -1; //@line 13794
   $l10n$1 = $l10n$0; //@line 13794
   $storemerge = $38; //@line 13794
  } else {
   $46 = $39; //@line 13797
   $argpos$0 = -1; //@line 13797
   $l10n$1 = $l10n$0; //@line 13797
   $storemerge = $38; //@line 13797
  }
  $45 = $46 << 24 >> 24; //@line 13799
  L25 : do if (($45 + -32 | 0) >>> 0 < 32) {
   $50 = $45; //@line 13804
   $55 = $46; //@line 13804
   $fl$0104 = 0; //@line 13804
   $storemerge7103 = $storemerge; //@line 13804
   while (1) {
    if (!(1 << $50 + -32 & 75913)) {
     $65 = $55; //@line 13811
     $fl$0100 = $fl$0104; //@line 13811
     $storemerge798 = $storemerge7103; //@line 13811
     break L25;
    }
    $58 = 1 << ($55 << 24 >> 24) + -32 | $fl$0104; //@line 13817
    $59 = $storemerge7103 + 1 | 0; //@line 13818
    $60 = HEAP8[$59 >> 0] | 0; //@line 13819
    $50 = $60 << 24 >> 24; //@line 13820
    if (($50 + -32 | 0) >>> 0 >= 32) {
     $65 = $60; //@line 13826
     $fl$0100 = $58; //@line 13826
     $storemerge798 = $59; //@line 13826
     break;
    } else {
     $55 = $60; //@line 13824
     $fl$0104 = $58; //@line 13824
     $storemerge7103 = $59; //@line 13824
    }
   }
  } else {
   $65 = $46; //@line 13831
   $fl$0100 = 0; //@line 13831
   $storemerge798 = $storemerge; //@line 13831
  } while (0);
  do if ($65 << 24 >> 24 == 42) {
   $66 = $storemerge798 + 1 | 0; //@line 13837
   $isdigittmp10 = (HEAP8[$66 >> 0] | 0) + -48 | 0; //@line 13840
   if ($isdigittmp10 >>> 0 < 10) if ((HEAP8[$storemerge798 + 2 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp10 << 2) >> 2] = 10; //@line 13848
    $l10n$2 = 1; //@line 13860
    $storemerge12 = $storemerge798 + 3 | 0; //@line 13860
    $w$0 = HEAP32[$nl_arg + ((HEAP8[$66 >> 0] | 0) + -48 << 3) >> 2] | 0; //@line 13860
   } else label = 24; //@line 13862
 else label = 24; //@line 13865
   if ((label | 0) == 24) {
    label = 0; //@line 13868
    if ($l10n$1) {
     $$0 = -1; //@line 13871
     label = 362; //@line 13872
     break L1;
    }
    if (!$1) {
     $100 = $66; //@line 13876
     $fl$1 = $fl$0100; //@line 13876
     $l10n$3 = 0; //@line 13876
     $w$1 = 0; //@line 13876
     break;
    }
    $arglist_current = HEAP32[$ap >> 2] | 0; //@line 13879
    $85 = HEAP32[$arglist_current >> 2] | 0; //@line 13880
    HEAP32[$ap >> 2] = $arglist_current + 4; //@line 13882
    $l10n$2 = 0; //@line 13883
    $storemerge12 = $66; //@line 13883
    $w$0 = $85; //@line 13883
   }
   if (($w$0 | 0) < 0) {
    $100 = $storemerge12; //@line 13889
    $fl$1 = $fl$0100 | 8192; //@line 13889
    $l10n$3 = $l10n$2; //@line 13889
    $w$1 = 0 - $w$0 | 0; //@line 13889
   } else {
    $100 = $storemerge12; //@line 13891
    $fl$1 = $fl$0100; //@line 13891
    $l10n$3 = $l10n$2; //@line 13891
    $w$1 = $w$0; //@line 13891
   }
  } else {
   $89 = $65 << 24 >> 24; //@line 13894
   if (($89 + -48 | 0) >>> 0 < 10) {
    $92 = $89; //@line 13898
    $95 = $storemerge798; //@line 13898
    $i$03$i = 0; //@line 13898
    do {
     $i$03$i = $92 + -48 + ($i$03$i * 10 | 0) | 0; //@line 13902
     $95 = $95 + 1 | 0; //@line 13903
     $92 = HEAP8[$95 >> 0] | 0; //@line 13905
    } while (($92 + -48 | 0) >>> 0 < 10);
    if (($i$03$i | 0) < 0) {
     $$0 = -1; //@line 13916
     label = 362; //@line 13917
     break L1;
    } else {
     $100 = $95; //@line 13920
     $fl$1 = $fl$0100; //@line 13920
     $l10n$3 = $l10n$1; //@line 13920
     $w$1 = $i$03$i; //@line 13920
    }
   } else {
    $100 = $storemerge798; //@line 13923
    $fl$1 = $fl$0100; //@line 13923
    $l10n$3 = $l10n$1; //@line 13923
    $w$1 = 0; //@line 13923
   }
  } while (0);
  L46 : do if ((HEAP8[$100 >> 0] | 0) == 46) {
   $102 = $100 + 1 | 0; //@line 13931
   $103 = HEAP8[$102 >> 0] | 0; //@line 13932
   if ($103 << 24 >> 24 != 42) {
    $125 = $103 << 24 >> 24; //@line 13935
    if (($125 + -48 | 0) >>> 0 < 10) {
     $128 = $125; //@line 13939
     $131 = $102; //@line 13939
     $i$03$i22 = 0; //@line 13939
    } else {
     $1048 = $102; //@line 13941
     $p$0 = 0; //@line 13941
     break;
    }
    while (1) {
     $129 = $128 + -48 + ($i$03$i22 * 10 | 0) | 0; //@line 13947
     $130 = $131 + 1 | 0; //@line 13948
     $128 = HEAP8[$130 >> 0] | 0; //@line 13950
     if (($128 + -48 | 0) >>> 0 >= 10) {
      $1048 = $130; //@line 13956
      $p$0 = $129; //@line 13956
      break L46;
     } else {
      $131 = $130; //@line 13954
      $i$03$i22 = $129; //@line 13954
     }
    }
   }
   $105 = $100 + 2 | 0; //@line 13961
   $isdigittmp8 = (HEAP8[$105 >> 0] | 0) + -48 | 0; //@line 13964
   if ($isdigittmp8 >>> 0 < 10) if ((HEAP8[$100 + 3 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp8 << 2) >> 2] = 10; //@line 13972
    $1048 = $100 + 4 | 0; //@line 13984
    $p$0 = HEAP32[$nl_arg + ((HEAP8[$105 >> 0] | 0) + -48 << 3) >> 2] | 0; //@line 13984
    break;
   }
   if ($l10n$3) {
    $$0 = -1; //@line 13990
    label = 362; //@line 13991
    break L1;
   }
   if ($1) {
    $arglist_current2 = HEAP32[$ap >> 2] | 0; //@line 13995
    $124 = HEAP32[$arglist_current2 >> 2] | 0; //@line 13996
    HEAP32[$ap >> 2] = $arglist_current2 + 4; //@line 13998
    $1048 = $105; //@line 13999
    $p$0 = $124; //@line 13999
   } else {
    $1048 = $105; //@line 14001
    $p$0 = 0; //@line 14001
   }
  } else {
   $1048 = $100; //@line 14004
   $p$0 = -1; //@line 14004
  } while (0);
  $135 = $1048; //@line 14007
  $st$0 = 0; //@line 14007
  while (1) {
   $134 = HEAP8[$135 >> 0] | 0; //@line 14009
   $137 = ($134 << 24 >> 24) + -65 | 0; //@line 14011
   if ($137 >>> 0 > 57) {
    $$0 = -1; //@line 14014
    label = 362; //@line 14015
    break L1;
   }
   $139 = $135 + 1 | 0; //@line 14018
   $141 = HEAP8[12568 + ($st$0 * 58 | 0) + $137 >> 0] | 0; //@line 14020
   $142 = $141 & 255; //@line 14021
   if (($142 + -1 | 0) >>> 0 < 8) {
    $135 = $139; //@line 14025
    $st$0 = $142; //@line 14025
   } else break;
  }
  if (!($141 << 24 >> 24)) {
   $$0 = -1; //@line 14032
   label = 362; //@line 14033
   break;
  }
  $147 = ($argpos$0 | 0) > -1; //@line 14037
  L65 : do if ($141 << 24 >> 24 == 19) if ($147) {
   $$0 = -1; //@line 14041
   label = 362; //@line 14042
   break L1;
  } else {
   $1049 = $1045; //@line 14045
   $1050 = $1046; //@line 14045
   label = 63; //@line 14046
  } else {
   if ($147) {
    HEAP32[$nl_type + ($argpos$0 << 2) >> 2] = $142; //@line 14051
    $150 = $nl_arg + ($argpos$0 << 3) | 0; //@line 14053
    $1049 = HEAP32[$150 + 4 >> 2] | 0; //@line 14060
    $1050 = HEAP32[$150 >> 2] | 0; //@line 14060
    label = 63; //@line 14061
    break;
   }
   if (!$1) {
    $$0 = 0; //@line 14065
    label = 362; //@line 14066
    break L1;
   }
   if (($141 & 255) > 20) {
    $199 = $134; //@line 14071
    $207 = $1046; //@line 14071
    $229 = $1045; //@line 14071
   } else do switch ($142 | 0) {
   case 12:
    {
     $arglist_current14 = HEAP32[$ap >> 2] | 0; //@line 14076
     $165 = $arglist_current14; //@line 14077
     $167 = HEAP32[$165 >> 2] | 0; //@line 14079
     $170 = HEAP32[$165 + 4 >> 2] | 0; //@line 14082
     HEAP32[$ap >> 2] = $arglist_current14 + 8; //@line 14084
     $1051 = $167; //@line 14086
     $1052 = $170; //@line 14086
     label = 64; //@line 14087
     break L65;
     break;
    }
   case 11:
    {
     $arglist_current11 = HEAP32[$ap >> 2] | 0; //@line 14092
     $163 = HEAP32[$arglist_current11 >> 2] | 0; //@line 14093
     HEAP32[$ap >> 2] = $arglist_current11 + 4; //@line 14095
     $1051 = $163; //@line 14097
     $1052 = 0; //@line 14097
     label = 64; //@line 14098
     break L65;
     break;
    }
   case 18:
    {
     $arglist_current32 = HEAP32[$ap >> 2] | 0; //@line 14103
     HEAP32[tempDoublePtr >> 2] = HEAP32[$arglist_current32 >> 2]; //@line 14104
     HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[$arglist_current32 + 4 >> 2]; //@line 14104
     $194 = +HEAPF64[tempDoublePtr >> 3]; //@line 14104
     HEAP32[$ap >> 2] = $arglist_current32 + 8; //@line 14106
     HEAPF64[tempDoublePtr >> 3] = $194; //@line 14107
     $1049 = HEAP32[tempDoublePtr + 4 >> 2] | 0; //@line 14110
     $1050 = HEAP32[tempDoublePtr >> 2] | 0; //@line 14110
     label = 63; //@line 14111
     break L65;
     break;
    }
   case 17:
    {
     $arglist_current29 = HEAP32[$ap >> 2] | 0; //@line 14116
     HEAP32[tempDoublePtr >> 2] = HEAP32[$arglist_current29 >> 2]; //@line 14117
     HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[$arglist_current29 + 4 >> 2]; //@line 14117
     $190 = +HEAPF64[tempDoublePtr >> 3]; //@line 14117
     HEAP32[$ap >> 2] = $arglist_current29 + 8; //@line 14119
     HEAPF64[tempDoublePtr >> 3] = $190; //@line 14120
     $1051 = HEAP32[tempDoublePtr >> 2] | 0; //@line 14123
     $1052 = HEAP32[tempDoublePtr + 4 >> 2] | 0; //@line 14123
     label = 64; //@line 14124
     break L65;
     break;
    }
   case 9:
    {
     $arglist_current5 = HEAP32[$ap >> 2] | 0; //@line 14129
     $158 = HEAP32[$arglist_current5 >> 2] | 0; //@line 14130
     HEAP32[$ap >> 2] = $arglist_current5 + 4; //@line 14132
     $1051 = $158; //@line 14133
     $1052 = $1045; //@line 14133
     label = 64; //@line 14134
     break L65;
     break;
    }
   case 10:
    {
     $arglist_current8 = HEAP32[$ap >> 2] | 0; //@line 14139
     $159 = HEAP32[$arglist_current8 >> 2] | 0; //@line 14140
     HEAP32[$ap >> 2] = $arglist_current8 + 4; //@line 14142
     $1051 = $159; //@line 14146
     $1052 = (($159 | 0) < 0) << 31 >> 31; //@line 14146
     label = 64; //@line 14147
     break L65;
     break;
    }
   case 14:
    {
     $arglist_current20 = HEAP32[$ap >> 2] | 0; //@line 14152
     $179 = HEAP32[$arglist_current20 >> 2] | 0; //@line 14153
     HEAP32[$ap >> 2] = $arglist_current20 + 4; //@line 14155
     $1051 = $179 & 65535; //@line 14158
     $1052 = 0; //@line 14158
     label = 64; //@line 14159
     break L65;
     break;
    }
   case 13:
    {
     $arglist_current17 = HEAP32[$ap >> 2] | 0; //@line 14164
     $172 = HEAP32[$arglist_current17 >> 2] | 0; //@line 14165
     HEAP32[$ap >> 2] = $arglist_current17 + 4; //@line 14167
     $1051 = $172 << 16 >> 16; //@line 14175
     $1052 = ((($172 & 65535) << 16 >> 16 | 0) < 0) << 31 >> 31; //@line 14175
     label = 64; //@line 14176
     break L65;
     break;
    }
   case 15:
    {
     $arglist_current23 = HEAP32[$ap >> 2] | 0; //@line 14181
     $181 = HEAP32[$arglist_current23 >> 2] | 0; //@line 14182
     HEAP32[$ap >> 2] = $arglist_current23 + 4; //@line 14184
     $1051 = $181 << 24 >> 24; //@line 14192
     $1052 = ((($181 & 255) << 24 >> 24 | 0) < 0) << 31 >> 31; //@line 14192
     label = 64; //@line 14193
     break L65;
     break;
    }
   case 16:
    {
     $arglist_current26 = HEAP32[$ap >> 2] | 0; //@line 14198
     $188 = HEAP32[$arglist_current26 >> 2] | 0; //@line 14199
     HEAP32[$ap >> 2] = $arglist_current26 + 4; //@line 14201
     $1051 = $188 & 255; //@line 14204
     $1052 = 0; //@line 14204
     label = 64; //@line 14205
     break L65;
     break;
    }
   default:
    {
     $1051 = $1046; //@line 14210
     $1052 = $1045; //@line 14210
     label = 64; //@line 14211
     break L65;
    }
   } while (0);
  } while (0);
  if ((label | 0) == 63) {
   label = 0; //@line 14220
   if ($1) {
    $1051 = $1050; //@line 14222
    $1052 = $1049; //@line 14222
    label = 64; //@line 14223
   } else {
    $1045 = $1049; //@line 14225
    $1046 = $1050; //@line 14225
    $22 = $139; //@line 14225
    $cnt$0 = $cnt$1; //@line 14225
    $l$0 = $36; //@line 14225
    $l10n$0 = $l10n$3; //@line 14225
    continue;
   }
  }
  if ((label | 0) == 64) {
   label = 0; //@line 14230
   $199 = HEAP8[$135 >> 0] | 0; //@line 14232
   $207 = $1051; //@line 14232
   $229 = $1052; //@line 14232
  }
  $198 = $199 << 24 >> 24; //@line 14234
  if (!$st$0) $t$0 = $198; //@line 14237
 else $t$0 = ($198 & 15 | 0) == 3 ? $198 & -33 : $198; //@line 14243
  $206 = $fl$1 & -65537; //@line 14247
  $fl$1$ = ($fl$1 & 8192 | 0) == 0 ? $fl$1 : $206; //@line 14248
  L92 : do switch ($t$0 | 0) {
  case 110:
   {
    switch ($st$0 | 0) {
    case 2:
     {
      $210 = $207; //@line 14256
      HEAP32[$210 >> 2] = $cnt$1; //@line 14258
      HEAP32[$210 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31; //@line 14261
      $1045 = $229; //@line 14262
      $1046 = $207; //@line 14262
      $22 = $139; //@line 14262
      $cnt$0 = $cnt$1; //@line 14262
      $l$0 = $36; //@line 14262
      $l10n$0 = $l10n$3; //@line 14262
      continue L1;
      break;
     }
    case 3:
     {
      HEAP16[$207 >> 1] = $cnt$1; //@line 14268
      $1045 = $229; //@line 14269
      $1046 = $207; //@line 14269
      $22 = $139; //@line 14269
      $cnt$0 = $cnt$1; //@line 14269
      $l$0 = $36; //@line 14269
      $l10n$0 = $l10n$3; //@line 14269
      continue L1;
      break;
     }
    case 0:
     {
      HEAP32[$207 >> 2] = $cnt$1; //@line 14274
      $1045 = $229; //@line 14275
      $1046 = $207; //@line 14275
      $22 = $139; //@line 14275
      $cnt$0 = $cnt$1; //@line 14275
      $l$0 = $36; //@line 14275
      $l10n$0 = $l10n$3; //@line 14275
      continue L1;
      break;
     }
    case 1:
     {
      HEAP32[$207 >> 2] = $cnt$1; //@line 14280
      $1045 = $229; //@line 14281
      $1046 = $207; //@line 14281
      $22 = $139; //@line 14281
      $cnt$0 = $cnt$1; //@line 14281
      $l$0 = $36; //@line 14281
      $l10n$0 = $l10n$3; //@line 14281
      continue L1;
      break;
     }
    case 7:
     {
      $218 = $207; //@line 14288
      HEAP32[$218 >> 2] = $cnt$1; //@line 14290
      HEAP32[$218 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31; //@line 14293
      $1045 = $229; //@line 14294
      $1046 = $207; //@line 14294
      $22 = $139; //@line 14294
      $cnt$0 = $cnt$1; //@line 14294
      $l$0 = $36; //@line 14294
      $l10n$0 = $l10n$3; //@line 14294
      continue L1;
      break;
     }
    case 4:
     {
      HEAP8[$207 >> 0] = $cnt$1; //@line 14300
      $1045 = $229; //@line 14301
      $1046 = $207; //@line 14301
      $22 = $139; //@line 14301
      $cnt$0 = $cnt$1; //@line 14301
      $l$0 = $36; //@line 14301
      $l10n$0 = $l10n$3; //@line 14301
      continue L1;
      break;
     }
    case 6:
     {
      HEAP32[$207 >> 2] = $cnt$1; //@line 14306
      $1045 = $229; //@line 14307
      $1046 = $207; //@line 14307
      $22 = $139; //@line 14307
      $cnt$0 = $cnt$1; //@line 14307
      $l$0 = $36; //@line 14307
      $l10n$0 = $l10n$3; //@line 14307
      continue L1;
      break;
     }
    default:
     {
      $1045 = $229; //@line 14312
      $1046 = $207; //@line 14312
      $22 = $139; //@line 14312
      $cnt$0 = $cnt$1; //@line 14312
      $l$0 = $36; //@line 14312
      $l10n$0 = $l10n$3; //@line 14312
      continue L1;
     }
    }
    break;
   }
  case 88:
  case 120:
   {
    $fl$3 = $fl$1$; //@line 14319
    $p$1 = $p$0; //@line 14319
    $t$1 = $t$0; //@line 14319
    label = 77; //@line 14320
    break;
   }
  case 65:
  case 71:
  case 70:
  case 69:
  case 97:
  case 103:
  case 102:
  case 101:
   {
    HEAP32[tempDoublePtr >> 2] = $207; //@line 14325
    HEAP32[tempDoublePtr + 4 >> 2] = $229; //@line 14325
    $369 = +HEAPF64[tempDoublePtr >> 3]; //@line 14325
    HEAP32[$e2$i >> 2] = 0; //@line 14326
    if (($229 | 0) < 0) {
     $$07$i = -$369; //@line 14330
     $pl$0$i = 1; //@line 14330
     $prefix$0$i = 13056; //@line 14330
    } else if (!($fl$1$ & 2048)) {
     $374 = $fl$1$ & 1; //@line 14335
     $$07$i = $369; //@line 14338
     $pl$0$i = $374; //@line 14338
     $prefix$0$i = ($374 | 0) == 0 ? 13057 : 13062; //@line 14338
    } else {
     $$07$i = $369; //@line 14340
     $pl$0$i = 1; //@line 14340
     $prefix$0$i = 13059; //@line 14340
    }
    HEAPF64[tempDoublePtr >> 3] = $$07$i; //@line 14343
    $378 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072; //@line 14345
    if (!($378 >>> 0 < 2146435072 | ($378 | 0) == 2146435072 & 0 < 0)) {
     $385 = ($t$0 & 32 | 0) != 0; //@line 14353
     if ($$07$i != $$07$i | 0.0 != 0.0) {
      $pl$1$i = 0; //@line 14358
      $s1$0$i = $385 ? 13096 : 13104; //@line 14358
     } else {
      $pl$1$i = $pl$0$i; //@line 14360
      $s1$0$i = $385 ? 13080 : 13088; //@line 14360
     }
     $389 = $pl$1$i + 3 | 0; //@line 14362
     $392 = ($389 | 0) < ($w$1 | 0); //@line 14365
     if (($fl$1$ & 8192 | 0) == 0 & $392) {
      $393 = $w$1 - $389 | 0; //@line 14368
      _memset($pad$i | 0, 32, ($393 >>> 0 > 256 ? 256 : $393) | 0) | 0; //@line 14371
      if ($393 >>> 0 > 255) {
       $$01$i36$i = $393; //@line 14374
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14376
        $397 = $$01$i36$i + -256 | 0; //@line 14377
        if ($397 >>> 0 > 255) $$01$i36$i = $397; //@line 14380
 else {
         $$0$lcssa$i38$i = $397; //@line 14382
         break;
        }
       }
      } else $$0$lcssa$i38$i = $393; //@line 14387
      ___fwritex($pad$i, $$0$lcssa$i38$i, $f) | 0; //@line 14389
     }
     ___fwritex($prefix$0$i, $pl$1$i, $f) | 0; //@line 14391
     ___fwritex($s1$0$i, 3, $f) | 0; //@line 14392
     if (($fl$1$ & 73728 | 0) == 8192 & $392) {
      $401 = $w$1 - $389 | 0; //@line 14397
      _memset($pad$i | 0, 32, ($401 >>> 0 > 256 ? 256 : $401) | 0) | 0; //@line 14400
      if ($401 >>> 0 > 255) {
       $$01$i43$i = $401; //@line 14403
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14405
        $405 = $$01$i43$i + -256 | 0; //@line 14406
        if ($405 >>> 0 > 255) $$01$i43$i = $405; //@line 14409
 else {
         $$0$lcssa$i45$i = $405; //@line 14411
         break;
        }
       }
      } else $$0$lcssa$i45$i = $401; //@line 14416
      ___fwritex($pad$i, $$0$lcssa$i45$i, $f) | 0; //@line 14418
     }
     $1045 = $229; //@line 14421
     $1046 = $207; //@line 14421
     $22 = $139; //@line 14421
     $cnt$0 = $cnt$1; //@line 14421
     $l$0 = $392 ? $w$1 : $389; //@line 14421
     $l10n$0 = $l10n$3; //@line 14421
     continue L1;
    }
    $408 = +_frexpl($$07$i, $e2$i) * 2.0; //@line 14425
    $409 = $408 != 0.0; //@line 14426
    if ($409) HEAP32[$e2$i >> 2] = (HEAP32[$e2$i >> 2] | 0) + -1; //@line 14430
    $412 = $t$0 | 32; //@line 14432
    if (($412 | 0) == 97) {
     $414 = $t$0 & 32; //@line 14435
     $prefix$0$$i = ($414 | 0) == 0 ? $prefix$0$i : $prefix$0$i + 9 | 0; //@line 14438
     $417 = $pl$0$i | 2; //@line 14439
     $re$0$i = $p$0 >>> 0 > 11 ? 0 : 12 - $p$0 | 0; //@line 14442
     do if (!$re$0$i) $$1$i = $408; //@line 14446
 else {
      $re$1165$i = $re$0$i; //@line 14448
      $round$0164$i = 8.0; //@line 14448
      do {
       $re$1165$i = $re$1165$i + -1 | 0; //@line 14450
       $round$0164$i = $round$0164$i * 16.0; //@line 14451
      } while (($re$1165$i | 0) != 0);
      if ((HEAP8[$prefix$0$$i >> 0] | 0) == 45) {
       $$1$i = -($round$0164$i + (-$408 - $round$0164$i)); //@line 14466
       break;
      } else {
       $$1$i = $408 + $round$0164$i - $round$0164$i; //@line 14471
       break;
      }
     } while (0);
     $432 = HEAP32[$e2$i >> 2] | 0; //@line 14476
     $435 = ($432 | 0) < 0 ? 0 - $432 | 0 : $432; //@line 14479
     if (($435 | 0) < 0) {
      $$05$i$i = $6; //@line 14484
      $439 = $435; //@line 14484
      $440 = (($435 | 0) < 0) << 31 >> 31; //@line 14484
      while (1) {
       $441 = ___uremdi3($439 | 0, $440 | 0, 10, 0) | 0; //@line 14486
       $$05$i$i = $$05$i$i + -1 | 0; //@line 14490
       HEAP8[$$05$i$i >> 0] = $441 | 48; //@line 14491
       $439$looptemp = $439;
       $439 = ___udivdi3($439 | 0, $440 | 0, 10, 0) | 0; //@line 14492
       if (!($440 >>> 0 > 9 | ($440 | 0) == 9 & $439$looptemp >>> 0 > 4294967295)) break; else $440 = tempRet0; //@line 14500
      }
      $$0$lcssa$i48$i = $$05$i$i; //@line 14505
      $$01$lcssa$off0$i$i = $439; //@line 14505
     } else {
      $$0$lcssa$i48$i = $6; //@line 14507
      $$01$lcssa$off0$i$i = $435; //@line 14507
     }
     if (!$$01$lcssa$off0$i$i) $$1$lcssa$i$i = $$0$lcssa$i48$i; //@line 14511
 else {
      $$12$i$i = $$0$lcssa$i48$i; //@line 14513
      $y$03$i$i = $$01$lcssa$off0$i$i; //@line 14513
      while (1) {
       $457 = $$12$i$i + -1 | 0; //@line 14518
       HEAP8[$457 >> 0] = ($y$03$i$i >>> 0) % 10 | 0 | 48; //@line 14519
       if ($y$03$i$i >>> 0 < 10) {
        $$1$lcssa$i$i = $457; //@line 14523
        break;
       } else {
        $$12$i$i = $457; //@line 14526
        $y$03$i$i = ($y$03$i$i >>> 0) / 10 | 0; //@line 14526
       }
      }
     }
     if (($$1$lcssa$i$i | 0) == ($6 | 0)) {
      HEAP8[$7 >> 0] = 48; //@line 14532
      $estr$0$i = $7; //@line 14533
     } else $estr$0$i = $$1$lcssa$i$i; //@line 14535
     HEAP8[$estr$0$i + -1 >> 0] = (HEAP32[$e2$i >> 2] >> 31 & 2) + 43; //@line 14543
     $469 = $estr$0$i + -2 | 0; //@line 14546
     HEAP8[$469 >> 0] = $t$0 + 15; //@line 14547
     $472 = ($fl$1$ & 8 | 0) == 0; //@line 14550
     if (($p$0 | 0) > 0) if ($472) {
      $$2$us$us$i = $$1$i; //@line 14553
      $s$0$us$us$i = $buf$i; //@line 14553
      while (1) {
       $473 = ~~$$2$us$us$i; //@line 14555
       $479 = $s$0$us$us$i + 1 | 0; //@line 14561
       HEAP8[$s$0$us$us$i >> 0] = HEAPU8[13112 + $473 >> 0] | $414; //@line 14562
       $$2$us$us$i = ($$2$us$us$i - +($473 | 0)) * 16.0; //@line 14565
       if (($479 - $0 | 0) == 1) {
        HEAP8[$479 >> 0] = 46; //@line 14571
        $s$1$us$us$i = $s$0$us$us$i + 2 | 0; //@line 14572
       } else $s$1$us$us$i = $479; //@line 14574
       if (!($$2$us$us$i != 0.0)) {
        $s$1$lcssa$i = $s$1$us$us$i; //@line 14580
        break;
       } else $s$0$us$us$i = $s$1$us$us$i; //@line 14578
      }
     } else {
      $$2$us$i = $$1$i; //@line 14585
      $s$0$us$i = $buf$i; //@line 14585
      while (1) {
       $488 = ~~$$2$us$i; //@line 14587
       $494 = $s$0$us$i + 1 | 0; //@line 14593
       HEAP8[$s$0$us$i >> 0] = HEAPU8[13112 + $488 >> 0] | $414; //@line 14594
       $$2$us$i = ($$2$us$i - +($488 | 0)) * 16.0; //@line 14597
       if (($494 - $0 | 0) == 1) {
        HEAP8[$494 >> 0] = 46; //@line 14603
        $s$1$us$i = $s$0$us$i + 2 | 0; //@line 14604
       } else $s$1$us$i = $494; //@line 14606
       if (!($$2$us$i != 0.0)) {
        $s$1$lcssa$i = $s$1$us$i; //@line 14612
        break;
       } else $s$0$us$i = $s$1$us$i; //@line 14610
      }
     } else if ($472) {
      $$2$us159$i = $$1$i; //@line 14619
      $s$0$us158$i = $buf$i; //@line 14619
      while (1) {
       $503 = ~~$$2$us159$i; //@line 14621
       $509 = $s$0$us158$i + 1 | 0; //@line 14627
       HEAP8[$s$0$us158$i >> 0] = HEAPU8[13112 + $503 >> 0] | $414; //@line 14628
       $$2$us159$i = ($$2$us159$i - +($503 | 0)) * 16.0; //@line 14631
       $516 = $$2$us159$i != 0.0; //@line 14635
       if (($509 - $0 | 0) == 1 & $516) {
        HEAP8[$509 >> 0] = 46; //@line 14639
        $s$1$us160$i = $s$0$us158$i + 2 | 0; //@line 14640
       } else $s$1$us160$i = $509; //@line 14642
       if (!$516) {
        $s$1$lcssa$i = $s$1$us160$i; //@line 14647
        break;
       } else $s$0$us158$i = $s$1$us160$i; //@line 14645
      }
     } else {
      $$2$i = $$1$i; //@line 14652
      $s$0$i = $buf$i; //@line 14652
      while (1) {
       $518 = ~~$$2$i; //@line 14654
       $524 = $s$0$i + 1 | 0; //@line 14660
       HEAP8[$s$0$i >> 0] = HEAPU8[13112 + $518 >> 0] | $414; //@line 14661
       $$2$i = ($$2$i - +($518 | 0)) * 16.0; //@line 14664
       if (($524 - $0 | 0) == 1) {
        HEAP8[$524 >> 0] = 46; //@line 14670
        $s$1$i = $s$0$i + 2 | 0; //@line 14671
       } else $s$1$i = $524; //@line 14673
       if (!($$2$i != 0.0)) {
        $s$1$lcssa$i = $s$1$i; //@line 14679
        break;
       } else $s$0$i = $s$1$i; //@line 14677
      }
     }
     $$pre319$i = $s$1$lcssa$i; //@line 14686
     do if (!$p$0) label = 173; //@line 14689
 else {
      if (($10 + $$pre319$i | 0) >= ($p$0 | 0)) {
       label = 173; //@line 14694
       break;
      }
      $l$0$i = $11 + $p$0 - $469 | 0; //@line 14700
     } while (0);
     if ((label | 0) == 173) {
      label = 0; //@line 14704
      $l$0$i = $9 - $469 + $$pre319$i | 0; //@line 14708
     }
     $542 = $l$0$i + $417 | 0; //@line 14710
     $543 = $fl$1$ & 73728; //@line 14711
     $545 = ($542 | 0) < ($w$1 | 0); //@line 14713
     if (($543 | 0) == 0 & $545) {
      $546 = $w$1 - $542 | 0; //@line 14716
      _memset($pad$i | 0, 32, ($546 >>> 0 > 256 ? 256 : $546) | 0) | 0; //@line 14719
      if ($546 >>> 0 > 255) {
       $$01$i53$i = $546; //@line 14722
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14724
        $550 = $$01$i53$i + -256 | 0; //@line 14725
        if ($550 >>> 0 > 255) $$01$i53$i = $550; //@line 14728
 else {
         $$0$lcssa$i55$i = $550; //@line 14730
         break;
        }
       }
      } else $$0$lcssa$i55$i = $546; //@line 14735
      ___fwritex($pad$i, $$0$lcssa$i55$i, $f) | 0; //@line 14737
     }
     ___fwritex($prefix$0$$i, $417, $f) | 0; //@line 14739
     if (($543 | 0) == 65536 & $545) {
      $553 = $w$1 - $542 | 0; //@line 14743
      _memset($pad$i | 0, 48, ($553 >>> 0 > 256 ? 256 : $553) | 0) | 0; //@line 14746
      if ($553 >>> 0 > 255) {
       $$01$i60$i = $553; //@line 14749
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14751
        $557 = $$01$i60$i + -256 | 0; //@line 14752
        if ($557 >>> 0 > 255) $$01$i60$i = $557; //@line 14755
 else {
         $$0$lcssa$i62$i = $557; //@line 14757
         break;
        }
       }
      } else $$0$lcssa$i62$i = $553; //@line 14762
      ___fwritex($pad$i, $$0$lcssa$i62$i, $f) | 0; //@line 14764
     }
     $559 = $$pre319$i - $0 | 0; //@line 14766
     ___fwritex($buf$i, $559, $f) | 0; //@line 14767
     $561 = $8 - $469 | 0; //@line 14769
     $563 = $l$0$i - $561 - $559 | 0; //@line 14771
     if (($563 | 0) > 0) {
      _memset($pad$i | 0, 48, ($563 >>> 0 > 256 ? 256 : $563) | 0) | 0; //@line 14776
      if ($563 >>> 0 > 255) {
       $$01$i66$i = $563; //@line 14779
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14781
        $568 = $$01$i66$i + -256 | 0; //@line 14782
        if ($568 >>> 0 > 255) $$01$i66$i = $568; //@line 14785
 else {
         $$0$lcssa$i68$i = $568; //@line 14787
         break;
        }
       }
      } else $$0$lcssa$i68$i = $563; //@line 14792
      ___fwritex($pad$i, $$0$lcssa$i68$i, $f) | 0; //@line 14794
     }
     ___fwritex($469, $561, $f) | 0; //@line 14796
     if (($543 | 0) == 8192 & $545) {
      $571 = $w$1 - $542 | 0; //@line 14800
      _memset($pad$i | 0, 32, ($571 >>> 0 > 256 ? 256 : $571) | 0) | 0; //@line 14803
      if ($571 >>> 0 > 255) {
       $$01$i73$i = $571; //@line 14806
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 14808
        $575 = $$01$i73$i + -256 | 0; //@line 14809
        if ($575 >>> 0 > 255) $$01$i73$i = $575; //@line 14812
 else {
         $$0$lcssa$i75$i = $575; //@line 14814
         break;
        }
       }
      } else $$0$lcssa$i75$i = $571; //@line 14819
      ___fwritex($pad$i, $$0$lcssa$i75$i, $f) | 0; //@line 14821
     }
     $1045 = $229; //@line 14824
     $1046 = $207; //@line 14824
     $22 = $139; //@line 14824
     $cnt$0 = $cnt$1; //@line 14824
     $l$0 = $545 ? $w$1 : $542; //@line 14824
     $l10n$0 = $l10n$3; //@line 14824
     continue L1;
    }
    $$p$i = ($p$0 | 0) < 0 ? 6 : $p$0; //@line 14828
    if ($409) {
     $580 = (HEAP32[$e2$i >> 2] | 0) + -28 | 0; //@line 14832
     HEAP32[$e2$i >> 2] = $580; //@line 14833
     $$3$i = $408 * 268435456.0; //@line 14834
     $582 = $580; //@line 14834
    } else {
     $$3$i = $408; //@line 14837
     $582 = HEAP32[$e2$i >> 2] | 0; //@line 14837
    }
    $$31$i = ($582 | 0) < 0 ? $big$i : $12; //@line 14840
    $$4$i = $$3$i; //@line 14841
    $z$0$i = $$31$i; //@line 14841
    do {
     $583 = ~~$$4$i >>> 0; //@line 14843
     HEAP32[$z$0$i >> 2] = $583; //@line 14844
     $z$0$i = $z$0$i + 4 | 0; //@line 14845
     $$4$i = ($$4$i - +($583 >>> 0)) * 1.0e9; //@line 14848
    } while ($$4$i != 0.0);
    $$pr$i = HEAP32[$e2$i >> 2] | 0; //@line 14856
    if (($$pr$i | 0) > 0) {
     $591 = $$pr$i; //@line 14859
     $a$1263$i = $$31$i; //@line 14859
     $z$1262$i = $z$0$i; //@line 14859
     while (1) {
      $592 = ($591 | 0) > 29 ? 29 : $591; //@line 14862
      $d$0254$i = $z$1262$i + -4 | 0; //@line 14863
      do if ($d$0254$i >>> 0 < $a$1263$i >>> 0) $a$2$ph$i = $a$1263$i; //@line 14867
 else {
       $carry$0255$i = 0; //@line 14869
       $d$0256$i = $d$0254$i; //@line 14869
       do {
        $595 = _bitshift64Shl(HEAP32[$d$0256$i >> 2] | 0, 0, $592 | 0) | 0; //@line 14872
        $597 = _i64Add($595 | 0, tempRet0 | 0, $carry$0255$i | 0, 0) | 0; //@line 14874
        $598 = tempRet0; //@line 14875
        $599 = ___uremdi3($597 | 0, $598 | 0, 1e9, 0) | 0; //@line 14876
        HEAP32[$d$0256$i >> 2] = $599; //@line 14878
        $carry$0255$i = ___udivdi3($597 | 0, $598 | 0, 1e9, 0) | 0; //@line 14879
        $d$0256$i = $d$0256$i + -4 | 0; //@line 14881
       } while ($d$0256$i >>> 0 >= $a$1263$i >>> 0);
       if (!$carry$0255$i) {
        $a$2$ph$i = $a$1263$i; //@line 14891
        break;
       }
       $605 = $a$1263$i + -4 | 0; //@line 14894
       HEAP32[$605 >> 2] = $carry$0255$i; //@line 14895
       $a$2$ph$i = $605; //@line 14896
      } while (0);
      $z$2$i = $z$1262$i; //@line 14899
      while (1) {
       if ($z$2$i >>> 0 <= $a$2$ph$i >>> 0) break;
       $607 = $z$2$i + -4 | 0; //@line 14905
       if (!(HEAP32[$607 >> 2] | 0)) $z$2$i = $607; //@line 14909
 else break;
      }
      $611 = (HEAP32[$e2$i >> 2] | 0) - $592 | 0; //@line 14915
      HEAP32[$e2$i >> 2] = $611; //@line 14916
      if (($611 | 0) > 0) {
       $591 = $611; //@line 14919
       $a$1263$i = $a$2$ph$i; //@line 14919
       $z$1262$i = $z$2$i; //@line 14919
      } else {
       $$pr146$i = $611; //@line 14921
       $a$1$lcssa$i = $a$2$ph$i; //@line 14921
       $z$1$lcssa$i = $z$2$i; //@line 14921
       break;
      }
     }
    } else {
     $$pr146$i = $$pr$i; //@line 14926
     $a$1$lcssa$i = $$31$i; //@line 14926
     $z$1$lcssa$i = $z$0$i; //@line 14926
    }
    L237 : do if (($$pr146$i | 0) < 0) {
     $616 = (($$p$i + 25 | 0) / 9 | 0) + 1 | 0; //@line 14933
     if (($412 | 0) == 102) {
      $618 = $$31$i; //@line 14936
      $619 = $$31$i + ($616 << 2) | 0; //@line 14937
      $621 = $$pr146$i; //@line 14938
      $a$3249$us$i = $a$1$lcssa$i; //@line 14938
      $z$3248$us$i = $z$1$lcssa$i; //@line 14938
      while (1) {
       $620 = 0 - $621 | 0; //@line 14940
       $$20$us$i = ($620 | 0) > 9 ? 9 : $620; //@line 14942
       do if ($a$3249$us$i >>> 0 < $z$3248$us$i >>> 0) {
        $642 = (1 << $$20$us$i) + -1 | 0; //@line 14947
        $645 = 1e9 >>> $$20$us$i; //@line 14948
        $carry3$0243$us$i = 0; //@line 14949
        $d$1242$us$i = $a$3249$us$i; //@line 14949
        do {
         $640 = HEAP32[$d$1242$us$i >> 2] | 0; //@line 14951
         HEAP32[$d$1242$us$i >> 2] = ($640 >>> $$20$us$i) + $carry3$0243$us$i; //@line 14955
         $carry3$0243$us$i = Math_imul($640 & $642, $645) | 0; //@line 14956
         $d$1242$us$i = $d$1242$us$i + 4 | 0; //@line 14957
        } while ($d$1242$us$i >>> 0 < $z$3248$us$i >>> 0);
        $$a$3$us$i = (HEAP32[$a$3249$us$i >> 2] | 0) == 0 ? $a$3249$us$i + 4 | 0 : $a$3249$us$i; //@line 14968
        if (!$carry3$0243$us$i) {
         $$a$3$us323$i = $$a$3$us$i; //@line 14971
         $z$4$us$i = $z$3248$us$i; //@line 14971
         break;
        }
        HEAP32[$z$3248$us$i >> 2] = $carry3$0243$us$i; //@line 14975
        $$a$3$us323$i = $$a$3$us$i; //@line 14976
        $z$4$us$i = $z$3248$us$i + 4 | 0; //@line 14976
       } else {
        $$a$3$us323$i = (HEAP32[$a$3249$us$i >> 2] | 0) == 0 ? $a$3249$us$i + 4 | 0 : $a$3249$us$i; //@line 14982
        $z$4$us$i = $z$3248$us$i; //@line 14982
       } while (0);
       $$z$4$us$i = ($z$4$us$i - $618 >> 2 | 0) > ($616 | 0) ? $619 : $z$4$us$i; //@line 14989
       $621 = (HEAP32[$e2$i >> 2] | 0) + $$20$us$i | 0; //@line 14991
       HEAP32[$e2$i >> 2] = $621; //@line 14992
       if (($621 | 0) >= 0) {
        $a$3$lcssa$i = $$a$3$us323$i; //@line 14997
        $z$3$lcssa$i = $$z$4$us$i; //@line 14997
        break L237;
       } else {
        $a$3249$us$i = $$a$3$us323$i; //@line 14995
        $z$3248$us$i = $$z$4$us$i; //@line 14995
       }
      }
     } else {
      $650 = $$pr146$i; //@line 15002
      $a$3249$i = $a$1$lcssa$i; //@line 15002
      $z$3248$i = $z$1$lcssa$i; //@line 15002
     }
     while (1) {
      $649 = 0 - $650 | 0; //@line 15005
      $$20$i = ($649 | 0) > 9 ? 9 : $649; //@line 15007
      do if ($a$3249$i >>> 0 < $z$3248$i >>> 0) {
       $657 = (1 << $$20$i) + -1 | 0; //@line 15012
       $658 = 1e9 >>> $$20$i; //@line 15013
       $carry3$0243$i = 0; //@line 15014
       $d$1242$i = $a$3249$i; //@line 15014
       do {
        $659 = HEAP32[$d$1242$i >> 2] | 0; //@line 15016
        HEAP32[$d$1242$i >> 2] = ($659 >>> $$20$i) + $carry3$0243$i; //@line 15020
        $carry3$0243$i = Math_imul($659 & $657, $658) | 0; //@line 15021
        $d$1242$i = $d$1242$i + 4 | 0; //@line 15022
       } while ($d$1242$i >>> 0 < $z$3248$i >>> 0);
       $$a$3$i = (HEAP32[$a$3249$i >> 2] | 0) == 0 ? $a$3249$i + 4 | 0 : $a$3249$i; //@line 15033
       if (!$carry3$0243$i) {
        $$a$3325$i = $$a$3$i; //@line 15036
        $z$4$i = $z$3248$i; //@line 15036
        break;
       }
       HEAP32[$z$3248$i >> 2] = $carry3$0243$i; //@line 15040
       $$a$3325$i = $$a$3$i; //@line 15041
       $z$4$i = $z$3248$i + 4 | 0; //@line 15041
      } else {
       $$a$3325$i = (HEAP32[$a$3249$i >> 2] | 0) == 0 ? $a$3249$i + 4 | 0 : $a$3249$i; //@line 15047
       $z$4$i = $z$3248$i; //@line 15047
      } while (0);
      if (($z$4$i - $$a$3325$i >> 2 | 0) > ($616 | 0)) $z$5$i = $$a$3325$i + ($616 << 2) | 0; //@line 15057
 else $z$5$i = $z$4$i; //@line 15059
      $650 = (HEAP32[$e2$i >> 2] | 0) + $$20$i | 0; //@line 15062
      HEAP32[$e2$i >> 2] = $650; //@line 15063
      if (($650 | 0) >= 0) {
       $a$3$lcssa$i = $$a$3325$i; //@line 15068
       $z$3$lcssa$i = $z$5$i; //@line 15068
       break;
      } else {
       $a$3249$i = $$a$3325$i; //@line 15066
       $z$3248$i = $z$5$i; //@line 15066
      }
     }
    } else {
     $a$3$lcssa$i = $a$1$lcssa$i; //@line 15073
     $z$3$lcssa$i = $z$1$lcssa$i; //@line 15073
    } while (0);
    $681 = $$31$i; //@line 15077
    do if ($a$3$lcssa$i >>> 0 < $z$3$lcssa$i >>> 0) {
     $685 = ($681 - $a$3$lcssa$i >> 2) * 9 | 0; //@line 15083
     $686 = HEAP32[$a$3$lcssa$i >> 2] | 0; //@line 15084
     if ($686 >>> 0 < 10) {
      $e$1$i = $685; //@line 15087
      break;
     } else {
      $e$0238$i = $685; //@line 15090
      $i$0237$i = 10; //@line 15090
     }
     while (1) {
      $i$0237$i = $i$0237$i * 10 | 0; //@line 15093
      $689 = $e$0238$i + 1 | 0; //@line 15094
      if ($686 >>> 0 < $i$0237$i >>> 0) {
       $e$1$i = $689; //@line 15097
       break;
      } else $e$0238$i = $689; //@line 15100
     }
    } else $e$1$i = 0; //@line 15104
 while (0);
    $694 = ($412 | 0) == 103; //@line 15110
    $696 = $$p$i - (($412 | 0) != 102 ? $e$1$i : 0) + (($694 & ($$p$i | 0) != 0) << 31 >> 31) | 0; //@line 15114
    if (($696 | 0) < ((($z$3$lcssa$i - $681 >> 2) * 9 | 0) + -9 | 0)) {
     $703 = $696 + 9216 | 0; //@line 15122
     $704 = ($703 | 0) / 9 | 0; //@line 15123
     $705 = $$31$i + ($704 + -1023 << 2) | 0; //@line 15125
     $j$0229$i = (($703 | 0) % 9 | 0) + 1 | 0; //@line 15127
     if (($j$0229$i | 0) < 9) {
      $i$1230$i = 10; //@line 15130
      $j$0231$i = $j$0229$i; //@line 15130
      while (1) {
       $708 = $i$1230$i * 10 | 0; //@line 15132
       $j$0231$i = $j$0231$i + 1 | 0; //@line 15133
       if (($j$0231$i | 0) == 9) {
        $i$1$lcssa$i = $708; //@line 15136
        break;
       } else $i$1230$i = $708; //@line 15139
      }
     } else $i$1$lcssa$i = 10; //@line 15143
     $709 = HEAP32[$705 >> 2] | 0; //@line 15145
     $710 = ($709 >>> 0) % ($i$1$lcssa$i >>> 0) | 0; //@line 15146
     if (!$710) if (($$31$i + ($704 + -1022 << 2) | 0) == ($z$3$lcssa$i | 0)) {
      $a$7$i = $a$3$lcssa$i; //@line 15153
      $d$3$i = $705; //@line 15153
      $e$3$i = $e$1$i; //@line 15153
     } else label = 233; //@line 15155
 else label = 233; //@line 15158
     do if ((label | 0) == 233) {
      label = 0; //@line 15162
      $$22$i = ((($709 >>> 0) / ($i$1$lcssa$i >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0; //@line 15166
      $717 = ($i$1$lcssa$i | 0) / 2 | 0; //@line 15167
      do if ($710 >>> 0 < $717 >>> 0) $small$0$i = .5; //@line 15171
 else {
       if (($710 | 0) == ($717 | 0)) if (($$31$i + ($704 + -1022 << 2) | 0) == ($z$3$lcssa$i | 0)) {
        $small$0$i = 1.0; //@line 15179
        break;
       }
       $small$0$i = 1.5; //@line 15183
      } while (0);
      do if (!$pl$0$i) {
       $round6$1$i = $$22$i; //@line 15189
       $small$1$i = $small$0$i; //@line 15189
      } else {
       if ((HEAP8[$prefix$0$i >> 0] | 0) != 45) {
        $round6$1$i = $$22$i; //@line 15194
        $small$1$i = $small$0$i; //@line 15194
        break;
       }
       $round6$1$i = $$22$i * -1.0; //@line 15199
       $small$1$i = $small$0$i * -1.0; //@line 15199
      } while (0);
      $727 = $709 - $710 | 0; //@line 15202
      HEAP32[$705 >> 2] = $727; //@line 15203
      if (!($round6$1$i + $small$1$i != $round6$1$i)) {
       $a$7$i = $a$3$lcssa$i; //@line 15207
       $d$3$i = $705; //@line 15207
       $e$3$i = $e$1$i; //@line 15207
       break;
      }
      $730 = $727 + $i$1$lcssa$i | 0; //@line 15210
      HEAP32[$705 >> 2] = $730; //@line 15211
      if ($730 >>> 0 > 999999999) {
       $a$5223$i = $a$3$lcssa$i; //@line 15214
       $d$2222$i = $705; //@line 15214
       while (1) {
        $732 = $d$2222$i + -4 | 0; //@line 15216
        HEAP32[$d$2222$i >> 2] = 0; //@line 15217
        if ($732 >>> 0 < $a$5223$i >>> 0) {
         $734 = $a$5223$i + -4 | 0; //@line 15220
         HEAP32[$734 >> 2] = 0; //@line 15221
         $a$6$i = $734; //@line 15222
        } else $a$6$i = $a$5223$i; //@line 15224
        $736 = (HEAP32[$732 >> 2] | 0) + 1 | 0; //@line 15227
        HEAP32[$732 >> 2] = $736; //@line 15228
        if ($736 >>> 0 > 999999999) {
         $a$5223$i = $a$6$i; //@line 15231
         $d$2222$i = $732; //@line 15231
        } else {
         $a$5$lcssa$i = $a$6$i; //@line 15233
         $d$2$lcssa$i = $732; //@line 15233
         break;
        }
       }
      } else {
       $a$5$lcssa$i = $a$3$lcssa$i; //@line 15238
       $d$2$lcssa$i = $705; //@line 15238
      }
      $741 = ($681 - $a$5$lcssa$i >> 2) * 9 | 0; //@line 15243
      $742 = HEAP32[$a$5$lcssa$i >> 2] | 0; //@line 15244
      if ($742 >>> 0 < 10) {
       $a$7$i = $a$5$lcssa$i; //@line 15247
       $d$3$i = $d$2$lcssa$i; //@line 15247
       $e$3$i = $741; //@line 15247
       break;
      } else {
       $e$2218$i = $741; //@line 15250
       $i$2217$i = 10; //@line 15250
      }
      while (1) {
       $i$2217$i = $i$2217$i * 10 | 0; //@line 15253
       $745 = $e$2218$i + 1 | 0; //@line 15254
       if ($742 >>> 0 < $i$2217$i >>> 0) {
        $a$7$i = $a$5$lcssa$i; //@line 15257
        $d$3$i = $d$2$lcssa$i; //@line 15257
        $e$3$i = $745; //@line 15257
        break;
       } else $e$2218$i = $745; //@line 15260
      }
     } while (0);
     $747 = $d$3$i + 4 | 0; //@line 15265
     $a$8$ph$i = $a$7$i; //@line 15268
     $e$4$ph$i = $e$3$i; //@line 15268
     $z$6$ph$i = $z$3$lcssa$i >>> 0 > $747 >>> 0 ? $747 : $z$3$lcssa$i; //@line 15268
    } else {
     $a$8$ph$i = $a$3$lcssa$i; //@line 15270
     $e$4$ph$i = $e$1$i; //@line 15270
     $z$6$ph$i = $z$3$lcssa$i; //@line 15270
    }
    $749 = 0 - $e$4$ph$i | 0; //@line 15272
    $z$6$i = $z$6$ph$i; //@line 15273
    while (1) {
     if ($z$6$i >>> 0 <= $a$8$ph$i >>> 0) {
      $$lcssa300$i = 0; //@line 15277
      break;
     }
     $751 = $z$6$i + -4 | 0; //@line 15280
     if (!(HEAP32[$751 >> 2] | 0)) $z$6$i = $751; //@line 15284
 else {
      $$lcssa300$i = 1; //@line 15286
      break;
     }
    }
    do if ($694) {
     $$$p$i = (($$p$i | 0) == 0 & 1) + $$p$i | 0; //@line 15294
     if (($$$p$i | 0) > ($e$4$ph$i | 0) & ($e$4$ph$i | 0) > -5) {
      $$013$i = $t$0 + -1 | 0; //@line 15302
      $$210$i = $$$p$i + -1 - $e$4$ph$i | 0; //@line 15302
     } else {
      $$013$i = $t$0 + -2 | 0; //@line 15306
      $$210$i = $$$p$i + -1 | 0; //@line 15306
     }
     if ($fl$1$ & 8) {
      $$114$i = $$013$i; //@line 15311
      $$311$i = $$210$i; //@line 15311
      break;
     }
     do if ($$lcssa300$i) {
      $765 = HEAP32[$z$6$i + -4 >> 2] | 0; //@line 15317
      if (!$765) {
       $j$2$i = 9; //@line 15320
       break;
      }
      if (!(($765 >>> 0) % 10 | 0)) {
       $i$3209$i = 10; //@line 15326
       $j$1210$i = 0; //@line 15326
      } else {
       $j$2$i = 0; //@line 15328
       break;
      }
      while (1) {
       $i$3209$i = $i$3209$i * 10 | 0; //@line 15332
       $770 = $j$1210$i + 1 | 0; //@line 15333
       if (($765 >>> 0) % ($i$3209$i >>> 0) | 0) {
        $j$2$i = $770; //@line 15339
        break;
       } else $j$1210$i = $770; //@line 15337
      }
     } else $j$2$i = 9; //@line 15344
 while (0);
     $779 = (($z$6$i - $681 >> 2) * 9 | 0) + -9 | 0; //@line 15353
     if (($$013$i | 32 | 0) == 102) {
      $780 = $779 - $j$2$i | 0; //@line 15355
      $$23$i = ($780 | 0) < 0 ? 0 : $780; //@line 15357
      $$114$i = $$013$i; //@line 15360
      $$311$i = ($$210$i | 0) < ($$23$i | 0) ? $$210$i : $$23$i; //@line 15360
      break;
     } else {
      $784 = $779 + $e$4$ph$i - $j$2$i | 0; //@line 15364
      $$25$i = ($784 | 0) < 0 ? 0 : $784; //@line 15366
      $$114$i = $$013$i; //@line 15369
      $$311$i = ($$210$i | 0) < ($$25$i | 0) ? $$210$i : $$25$i; //@line 15369
      break;
     }
    } else {
     $$114$i = $t$0; //@line 15373
     $$311$i = $$p$i; //@line 15373
    } while (0);
    $787 = ($$311$i | 0) != 0; //@line 15376
    if ($787) $791 = 1; //@line 15378
 else $791 = ($fl$1$ & 8 | 0) != 0; //@line 15382
    $790 = $791 & 1; //@line 15384
    $793 = ($$114$i | 32 | 0) == 102; //@line 15386
    if ($793) {
     $$pn$i = ($e$4$ph$i | 0) > 0 ? $e$4$ph$i : 0; //@line 15390
     $estr$2$i = 0; //@line 15390
    } else {
     $797 = ($e$4$ph$i | 0) < 0 ? $749 : $e$4$ph$i; //@line 15393
     if (($797 | 0) < 0) {
      $$05$i79$i = $6; //@line 15398
      $801 = $797; //@line 15398
      $802 = (($797 | 0) < 0) << 31 >> 31; //@line 15398
      while (1) {
       $803 = ___uremdi3($801 | 0, $802 | 0, 10, 0) | 0; //@line 15400
       $$05$i79$i = $$05$i79$i + -1 | 0; //@line 15404
       HEAP8[$$05$i79$i >> 0] = $803 | 48; //@line 15405
       $801$looptemp = $801;
       $801 = ___udivdi3($801 | 0, $802 | 0, 10, 0) | 0; //@line 15406
       if (!($802 >>> 0 > 9 | ($802 | 0) == 9 & $801$looptemp >>> 0 > 4294967295)) break; else $802 = tempRet0; //@line 15414
      }
      $$0$lcssa$i84$i = $$05$i79$i; //@line 15419
      $$01$lcssa$off0$i85$i = $801; //@line 15419
     } else {
      $$0$lcssa$i84$i = $6; //@line 15421
      $$01$lcssa$off0$i85$i = $797; //@line 15421
     }
     if (!$$01$lcssa$off0$i85$i) $estr$1$ph$i = $$0$lcssa$i84$i; //@line 15425
 else {
      $$12$i87$i = $$0$lcssa$i84$i; //@line 15427
      $y$03$i86$i = $$01$lcssa$off0$i85$i; //@line 15427
      while (1) {
       $819 = $$12$i87$i + -1 | 0; //@line 15432
       HEAP8[$819 >> 0] = ($y$03$i86$i >>> 0) % 10 | 0 | 48; //@line 15433
       if ($y$03$i86$i >>> 0 < 10) {
        $estr$1$ph$i = $819; //@line 15437
        break;
       } else {
        $$12$i87$i = $819; //@line 15440
        $y$03$i86$i = ($y$03$i86$i >>> 0) / 10 | 0; //@line 15440
       }
      }
     }
     if (($8 - $estr$1$ph$i | 0) < 2) {
      $estr$1200$i = $estr$1$ph$i; //@line 15448
      while (1) {
       $825 = $estr$1200$i + -1 | 0; //@line 15450
       HEAP8[$825 >> 0] = 48; //@line 15451
       if (($8 - $825 | 0) < 2) $estr$1200$i = $825; //@line 15456
 else {
        $estr$1$lcssa$i = $825; //@line 15458
        break;
       }
      }
     } else $estr$1$lcssa$i = $estr$1$ph$i; //@line 15463
     HEAP8[$estr$1$lcssa$i + -1 >> 0] = ($e$4$ph$i >> 31 & 2) + 43; //@line 15470
     $835 = $estr$1$lcssa$i + -2 | 0; //@line 15472
     HEAP8[$835 >> 0] = $$114$i; //@line 15473
     $$pn$i = $8 - $835 | 0; //@line 15476
     $estr$2$i = $835; //@line 15476
    }
    $840 = $pl$0$i + 1 + $$311$i + $790 + $$pn$i | 0; //@line 15481
    $841 = $fl$1$ & 73728; //@line 15482
    $843 = ($840 | 0) < ($w$1 | 0); //@line 15484
    if (($841 | 0) == 0 & $843) {
     $844 = $w$1 - $840 | 0; //@line 15487
     _memset($pad$i | 0, 32, ($844 >>> 0 > 256 ? 256 : $844) | 0) | 0; //@line 15490
     if ($844 >>> 0 > 255) {
      $$01$i94$i = $844; //@line 15493
      while (1) {
       ___fwritex($pad$i, 256, $f) | 0; //@line 15495
       $848 = $$01$i94$i + -256 | 0; //@line 15496
       if ($848 >>> 0 > 255) $$01$i94$i = $848; //@line 15499
 else {
        $$0$lcssa$i96$i = $848; //@line 15501
        break;
       }
      }
     } else $$0$lcssa$i96$i = $844; //@line 15506
     ___fwritex($pad$i, $$0$lcssa$i96$i, $f) | 0; //@line 15508
    }
    ___fwritex($prefix$0$i, $pl$0$i, $f) | 0; //@line 15510
    if (($841 | 0) == 65536 & $843) {
     $851 = $w$1 - $840 | 0; //@line 15514
     _memset($pad$i | 0, 48, ($851 >>> 0 > 256 ? 256 : $851) | 0) | 0; //@line 15517
     if ($851 >>> 0 > 255) {
      $$01$i101$i = $851; //@line 15520
      while (1) {
       ___fwritex($pad$i, 256, $f) | 0; //@line 15522
       $855 = $$01$i101$i + -256 | 0; //@line 15523
       if ($855 >>> 0 > 255) $$01$i101$i = $855; //@line 15526
 else {
        $$0$lcssa$i103$i = $855; //@line 15528
        break;
       }
      }
     } else $$0$lcssa$i103$i = $851; //@line 15533
     ___fwritex($pad$i, $$0$lcssa$i103$i, $f) | 0; //@line 15535
    }
    do if ($793) {
     $r$0$a$8$i = $a$8$ph$i >>> 0 > $$31$i >>> 0 ? $$31$i : $a$8$ph$i; //@line 15540
     $d$4183$i = $r$0$a$8$i; //@line 15541
     do {
      $858 = HEAP32[$d$4183$i >> 2] | 0; //@line 15543
      if (!$858) $$1$lcssa$i112$i = $13; //@line 15546
 else {
       $$12$i110$i = $13; //@line 15548
       $y$03$i109$i = $858; //@line 15548
       while (1) {
        $863 = $$12$i110$i + -1 | 0; //@line 15553
        HEAP8[$863 >> 0] = ($y$03$i109$i >>> 0) % 10 | 0 | 48; //@line 15554
        if ($y$03$i109$i >>> 0 < 10) {
         $$1$lcssa$i112$i = $863; //@line 15558
         break;
        } else {
         $$12$i110$i = $863; //@line 15561
         $y$03$i109$i = ($y$03$i109$i >>> 0) / 10 | 0; //@line 15561
        }
       }
      }
      do if (($d$4183$i | 0) == ($r$0$a$8$i | 0)) {
       if (($$1$lcssa$i112$i | 0) != ($13 | 0)) {
        $s7$1$i = $$1$lcssa$i112$i; //@line 15570
        break;
       }
       HEAP8[$15 >> 0] = 48; //@line 15573
       $s7$1$i = $15; //@line 15574
      } else {
       if ($$1$lcssa$i112$i >>> 0 > $buf$i >>> 0) $s7$0180$i = $$1$lcssa$i112$i; //@line 15578
 else {
        $s7$1$i = $$1$lcssa$i112$i; //@line 15580
        break;
       }
       while (1) {
        $868 = $s7$0180$i + -1 | 0; //@line 15584
        HEAP8[$868 >> 0] = 48; //@line 15585
        if ($868 >>> 0 > $buf$i >>> 0) $s7$0180$i = $868; //@line 15588
 else {
         $s7$1$i = $868; //@line 15590
         break;
        }
       }
      } while (0);
      ___fwritex($s7$1$i, $14 - $s7$1$i | 0, $f) | 0; //@line 15598
      $d$4183$i = $d$4183$i + 4 | 0; //@line 15599
     } while ($d$4183$i >>> 0 <= $$31$i >>> 0);
     if (!$787) if (!($fl$1$ & 8)) break;
     ___fwritex(13128, 1, $f) | 0; //@line 15614
     if ($d$4183$i >>> 0 < $z$6$i >>> 0 & ($$311$i | 0) > 0) {
      $$412175$i = $$311$i; //@line 15619
      $d$5174$i = $d$4183$i; //@line 15619
      while (1) {
       $879 = HEAP32[$d$5174$i >> 2] | 0; //@line 15621
       if (!$879) {
        $s8$0169$i = $13; //@line 15624
        label = 300; //@line 15625
       } else {
        $$12$i119$i = $13; //@line 15627
        $y$03$i118$i = $879; //@line 15627
        while (1) {
         $$12$i119$i = $$12$i119$i + -1 | 0; //@line 15632
         HEAP8[$$12$i119$i >> 0] = ($y$03$i118$i >>> 0) % 10 | 0 | 48; //@line 15633
         if ($y$03$i118$i >>> 0 < 10) break; else $y$03$i118$i = ($y$03$i118$i >>> 0) / 10 | 0; //@line 15639
        }
        if ($$12$i119$i >>> 0 > $buf$i >>> 0) {
         $s8$0169$i = $$12$i119$i; //@line 15644
         label = 300; //@line 15645
        } else $s8$0$lcssa$i = $$12$i119$i; //@line 15647
       }
       if ((label | 0) == 300) while (1) {
        label = 0; //@line 15652
        $888 = $s8$0169$i + -1 | 0; //@line 15653
        HEAP8[$888 >> 0] = 48; //@line 15654
        if ($888 >>> 0 > $buf$i >>> 0) {
         $s8$0169$i = $888; //@line 15657
         label = 300; //@line 15658
        } else {
         $s8$0$lcssa$i = $888; //@line 15660
         break;
        }
       }
       ___fwritex($s8$0$lcssa$i, ($$412175$i | 0) > 9 ? 9 : $$412175$i, $f) | 0; //@line 15667
       $d$5174$i = $d$5174$i + 4 | 0; //@line 15668
       $893 = $$412175$i + -9 | 0; //@line 15669
       if (!($d$5174$i >>> 0 < $z$6$i >>> 0 & ($893 | 0) > 0)) {
        $$412$lcssa$i = $893; //@line 15676
        break;
       } else $$412175$i = $893; //@line 15674
      }
     } else $$412$lcssa$i = $$311$i; //@line 15681
     if (($$412$lcssa$i | 0) <= 0) break;
     _memset($pad$i | 0, 48, ($$412$lcssa$i >>> 0 > 256 ? 256 : $$412$lcssa$i) | 0) | 0; //@line 15689
     if ($$412$lcssa$i >>> 0 > 255) {
      $$01$i125$i = $$412$lcssa$i; //@line 15692
      while (1) {
       ___fwritex($pad$i, 256, $f) | 0; //@line 15694
       $900 = $$01$i125$i + -256 | 0; //@line 15695
       if ($900 >>> 0 > 255) $$01$i125$i = $900; //@line 15698
 else {
        $$0$lcssa$i127$i = $900; //@line 15700
        break;
       }
      }
     } else $$0$lcssa$i127$i = $$412$lcssa$i; //@line 15705
     ___fwritex($pad$i, $$0$lcssa$i127$i, $f) | 0; //@line 15707
    } else {
     $z$6$$i = $$lcssa300$i ? $z$6$i : $a$8$ph$i + 4 | 0; //@line 15710
     do if (($$311$i | 0) > -1) {
      $$not$i = ($fl$1$ & 8 | 0) != 0; //@line 15715
      $$5193$i = $$311$i; //@line 15716
      $d$6192$i = $a$8$ph$i; //@line 15716
      do {
       $905 = HEAP32[$d$6192$i >> 2] | 0; //@line 15718
       if (!$905) label = 311; //@line 15721
 else {
        $$12$i134$i = $13; //@line 15723
        $y$03$i133$i = $905; //@line 15723
        while (1) {
         $$12$i134$i = $$12$i134$i + -1 | 0; //@line 15728
         HEAP8[$$12$i134$i >> 0] = ($y$03$i133$i >>> 0) % 10 | 0 | 48; //@line 15729
         if ($y$03$i133$i >>> 0 < 10) break; else $y$03$i133$i = ($y$03$i133$i >>> 0) / 10 | 0; //@line 15735
        }
        if (($$12$i134$i | 0) == ($13 | 0)) label = 311; //@line 15740
 else $s9$0$i = $$12$i134$i; //@line 15742
       }
       if ((label | 0) == 311) {
        label = 0; //@line 15746
        HEAP8[$15 >> 0] = 48; //@line 15747
        $s9$0$i = $15; //@line 15748
       }
       do if (($d$6192$i | 0) == ($a$8$ph$i | 0)) {
        $918 = $s9$0$i + 1 | 0; //@line 15753
        ___fwritex($s9$0$i, 1, $f) | 0; //@line 15754
        if (!(($$5193$i | 0) > 0 | $$not$i)) {
         $s9$2$i = $918; //@line 15758
         break;
        }
        ___fwritex(13128, 1, $f) | 0; //@line 15761
        $s9$2$i = $918; //@line 15762
       } else {
        if ($s9$0$i >>> 0 > $buf$i >>> 0) $s9$1188$i = $s9$0$i; //@line 15766
 else {
         $s9$2$i = $s9$0$i; //@line 15768
         break;
        }
        while (1) {
         $916 = $s9$1188$i + -1 | 0; //@line 15772
         HEAP8[$916 >> 0] = 48; //@line 15773
         if ($916 >>> 0 > $buf$i >>> 0) $s9$1188$i = $916; //@line 15776
 else {
          $s9$2$i = $916; //@line 15778
          break;
         }
        }
       } while (0);
       $921 = $14 - $s9$2$i | 0; //@line 15785
       ___fwritex($s9$2$i, ($921 | 0) < ($$5193$i | 0) ? $921 : $$5193$i, $f) | 0; //@line 15788
       $$5193$i = $$5193$i - $921 | 0; //@line 15789
       $d$6192$i = $d$6192$i + 4 | 0; //@line 15790
      } while ($d$6192$i >>> 0 < $z$6$$i >>> 0 & ($$5193$i | 0) > -1);
      if (($$5193$i | 0) <= 0) break;
      _memset($pad$i | 0, 48, ($$5193$i >>> 0 > 256 ? 256 : $$5193$i) | 0) | 0; //@line 15806
      if ($$5193$i >>> 0 > 255) {
       $$01$i140$i = $$5193$i; //@line 15809
       while (1) {
        ___fwritex($pad$i, 256, $f) | 0; //@line 15811
        $931 = $$01$i140$i + -256 | 0; //@line 15812
        if ($931 >>> 0 > 255) $$01$i140$i = $931; //@line 15815
 else {
         $$0$lcssa$i142$i = $931; //@line 15817
         break;
        }
       }
      } else $$0$lcssa$i142$i = $$5193$i; //@line 15822
      ___fwritex($pad$i, $$0$lcssa$i142$i, $f) | 0; //@line 15824
     } while (0);
     ___fwritex($estr$2$i, $8 - $estr$2$i | 0, $f) | 0; //@line 15829
    } while (0);
    if (($841 | 0) == 8192 & $843) {
     $936 = $w$1 - $840 | 0; //@line 15835
     _memset($pad$i | 0, 32, ($936 >>> 0 > 256 ? 256 : $936) | 0) | 0; //@line 15838
     if ($936 >>> 0 > 255) {
      $$01$i$i = $936; //@line 15841
      while (1) {
       ___fwritex($pad$i, 256, $f) | 0; //@line 15843
       $940 = $$01$i$i + -256 | 0; //@line 15844
       if ($940 >>> 0 > 255) $$01$i$i = $940; //@line 15847
 else {
        $$0$lcssa$i$i = $940; //@line 15849
        break;
       }
      }
     } else $$0$lcssa$i$i = $936; //@line 15854
     ___fwritex($pad$i, $$0$lcssa$i$i, $f) | 0; //@line 15856
    }
    $1045 = $229; //@line 15859
    $1046 = $207; //@line 15859
    $22 = $139; //@line 15859
    $cnt$0 = $cnt$1; //@line 15859
    $l$0 = $843 ? $w$1 : $840; //@line 15859
    $l10n$0 = $l10n$3; //@line 15859
    continue L1;
    break;
   }
  case 111:
   {
    $249 = $207; //@line 15864
    $252 = ($249 | 0) == 0 & ($229 | 0) == 0; //@line 15867
    if ($252) $$0$lcssa$i43 = $2; //@line 15869
 else {
     $$03$i40 = $2; //@line 15871
     $254 = $249; //@line 15871
     $258 = $229; //@line 15871
     while (1) {
      $257 = $$03$i40 + -1 | 0; //@line 15876
      HEAP8[$257 >> 0] = $254 & 7 | 48; //@line 15877
      $254 = _bitshift64Lshr($254 | 0, $258 | 0, 3) | 0; //@line 15878
      $258 = tempRet0; //@line 15879
      if (($254 | 0) == 0 & ($258 | 0) == 0) {
       $$0$lcssa$i43 = $257; //@line 15884
       break;
      } else $$03$i40 = $257; //@line 15887
     }
    }
    if (!($fl$1$ & 8)) {
     $308 = $207; //@line 15894
     $311 = $229; //@line 15894
     $a$0 = $$0$lcssa$i43; //@line 15894
     $fl$4 = $fl$1$; //@line 15894
     $p$2 = $p$0; //@line 15894
     $pl$1 = 0; //@line 15894
     $prefix$1 = 13032; //@line 15894
     label = 94; //@line 15895
    } else {
     $308 = $207; //@line 15900
     $311 = $229; //@line 15900
     $a$0 = $$0$lcssa$i43; //@line 15900
     $fl$4 = $fl$1$; //@line 15900
     $p$2 = $p$0; //@line 15900
     $pl$1 = $252 & 1 ^ 1; //@line 15900
     $prefix$1 = $252 ? 13032 : 13037; //@line 15900
     label = 94; //@line 15901
    }
    break;
   }
  case 112:
   {
    $fl$3 = $fl$1$ | 8; //@line 15909
    $p$1 = $p$0 >>> 0 > 8 ? $p$0 : 8; //@line 15909
    $t$1 = 120; //@line 15909
    label = 77; //@line 15910
    break;
   }
  case 99:
   {
    HEAP8[$4 >> 0] = $207; //@line 15916
    $1053 = $229; //@line 15917
    $1054 = $207; //@line 15917
    $a$2 = $4; //@line 15917
    $fl$6 = $206; //@line 15917
    $p$5 = 1; //@line 15917
    $pl$2 = 0; //@line 15917
    $prefix$2 = 13032; //@line 15917
    $z$2 = $2; //@line 15917
    break;
   }
  case 109:
   {
    $a$1 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 15924
    label = 99; //@line 15925
    break;
   }
  case 115:
   {
    $a$1 = ($207 | 0) == 0 ? 13048 : $207; //@line 15931
    label = 99; //@line 15932
    break;
   }
  case 67:
   {
    HEAP32[$wc >> 2] = $207; //@line 15937
    HEAP32[$5 >> 2] = 0; //@line 15938
    $1055 = $wc; //@line 15939
    $1056 = $wc; //@line 15939
    $p$4296 = -1; //@line 15939
    label = 104; //@line 15940
    break;
   }
  case 83:
   {
    if (!$p$0) {
     $1057 = $207; //@line 15946
     $1058 = $207; //@line 15946
     $i$0166 = 0; //@line 15946
     label = 110; //@line 15947
    } else {
     $1055 = $207; //@line 15949
     $1056 = $207; //@line 15949
     $p$4296 = $p$0; //@line 15949
     label = 104; //@line 15950
    }
    break;
   }
  case 105:
  case 100:
   {
    if (($229 | 0) < 0) {
     $269 = _i64Subtract(0, 0, $207 | 0, $229 | 0) | 0; //@line 15958
     $277 = $269; //@line 15961
     $279 = tempRet0; //@line 15961
     $pl$0 = 1; //@line 15961
     $prefix$0 = 13032; //@line 15961
     label = 89; //@line 15962
     break L92;
    }
    if (!($fl$1$ & 2048)) {
     $274 = $fl$1$ & 1; //@line 15968
     $277 = $207; //@line 15971
     $279 = $229; //@line 15971
     $pl$0 = $274; //@line 15971
     $prefix$0 = ($274 | 0) == 0 ? 13032 : 13034; //@line 15971
     label = 89; //@line 15972
    } else {
     $277 = $207; //@line 15974
     $279 = $229; //@line 15974
     $pl$0 = 1; //@line 15974
     $prefix$0 = 13033; //@line 15974
     label = 89; //@line 15975
    }
    break;
   }
  case 117:
   {
    $277 = $207; //@line 15980
    $279 = $229; //@line 15980
    $pl$0 = 0; //@line 15980
    $prefix$0 = 13032; //@line 15980
    label = 89; //@line 15981
    break;
   }
  default:
   {
    $1053 = $229; //@line 15985
    $1054 = $207; //@line 15985
    $a$2 = $22; //@line 15985
    $fl$6 = $fl$1$; //@line 15985
    $p$5 = $p$0; //@line 15985
    $pl$2 = 0; //@line 15985
    $prefix$2 = 13032; //@line 15985
    $z$2 = $2; //@line 15985
   }
  } while (0);
  L445 : do if ((label | 0) == 77) {
   label = 0; //@line 15991
   $225 = $207; //@line 15992
   $226 = $t$1 & 32; //@line 15993
   if (($225 | 0) == 0 & ($229 | 0) == 0) {
    $308 = $207; //@line 15998
    $311 = $229; //@line 15998
    $a$0 = $2; //@line 15998
    $fl$4 = $fl$3; //@line 15998
    $p$2 = $p$1; //@line 15998
    $pl$1 = 0; //@line 15998
    $prefix$1 = 13032; //@line 15998
    label = 94; //@line 15999
   } else {
    $$012$i = $2; //@line 16001
    $232 = $225; //@line 16001
    $239 = $229; //@line 16001
    do {
     $$012$i = $$012$i + -1 | 0; //@line 16009
     HEAP8[$$012$i >> 0] = HEAPU8[13112 + ($232 & 15) >> 0] | $226; //@line 16010
     $232 = _bitshift64Lshr($232 | 0, $239 | 0, 4) | 0; //@line 16011
     $239 = tempRet0; //@line 16012
    } while (!(($232 | 0) == 0 & ($239 | 0) == 0));
    if (!($fl$3 & 8)) {
     $308 = $207; //@line 16025
     $311 = $229; //@line 16025
     $a$0 = $$012$i; //@line 16025
     $fl$4 = $fl$3; //@line 16025
     $p$2 = $p$1; //@line 16025
     $pl$1 = 0; //@line 16025
     $prefix$1 = 13032; //@line 16025
     label = 94; //@line 16026
    } else {
     $308 = $207; //@line 16030
     $311 = $229; //@line 16030
     $a$0 = $$012$i; //@line 16030
     $fl$4 = $fl$3; //@line 16030
     $p$2 = $p$1; //@line 16030
     $pl$1 = 2; //@line 16030
     $prefix$1 = 13032 + ($t$1 >> 4) | 0; //@line 16030
     label = 94; //@line 16031
    }
   }
  } else if ((label | 0) == 89) {
   label = 0; //@line 16036
   $276 = $277; //@line 16037
   if ($279 >>> 0 > 0 | ($279 | 0) == 0 & $276 >>> 0 > 4294967295) {
    $$05$i = $2; //@line 16044
    $284 = $276; //@line 16044
    $285 = $279; //@line 16044
    while (1) {
     $286 = ___uremdi3($284 | 0, $285 | 0, 10, 0) | 0; //@line 16046
     $$05$i = $$05$i + -1 | 0; //@line 16050
     HEAP8[$$05$i >> 0] = $286 | 48; //@line 16051
     $284$looptemp = $284;
     $284 = ___udivdi3($284 | 0, $285 | 0, 10, 0) | 0; //@line 16052
     if (!($285 >>> 0 > 9 | ($285 | 0) == 9 & $284$looptemp >>> 0 > 4294967295)) break; else $285 = tempRet0; //@line 16060
    }
    $$0$lcssa$i45 = $$05$i; //@line 16065
    $$01$lcssa$off0$i = $284; //@line 16065
   } else {
    $$0$lcssa$i45 = $2; //@line 16067
    $$01$lcssa$off0$i = $276; //@line 16067
   }
   if (!$$01$lcssa$off0$i) {
    $308 = $277; //@line 16071
    $311 = $279; //@line 16071
    $a$0 = $$0$lcssa$i45; //@line 16071
    $fl$4 = $fl$1$; //@line 16071
    $p$2 = $p$0; //@line 16071
    $pl$1 = $pl$0; //@line 16071
    $prefix$1 = $prefix$0; //@line 16071
    label = 94; //@line 16072
   } else {
    $$12$i = $$0$lcssa$i45; //@line 16074
    $y$03$i = $$01$lcssa$off0$i; //@line 16074
    while (1) {
     $302 = $$12$i + -1 | 0; //@line 16079
     HEAP8[$302 >> 0] = ($y$03$i >>> 0) % 10 | 0 | 48; //@line 16080
     if ($y$03$i >>> 0 < 10) {
      $308 = $277; //@line 16084
      $311 = $279; //@line 16084
      $a$0 = $302; //@line 16084
      $fl$4 = $fl$1$; //@line 16084
      $p$2 = $p$0; //@line 16084
      $pl$1 = $pl$0; //@line 16084
      $prefix$1 = $prefix$0; //@line 16084
      label = 94; //@line 16085
      break;
     } else {
      $$12$i = $302; //@line 16088
      $y$03$i = ($y$03$i >>> 0) / 10 | 0; //@line 16088
     }
    }
   }
  } else if ((label | 0) == 99) {
   label = 0; //@line 16094
   $325 = _memchr($a$1, 0, $p$0) | 0; //@line 16095
   if (!$325) {
    $1053 = $229; //@line 16099
    $1054 = $207; //@line 16099
    $a$2 = $a$1; //@line 16099
    $fl$6 = $206; //@line 16099
    $p$5 = $p$0; //@line 16099
    $pl$2 = 0; //@line 16099
    $prefix$2 = 13032; //@line 16099
    $z$2 = $a$1 + $p$0 | 0; //@line 16099
    break;
   } else {
    $1053 = $229; //@line 16105
    $1054 = $207; //@line 16105
    $a$2 = $a$1; //@line 16105
    $fl$6 = $206; //@line 16105
    $p$5 = $325 - $a$1 | 0; //@line 16105
    $pl$2 = 0; //@line 16105
    $prefix$2 = 13032; //@line 16105
    $z$2 = $325; //@line 16105
    break;
   }
  } else if ((label | 0) == 104) {
   label = 0; //@line 16110
   $i$0168 = 0; //@line 16111
   $l$1167 = 0; //@line 16111
   $ws$0169 = $1055; //@line 16111
   while (1) {
    $336 = HEAP32[$ws$0169 >> 2] | 0; //@line 16113
    if (!$336) {
     $i$0$lcssa = $i$0168; //@line 16116
     $l$1$lcssa = $l$1167; //@line 16116
     break;
    }
    $338 = _wctomb($mb, $336) | 0; //@line 16119
    if (($338 | 0) <= -1) {
     $$0 = -1; //@line 16122
     label = 362; //@line 16123
     break L1;
    }
    $335 = $338 + $i$0168 | 0; //@line 16128
    if ($338 >>> 0 > ($p$4296 - $i$0168 | 0) >>> 0) {
     $1057 = $1055; //@line 16130
     $1058 = $1056; //@line 16130
     $i$0166 = $i$0168; //@line 16130
     label = 110; //@line 16131
     break L445;
    }
    if ($335 >>> 0 < $p$4296 >>> 0) {
     $i$0168 = $335; //@line 16137
     $l$1167 = $338; //@line 16137
     $ws$0169 = $ws$0169 + 4 | 0; //@line 16137
    } else {
     $i$0$lcssa = $335; //@line 16139
     $l$1$lcssa = $338; //@line 16139
     break;
    }
   }
   if (($l$1$lcssa | 0) < 0) {
    $$0 = -1; //@line 16145
    label = 362; //@line 16146
    break L1;
   } else {
    $1057 = $1055; //@line 16149
    $1058 = $1056; //@line 16149
    $i$0166 = $i$0$lcssa; //@line 16149
    label = 110; //@line 16150
   }
  } while (0);
  if ((label | 0) == 94) {
   label = 0; //@line 16155
   $$fl$4 = ($p$2 | 0) > -1 ? $fl$4 & -65537 : $fl$4; //@line 16158
   $312 = ($308 | 0) == 0 & ($311 | 0) == 0; //@line 16162
   if ($312 & ($p$2 | 0) == 0) {
    $1053 = $311; //@line 16166
    $1054 = $308; //@line 16166
    $a$2 = $2; //@line 16166
    $fl$6 = $$fl$4; //@line 16166
    $p$5 = 0; //@line 16166
    $pl$2 = $pl$1; //@line 16166
    $prefix$2 = $prefix$1; //@line 16166
    $z$2 = $2; //@line 16166
   } else {
    $317 = ($312 & 1) + ($3 - $a$0) | 0; //@line 16171
    $1053 = $311; //@line 16174
    $1054 = $308; //@line 16174
    $a$2 = $a$0; //@line 16174
    $fl$6 = $$fl$4; //@line 16174
    $p$5 = ($p$2 | 0) > ($317 | 0) ? $p$2 : $317; //@line 16174
    $pl$2 = $pl$1; //@line 16174
    $prefix$2 = $prefix$1; //@line 16174
    $z$2 = $2; //@line 16174
   }
  } else if ((label | 0) == 110) {
   label = 0; //@line 16178
   $343 = $fl$1$ & 73728; //@line 16179
   $345 = ($i$0166 | 0) < ($w$1 | 0); //@line 16181
   if (($343 | 0) == 0 & $345) {
    $346 = $w$1 - $i$0166 | 0; //@line 16184
    _memset($pad$i | 0, 32, ($346 >>> 0 > 256 ? 256 : $346) | 0) | 0; //@line 16187
    if ($346 >>> 0 > 255) {
     $$01$i57 = $346; //@line 16190
     while (1) {
      ___fwritex($pad$i, 256, $f) | 0; //@line 16192
      $350 = $$01$i57 + -256 | 0; //@line 16193
      if ($350 >>> 0 > 255) $$01$i57 = $350; //@line 16196
 else {
       $$0$lcssa$i59 = $350; //@line 16198
       break;
      }
     }
    } else $$0$lcssa$i59 = $346; //@line 16203
    ___fwritex($pad$i, $$0$lcssa$i59, $f) | 0; //@line 16205
   }
   L479 : do if ($i$0166) {
    $i$1174 = 0; //@line 16210
    $ws$1175 = $1057; //@line 16210
    while (1) {
     $353 = HEAP32[$ws$1175 >> 2] | 0; //@line 16212
     if (!$353) break L479;
     $355 = _wctomb($mb, $353) | 0; //@line 16217
     $i$1174 = $355 + $i$1174 | 0; //@line 16218
     if (($i$1174 | 0) > ($i$0166 | 0)) break L479;
     ___fwritex($mb, $355, $f) | 0; //@line 16224
     if ($i$1174 >>> 0 >= $i$0166 >>> 0) break; else $ws$1175 = $ws$1175 + 4 | 0; //@line 16227
    }
   } while (0);
   if (($343 | 0) == 8192 & $345) {
    $361 = $w$1 - $i$0166 | 0; //@line 16237
    _memset($pad$i | 0, 32, ($361 >>> 0 > 256 ? 256 : $361) | 0) | 0; //@line 16240
    if ($361 >>> 0 > 255) {
     $$01$i64 = $361; //@line 16243
     while (1) {
      ___fwritex($pad$i, 256, $f) | 0; //@line 16245
      $365 = $$01$i64 + -256 | 0; //@line 16246
      if ($365 >>> 0 > 255) $$01$i64 = $365; //@line 16249
 else {
       $$0$lcssa$i66 = $365; //@line 16251
       break;
      }
     }
    } else $$0$lcssa$i66 = $361; //@line 16256
    ___fwritex($pad$i, $$0$lcssa$i66, $f) | 0; //@line 16258
   }
   $1045 = $229; //@line 16261
   $1046 = $1058; //@line 16261
   $22 = $139; //@line 16261
   $cnt$0 = $cnt$1; //@line 16261
   $l$0 = $345 ? $w$1 : $i$0166; //@line 16261
   $l10n$0 = $l10n$3; //@line 16261
   continue;
  }
  $944 = $z$2 - $a$2 | 0; //@line 16266
  $$p$5 = ($p$5 | 0) < ($944 | 0) ? $944 : $p$5; //@line 16268
  $946 = $pl$2 + $$p$5 | 0; //@line 16269
  $w$2 = ($w$1 | 0) < ($946 | 0) ? $946 : $w$1; //@line 16271
  $948 = $fl$6 & 73728; //@line 16272
  $950 = ($946 | 0) < ($w$2 | 0); //@line 16274
  if (($948 | 0) == 0 & $950) {
   $951 = $w$2 - $946 | 0; //@line 16277
   _memset($pad$i | 0, 32, ($951 >>> 0 > 256 ? 256 : $951) | 0) | 0; //@line 16280
   if ($951 >>> 0 > 255) {
    $$01$i74 = $951; //@line 16283
    while (1) {
     ___fwritex($pad$i, 256, $f) | 0; //@line 16285
     $955 = $$01$i74 + -256 | 0; //@line 16286
     if ($955 >>> 0 > 255) $$01$i74 = $955; //@line 16289
 else {
      $$0$lcssa$i76 = $955; //@line 16291
      break;
     }
    }
   } else $$0$lcssa$i76 = $951; //@line 16296
   ___fwritex($pad$i, $$0$lcssa$i76, $f) | 0; //@line 16298
  }
  ___fwritex($prefix$2, $pl$2, $f) | 0; //@line 16300
  if (($948 | 0) == 65536 & $950) {
   $958 = $w$2 - $946 | 0; //@line 16304
   _memset($pad$i | 0, 48, ($958 >>> 0 > 256 ? 256 : $958) | 0) | 0; //@line 16307
   if ($958 >>> 0 > 255) {
    $$01$i50 = $958; //@line 16310
    while (1) {
     ___fwritex($pad$i, 256, $f) | 0; //@line 16312
     $962 = $$01$i50 + -256 | 0; //@line 16313
     if ($962 >>> 0 > 255) $$01$i50 = $962; //@line 16316
 else {
      $$0$lcssa$i52 = $962; //@line 16318
      break;
     }
    }
   } else $$0$lcssa$i52 = $958; //@line 16323
   ___fwritex($pad$i, $$0$lcssa$i52, $f) | 0; //@line 16325
  }
  if (($944 | 0) < ($$p$5 | 0)) {
   $965 = $$p$5 - $944 | 0; //@line 16329
   _memset($pad$i | 0, 48, ($965 >>> 0 > 256 ? 256 : $965) | 0) | 0; //@line 16332
   if ($965 >>> 0 > 255) {
    $$01$i35 = $965; //@line 16335
    while (1) {
     ___fwritex($pad$i, 256, $f) | 0; //@line 16337
     $969 = $$01$i35 + -256 | 0; //@line 16338
     if ($969 >>> 0 > 255) $$01$i35 = $969; //@line 16341
 else {
      $$0$lcssa$i37 = $969; //@line 16343
      break;
     }
    }
   } else $$0$lcssa$i37 = $965; //@line 16348
   ___fwritex($pad$i, $$0$lcssa$i37, $f) | 0; //@line 16350
  }
  ___fwritex($a$2, $944, $f) | 0; //@line 16352
  if (!(($948 | 0) == 8192 & $950)) {
   $1045 = $1053; //@line 16356
   $1046 = $1054; //@line 16356
   $22 = $139; //@line 16356
   $cnt$0 = $cnt$1; //@line 16356
   $l$0 = $w$2; //@line 16356
   $l10n$0 = $l10n$3; //@line 16356
   continue;
  }
  $972 = $w$2 - $946 | 0; //@line 16359
  _memset($pad$i | 0, 32, ($972 >>> 0 > 256 ? 256 : $972) | 0) | 0; //@line 16362
  if ($972 >>> 0 > 255) {
   $$01$i = $972; //@line 16365
   while (1) {
    ___fwritex($pad$i, 256, $f) | 0; //@line 16367
    $976 = $$01$i + -256 | 0; //@line 16368
    if ($976 >>> 0 > 255) $$01$i = $976; //@line 16371
 else {
     $$0$lcssa$i = $976; //@line 16373
     break;
    }
   }
  } else $$0$lcssa$i = $972; //@line 16378
  ___fwritex($pad$i, $$0$lcssa$i, $f) | 0; //@line 16380
  $1045 = $1053; //@line 16381
  $1046 = $1054; //@line 16381
  $22 = $139; //@line 16381
  $cnt$0 = $cnt$1; //@line 16381
  $l$0 = $w$2; //@line 16381
  $l10n$0 = $l10n$3; //@line 16381
 }
 if ((label | 0) == 344) {
  if ($f) {
   $$0 = $cnt$1; //@line 16386
   STACKTOP = sp; //@line 16387
   return $$0 | 0; //@line 16387
  }
  if (!$l10n$0) {
   $$0 = 0; //@line 16391
   STACKTOP = sp; //@line 16392
   return $$0 | 0; //@line 16392
  } else $i$289 = 1; //@line 16394
  while (1) {
   $981 = HEAP32[$nl_type + ($i$289 << 2) >> 2] | 0; //@line 16398
   if (!$981) {
    $i$388 = $i$289; //@line 16401
    break;
   }
   $983 = $nl_arg + ($i$289 << 3) | 0; //@line 16404
   L531 : do if ($981 >>> 0 <= 20) do switch ($981 | 0) {
   case 9:
    {
     $arglist_current35 = HEAP32[$ap >> 2] | 0; //@line 16411
     $985 = HEAP32[$arglist_current35 >> 2] | 0; //@line 16412
     HEAP32[$ap >> 2] = $arglist_current35 + 4; //@line 16414
     HEAP32[$983 >> 2] = $985; //@line 16415
     break L531;
     break;
    }
   case 10:
    {
     $arglist_current38 = HEAP32[$ap >> 2] | 0; //@line 16420
     $986 = HEAP32[$arglist_current38 >> 2] | 0; //@line 16421
     HEAP32[$ap >> 2] = $arglist_current38 + 4; //@line 16423
     $989 = $983; //@line 16426
     HEAP32[$989 >> 2] = $986; //@line 16428
     HEAP32[$989 + 4 >> 2] = (($986 | 0) < 0) << 31 >> 31; //@line 16431
     break L531;
     break;
    }
   case 11:
    {
     $arglist_current41 = HEAP32[$ap >> 2] | 0; //@line 16436
     $993 = HEAP32[$arglist_current41 >> 2] | 0; //@line 16437
     HEAP32[$ap >> 2] = $arglist_current41 + 4; //@line 16439
     $994 = $983; //@line 16440
     HEAP32[$994 >> 2] = $993; //@line 16442
     HEAP32[$994 + 4 >> 2] = 0; //@line 16445
     break L531;
     break;
    }
   case 12:
    {
     $arglist_current44 = HEAP32[$ap >> 2] | 0; //@line 16450
     $998 = $arglist_current44; //@line 16451
     $1000 = HEAP32[$998 >> 2] | 0; //@line 16453
     $1003 = HEAP32[$998 + 4 >> 2] | 0; //@line 16456
     HEAP32[$ap >> 2] = $arglist_current44 + 8; //@line 16458
     $1004 = $983; //@line 16459
     HEAP32[$1004 >> 2] = $1000; //@line 16461
     HEAP32[$1004 + 4 >> 2] = $1003; //@line 16464
     break L531;
     break;
    }
   case 13:
    {
     $arglist_current47 = HEAP32[$ap >> 2] | 0; //@line 16469
     $1008 = HEAP32[$arglist_current47 >> 2] | 0; //@line 16470
     HEAP32[$ap >> 2] = $arglist_current47 + 4; //@line 16472
     $1010 = ($1008 & 65535) << 16 >> 16; //@line 16474
     $1013 = $983; //@line 16477
     HEAP32[$1013 >> 2] = $1010; //@line 16479
     HEAP32[$1013 + 4 >> 2] = (($1010 | 0) < 0) << 31 >> 31; //@line 16482
     break L531;
     break;
    }
   case 14:
    {
     $arglist_current50 = HEAP32[$ap >> 2] | 0; //@line 16487
     $1017 = HEAP32[$arglist_current50 >> 2] | 0; //@line 16488
     HEAP32[$ap >> 2] = $arglist_current50 + 4; //@line 16490
     $1018 = $983; //@line 16492
     HEAP32[$1018 >> 2] = $1017 & 65535; //@line 16494
     HEAP32[$1018 + 4 >> 2] = 0; //@line 16497
     break L531;
     break;
    }
   case 15:
    {
     $arglist_current53 = HEAP32[$ap >> 2] | 0; //@line 16502
     $1022 = HEAP32[$arglist_current53 >> 2] | 0; //@line 16503
     HEAP32[$ap >> 2] = $arglist_current53 + 4; //@line 16505
     $1024 = ($1022 & 255) << 24 >> 24; //@line 16507
     $1027 = $983; //@line 16510
     HEAP32[$1027 >> 2] = $1024; //@line 16512
     HEAP32[$1027 + 4 >> 2] = (($1024 | 0) < 0) << 31 >> 31; //@line 16515
     break L531;
     break;
    }
   case 16:
    {
     $arglist_current56 = HEAP32[$ap >> 2] | 0; //@line 16520
     $1031 = HEAP32[$arglist_current56 >> 2] | 0; //@line 16521
     HEAP32[$ap >> 2] = $arglist_current56 + 4; //@line 16523
     $1032 = $983; //@line 16525
     HEAP32[$1032 >> 2] = $1031 & 255; //@line 16527
     HEAP32[$1032 + 4 >> 2] = 0; //@line 16530
     break L531;
     break;
    }
   case 17:
    {
     $arglist_current59 = HEAP32[$ap >> 2] | 0; //@line 16535
     HEAP32[tempDoublePtr >> 2] = HEAP32[$arglist_current59 >> 2]; //@line 16536
     HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[$arglist_current59 + 4 >> 2]; //@line 16536
     $1036 = +HEAPF64[tempDoublePtr >> 3]; //@line 16536
     HEAP32[$ap >> 2] = $arglist_current59 + 8; //@line 16538
     HEAPF64[$983 >> 3] = $1036; //@line 16539
     break L531;
     break;
    }
   case 18:
    {
     $arglist_current62 = HEAP32[$ap >> 2] | 0; //@line 16544
     HEAP32[tempDoublePtr >> 2] = HEAP32[$arglist_current62 >> 2]; //@line 16545
     HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[$arglist_current62 + 4 >> 2]; //@line 16545
     $1037 = +HEAPF64[tempDoublePtr >> 3]; //@line 16545
     HEAP32[$ap >> 2] = $arglist_current62 + 8; //@line 16547
     HEAPF64[$983 >> 3] = $1037; //@line 16548
     break L531;
     break;
    }
   default:
    break L531;
   } while (0); while (0);
   $i$289 = $i$289 + 1 | 0; //@line 16559
   if (($i$289 | 0) >= 10) {
    $$0 = 1; //@line 16564
    label = 362; //@line 16565
    break;
   }
  }
  if ((label | 0) == 362) {
   STACKTOP = sp; //@line 16570
   return $$0 | 0; //@line 16570
  }
  while (1) {
   if (HEAP32[$nl_type + ($i$388 << 2) >> 2] | 0) {
    $$0 = -1; //@line 16578
    label = 362; //@line 16579
    break;
   }
   $i$388 = $i$388 + 1 | 0; //@line 16576
   if (($i$388 | 0) >= 10) {
    $$0 = 1; //@line 16586
    label = 362; //@line 16587
    break;
   }
  }
  if ((label | 0) == 362) {
   STACKTOP = sp; //@line 16592
   return $$0 | 0; //@line 16592
  }
 } else if ((label | 0) == 362) {
  STACKTOP = sp; //@line 16596
  return $$0 | 0; //@line 16596
 }
 return 0; //@line 16598
}
function _malloc($bytes) {
 $bytes = $bytes | 0;
 var $$pre$phi$i$iZ2D = 0, $$pre$phi$i26$iZ2D = 0, $$pre$phi$i26Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi58$i$iZ2D = 0, $$pre$phiZ2D = 0, $$rsize$3$i = 0, $$sum$i21$i = 0, $$sum2$i23$i = 0, $$sum3132$i$i = 0, $$sum67$i$i = 0, $100 = 0, $1004 = 0, $1005 = 0, $1008 = 0, $1010 = 0, $1013 = 0, $1018 = 0, $1024 = 0, $1028 = 0, $1029 = 0, $1036 = 0, $1045 = 0, $1048 = 0, $1053 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1069 = 0, $1071 = 0, $1072 = 0, $110 = 0, $112 = 0, $113 = 0, $115 = 0, $117 = 0, $119 = 0, $12 = 0, $121 = 0, $123 = 0, $125 = 0, $127 = 0, $13 = 0, $132 = 0, $138 = 0, $14 = 0, $141 = 0, $144 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $151 = 0, $154 = 0, $156 = 0, $159 = 0, $16 = 0, $161 = 0, $164 = 0, $167 = 0, $168 = 0, $17 = 0, $170 = 0, $171 = 0, $173 = 0, $174 = 0, $176 = 0, $177 = 0, $18 = 0, $182 = 0, $183 = 0, $192 = 0, $201 = 0, $208 = 0, $215 = 0, $218 = 0, $226 = 0, $228 = 0, $229 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $237 = 0, $238 = 0, $246 = 0, $247 = 0, $248 = 0, $25 = 0, $250 = 0, $251 = 0, $256 = 0, $257 = 0, $260 = 0, $262 = 0, $265 = 0, $270 = 0, $277 = 0, $28 = 0, $283 = 0, $286 = 0, $287 = 0, $291 = 0, $301 = 0, $304 = 0, $308 = 0, $31 = 0, $310 = 0, $311 = 0, $313 = 0, $315 = 0, $317 = 0, $319 = 0, $321 = 0, $323 = 0, $325 = 0, $335 = 0, $336 = 0, $338 = 0, $347 = 0, $349 = 0, $352 = 0, $354 = 0, $357 = 0, $359 = 0, $362 = 0, $365 = 0, $366 = 0, $368 = 0, $369 = 0, $371 = 0, $372 = 0, $374 = 0, $375 = 0, $38 = 0, $380 = 0, $381 = 0, $390 = 0, $399 = 0, $4 = 0, $406 = 0, $41 = 0, $413 = 0, $416 = 0, $424 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $433 = 0, $434 = 0, $44 = 0, $440 = 0, $445 = 0, $446 = 0, $449 = 0, $451 = 0, $454 = 0, $459 = 0, $46 = 0, $465 = 0, $469 = 0, $47 = 0, $470 = 0, $477 = 0, $486 = 0, $489 = 0, $49 = 0, $494 = 0, $5 = 0, $501 = 0, $502 = 0, $503 = 0, $51 = 0, $511 = 0, $513 = 0, $514 = 0, $524 = 0, $528 = 0, $53 = 0, $530 = 0, $531 = 0, $540 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $554 = 0, $556 = 0, $557 = 0, $563 = 0, $565 = 0, $567 = 0, $57 = 0, $572 = 0, $575 = 0, $577 = 0, $578 = 0, $579 = 0, $587 = 0, $588 = 0, $59 = 0, $591 = 0, $595 = 0, $596 = 0, $599 = 0, $6 = 0, $601 = 0, $605 = 0, $606 = 0, $61 = 0, $611 = 0, $615 = 0, $624 = 0, $625 = 0, $629 = 0, $631 = 0, $633 = 0, $636 = 0, $638 = 0, $64 = 0, $642 = 0, $643 = 0, $649 = 0, $65 = 0, $655 = 0, $656 = 0, $66 = 0, $661 = 0, $662 = 0, $663 = 0, $667 = 0, $67 = 0, $677 = 0, $679 = 0, $68 = 0, $685 = 0, $686 = 0, $69 = 0, $693 = 0, $697 = 0, $7 = 0, $70 = 0, $703 = 0, $707 = 0, $713 = 0, $715 = 0, $720 = 0, $721 = 0, $725 = 0, $726 = 0, $732 = 0, $738 = 0, $743 = 0, $746 = 0, $747 = 0, $750 = 0, $752 = 0, $754 = 0, $769 = 0, $77 = 0, $774 = 0, $776 = 0, $779 = 0, $782 = 0, $785 = 0, $788 = 0, $789 = 0, $791 = 0, $792 = 0, $794 = 0, $795 = 0, $797 = 0, $798 = 0, $80 = 0, $804 = 0, $805 = 0, $81 = 0, $814 = 0, $823 = 0, $830 = 0, $838 = 0, $84 = 0, $844 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $853 = 0, $854 = 0, $860 = 0, $865 = 0, $866 = 0, $869 = 0, $871 = 0, $874 = 0, $879 = 0, $88 = 0, $885 = 0, $889 = 0, $890 = 0, $897 = 0, $90 = 0, $906 = 0, $909 = 0, $91 = 0, $914 = 0, $92 = 0, $921 = 0, $922 = 0, $923 = 0, $93 = 0, $931 = 0, $934 = 0, $935 = 0, $94 = 0, $940 = 0, $945 = 0, $946 = 0, $949 = 0, $95 = 0, $950 = 0, $953 = 0, $959 = 0, $960 = 0, $966 = 0, $970 = 0, $976 = 0, $978 = 0, $983 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $99 = 0, $992 = 0, $993 = 0, $999 = 0, $F$0$i$i = 0, $F1$0$i = 0, $F4$0 = 0, $F4$0$i$i = 0, $F5$0$i = 0, $I1$0$i$i = 0, $I7$0$i = 0, $I7$0$i$i = 0, $K12$025$i = 0, $K2$014$i$i = 0, $K8$052$i$i = 0, $R$0$i = 0, $R$0$i$i = 0, $R$0$i18 = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i20 = 0, $RP$0$i = 0, $RP$0$i$i = 0, $RP$0$i17 = 0, $T$0$lcssa$i = 0, $T$0$lcssa$i$i = 0, $T$0$lcssa$i28$i = 0, $T$013$i$i = 0, $T$024$i = 0, $T$051$i$i = 0, $br$0$i = 0, $i$02$i$i = 0, $idx$0$i = 0, $mem$0 = 0, $nb$0 = 0, $oldfirst$0$i$i = 0, $qsize$0$i$i = 0, $rsize$0$i = 0, $rsize$0$i15 = 0, $rsize$1$i = 0, $rsize$2$i = 0, $rsize$3$lcssa$i = 0, $rsize$329$i = 0, $rst$0$i = 0, $rst$1$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$075$i = 0, $sp$168$i = 0, $ssize$0$i = 0, $ssize$1$i = 0, $ssize$2$i = 0, $t$0$i = 0, $t$0$i14 = 0, $t$1$i = 0, $t$2$ph$i = 0, $t$2$v$3$i = 0, $t$228$i = 0, $tbase$0$i = 0, $tbase$247$i = 0, $tsize$0$i = 0, $tsize$0323841$i = 0, $tsize$1$i = 0, $tsize$246$i = 0, $v$0$i = 0, $v$0$i16 = 0, $v$1$i = 0, $v$2$i = 0, $v$3$lcssa$i = 0, $v$330$i = 0, label = 0, sp = 0, $970$looptemp = 0;
 sp = STACKTOP; //@line 6532
 do if ($bytes >>> 0 < 245) {
  if ($bytes >>> 0 < 11) $5 = 16; //@line 6538
 else $5 = $bytes + 11 & -8; //@line 6542
  $4 = $5 >>> 3; //@line 6544
  $6 = HEAP32[3e3] | 0; //@line 6545
  $7 = $6 >>> $4; //@line 6546
  if ($7 & 3) {
   $12 = ($7 & 1 ^ 1) + $4 | 0; //@line 6552
   $13 = $12 << 1; //@line 6553
   $14 = 12040 + ($13 << 2) | 0; //@line 6554
   $15 = 12040 + ($13 + 2 << 2) | 0; //@line 6556
   $16 = HEAP32[$15 >> 2] | 0; //@line 6557
   $17 = $16 + 8 | 0; //@line 6558
   $18 = HEAP32[$17 >> 2] | 0; //@line 6559
   do if (($14 | 0) == ($18 | 0)) HEAP32[3e3] = $6 & ~(1 << $12); //@line 6566
 else {
    if ($18 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6571
    $25 = $18 + 12 | 0; //@line 6574
    if ((HEAP32[$25 >> 2] | 0) == ($16 | 0)) {
     HEAP32[$25 >> 2] = $14; //@line 6578
     HEAP32[$15 >> 2] = $18; //@line 6579
     break;
    } else _abort(); //@line 6582
   } while (0);
   $28 = $12 << 3; //@line 6587
   HEAP32[$16 + 4 >> 2] = $28 | 3; //@line 6590
   $31 = $16 + ($28 | 4) | 0; //@line 6592
   HEAP32[$31 >> 2] = HEAP32[$31 >> 2] | 1; //@line 6595
   $mem$0 = $17; //@line 6596
   STACKTOP = sp; //@line 6597
   return $mem$0 | 0; //@line 6597
  }
  if ($5 >>> 0 > (HEAP32[3002] | 0) >>> 0) {
   if ($7) {
    $38 = 2 << $4; //@line 6605
    $41 = $7 << $4 & ($38 | 0 - $38); //@line 6608
    $44 = ($41 & 0 - $41) + -1 | 0; //@line 6611
    $46 = $44 >>> 12 & 16; //@line 6613
    $47 = $44 >>> $46; //@line 6614
    $49 = $47 >>> 5 & 8; //@line 6616
    $51 = $47 >>> $49; //@line 6618
    $53 = $51 >>> 2 & 4; //@line 6620
    $55 = $51 >>> $53; //@line 6622
    $57 = $55 >>> 1 & 2; //@line 6624
    $59 = $55 >>> $57; //@line 6626
    $61 = $59 >>> 1 & 1; //@line 6628
    $64 = ($49 | $46 | $53 | $57 | $61) + ($59 >>> $61) | 0; //@line 6631
    $65 = $64 << 1; //@line 6632
    $66 = 12040 + ($65 << 2) | 0; //@line 6633
    $67 = 12040 + ($65 + 2 << 2) | 0; //@line 6635
    $68 = HEAP32[$67 >> 2] | 0; //@line 6636
    $69 = $68 + 8 | 0; //@line 6637
    $70 = HEAP32[$69 >> 2] | 0; //@line 6638
    do if (($66 | 0) == ($70 | 0)) HEAP32[3e3] = $6 & ~(1 << $64); //@line 6645
 else {
     if ($70 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6650
     $77 = $70 + 12 | 0; //@line 6653
     if ((HEAP32[$77 >> 2] | 0) == ($68 | 0)) {
      HEAP32[$77 >> 2] = $66; //@line 6657
      HEAP32[$67 >> 2] = $70; //@line 6658
      break;
     } else _abort(); //@line 6661
    } while (0);
    $80 = $64 << 3; //@line 6666
    $81 = $80 - $5 | 0; //@line 6667
    HEAP32[$68 + 4 >> 2] = $5 | 3; //@line 6670
    $84 = $68 + $5 | 0; //@line 6671
    HEAP32[$68 + ($5 | 4) >> 2] = $81 | 1; //@line 6675
    HEAP32[$68 + $80 >> 2] = $81; //@line 6677
    $88 = HEAP32[3002] | 0; //@line 6678
    if ($88) {
     $90 = HEAP32[3005] | 0; //@line 6681
     $91 = $88 >>> 3; //@line 6682
     $92 = $91 << 1; //@line 6683
     $93 = 12040 + ($92 << 2) | 0; //@line 6684
     $94 = HEAP32[3e3] | 0; //@line 6685
     $95 = 1 << $91; //@line 6686
     if (!($94 & $95)) {
      HEAP32[3e3] = $94 | $95; //@line 6691
      $$pre$phiZ2D = 12040 + ($92 + 2 << 2) | 0; //@line 6694
      $F4$0 = $93; //@line 6694
     } else {
      $99 = 12040 + ($92 + 2 << 2) | 0; //@line 6697
      $100 = HEAP32[$99 >> 2] | 0; //@line 6698
      if ($100 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6702
 else {
       $$pre$phiZ2D = $99; //@line 6705
       $F4$0 = $100; //@line 6705
      }
     }
     HEAP32[$$pre$phiZ2D >> 2] = $90; //@line 6708
     HEAP32[$F4$0 + 12 >> 2] = $90; //@line 6710
     HEAP32[$90 + 8 >> 2] = $F4$0; //@line 6712
     HEAP32[$90 + 12 >> 2] = $93; //@line 6714
    }
    HEAP32[3002] = $81; //@line 6716
    HEAP32[3005] = $84; //@line 6717
    $mem$0 = $69; //@line 6718
    STACKTOP = sp; //@line 6719
    return $mem$0 | 0; //@line 6719
   }
   $106 = HEAP32[3001] | 0; //@line 6721
   if (!$106) $nb$0 = $5; //@line 6724
 else {
    $110 = ($106 & 0 - $106) + -1 | 0; //@line 6728
    $112 = $110 >>> 12 & 16; //@line 6730
    $113 = $110 >>> $112; //@line 6731
    $115 = $113 >>> 5 & 8; //@line 6733
    $117 = $113 >>> $115; //@line 6735
    $119 = $117 >>> 2 & 4; //@line 6737
    $121 = $117 >>> $119; //@line 6739
    $123 = $121 >>> 1 & 2; //@line 6741
    $125 = $121 >>> $123; //@line 6743
    $127 = $125 >>> 1 & 1; //@line 6745
    $132 = HEAP32[12304 + (($115 | $112 | $119 | $123 | $127) + ($125 >>> $127) << 2) >> 2] | 0; //@line 6750
    $rsize$0$i = (HEAP32[$132 + 4 >> 2] & -8) - $5 | 0; //@line 6755
    $t$0$i = $132; //@line 6755
    $v$0$i = $132; //@line 6755
    while (1) {
     $138 = HEAP32[$t$0$i + 16 >> 2] | 0; //@line 6758
     if (!$138) {
      $141 = HEAP32[$t$0$i + 20 >> 2] | 0; //@line 6762
      if (!$141) break; else $144 = $141; //@line 6767
     } else $144 = $138; //@line 6770
     $147 = (HEAP32[$144 + 4 >> 2] & -8) - $5 | 0; //@line 6775
     $148 = $147 >>> 0 < $rsize$0$i >>> 0; //@line 6776
     $rsize$0$i = $148 ? $147 : $rsize$0$i; //@line 6779
     $t$0$i = $144; //@line 6779
     $v$0$i = $148 ? $144 : $v$0$i; //@line 6779
    }
    $149 = HEAP32[3004] | 0; //@line 6781
    if ($v$0$i >>> 0 < $149 >>> 0) _abort(); //@line 6784
    $151 = $v$0$i + $5 | 0; //@line 6787
    if ($v$0$i >>> 0 >= $151 >>> 0) _abort(); //@line 6790
    $154 = HEAP32[$v$0$i + 24 >> 2] | 0; //@line 6794
    $156 = HEAP32[$v$0$i + 12 >> 2] | 0; //@line 6796
    do if (($156 | 0) == ($v$0$i | 0)) {
     $167 = $v$0$i + 20 | 0; //@line 6800
     $168 = HEAP32[$167 >> 2] | 0; //@line 6801
     if (!$168) {
      $170 = $v$0$i + 16 | 0; //@line 6804
      $171 = HEAP32[$170 >> 2] | 0; //@line 6805
      if (!$171) {
       $R$1$i = 0; //@line 6808
       break;
      } else {
       $R$0$i = $171; //@line 6811
       $RP$0$i = $170; //@line 6811
      }
     } else {
      $R$0$i = $168; //@line 6814
      $RP$0$i = $167; //@line 6814
     }
     while (1) {
      $173 = $R$0$i + 20 | 0; //@line 6817
      $174 = HEAP32[$173 >> 2] | 0; //@line 6818
      if ($174) {
       $R$0$i = $174; //@line 6821
       $RP$0$i = $173; //@line 6821
       continue;
      }
      $176 = $R$0$i + 16 | 0; //@line 6824
      $177 = HEAP32[$176 >> 2] | 0; //@line 6825
      if (!$177) break; else {
       $R$0$i = $177; //@line 6830
       $RP$0$i = $176; //@line 6830
      }
     }
     if ($RP$0$i >>> 0 < $149 >>> 0) _abort(); //@line 6835
 else {
      HEAP32[$RP$0$i >> 2] = 0; //@line 6838
      $R$1$i = $R$0$i; //@line 6839
      break;
     }
    } else {
     $159 = HEAP32[$v$0$i + 8 >> 2] | 0; //@line 6844
     if ($159 >>> 0 < $149 >>> 0) _abort(); //@line 6847
     $161 = $159 + 12 | 0; //@line 6850
     if ((HEAP32[$161 >> 2] | 0) != ($v$0$i | 0)) _abort(); //@line 6854
     $164 = $156 + 8 | 0; //@line 6857
     if ((HEAP32[$164 >> 2] | 0) == ($v$0$i | 0)) {
      HEAP32[$161 >> 2] = $156; //@line 6861
      HEAP32[$164 >> 2] = $159; //@line 6862
      $R$1$i = $156; //@line 6863
      break;
     } else _abort(); //@line 6866
    } while (0);
    do if ($154) {
     $182 = HEAP32[$v$0$i + 28 >> 2] | 0; //@line 6875
     $183 = 12304 + ($182 << 2) | 0; //@line 6876
     if (($v$0$i | 0) == (HEAP32[$183 >> 2] | 0)) {
      HEAP32[$183 >> 2] = $R$1$i; //@line 6880
      if (!$R$1$i) {
       HEAP32[3001] = HEAP32[3001] & ~(1 << $182); //@line 6887
       break;
      }
     } else {
      if ($154 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6894
      $192 = $154 + 16 | 0; //@line 6897
      if ((HEAP32[$192 >> 2] | 0) == ($v$0$i | 0)) HEAP32[$192 >> 2] = $R$1$i; //@line 6901
 else HEAP32[$154 + 20 >> 2] = $R$1$i; //@line 6904
      if (!$R$1$i) break;
     }
     if ($R$1$i >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6914
     HEAP32[$R$1$i + 24 >> 2] = $154; //@line 6918
     $201 = HEAP32[$v$0$i + 16 >> 2] | 0; //@line 6920
     do if ($201) if ($201 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6927
 else {
      HEAP32[$R$1$i + 16 >> 2] = $201; //@line 6931
      HEAP32[$201 + 24 >> 2] = $R$1$i; //@line 6933
      break;
     } while (0);
     $208 = HEAP32[$v$0$i + 20 >> 2] | 0; //@line 6939
     if ($208) if ($208 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 6945
 else {
      HEAP32[$R$1$i + 20 >> 2] = $208; //@line 6949
      HEAP32[$208 + 24 >> 2] = $R$1$i; //@line 6951
      break;
     }
    } while (0);
    if ($rsize$0$i >>> 0 < 16) {
     $215 = $rsize$0$i + $5 | 0; //@line 6959
     HEAP32[$v$0$i + 4 >> 2] = $215 | 3; //@line 6962
     $218 = $v$0$i + ($215 + 4) | 0; //@line 6964
     HEAP32[$218 >> 2] = HEAP32[$218 >> 2] | 1; //@line 6967
    } else {
     HEAP32[$v$0$i + 4 >> 2] = $5 | 3; //@line 6971
     HEAP32[$v$0$i + ($5 | 4) >> 2] = $rsize$0$i | 1; //@line 6975
     HEAP32[$v$0$i + ($rsize$0$i + $5) >> 2] = $rsize$0$i; //@line 6978
     $226 = HEAP32[3002] | 0; //@line 6979
     if ($226) {
      $228 = HEAP32[3005] | 0; //@line 6982
      $229 = $226 >>> 3; //@line 6983
      $230 = $229 << 1; //@line 6984
      $231 = 12040 + ($230 << 2) | 0; //@line 6985
      $232 = HEAP32[3e3] | 0; //@line 6986
      $233 = 1 << $229; //@line 6987
      if (!($232 & $233)) {
       HEAP32[3e3] = $232 | $233; //@line 6992
       $$pre$phi$iZ2D = 12040 + ($230 + 2 << 2) | 0; //@line 6995
       $F1$0$i = $231; //@line 6995
      } else {
       $237 = 12040 + ($230 + 2 << 2) | 0; //@line 6998
       $238 = HEAP32[$237 >> 2] | 0; //@line 6999
       if ($238 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7003
 else {
        $$pre$phi$iZ2D = $237; //@line 7006
        $F1$0$i = $238; //@line 7006
       }
      }
      HEAP32[$$pre$phi$iZ2D >> 2] = $228; //@line 7009
      HEAP32[$F1$0$i + 12 >> 2] = $228; //@line 7011
      HEAP32[$228 + 8 >> 2] = $F1$0$i; //@line 7013
      HEAP32[$228 + 12 >> 2] = $231; //@line 7015
     }
     HEAP32[3002] = $rsize$0$i; //@line 7017
     HEAP32[3005] = $151; //@line 7018
    }
    $mem$0 = $v$0$i + 8 | 0; //@line 7021
    STACKTOP = sp; //@line 7022
    return $mem$0 | 0; //@line 7022
   }
  } else $nb$0 = $5; //@line 7025
 } else if ($bytes >>> 0 > 4294967231) $nb$0 = -1; //@line 7030
 else {
  $246 = $bytes + 11 | 0; //@line 7032
  $247 = $246 & -8; //@line 7033
  $248 = HEAP32[3001] | 0; //@line 7034
  if (!$248) $nb$0 = $247; //@line 7037
 else {
   $250 = 0 - $247 | 0; //@line 7039
   $251 = $246 >>> 8; //@line 7040
   if (!$251) $idx$0$i = 0; //@line 7043
 else if ($247 >>> 0 > 16777215) $idx$0$i = 31; //@line 7047
 else {
    $256 = ($251 + 1048320 | 0) >>> 16 & 8; //@line 7051
    $257 = $251 << $256; //@line 7052
    $260 = ($257 + 520192 | 0) >>> 16 & 4; //@line 7055
    $262 = $257 << $260; //@line 7057
    $265 = ($262 + 245760 | 0) >>> 16 & 2; //@line 7060
    $270 = 14 - ($260 | $256 | $265) + ($262 << $265 >>> 15) | 0; //@line 7065
    $idx$0$i = $247 >>> ($270 + 7 | 0) & 1 | $270 << 1; //@line 7071
   }
   $277 = HEAP32[12304 + ($idx$0$i << 2) >> 2] | 0; //@line 7075
   L126 : do if (!$277) {
    $rsize$2$i = $250; //@line 7079
    $t$1$i = 0; //@line 7079
    $v$2$i = 0; //@line 7079
   } else {
    if (($idx$0$i | 0) == 31) $283 = 0; //@line 7083
 else $283 = 25 - ($idx$0$i >>> 1) | 0; //@line 7087
    $rsize$0$i15 = $250; //@line 7090
    $rst$0$i = 0; //@line 7090
    $sizebits$0$i = $247 << $283; //@line 7090
    $t$0$i14 = $277; //@line 7090
    $v$0$i16 = 0; //@line 7090
    while (1) {
     $286 = HEAP32[$t$0$i14 + 4 >> 2] & -8; //@line 7094
     $287 = $286 - $247 | 0; //@line 7095
     if ($287 >>> 0 < $rsize$0$i15 >>> 0) if (($286 | 0) == ($247 | 0)) {
      $rsize$2$i = $287; //@line 7100
      $t$1$i = $t$0$i14; //@line 7100
      $v$2$i = $t$0$i14; //@line 7100
      break L126;
     } else {
      $rsize$1$i = $287; //@line 7103
      $v$1$i = $t$0$i14; //@line 7103
     } else {
      $rsize$1$i = $rsize$0$i15; //@line 7106
      $v$1$i = $v$0$i16; //@line 7106
     }
     $291 = HEAP32[$t$0$i14 + 20 >> 2] | 0; //@line 7109
     $t$0$i14 = HEAP32[$t$0$i14 + ($sizebits$0$i >>> 31 << 2) + 16 >> 2] | 0; //@line 7112
     $rst$1$i = ($291 | 0) == 0 | ($291 | 0) == ($t$0$i14 | 0) ? $rst$0$i : $291; //@line 7116
     if (!$t$0$i14) {
      $rsize$2$i = $rsize$1$i; //@line 7120
      $t$1$i = $rst$1$i; //@line 7120
      $v$2$i = $v$1$i; //@line 7120
      break;
     } else {
      $rsize$0$i15 = $rsize$1$i; //@line 7123
      $rst$0$i = $rst$1$i; //@line 7123
      $sizebits$0$i = $sizebits$0$i << 1; //@line 7123
      $v$0$i16 = $v$1$i; //@line 7123
     }
    }
   } while (0);
   if (($t$1$i | 0) == 0 & ($v$2$i | 0) == 0) {
    $301 = 2 << $idx$0$i; //@line 7132
    $304 = $248 & ($301 | 0 - $301); //@line 7135
    if (!$304) {
     $nb$0 = $247; //@line 7138
     break;
    }
    $308 = ($304 & 0 - $304) + -1 | 0; //@line 7143
    $310 = $308 >>> 12 & 16; //@line 7145
    $311 = $308 >>> $310; //@line 7146
    $313 = $311 >>> 5 & 8; //@line 7148
    $315 = $311 >>> $313; //@line 7150
    $317 = $315 >>> 2 & 4; //@line 7152
    $319 = $315 >>> $317; //@line 7154
    $321 = $319 >>> 1 & 2; //@line 7156
    $323 = $319 >>> $321; //@line 7158
    $325 = $323 >>> 1 & 1; //@line 7160
    $t$2$ph$i = HEAP32[12304 + (($313 | $310 | $317 | $321 | $325) + ($323 >>> $325) << 2) >> 2] | 0; //@line 7166
   } else $t$2$ph$i = $t$1$i; //@line 7168
   if (!$t$2$ph$i) {
    $rsize$3$lcssa$i = $rsize$2$i; //@line 7172
    $v$3$lcssa$i = $v$2$i; //@line 7172
   } else {
    $rsize$329$i = $rsize$2$i; //@line 7174
    $t$228$i = $t$2$ph$i; //@line 7174
    $v$330$i = $v$2$i; //@line 7174
    while (1) {
     $335 = (HEAP32[$t$228$i + 4 >> 2] & -8) - $247 | 0; //@line 7179
     $336 = $335 >>> 0 < $rsize$329$i >>> 0; //@line 7180
     $$rsize$3$i = $336 ? $335 : $rsize$329$i; //@line 7181
     $t$2$v$3$i = $336 ? $t$228$i : $v$330$i; //@line 7182
     $338 = HEAP32[$t$228$i + 16 >> 2] | 0; //@line 7184
     if ($338) {
      $rsize$329$i = $$rsize$3$i; //@line 7187
      $t$228$i = $338; //@line 7187
      $v$330$i = $t$2$v$3$i; //@line 7187
      continue;
     }
     $t$228$i = HEAP32[$t$228$i + 20 >> 2] | 0; //@line 7191
     if (!$t$228$i) {
      $rsize$3$lcssa$i = $$rsize$3$i; //@line 7194
      $v$3$lcssa$i = $t$2$v$3$i; //@line 7194
      break;
     } else {
      $rsize$329$i = $$rsize$3$i; //@line 7197
      $v$330$i = $t$2$v$3$i; //@line 7197
     }
    }
   }
   if (!$v$3$lcssa$i) $nb$0 = $247; //@line 7203
 else if ($rsize$3$lcssa$i >>> 0 < ((HEAP32[3002] | 0) - $247 | 0) >>> 0) {
    $347 = HEAP32[3004] | 0; //@line 7209
    if ($v$3$lcssa$i >>> 0 < $347 >>> 0) _abort(); //@line 7212
    $349 = $v$3$lcssa$i + $247 | 0; //@line 7215
    if ($v$3$lcssa$i >>> 0 >= $349 >>> 0) _abort(); //@line 7218
    $352 = HEAP32[$v$3$lcssa$i + 24 >> 2] | 0; //@line 7222
    $354 = HEAP32[$v$3$lcssa$i + 12 >> 2] | 0; //@line 7224
    do if (($354 | 0) == ($v$3$lcssa$i | 0)) {
     $365 = $v$3$lcssa$i + 20 | 0; //@line 7228
     $366 = HEAP32[$365 >> 2] | 0; //@line 7229
     if (!$366) {
      $368 = $v$3$lcssa$i + 16 | 0; //@line 7232
      $369 = HEAP32[$368 >> 2] | 0; //@line 7233
      if (!$369) {
       $R$1$i20 = 0; //@line 7236
       break;
      } else {
       $R$0$i18 = $369; //@line 7239
       $RP$0$i17 = $368; //@line 7239
      }
     } else {
      $R$0$i18 = $366; //@line 7242
      $RP$0$i17 = $365; //@line 7242
     }
     while (1) {
      $371 = $R$0$i18 + 20 | 0; //@line 7245
      $372 = HEAP32[$371 >> 2] | 0; //@line 7246
      if ($372) {
       $R$0$i18 = $372; //@line 7249
       $RP$0$i17 = $371; //@line 7249
       continue;
      }
      $374 = $R$0$i18 + 16 | 0; //@line 7252
      $375 = HEAP32[$374 >> 2] | 0; //@line 7253
      if (!$375) break; else {
       $R$0$i18 = $375; //@line 7258
       $RP$0$i17 = $374; //@line 7258
      }
     }
     if ($RP$0$i17 >>> 0 < $347 >>> 0) _abort(); //@line 7263
 else {
      HEAP32[$RP$0$i17 >> 2] = 0; //@line 7266
      $R$1$i20 = $R$0$i18; //@line 7267
      break;
     }
    } else {
     $357 = HEAP32[$v$3$lcssa$i + 8 >> 2] | 0; //@line 7272
     if ($357 >>> 0 < $347 >>> 0) _abort(); //@line 7275
     $359 = $357 + 12 | 0; //@line 7278
     if ((HEAP32[$359 >> 2] | 0) != ($v$3$lcssa$i | 0)) _abort(); //@line 7282
     $362 = $354 + 8 | 0; //@line 7285
     if ((HEAP32[$362 >> 2] | 0) == ($v$3$lcssa$i | 0)) {
      HEAP32[$359 >> 2] = $354; //@line 7289
      HEAP32[$362 >> 2] = $357; //@line 7290
      $R$1$i20 = $354; //@line 7291
      break;
     } else _abort(); //@line 7294
    } while (0);
    do if ($352) {
     $380 = HEAP32[$v$3$lcssa$i + 28 >> 2] | 0; //@line 7303
     $381 = 12304 + ($380 << 2) | 0; //@line 7304
     if (($v$3$lcssa$i | 0) == (HEAP32[$381 >> 2] | 0)) {
      HEAP32[$381 >> 2] = $R$1$i20; //@line 7308
      if (!$R$1$i20) {
       HEAP32[3001] = HEAP32[3001] & ~(1 << $380); //@line 7315
       break;
      }
     } else {
      if ($352 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7322
      $390 = $352 + 16 | 0; //@line 7325
      if ((HEAP32[$390 >> 2] | 0) == ($v$3$lcssa$i | 0)) HEAP32[$390 >> 2] = $R$1$i20; //@line 7329
 else HEAP32[$352 + 20 >> 2] = $R$1$i20; //@line 7332
      if (!$R$1$i20) break;
     }
     if ($R$1$i20 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7342
     HEAP32[$R$1$i20 + 24 >> 2] = $352; //@line 7346
     $399 = HEAP32[$v$3$lcssa$i + 16 >> 2] | 0; //@line 7348
     do if ($399) if ($399 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7355
 else {
      HEAP32[$R$1$i20 + 16 >> 2] = $399; //@line 7359
      HEAP32[$399 + 24 >> 2] = $R$1$i20; //@line 7361
      break;
     } while (0);
     $406 = HEAP32[$v$3$lcssa$i + 20 >> 2] | 0; //@line 7367
     if ($406) if ($406 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7373
 else {
      HEAP32[$R$1$i20 + 20 >> 2] = $406; //@line 7377
      HEAP32[$406 + 24 >> 2] = $R$1$i20; //@line 7379
      break;
     }
    } while (0);
    L204 : do if ($rsize$3$lcssa$i >>> 0 < 16) {
     $413 = $rsize$3$lcssa$i + $247 | 0; //@line 7388
     HEAP32[$v$3$lcssa$i + 4 >> 2] = $413 | 3; //@line 7391
     $416 = $v$3$lcssa$i + ($413 + 4) | 0; //@line 7393
     HEAP32[$416 >> 2] = HEAP32[$416 >> 2] | 1; //@line 7396
    } else {
     HEAP32[$v$3$lcssa$i + 4 >> 2] = $247 | 3; //@line 7400
     HEAP32[$v$3$lcssa$i + ($247 | 4) >> 2] = $rsize$3$lcssa$i | 1; //@line 7404
     HEAP32[$v$3$lcssa$i + ($rsize$3$lcssa$i + $247) >> 2] = $rsize$3$lcssa$i; //@line 7407
     $424 = $rsize$3$lcssa$i >>> 3; //@line 7408
     if ($rsize$3$lcssa$i >>> 0 < 256) {
      $426 = $424 << 1; //@line 7411
      $427 = 12040 + ($426 << 2) | 0; //@line 7412
      $428 = HEAP32[3e3] | 0; //@line 7413
      $429 = 1 << $424; //@line 7414
      do if (!($428 & $429)) {
       HEAP32[3e3] = $428 | $429; //@line 7420
       $$pre$phi$i26Z2D = 12040 + ($426 + 2 << 2) | 0; //@line 7423
       $F5$0$i = $427; //@line 7423
      } else {
       $433 = 12040 + ($426 + 2 << 2) | 0; //@line 7426
       $434 = HEAP32[$433 >> 2] | 0; //@line 7427
       if ($434 >>> 0 >= (HEAP32[3004] | 0) >>> 0) {
        $$pre$phi$i26Z2D = $433; //@line 7431
        $F5$0$i = $434; //@line 7431
        break;
       }
       _abort(); //@line 7434
      } while (0);
      HEAP32[$$pre$phi$i26Z2D >> 2] = $349; //@line 7438
      HEAP32[$F5$0$i + 12 >> 2] = $349; //@line 7440
      HEAP32[$v$3$lcssa$i + ($247 + 8) >> 2] = $F5$0$i; //@line 7443
      HEAP32[$v$3$lcssa$i + ($247 + 12) >> 2] = $427; //@line 7446
      break;
     }
     $440 = $rsize$3$lcssa$i >>> 8; //@line 7449
     if (!$440) $I7$0$i = 0; //@line 7452
 else if ($rsize$3$lcssa$i >>> 0 > 16777215) $I7$0$i = 31; //@line 7456
 else {
      $445 = ($440 + 1048320 | 0) >>> 16 & 8; //@line 7460
      $446 = $440 << $445; //@line 7461
      $449 = ($446 + 520192 | 0) >>> 16 & 4; //@line 7464
      $451 = $446 << $449; //@line 7466
      $454 = ($451 + 245760 | 0) >>> 16 & 2; //@line 7469
      $459 = 14 - ($449 | $445 | $454) + ($451 << $454 >>> 15) | 0; //@line 7474
      $I7$0$i = $rsize$3$lcssa$i >>> ($459 + 7 | 0) & 1 | $459 << 1; //@line 7480
     }
     $465 = 12304 + ($I7$0$i << 2) | 0; //@line 7483
     HEAP32[$v$3$lcssa$i + ($247 + 28) >> 2] = $I7$0$i; //@line 7486
     HEAP32[$v$3$lcssa$i + ($247 + 20) >> 2] = 0; //@line 7491
     HEAP32[$v$3$lcssa$i + ($247 + 16) >> 2] = 0; //@line 7492
     $469 = HEAP32[3001] | 0; //@line 7493
     $470 = 1 << $I7$0$i; //@line 7494
     if (!($469 & $470)) {
      HEAP32[3001] = $469 | $470; //@line 7499
      HEAP32[$465 >> 2] = $349; //@line 7500
      HEAP32[$v$3$lcssa$i + ($247 + 24) >> 2] = $465; //@line 7503
      HEAP32[$v$3$lcssa$i + ($247 + 12) >> 2] = $349; //@line 7506
      HEAP32[$v$3$lcssa$i + ($247 + 8) >> 2] = $349; //@line 7509
      break;
     }
     $477 = HEAP32[$465 >> 2] | 0; //@line 7512
     if (($I7$0$i | 0) == 31) $486 = 0; //@line 7515
 else $486 = 25 - ($I7$0$i >>> 1) | 0; //@line 7519
     L225 : do if ((HEAP32[$477 + 4 >> 2] & -8 | 0) == ($rsize$3$lcssa$i | 0)) $T$0$lcssa$i = $477; //@line 7527
 else {
      $K12$025$i = $rsize$3$lcssa$i << $486; //@line 7530
      $T$024$i = $477; //@line 7530
      while (1) {
       $494 = $T$024$i + ($K12$025$i >>> 31 << 2) + 16 | 0; //@line 7533
       $489 = HEAP32[$494 >> 2] | 0; //@line 7534
       if (!$489) break;
       if ((HEAP32[$489 + 4 >> 2] & -8 | 0) == ($rsize$3$lcssa$i | 0)) {
        $T$0$lcssa$i = $489; //@line 7545
        break L225;
       } else {
        $K12$025$i = $K12$025$i << 1; //@line 7548
        $T$024$i = $489; //@line 7548
       }
      }
      if ($494 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 7554
 else {
       HEAP32[$494 >> 2] = $349; //@line 7557
       HEAP32[$v$3$lcssa$i + ($247 + 24) >> 2] = $T$024$i; //@line 7560
       HEAP32[$v$3$lcssa$i + ($247 + 12) >> 2] = $349; //@line 7563
       HEAP32[$v$3$lcssa$i + ($247 + 8) >> 2] = $349; //@line 7566
       break L204;
      }
     } while (0);
     $501 = $T$0$lcssa$i + 8 | 0; //@line 7571
     $502 = HEAP32[$501 >> 2] | 0; //@line 7572
     $503 = HEAP32[3004] | 0; //@line 7573
     if ($T$0$lcssa$i >>> 0 < $503 >>> 0) _abort(); //@line 7576
     if ($502 >>> 0 < $503 >>> 0) _abort(); //@line 7581
 else {
      HEAP32[$502 + 12 >> 2] = $349; //@line 7585
      HEAP32[$501 >> 2] = $349; //@line 7586
      HEAP32[$v$3$lcssa$i + ($247 + 8) >> 2] = $502; //@line 7589
      HEAP32[$v$3$lcssa$i + ($247 + 12) >> 2] = $T$0$lcssa$i; //@line 7592
      HEAP32[$v$3$lcssa$i + ($247 + 24) >> 2] = 0; //@line 7595
      break;
     }
    } while (0);
    $mem$0 = $v$3$lcssa$i + 8 | 0; //@line 7601
    STACKTOP = sp; //@line 7602
    return $mem$0 | 0; //@line 7602
   } else $nb$0 = $247; //@line 7604
  }
 } while (0);
 $511 = HEAP32[3002] | 0; //@line 7611
 if ($nb$0 >>> 0 <= $511 >>> 0) {
  $513 = $511 - $nb$0 | 0; //@line 7614
  $514 = HEAP32[3005] | 0; //@line 7615
  if ($513 >>> 0 > 15) {
   HEAP32[3005] = $514 + $nb$0; //@line 7619
   HEAP32[3002] = $513; //@line 7620
   HEAP32[$514 + ($nb$0 + 4) >> 2] = $513 | 1; //@line 7624
   HEAP32[$514 + $511 >> 2] = $513; //@line 7626
   HEAP32[$514 + 4 >> 2] = $nb$0 | 3; //@line 7629
  } else {
   HEAP32[3002] = 0; //@line 7631
   HEAP32[3005] = 0; //@line 7632
   HEAP32[$514 + 4 >> 2] = $511 | 3; //@line 7635
   $524 = $514 + ($511 + 4) | 0; //@line 7637
   HEAP32[$524 >> 2] = HEAP32[$524 >> 2] | 1; //@line 7640
  }
  $mem$0 = $514 + 8 | 0; //@line 7643
  STACKTOP = sp; //@line 7644
  return $mem$0 | 0; //@line 7644
 }
 $528 = HEAP32[3003] | 0; //@line 7646
 if ($nb$0 >>> 0 < $528 >>> 0) {
  $530 = $528 - $nb$0 | 0; //@line 7649
  HEAP32[3003] = $530; //@line 7650
  $531 = HEAP32[3006] | 0; //@line 7651
  HEAP32[3006] = $531 + $nb$0; //@line 7653
  HEAP32[$531 + ($nb$0 + 4) >> 2] = $530 | 1; //@line 7657
  HEAP32[$531 + 4 >> 2] = $nb$0 | 3; //@line 7660
  $mem$0 = $531 + 8 | 0; //@line 7662
  STACKTOP = sp; //@line 7663
  return $mem$0 | 0; //@line 7663
 }
 do if (!(HEAP32[3118] | 0)) {
  $540 = _sysconf(30) | 0; //@line 7669
  if (!($540 + -1 & $540)) {
   HEAP32[3120] = $540; //@line 7674
   HEAP32[3119] = $540; //@line 7675
   HEAP32[3121] = -1; //@line 7676
   HEAP32[3122] = -1; //@line 7677
   HEAP32[3123] = 0; //@line 7678
   HEAP32[3111] = 0; //@line 7679
   HEAP32[3118] = (_time(0) | 0) & -16 ^ 1431655768; //@line 7683
   break;
  } else _abort(); //@line 7686
 } while (0);
 $547 = $nb$0 + 48 | 0; //@line 7691
 $548 = HEAP32[3120] | 0; //@line 7692
 $549 = $nb$0 + 47 | 0; //@line 7693
 $550 = $548 + $549 | 0; //@line 7694
 $551 = 0 - $548 | 0; //@line 7695
 $552 = $550 & $551; //@line 7696
 if ($552 >>> 0 <= $nb$0 >>> 0) {
  $mem$0 = 0; //@line 7699
  STACKTOP = sp; //@line 7700
  return $mem$0 | 0; //@line 7700
 }
 $554 = HEAP32[3110] | 0; //@line 7702
 if ($554) {
  $556 = HEAP32[3108] | 0; //@line 7705
  $557 = $556 + $552 | 0; //@line 7706
  if ($557 >>> 0 <= $556 >>> 0 | $557 >>> 0 > $554 >>> 0) {
   $mem$0 = 0; //@line 7711
   STACKTOP = sp; //@line 7712
   return $mem$0 | 0; //@line 7712
  }
 }
 L269 : do if (!(HEAP32[3111] & 4)) {
  $563 = HEAP32[3006] | 0; //@line 7720
  L271 : do if (!$563) label = 182; //@line 7724
 else {
   $sp$0$i$i = 12448 | 0; //@line 7726
   while (1) {
    $565 = HEAP32[$sp$0$i$i >> 2] | 0; //@line 7728
    if ($565 >>> 0 <= $563 >>> 0) {
     $567 = $sp$0$i$i + 4 | 0; //@line 7731
     if (($565 + (HEAP32[$567 >> 2] | 0) | 0) >>> 0 > $563 >>> 0) break;
    }
    $572 = HEAP32[$sp$0$i$i + 8 >> 2] | 0; //@line 7740
    if (!$572) {
     label = 182; //@line 7743
     break L271;
    } else $sp$0$i$i = $572; //@line 7746
   }
   if (!$sp$0$i$i) label = 182; //@line 7751
 else {
    $599 = $550 - (HEAP32[3003] | 0) & $551; //@line 7755
    if ($599 >>> 0 < 2147483647) {
     $601 = _sbrk($599 | 0) | 0; //@line 7758
     $605 = ($601 | 0) == ((HEAP32[$sp$0$i$i >> 2] | 0) + (HEAP32[$567 >> 2] | 0) | 0); //@line 7762
     $br$0$i = $601; //@line 7765
     $ssize$1$i = $599; //@line 7765
     $tbase$0$i = $605 ? $601 : -1; //@line 7765
     $tsize$0$i = $605 ? $599 : 0; //@line 7765
     label = 191; //@line 7766
    } else $tsize$0323841$i = 0; //@line 7768
   }
  } while (0);
  do if ((label | 0) == 182) {
   $575 = _sbrk(0) | 0; //@line 7775
   if (($575 | 0) == (-1 | 0)) $tsize$0323841$i = 0; //@line 7778
 else {
    $577 = $575; //@line 7780
    $578 = HEAP32[3119] | 0; //@line 7781
    $579 = $578 + -1 | 0; //@line 7782
    if (!($579 & $577)) $ssize$0$i = $552; //@line 7786
 else $ssize$0$i = $552 - $577 + ($579 + $577 & 0 - $578) | 0; //@line 7793
    $587 = HEAP32[3108] | 0; //@line 7795
    $588 = $587 + $ssize$0$i | 0; //@line 7796
    if ($ssize$0$i >>> 0 > $nb$0 >>> 0 & $ssize$0$i >>> 0 < 2147483647) {
     $591 = HEAP32[3110] | 0; //@line 7801
     if ($591) if ($588 >>> 0 <= $587 >>> 0 | $588 >>> 0 > $591 >>> 0) {
      $tsize$0323841$i = 0; //@line 7808
      break;
     }
     $595 = _sbrk($ssize$0$i | 0) | 0; //@line 7812
     $596 = ($595 | 0) == ($575 | 0); //@line 7813
     $br$0$i = $595; //@line 7816
     $ssize$1$i = $ssize$0$i; //@line 7816
     $tbase$0$i = $596 ? $575 : -1; //@line 7816
     $tsize$0$i = $596 ? $ssize$0$i : 0; //@line 7816
     label = 191; //@line 7817
    } else $tsize$0323841$i = 0; //@line 7819
   }
  } while (0);
  L291 : do if ((label | 0) == 191) {
   $606 = 0 - $ssize$1$i | 0; //@line 7826
   if (($tbase$0$i | 0) != (-1 | 0)) {
    $tbase$247$i = $tbase$0$i; //@line 7829
    $tsize$246$i = $tsize$0$i; //@line 7829
    label = 202; //@line 7830
    break L269;
   }
   do if (($br$0$i | 0) != (-1 | 0) & $ssize$1$i >>> 0 < 2147483647 & $ssize$1$i >>> 0 < $547 >>> 0) {
    $611 = HEAP32[3120] | 0; //@line 7840
    $615 = $549 - $ssize$1$i + $611 & 0 - $611; //@line 7844
    if ($615 >>> 0 < 2147483647) if ((_sbrk($615 | 0) | 0) == (-1 | 0)) {
     _sbrk($606 | 0) | 0; //@line 7850
     $tsize$0323841$i = $tsize$0$i; //@line 7851
     break L291;
    } else {
     $ssize$2$i = $615 + $ssize$1$i | 0; //@line 7855
     break;
    } else $ssize$2$i = $ssize$1$i; //@line 7859
   } else $ssize$2$i = $ssize$1$i; //@line 7862
 while (0);
   if (($br$0$i | 0) == (-1 | 0)) $tsize$0323841$i = $tsize$0$i; //@line 7867
 else {
    $tbase$247$i = $br$0$i; //@line 7869
    $tsize$246$i = $ssize$2$i; //@line 7869
    label = 202; //@line 7870
    break L269;
   }
  } while (0);
  HEAP32[3111] = HEAP32[3111] | 4; //@line 7877
  $tsize$1$i = $tsize$0323841$i; //@line 7878
  label = 199; //@line 7879
 } else {
  $tsize$1$i = 0; //@line 7881
  label = 199; //@line 7882
 } while (0);
 if ((label | 0) == 199) if ($552 >>> 0 < 2147483647) {
  $624 = _sbrk($552 | 0) | 0; //@line 7888
  $625 = _sbrk(0) | 0; //@line 7889
  if (($625 | 0) != (-1 | 0) & ($624 | 0) != (-1 | 0) & $624 >>> 0 < $625 >>> 0) {
   $629 = $625 - $624 | 0; //@line 7898
   $631 = $629 >>> 0 > ($nb$0 + 40 | 0) >>> 0; //@line 7900
   if ($631) {
    $tbase$247$i = $624; //@line 7903
    $tsize$246$i = $631 ? $629 : $tsize$1$i; //@line 7903
    label = 202; //@line 7904
   }
  }
 }
 if ((label | 0) == 202) {
  $633 = (HEAP32[3108] | 0) + $tsize$246$i | 0; //@line 7911
  HEAP32[3108] = $633; //@line 7912
  if ($633 >>> 0 > (HEAP32[3109] | 0) >>> 0) HEAP32[3109] = $633; //@line 7916
  $636 = HEAP32[3006] | 0; //@line 7918
  L311 : do if (!$636) {
   $638 = HEAP32[3004] | 0; //@line 7922
   if (($638 | 0) == 0 | $tbase$247$i >>> 0 < $638 >>> 0) HEAP32[3004] = $tbase$247$i; //@line 7927
   HEAP32[3112] = $tbase$247$i; //@line 7929
   HEAP32[3113] = $tsize$246$i; //@line 7930
   HEAP32[3115] = 0; //@line 7931
   HEAP32[3009] = HEAP32[3118]; //@line 7933
   HEAP32[3008] = -1; //@line 7934
   $i$02$i$i = 0; //@line 7935
   do {
    $642 = $i$02$i$i << 1; //@line 7937
    $643 = 12040 + ($642 << 2) | 0; //@line 7938
    HEAP32[12040 + ($642 + 3 << 2) >> 2] = $643; //@line 7941
    HEAP32[12040 + ($642 + 2 << 2) >> 2] = $643; //@line 7944
    $i$02$i$i = $i$02$i$i + 1 | 0; //@line 7945
   } while (($i$02$i$i | 0) != 32);
   $649 = $tbase$247$i + 8 | 0; //@line 7955
   if (!($649 & 7)) $655 = 0; //@line 7959
 else $655 = 0 - $649 & 7; //@line 7963
   $656 = $tsize$246$i + -40 - $655 | 0; //@line 7966
   HEAP32[3006] = $tbase$247$i + $655; //@line 7967
   HEAP32[3003] = $656; //@line 7968
   HEAP32[$tbase$247$i + ($655 + 4) >> 2] = $656 | 1; //@line 7972
   HEAP32[$tbase$247$i + ($tsize$246$i + -36) >> 2] = 40; //@line 7975
   HEAP32[3007] = HEAP32[3122]; //@line 7977
  } else {
   $sp$075$i = 12448 | 0; //@line 7979
   while (1) {
    $661 = HEAP32[$sp$075$i >> 2] | 0; //@line 7981
    $662 = $sp$075$i + 4 | 0; //@line 7982
    $663 = HEAP32[$662 >> 2] | 0; //@line 7983
    if (($tbase$247$i | 0) == ($661 + $663 | 0)) {
     label = 214; //@line 7987
     break;
    }
    $667 = HEAP32[$sp$075$i + 8 >> 2] | 0; //@line 7991
    if (!$667) break; else $sp$075$i = $667; //@line 7996
   }
   if ((label | 0) == 214) if (!(HEAP32[$sp$075$i + 12 >> 2] & 8)) if ($636 >>> 0 >= $661 >>> 0 & $636 >>> 0 < $tbase$247$i >>> 0) {
    HEAP32[$662 >> 2] = $663 + $tsize$246$i; //@line 8010
    $677 = (HEAP32[3003] | 0) + $tsize$246$i | 0; //@line 8012
    $679 = $636 + 8 | 0; //@line 8014
    if (!($679 & 7)) $685 = 0; //@line 8018
 else $685 = 0 - $679 & 7; //@line 8022
    $686 = $677 - $685 | 0; //@line 8025
    HEAP32[3006] = $636 + $685; //@line 8026
    HEAP32[3003] = $686; //@line 8027
    HEAP32[$636 + ($685 + 4) >> 2] = $686 | 1; //@line 8031
    HEAP32[$636 + ($677 + 4) >> 2] = 40; //@line 8034
    HEAP32[3007] = HEAP32[3122]; //@line 8036
    break;
   }
   if ($tbase$247$i >>> 0 < (HEAP32[3004] | 0) >>> 0) HEAP32[3004] = $tbase$247$i; //@line 8044
   $693 = $tbase$247$i + $tsize$246$i | 0; //@line 8046
   $sp$168$i = 12448 | 0; //@line 8047
   while (1) {
    if ((HEAP32[$sp$168$i >> 2] | 0) == ($693 | 0)) {
     label = 224; //@line 8052
     break;
    }
    $697 = HEAP32[$sp$168$i + 8 >> 2] | 0; //@line 8056
    if (!$697) break; else $sp$168$i = $697; //@line 8061
   }
   if ((label | 0) == 224) if (!(HEAP32[$sp$168$i + 12 >> 2] & 8)) {
    HEAP32[$sp$168$i >> 2] = $tbase$247$i; //@line 8070
    $703 = $sp$168$i + 4 | 0; //@line 8071
    HEAP32[$703 >> 2] = (HEAP32[$703 >> 2] | 0) + $tsize$246$i; //@line 8074
    $707 = $tbase$247$i + 8 | 0; //@line 8076
    if (!($707 & 7)) $713 = 0; //@line 8080
 else $713 = 0 - $707 & 7; //@line 8084
    $715 = $tbase$247$i + ($tsize$246$i + 8) | 0; //@line 8089
    if (!($715 & 7)) $720 = 0; //@line 8093
 else $720 = 0 - $715 & 7; //@line 8097
    $721 = $tbase$247$i + ($720 + $tsize$246$i) | 0; //@line 8100
    $$sum$i21$i = $713 + $nb$0 | 0; //@line 8104
    $725 = $tbase$247$i + $$sum$i21$i | 0; //@line 8105
    $726 = $721 - ($tbase$247$i + $713) - $nb$0 | 0; //@line 8106
    HEAP32[$tbase$247$i + ($713 + 4) >> 2] = $nb$0 | 3; //@line 8110
    L348 : do if (($721 | 0) == (HEAP32[3006] | 0)) {
     $732 = (HEAP32[3003] | 0) + $726 | 0; //@line 8116
     HEAP32[3003] = $732; //@line 8117
     HEAP32[3006] = $725; //@line 8118
     HEAP32[$tbase$247$i + ($$sum$i21$i + 4) >> 2] = $732 | 1; //@line 8122
    } else {
     if (($721 | 0) == (HEAP32[3005] | 0)) {
      $738 = (HEAP32[3002] | 0) + $726 | 0; //@line 8128
      HEAP32[3002] = $738; //@line 8129
      HEAP32[3005] = $725; //@line 8130
      HEAP32[$tbase$247$i + ($$sum$i21$i + 4) >> 2] = $738 | 1; //@line 8134
      HEAP32[$tbase$247$i + ($738 + $$sum$i21$i) >> 2] = $738; //@line 8137
      break;
     }
     $$sum2$i23$i = $tsize$246$i + 4 | 0; //@line 8140
     $743 = HEAP32[$tbase$247$i + ($$sum2$i23$i + $720) >> 2] | 0; //@line 8143
     if (($743 & 3 | 0) == 1) {
      $746 = $743 & -8; //@line 8147
      $747 = $743 >>> 3; //@line 8148
      L356 : do if ($743 >>> 0 < 256) {
       $750 = HEAP32[$tbase$247$i + (($720 | 8) + $tsize$246$i) >> 2] | 0; //@line 8155
       $752 = HEAP32[$tbase$247$i + ($tsize$246$i + 12 + $720) >> 2] | 0; //@line 8159
       $754 = 12040 + ($747 << 1 << 2) | 0; //@line 8161
       do if (($750 | 0) != ($754 | 0)) {
        if ($750 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8168
        if ((HEAP32[$750 + 12 >> 2] | 0) == ($721 | 0)) break;
        _abort(); //@line 8177
       } while (0);
       if (($752 | 0) == ($750 | 0)) {
        HEAP32[3e3] = HEAP32[3e3] & ~(1 << $747); //@line 8187
        break;
       }
       do if (($752 | 0) == ($754 | 0)) $$pre$phi58$i$iZ2D = $752 + 8 | 0; //@line 8194
 else {
        if ($752 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8199
        $769 = $752 + 8 | 0; //@line 8202
        if ((HEAP32[$769 >> 2] | 0) == ($721 | 0)) {
         $$pre$phi58$i$iZ2D = $769; //@line 8206
         break;
        }
        _abort(); //@line 8209
       } while (0);
       HEAP32[$750 + 12 >> 2] = $752; //@line 8214
       HEAP32[$$pre$phi58$i$iZ2D >> 2] = $750; //@line 8215
      } else {
       $774 = HEAP32[$tbase$247$i + (($720 | 24) + $tsize$246$i) >> 2] | 0; //@line 8220
       $776 = HEAP32[$tbase$247$i + ($tsize$246$i + 12 + $720) >> 2] | 0; //@line 8224
       do if (($776 | 0) == ($721 | 0)) {
        $$sum67$i$i = $720 | 16; //@line 8228
        $788 = $tbase$247$i + ($$sum2$i23$i + $$sum67$i$i) | 0; //@line 8230
        $789 = HEAP32[$788 >> 2] | 0; //@line 8231
        if (!$789) {
         $791 = $tbase$247$i + ($$sum67$i$i + $tsize$246$i) | 0; //@line 8235
         $792 = HEAP32[$791 >> 2] | 0; //@line 8236
         if (!$792) {
          $R$1$i$i = 0; //@line 8239
          break;
         } else {
          $R$0$i$i = $792; //@line 8242
          $RP$0$i$i = $791; //@line 8242
         }
        } else {
         $R$0$i$i = $789; //@line 8245
         $RP$0$i$i = $788; //@line 8245
        }
        while (1) {
         $794 = $R$0$i$i + 20 | 0; //@line 8248
         $795 = HEAP32[$794 >> 2] | 0; //@line 8249
         if ($795) {
          $R$0$i$i = $795; //@line 8252
          $RP$0$i$i = $794; //@line 8252
          continue;
         }
         $797 = $R$0$i$i + 16 | 0; //@line 8255
         $798 = HEAP32[$797 >> 2] | 0; //@line 8256
         if (!$798) break; else {
          $R$0$i$i = $798; //@line 8261
          $RP$0$i$i = $797; //@line 8261
         }
        }
        if ($RP$0$i$i >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8267
 else {
         HEAP32[$RP$0$i$i >> 2] = 0; //@line 8270
         $R$1$i$i = $R$0$i$i; //@line 8271
         break;
        }
       } else {
        $779 = HEAP32[$tbase$247$i + (($720 | 8) + $tsize$246$i) >> 2] | 0; //@line 8278
        if ($779 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8282
        $782 = $779 + 12 | 0; //@line 8285
        if ((HEAP32[$782 >> 2] | 0) != ($721 | 0)) _abort(); //@line 8289
        $785 = $776 + 8 | 0; //@line 8292
        if ((HEAP32[$785 >> 2] | 0) == ($721 | 0)) {
         HEAP32[$782 >> 2] = $776; //@line 8296
         HEAP32[$785 >> 2] = $779; //@line 8297
         $R$1$i$i = $776; //@line 8298
         break;
        } else _abort(); //@line 8301
       } while (0);
       if (!$774) break;
       $804 = HEAP32[$tbase$247$i + ($tsize$246$i + 28 + $720) >> 2] | 0; //@line 8313
       $805 = 12304 + ($804 << 2) | 0; //@line 8314
       do if (($721 | 0) == (HEAP32[$805 >> 2] | 0)) {
        HEAP32[$805 >> 2] = $R$1$i$i; //@line 8319
        if ($R$1$i$i) break;
        HEAP32[3001] = HEAP32[3001] & ~(1 << $804); //@line 8328
        break L356;
       } else {
        if ($774 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8334
        $814 = $774 + 16 | 0; //@line 8337
        if ((HEAP32[$814 >> 2] | 0) == ($721 | 0)) HEAP32[$814 >> 2] = $R$1$i$i; //@line 8341
 else HEAP32[$774 + 20 >> 2] = $R$1$i$i; //@line 8344
        if (!$R$1$i$i) break L356;
       } while (0);
       if ($R$1$i$i >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8355
       HEAP32[$R$1$i$i + 24 >> 2] = $774; //@line 8359
       $$sum3132$i$i = $720 | 16; //@line 8360
       $823 = HEAP32[$tbase$247$i + ($$sum3132$i$i + $tsize$246$i) >> 2] | 0; //@line 8363
       do if ($823) if ($823 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8370
 else {
        HEAP32[$R$1$i$i + 16 >> 2] = $823; //@line 8374
        HEAP32[$823 + 24 >> 2] = $R$1$i$i; //@line 8376
        break;
       } while (0);
       $830 = HEAP32[$tbase$247$i + ($$sum2$i23$i + $$sum3132$i$i) >> 2] | 0; //@line 8383
       if (!$830) break;
       if ($830 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8391
 else {
        HEAP32[$R$1$i$i + 20 >> 2] = $830; //@line 8395
        HEAP32[$830 + 24 >> 2] = $R$1$i$i; //@line 8397
        break;
       }
      } while (0);
      $oldfirst$0$i$i = $tbase$247$i + (($746 | $720) + $tsize$246$i) | 0; //@line 8406
      $qsize$0$i$i = $746 + $726 | 0; //@line 8406
     } else {
      $oldfirst$0$i$i = $721; //@line 8408
      $qsize$0$i$i = $726; //@line 8408
     }
     $838 = $oldfirst$0$i$i + 4 | 0; //@line 8410
     HEAP32[$838 >> 2] = HEAP32[$838 >> 2] & -2; //@line 8413
     HEAP32[$tbase$247$i + ($$sum$i21$i + 4) >> 2] = $qsize$0$i$i | 1; //@line 8417
     HEAP32[$tbase$247$i + ($qsize$0$i$i + $$sum$i21$i) >> 2] = $qsize$0$i$i; //@line 8420
     $844 = $qsize$0$i$i >>> 3; //@line 8421
     if ($qsize$0$i$i >>> 0 < 256) {
      $846 = $844 << 1; //@line 8424
      $847 = 12040 + ($846 << 2) | 0; //@line 8425
      $848 = HEAP32[3e3] | 0; //@line 8426
      $849 = 1 << $844; //@line 8427
      do if (!($848 & $849)) {
       HEAP32[3e3] = $848 | $849; //@line 8433
       $$pre$phi$i26$iZ2D = 12040 + ($846 + 2 << 2) | 0; //@line 8436
       $F4$0$i$i = $847; //@line 8436
      } else {
       $853 = 12040 + ($846 + 2 << 2) | 0; //@line 8439
       $854 = HEAP32[$853 >> 2] | 0; //@line 8440
       if ($854 >>> 0 >= (HEAP32[3004] | 0) >>> 0) {
        $$pre$phi$i26$iZ2D = $853; //@line 8444
        $F4$0$i$i = $854; //@line 8444
        break;
       }
       _abort(); //@line 8447
      } while (0);
      HEAP32[$$pre$phi$i26$iZ2D >> 2] = $725; //@line 8451
      HEAP32[$F4$0$i$i + 12 >> 2] = $725; //@line 8453
      HEAP32[$tbase$247$i + ($$sum$i21$i + 8) >> 2] = $F4$0$i$i; //@line 8456
      HEAP32[$tbase$247$i + ($$sum$i21$i + 12) >> 2] = $847; //@line 8459
      break;
     }
     $860 = $qsize$0$i$i >>> 8; //@line 8462
     do if (!$860) $I7$0$i$i = 0; //@line 8466
 else {
      if ($qsize$0$i$i >>> 0 > 16777215) {
       $I7$0$i$i = 31; //@line 8470
       break;
      }
      $865 = ($860 + 1048320 | 0) >>> 16 & 8; //@line 8475
      $866 = $860 << $865; //@line 8476
      $869 = ($866 + 520192 | 0) >>> 16 & 4; //@line 8479
      $871 = $866 << $869; //@line 8481
      $874 = ($871 + 245760 | 0) >>> 16 & 2; //@line 8484
      $879 = 14 - ($869 | $865 | $874) + ($871 << $874 >>> 15) | 0; //@line 8489
      $I7$0$i$i = $qsize$0$i$i >>> ($879 + 7 | 0) & 1 | $879 << 1; //@line 8495
     } while (0);
     $885 = 12304 + ($I7$0$i$i << 2) | 0; //@line 8498
     HEAP32[$tbase$247$i + ($$sum$i21$i + 28) >> 2] = $I7$0$i$i; //@line 8501
     HEAP32[$tbase$247$i + ($$sum$i21$i + 20) >> 2] = 0; //@line 8506
     HEAP32[$tbase$247$i + ($$sum$i21$i + 16) >> 2] = 0; //@line 8507
     $889 = HEAP32[3001] | 0; //@line 8508
     $890 = 1 << $I7$0$i$i; //@line 8509
     if (!($889 & $890)) {
      HEAP32[3001] = $889 | $890; //@line 8514
      HEAP32[$885 >> 2] = $725; //@line 8515
      HEAP32[$tbase$247$i + ($$sum$i21$i + 24) >> 2] = $885; //@line 8518
      HEAP32[$tbase$247$i + ($$sum$i21$i + 12) >> 2] = $725; //@line 8521
      HEAP32[$tbase$247$i + ($$sum$i21$i + 8) >> 2] = $725; //@line 8524
      break;
     }
     $897 = HEAP32[$885 >> 2] | 0; //@line 8527
     if (($I7$0$i$i | 0) == 31) $906 = 0; //@line 8530
 else $906 = 25 - ($I7$0$i$i >>> 1) | 0; //@line 8534
     L445 : do if ((HEAP32[$897 + 4 >> 2] & -8 | 0) == ($qsize$0$i$i | 0)) $T$0$lcssa$i28$i = $897; //@line 8542
 else {
      $K8$052$i$i = $qsize$0$i$i << $906; //@line 8545
      $T$051$i$i = $897; //@line 8545
      while (1) {
       $914 = $T$051$i$i + ($K8$052$i$i >>> 31 << 2) + 16 | 0; //@line 8548
       $909 = HEAP32[$914 >> 2] | 0; //@line 8549
       if (!$909) break;
       if ((HEAP32[$909 + 4 >> 2] & -8 | 0) == ($qsize$0$i$i | 0)) {
        $T$0$lcssa$i28$i = $909; //@line 8560
        break L445;
       } else {
        $K8$052$i$i = $K8$052$i$i << 1; //@line 8563
        $T$051$i$i = $909; //@line 8563
       }
      }
      if ($914 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8569
 else {
       HEAP32[$914 >> 2] = $725; //@line 8572
       HEAP32[$tbase$247$i + ($$sum$i21$i + 24) >> 2] = $T$051$i$i; //@line 8575
       HEAP32[$tbase$247$i + ($$sum$i21$i + 12) >> 2] = $725; //@line 8578
       HEAP32[$tbase$247$i + ($$sum$i21$i + 8) >> 2] = $725; //@line 8581
       break L348;
      }
     } while (0);
     $921 = $T$0$lcssa$i28$i + 8 | 0; //@line 8586
     $922 = HEAP32[$921 >> 2] | 0; //@line 8587
     $923 = HEAP32[3004] | 0; //@line 8588
     if ($T$0$lcssa$i28$i >>> 0 < $923 >>> 0) _abort(); //@line 8591
     if ($922 >>> 0 < $923 >>> 0) _abort(); //@line 8596
 else {
      HEAP32[$922 + 12 >> 2] = $725; //@line 8600
      HEAP32[$921 >> 2] = $725; //@line 8601
      HEAP32[$tbase$247$i + ($$sum$i21$i + 8) >> 2] = $922; //@line 8604
      HEAP32[$tbase$247$i + ($$sum$i21$i + 12) >> 2] = $T$0$lcssa$i28$i; //@line 8607
      HEAP32[$tbase$247$i + ($$sum$i21$i + 24) >> 2] = 0; //@line 8610
      break;
     }
    } while (0);
    $mem$0 = $tbase$247$i + ($713 | 8) | 0; //@line 8617
    STACKTOP = sp; //@line 8618
    return $mem$0 | 0; //@line 8618
   }
   $sp$0$i$i$i = 12448 | 0; //@line 8621
   while (1) {
    $931 = HEAP32[$sp$0$i$i$i >> 2] | 0; //@line 8623
    if ($931 >>> 0 <= $636 >>> 0) {
     $934 = HEAP32[$sp$0$i$i$i + 4 >> 2] | 0; //@line 8627
     $935 = $931 + $934 | 0; //@line 8628
     if ($935 >>> 0 > $636 >>> 0) break;
    }
    $sp$0$i$i$i = HEAP32[$sp$0$i$i$i + 8 >> 2] | 0; //@line 8636
   }
   $940 = $931 + ($934 + -39) | 0; //@line 8641
   if (!($940 & 7)) $945 = 0; //@line 8645
 else $945 = 0 - $940 & 7; //@line 8649
   $946 = $931 + ($934 + -47 + $945) | 0; //@line 8652
   $949 = $946 >>> 0 < ($636 + 16 | 0) >>> 0 ? $636 : $946; //@line 8655
   $950 = $949 + 8 | 0; //@line 8656
   $953 = $tbase$247$i + 8 | 0; //@line 8659
   if (!($953 & 7)) $959 = 0; //@line 8663
 else $959 = 0 - $953 & 7; //@line 8667
   $960 = $tsize$246$i + -40 - $959 | 0; //@line 8670
   HEAP32[3006] = $tbase$247$i + $959; //@line 8671
   HEAP32[3003] = $960; //@line 8672
   HEAP32[$tbase$247$i + ($959 + 4) >> 2] = $960 | 1; //@line 8676
   HEAP32[$tbase$247$i + ($tsize$246$i + -36) >> 2] = 40; //@line 8679
   HEAP32[3007] = HEAP32[3122]; //@line 8681
   HEAP32[$949 + 4 >> 2] = 27; //@line 8683
   HEAP32[$950 + 0 >> 2] = HEAP32[3112]; //@line 8684
   HEAP32[$950 + 4 >> 2] = HEAP32[3113]; //@line 8684
   HEAP32[$950 + 8 >> 2] = HEAP32[3114]; //@line 8684
   HEAP32[$950 + 12 >> 2] = HEAP32[3115]; //@line 8684
   HEAP32[3112] = $tbase$247$i; //@line 8685
   HEAP32[3113] = $tsize$246$i; //@line 8686
   HEAP32[3115] = 0; //@line 8687
   HEAP32[3114] = $950; //@line 8688
   $966 = $949 + 28 | 0; //@line 8689
   HEAP32[$966 >> 2] = 7; //@line 8690
   if (($949 + 32 | 0) >>> 0 < $935 >>> 0) {
    $970 = $966; //@line 8694
    do {
     $970$looptemp = $970;
     $970 = $970 + 4 | 0; //@line 8696
     HEAP32[$970 >> 2] = 7; //@line 8697
    } while (($970$looptemp + 8 | 0) >>> 0 < $935 >>> 0);
   }
   if (($949 | 0) != ($636 | 0)) {
    $976 = $949 - $636 | 0; //@line 8711
    $978 = $636 + ($976 + 4) | 0; //@line 8714
    HEAP32[$978 >> 2] = HEAP32[$978 >> 2] & -2; //@line 8717
    HEAP32[$636 + 4 >> 2] = $976 | 1; //@line 8720
    HEAP32[$636 + $976 >> 2] = $976; //@line 8721
    $983 = $976 >>> 3; //@line 8722
    if ($976 >>> 0 < 256) {
     $985 = $983 << 1; //@line 8725
     $986 = 12040 + ($985 << 2) | 0; //@line 8726
     $987 = HEAP32[3e3] | 0; //@line 8727
     $988 = 1 << $983; //@line 8728
     do if (!($987 & $988)) {
      HEAP32[3e3] = $987 | $988; //@line 8734
      $$pre$phi$i$iZ2D = 12040 + ($985 + 2 << 2) | 0; //@line 8737
      $F$0$i$i = $986; //@line 8737
     } else {
      $992 = 12040 + ($985 + 2 << 2) | 0; //@line 8740
      $993 = HEAP32[$992 >> 2] | 0; //@line 8741
      if ($993 >>> 0 >= (HEAP32[3004] | 0) >>> 0) {
       $$pre$phi$i$iZ2D = $992; //@line 8745
       $F$0$i$i = $993; //@line 8745
       break;
      }
      _abort(); //@line 8748
     } while (0);
     HEAP32[$$pre$phi$i$iZ2D >> 2] = $636; //@line 8752
     HEAP32[$F$0$i$i + 12 >> 2] = $636; //@line 8754
     HEAP32[$636 + 8 >> 2] = $F$0$i$i; //@line 8756
     HEAP32[$636 + 12 >> 2] = $986; //@line 8758
     break;
    }
    $999 = $976 >>> 8; //@line 8761
    if (!$999) $I1$0$i$i = 0; //@line 8764
 else if ($976 >>> 0 > 16777215) $I1$0$i$i = 31; //@line 8768
 else {
     $1004 = ($999 + 1048320 | 0) >>> 16 & 8; //@line 8772
     $1005 = $999 << $1004; //@line 8773
     $1008 = ($1005 + 520192 | 0) >>> 16 & 4; //@line 8776
     $1010 = $1005 << $1008; //@line 8778
     $1013 = ($1010 + 245760 | 0) >>> 16 & 2; //@line 8781
     $1018 = 14 - ($1008 | $1004 | $1013) + ($1010 << $1013 >>> 15) | 0; //@line 8786
     $I1$0$i$i = $976 >>> ($1018 + 7 | 0) & 1 | $1018 << 1; //@line 8792
    }
    $1024 = 12304 + ($I1$0$i$i << 2) | 0; //@line 8795
    HEAP32[$636 + 28 >> 2] = $I1$0$i$i; //@line 8798
    HEAP32[$636 + 20 >> 2] = 0; //@line 8800
    HEAP32[$636 + 16 >> 2] = 0; //@line 8802
    $1028 = HEAP32[3001] | 0; //@line 8803
    $1029 = 1 << $I1$0$i$i; //@line 8804
    if (!($1028 & $1029)) {
     HEAP32[3001] = $1028 | $1029; //@line 8809
     HEAP32[$1024 >> 2] = $636; //@line 8810
     HEAP32[$636 + 24 >> 2] = $1024; //@line 8812
     HEAP32[$636 + 12 >> 2] = $636; //@line 8814
     HEAP32[$636 + 8 >> 2] = $636; //@line 8816
     break;
    }
    $1036 = HEAP32[$1024 >> 2] | 0; //@line 8819
    if (($I1$0$i$i | 0) == 31) $1045 = 0; //@line 8822
 else $1045 = 25 - ($I1$0$i$i >>> 1) | 0; //@line 8826
    L499 : do if ((HEAP32[$1036 + 4 >> 2] & -8 | 0) == ($976 | 0)) $T$0$lcssa$i$i = $1036; //@line 8834
 else {
     $K2$014$i$i = $976 << $1045; //@line 8837
     $T$013$i$i = $1036; //@line 8837
     while (1) {
      $1053 = $T$013$i$i + ($K2$014$i$i >>> 31 << 2) + 16 | 0; //@line 8840
      $1048 = HEAP32[$1053 >> 2] | 0; //@line 8841
      if (!$1048) break;
      if ((HEAP32[$1048 + 4 >> 2] & -8 | 0) == ($976 | 0)) {
       $T$0$lcssa$i$i = $1048; //@line 8852
       break L499;
      } else {
       $K2$014$i$i = $K2$014$i$i << 1; //@line 8855
       $T$013$i$i = $1048; //@line 8855
      }
     }
     if ($1053 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 8861
 else {
      HEAP32[$1053 >> 2] = $636; //@line 8864
      HEAP32[$636 + 24 >> 2] = $T$013$i$i; //@line 8866
      HEAP32[$636 + 12 >> 2] = $636; //@line 8868
      HEAP32[$636 + 8 >> 2] = $636; //@line 8870
      break L311;
     }
    } while (0);
    $1060 = $T$0$lcssa$i$i + 8 | 0; //@line 8875
    $1061 = HEAP32[$1060 >> 2] | 0; //@line 8876
    $1062 = HEAP32[3004] | 0; //@line 8877
    if ($T$0$lcssa$i$i >>> 0 < $1062 >>> 0) _abort(); //@line 8880
    if ($1061 >>> 0 < $1062 >>> 0) _abort(); //@line 8885
 else {
     HEAP32[$1061 + 12 >> 2] = $636; //@line 8889
     HEAP32[$1060 >> 2] = $636; //@line 8890
     HEAP32[$636 + 8 >> 2] = $1061; //@line 8892
     HEAP32[$636 + 12 >> 2] = $T$0$lcssa$i$i; //@line 8894
     HEAP32[$636 + 24 >> 2] = 0; //@line 8896
     break;
    }
   }
  } while (0);
  $1069 = HEAP32[3003] | 0; //@line 8902
  if ($1069 >>> 0 > $nb$0 >>> 0) {
   $1071 = $1069 - $nb$0 | 0; //@line 8905
   HEAP32[3003] = $1071; //@line 8906
   $1072 = HEAP32[3006] | 0; //@line 8907
   HEAP32[3006] = $1072 + $nb$0; //@line 8909
   HEAP32[$1072 + ($nb$0 + 4) >> 2] = $1071 | 1; //@line 8913
   HEAP32[$1072 + 4 >> 2] = $nb$0 | 3; //@line 8916
   $mem$0 = $1072 + 8 | 0; //@line 8918
   STACKTOP = sp; //@line 8919
   return $mem$0 | 0; //@line 8919
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12; //@line 8923
 $mem$0 = 0; //@line 8924
 STACKTOP = sp; //@line 8925
 return $mem$0 | 0; //@line 8925
}
function ___floatscan($f, $prec, $pok) {
 $f = $f | 0;
 $prec = $prec | 0;
 $pok = $pok | 0;
 var $$0 = 0.0, $$02$i = 0, $$08$i = 0, $$09$i = 0, $$1$be$i = 0, $$1$ph$i = 0, $$14$i = 0, $$2$i = 0, $$3$be$i = 0, $$3$lcssa$i = 0, $$388$i = 0, $$397$i = 0, $$in = 0, $$lcssa43$i = 0, $$pn$i = 0.0, $$pre$i17 = 0, $$pre$phi$iZ2D = 0.0, $$sink$off0$us$i = 0, $$sink$off0$us53$i = 0, $0 = 0, $1 = 0, $114 = 0, $122 = 0, $124 = 0, $131 = 0, $138 = 0, $146 = 0, $15 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $159 = 0, $16 = 0, $161 = 0, $164 = 0, $169 = 0, $172 = 0, $183 = 0.0, $190 = 0, $192 = 0, $2 = 0, $201 = 0, $204 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $220 = 0, $221 = 0, $222 = 0, $232 = 0, $233 = 0, $245 = 0, $247 = 0, $249 = 0, $250 = 0, $251 = 0, $252 = 0, $266 = 0, $268 = 0, $280 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $29 = 0, $290 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $305 = 0.0, $306 = 0.0, $309 = 0, $317 = 0.0, $325 = 0, $326 = 0, $333 = 0, $341 = 0, $349 = 0, $350 = 0, $351 = 0, $353 = 0, $355 = 0, $356 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $364 = 0, $369 = 0, $370 = 0, $374 = 0, $384 = 0, $386 = 0, $387 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $394 = 0, $395 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $415 = 0, $42 = 0, $420 = 0, $421 = 0, $423 = 0, $424 = 0, $437 = 0, $439 = 0, $449 = 0, $451 = 0, $463 = 0, $465 = 0, $487 = 0, $499 = 0, $503 = 0, $506 = 0, $508 = 0, $509 = 0, $510 = 0, $513 = 0, $527 = 0, $530 = 0, $532 = 0, $534 = 0, $535 = 0, $541 = 0, $543 = 0, $548 = 0, $551 = 0, $556 = 0, $558 = 0, $560 = 0, $561 = 0, $567 = 0, $569 = 0, $574 = 0, $577 = 0, $581 = 0, $584 = 0, $589 = 0, $59 = 0, $594 = 0, $596 = 0, $599 = 0, $601 = 0, $605 = 0, $606 = 0, $608 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $617 = 0, $627 = 0, $632 = 0, $640 = 0.0, $642 = 0, $645 = 0, $649 = 0.0, $650 = 0.0, $653 = 0.0, $657 = 0, $66 = 0, $660 = 0, $667 = 0.0, $68 = 0, $685 = 0.0, $687 = 0, $703 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $76 = 0, $81 = 0, $89 = 0, $9 = 0, $98 = 0, $a$0$lcssa161$i = 0, $a$061$i = 0, $a$1$i = 0, $a$2$ph40$i = 0, $a$3$i = 0, $a$3$i$ph = 0, $a$3$ph$i = 0, $a$427$i = 0, $bias$0$i = 0.0, $bias$07$i = 0.0, $bits$0$ph = 0, $c$0 = 0, $c$0$i = 0, $c$1$lcssa = 0, $c$1$ph$i = 0, $c$169 = 0, $c$2 = 0, $c$2$i = 0, $c$2$lcssa$i = 0, $c$364 = 0, $c$4 = 0, $c$5 = 0, $c$6 = 0, $carry$063$i = 0, $carry1$0$us$i = 0, $carry1$0$us49$i = 0, $carry1$1$lcssa$lcssa$i = 0, $carry1$1$us$i = 0, $carry1$1$us54$i = 0, $carry3$030$i = 0, $d$0$i = 0, $denormal$0$i = 0, $denormal$2$i = 0, $e2$0$ph$i = 0, $e2$0$us$i = 0, $e2$0$us44$i = 0, $e2$1$i = 0, $e2$1$i$ph = 0, $e2$1$ph$i = 0, $e2$2$i = 0, $e2$3$i = 0, $emin$0$ph = 0, $frac$0$i = 0.0, $frac$1$i = 0.0, $frac$2$i = 0.0, $gotdig$0$i = 0, $gotdig$0$i9 = 0, $gotdig$2$i = 0, $gotdig$2$i11 = 0, $gotdig$3$i = 0, $gotdig$3$lcssa$i = 0, $gotdig$381$i = 0, $gotdig$393$i = 0, $gotdig$4$i = 0, $gotrad$0$i = 0, $gotrad$0$i12 = 0, $gotrad$1$i = 0, $gotrad$1$lcssa$i = 0, $gotrad$194$i = 0, $gotrad$2$i = 0, $gottail$0$i = 0, $gottail$1$i = 0, $gottail$2$i = 0, $i$0$lcssa = 0, $i$025$i = 0, $i$068 = 0, $i$1$i = 0, $i$166 = 0, $i$263 = 0, $i$3 = 0, $i$4 = 0, $j$0$lcssa$i = 0, $j$086$i = 0, $j$096$i = 0, $j$2$i = 0, $j$371$i = 0, $k$0$lcssa$i = 0, $k$084$i = 0, $k$095$i = 0, $k$2$i = 0, $k$3$i = 0, $k$462$i = 0, $k$5$in$us$i = 0, $k$5$in$us48$i = 0, $k$5$us$i = 0, $k$5$us50$i = 0, $k$628$i = 0, $lnz$0$lcssa$i = 0, $lnz$079$i = 0, $lnz$092$i = 0, $lnz$2$i = 0, $or$cond15$i = 0, $rp$0$lcssa162$i = 0, $rp$060$i = 0, $rp$1$i18 = 0, $rp$2$ph38$i = 0, $rp$3$i$ph = 0, $rp$3$ph33$i = 0, $rp$426$i = 0, $scale$0$i = 0.0, $scale$1$i = 0.0, $scale$2$i = 0.0, $sign$0 = 0, $storemerge$i = 0, $sum$i = 0, $x$0$i = 0, $x$1$i = 0, $x$2$i = 0, $x$3$lcssa$i = 0, $x$313$i = 0, $x$4$lcssa$i = 0, $x$48$i = 0, $x$5$i = 0, $x$6$i = 0, $x$i = 0, $y$0$i = 0.0, $y$1$i = 0.0, $y$1$i23 = 0.0, $y$2$i = 0.0, $y$2$i24 = 0.0, $y$3$i = 0.0, $y$3$lcssa$i = 0.0, $y$39$i = 0.0, $y$4$i = 0.0, $y$5$i = 0.0, $z$0$i = 0, $z$1$ph39$i = 0, $z$1$us$i = 0, $z$1$us45$i = 0, $z$2$us$i = 0, $z$2$us47$i = 0, $z$3$lcssa$lcssa$i = 0, $z$3$us$i = 0, $z$3$us57$i = 0, $z$4$i = 0, $z$5$ph$i = 0, $z$7$1$i = 0, $z$7$i = 0, label = 0, sp = 0, $k$462$i$looptemp = 0;
 sp = STACKTOP; //@line 11150
 STACKTOP = STACKTOP + 512 | 0; //@line 11151
 $x$i = sp; //@line 11152
 if (($prec | 0) == 1) {
  $bits$0$ph = 53; //@line 11154
  $emin$0$ph = -1074; //@line 11154
 } else if (!$prec) {
  $bits$0$ph = 24; //@line 11156
  $emin$0$ph = -149; //@line 11156
 } else if (($prec | 0) == 2) {
  $bits$0$ph = 53; //@line 11158
  $emin$0$ph = -1074; //@line 11158
 } else {
  $$0 = 0.0; //@line 11160
  STACKTOP = sp; //@line 11161
  return +$$0;
 }
 $0 = $f + 4 | 0; //@line 11163
 $1 = $f + 100 | 0; //@line 11164
 do {
  $2 = HEAP32[$0 >> 2] | 0; //@line 11166
  if ($2 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
   HEAP32[$0 >> 2] = $2 + 1; //@line 11171
   $9 = HEAPU8[$2 >> 0] | 0; //@line 11174
  } else $9 = ___shgetc($f) | 0; //@line 11177
 } while ((_isspace($9) | 0) != 0);
 do if (($9 | 0) == 43 | ($9 | 0) == 45) {
  $15 = 1 - ((($9 | 0) == 45 & 1) << 1) | 0; //@line 11190
  $16 = HEAP32[$0 >> 2] | 0; //@line 11191
  if ($16 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
   HEAP32[$0 >> 2] = $16 + 1; //@line 11196
   $c$0 = HEAPU8[$16 >> 0] | 0; //@line 11199
   $sign$0 = $15; //@line 11199
   break;
  } else {
   $c$0 = ___shgetc($f) | 0; //@line 11203
   $sign$0 = $15; //@line 11203
   break;
  }
 } else {
  $c$0 = $9; //@line 11207
  $sign$0 = 1; //@line 11207
 } while (0);
 $c$169 = $c$0; //@line 11210
 $i$068 = 0; //@line 11210
 while (1) {
  if (($c$169 | 32 | 0) != (HEAP8[12496 + $i$068 >> 0] | 0)) {
   $c$1$lcssa = $c$169; //@line 11218
   $i$0$lcssa = $i$068; //@line 11218
   break;
  }
  do if ($i$068 >>> 0 < 7) {
   $29 = HEAP32[$0 >> 2] | 0; //@line 11224
   if ($29 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $29 + 1; //@line 11229
    $c$2 = HEAPU8[$29 >> 0] | 0; //@line 11232
    break;
   } else {
    $c$2 = ___shgetc($f) | 0; //@line 11236
    break;
   }
  } else $c$2 = $c$169; //@line 11240
 while (0);
  $36 = $i$068 + 1 | 0; //@line 11243
  if ($36 >>> 0 < 8) {
   $c$169 = $c$2; //@line 11246
   $i$068 = $36; //@line 11246
  } else {
   $c$1$lcssa = $c$2; //@line 11248
   $i$0$lcssa = $36; //@line 11248
   break;
  }
 }
 do if (($i$0$lcssa | 0) == 3) label = 23; //@line 11254
 else if (($i$0$lcssa | 0) != 8) {
  $39 = ($pok | 0) == 0; //@line 11257
  if (!($i$0$lcssa >>> 0 < 4 | $39)) if (($i$0$lcssa | 0) == 8) break; else {
   label = 23; //@line 11264
   break;
  }
  L34 : do if (!$i$0$lcssa) {
   $c$364 = $c$1$lcssa; //@line 11271
   $i$263 = 0; //@line 11271
   while (1) {
    if (($c$364 | 32 | 0) != (HEAP8[12512 + $i$263 >> 0] | 0)) {
     $c$5 = $c$364; //@line 11279
     $i$3 = $i$263; //@line 11279
     break L34;
    }
    do if ($i$263 >>> 0 < 2) {
     $59 = HEAP32[$0 >> 2] | 0; //@line 11285
     if ($59 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
      HEAP32[$0 >> 2] = $59 + 1; //@line 11290
      $c$4 = HEAPU8[$59 >> 0] | 0; //@line 11293
      break;
     } else {
      $c$4 = ___shgetc($f) | 0; //@line 11297
      break;
     }
    } else $c$4 = $c$364; //@line 11301
 while (0);
    $66 = $i$263 + 1 | 0; //@line 11304
    if ($66 >>> 0 < 3) {
     $c$364 = $c$4; //@line 11307
     $i$263 = $66; //@line 11307
    } else {
     $c$5 = $c$4; //@line 11309
     $i$3 = $66; //@line 11309
     break;
    }
   }
  } else {
   $c$5 = $c$1$lcssa; //@line 11314
   $i$3 = $i$0$lcssa; //@line 11314
  } while (0);
  if (!$i$3) {
   do if (($c$5 | 0) == 48) {
    $114 = HEAP32[$0 >> 2] | 0; //@line 11321
    if ($114 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $114 + 1; //@line 11326
     $122 = HEAPU8[$114 >> 0] | 0; //@line 11329
    } else $122 = ___shgetc($f) | 0; //@line 11332
    if (($122 | 32 | 0) != 120) {
     if (!(HEAP32[$1 >> 2] | 0)) {
      $c$6 = 48; //@line 11340
      break;
     }
     HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11345
     $c$6 = 48; //@line 11346
     break;
    }
    $124 = HEAP32[$0 >> 2] | 0; //@line 11349
    if ($124 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $124 + 1; //@line 11354
     $c$0$i = HEAPU8[$124 >> 0] | 0; //@line 11357
     $gotdig$0$i = 0; //@line 11357
    } else {
     $c$0$i = ___shgetc($f) | 0; //@line 11360
     $gotdig$0$i = 0; //@line 11360
    }
    while (1) {
     if (($c$0$i | 0) == 46) {
      label = 70; //@line 11364
      break;
     } else if (($c$0$i | 0) != 48) {
      $169 = 0; //@line 11367
      $172 = 0; //@line 11367
      $212 = 0; //@line 11367
      $214 = 0; //@line 11367
      $c$2$i = $c$0$i; //@line 11367
      $gotdig$2$i = $gotdig$0$i; //@line 11367
      $gotrad$0$i = 0; //@line 11367
      $gottail$0$i = 0; //@line 11367
      $scale$0$i = 1.0; //@line 11367
      $x$0$i = 0; //@line 11367
      $y$0$i = 0.0; //@line 11367
      break;
     }
     $131 = HEAP32[$0 >> 2] | 0; //@line 11370
     if ($131 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
      HEAP32[$0 >> 2] = $131 + 1; //@line 11375
      $c$0$i = HEAPU8[$131 >> 0] | 0; //@line 11378
      $gotdig$0$i = 1; //@line 11378
      continue;
     } else {
      $c$0$i = ___shgetc($f) | 0; //@line 11382
      $gotdig$0$i = 1; //@line 11382
      continue;
     }
    }
    L66 : do if ((label | 0) == 70) {
     $138 = HEAP32[$0 >> 2] | 0; //@line 11388
     if ($138 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
      HEAP32[$0 >> 2] = $138 + 1; //@line 11393
      $c$1$ph$i = HEAPU8[$138 >> 0] | 0; //@line 11396
     } else $c$1$ph$i = ___shgetc($f) | 0; //@line 11399
     if (($c$1$ph$i | 0) == 48) {
      $155 = -1; //@line 11403
      $156 = -1; //@line 11403
      while (1) {
       $146 = HEAP32[$0 >> 2] | 0; //@line 11405
       if ($146 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $146 + 1; //@line 11410
        $154 = HEAPU8[$146 >> 0] | 0; //@line 11413
       } else $154 = ___shgetc($f) | 0; //@line 11416
       if (($154 | 0) != 48) {
        $169 = 0; //@line 11420
        $172 = 0; //@line 11420
        $212 = $155; //@line 11420
        $214 = $156; //@line 11420
        $c$2$i = $154; //@line 11420
        $gotdig$2$i = 1; //@line 11420
        $gotrad$0$i = 1; //@line 11420
        $gottail$0$i = 0; //@line 11420
        $scale$0$i = 1.0; //@line 11420
        $x$0$i = 0; //@line 11420
        $y$0$i = 0.0; //@line 11420
        break L66;
       }
       $157 = _i64Add($155 | 0, $156 | 0, -1, -1) | 0; //@line 11423
       $155 = $157; //@line 11425
       $156 = tempRet0; //@line 11425
      }
     } else {
      $169 = 0; //@line 11428
      $172 = 0; //@line 11428
      $212 = 0; //@line 11428
      $214 = 0; //@line 11428
      $c$2$i = $c$1$ph$i; //@line 11428
      $gotdig$2$i = $gotdig$0$i; //@line 11428
      $gotrad$0$i = 1; //@line 11428
      $gottail$0$i = 0; //@line 11428
      $scale$0$i = 1.0; //@line 11428
      $x$0$i = 0; //@line 11428
      $y$0$i = 0.0; //@line 11428
     }
    } while (0);
    L79 : while (1) {
     $159 = $c$2$i + -48 | 0; //@line 11433
     do if ($159 >>> 0 < 10) {
      $d$0$i = $159; //@line 11437
      label = 84; //@line 11438
     } else {
      $161 = $c$2$i | 32; //@line 11440
      $164 = ($c$2$i | 0) == 46; //@line 11443
      if (!(($161 + -97 | 0) >>> 0 < 6 | $164)) {
       $c$2$lcssa$i = $c$2$i; //@line 11446
       break L79;
      }
      if ($164) if (!$gotrad$0$i) {
       $712 = $172; //@line 11452
       $713 = $169; //@line 11452
       $714 = $172; //@line 11452
       $715 = $169; //@line 11452
       $gotdig$3$i = $gotdig$2$i; //@line 11452
       $gotrad$1$i = 1; //@line 11452
       $gottail$2$i = $gottail$0$i; //@line 11452
       $scale$2$i = $scale$0$i; //@line 11452
       $x$2$i = $x$0$i; //@line 11452
       $y$2$i = $y$0$i; //@line 11452
       break;
      } else {
       $c$2$lcssa$i = 46; //@line 11455
       break L79;
      } else {
       $d$0$i = ($c$2$i | 0) > 57 ? $161 + -87 | 0 : $159; //@line 11462
       label = 84; //@line 11463
       break;
      }
     } while (0);
     if ((label | 0) == 84) {
      label = 0; //@line 11469
      do if (($169 | 0) < 0 | ($169 | 0) == 0 & $172 >>> 0 < 8) {
       $gottail$1$i = $gottail$0$i; //@line 11479
       $scale$1$i = $scale$0$i; //@line 11479
       $x$1$i = $d$0$i + ($x$0$i << 4) | 0; //@line 11479
       $y$1$i = $y$0$i; //@line 11479
      } else {
       if (($169 | 0) < 0 | ($169 | 0) == 0 & $172 >>> 0 < 14) {
        $183 = $scale$0$i * .0625; //@line 11488
        $gottail$1$i = $gottail$0$i; //@line 11491
        $scale$1$i = $183; //@line 11491
        $x$1$i = $x$0$i; //@line 11491
        $y$1$i = $y$0$i + $183 * +($d$0$i | 0); //@line 11491
        break;
       }
       if (($d$0$i | 0) != 0 & ($gottail$0$i | 0) == 0) {
        $gottail$1$i = 1; //@line 11500
        $scale$1$i = $scale$0$i; //@line 11500
        $x$1$i = $x$0$i; //@line 11500
        $y$1$i = $y$0$i + $scale$0$i * .5; //@line 11500
       } else {
        $gottail$1$i = $gottail$0$i; //@line 11502
        $scale$1$i = $scale$0$i; //@line 11502
        $x$1$i = $x$0$i; //@line 11502
        $y$1$i = $y$0$i; //@line 11502
       }
      } while (0);
      $190 = _i64Add($172 | 0, $169 | 0, 1, 0) | 0; //@line 11506
      $712 = $212; //@line 11508
      $713 = $214; //@line 11508
      $714 = $190; //@line 11508
      $715 = tempRet0; //@line 11508
      $gotdig$3$i = 1; //@line 11508
      $gotrad$1$i = $gotrad$0$i; //@line 11508
      $gottail$2$i = $gottail$1$i; //@line 11508
      $scale$2$i = $scale$1$i; //@line 11508
      $x$2$i = $x$1$i; //@line 11508
      $y$2$i = $y$1$i; //@line 11508
     }
     $192 = HEAP32[$0 >> 2] | 0; //@line 11510
     if ($192 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
      HEAP32[$0 >> 2] = $192 + 1; //@line 11515
      $169 = $715; //@line 11518
      $172 = $714; //@line 11518
      $212 = $712; //@line 11518
      $214 = $713; //@line 11518
      $c$2$i = HEAPU8[$192 >> 0] | 0; //@line 11518
      $gotdig$2$i = $gotdig$3$i; //@line 11518
      $gotrad$0$i = $gotrad$1$i; //@line 11518
      $gottail$0$i = $gottail$2$i; //@line 11518
      $scale$0$i = $scale$2$i; //@line 11518
      $x$0$i = $x$2$i; //@line 11518
      $y$0$i = $y$2$i; //@line 11518
      continue;
     } else {
      $169 = $715; //@line 11522
      $172 = $714; //@line 11522
      $212 = $712; //@line 11522
      $214 = $713; //@line 11522
      $c$2$i = ___shgetc($f) | 0; //@line 11522
      $gotdig$2$i = $gotdig$3$i; //@line 11522
      $gotrad$0$i = $gotrad$1$i; //@line 11522
      $gottail$0$i = $gottail$2$i; //@line 11522
      $scale$0$i = $scale$2$i; //@line 11522
      $x$0$i = $x$2$i; //@line 11522
      $y$0$i = $y$2$i; //@line 11522
      continue;
     }
    }
    if (!$gotdig$2$i) {
     $201 = (HEAP32[$1 >> 2] | 0) == 0; //@line 11529
     if (!$201) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11533
     if ($39) ___shlim($f, 0); //@line 11536
 else if (!$201) {
      $204 = HEAP32[$0 >> 2] | 0; //@line 11539
      HEAP32[$0 >> 2] = $204 + -1; //@line 11541
      if ($gotrad$0$i) HEAP32[$0 >> 2] = $204 + -2; //@line 11545
     }
     $$0 = +($sign$0 | 0) * 0.0; //@line 11551
     STACKTOP = sp; //@line 11552
     return +$$0;
    }
    $210 = ($gotrad$0$i | 0) == 0; //@line 11554
    $211 = $210 ? $172 : $212; //@line 11555
    $213 = $210 ? $169 : $214; //@line 11556
    if (($169 | 0) < 0 | ($169 | 0) == 0 & $172 >>> 0 < 8) {
     $221 = $172; //@line 11563
     $222 = $169; //@line 11563
     $x$313$i = $x$0$i; //@line 11563
     while (1) {
      $220 = $x$313$i << 4; //@line 11565
      $221 = _i64Add($221 | 0, $222 | 0, 1, 0) | 0; //@line 11566
      $222 = tempRet0; //@line 11567
      if (!(($222 | 0) < 0 | ($222 | 0) == 0 & $221 >>> 0 < 8)) {
       $x$3$lcssa$i = $220; //@line 11576
       break;
      } else $x$313$i = $220; //@line 11574
     }
    } else $x$3$lcssa$i = $x$0$i; //@line 11581
    do if (($c$2$lcssa$i | 32 | 0) == 112) {
     $232 = _scanexp($f, $pok) | 0; //@line 11587
     $233 = tempRet0; //@line 11588
     if (($232 | 0) == 0 & ($233 | 0) == -2147483648) if ($39) {
      ___shlim($f, 0); //@line 11594
      $$0 = 0.0; //@line 11595
      STACKTOP = sp; //@line 11596
      return +$$0;
     } else {
      if (!(HEAP32[$1 >> 2] | 0)) {
       $249 = 0; //@line 11601
       $250 = 0; //@line 11601
       break;
      }
      HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11606
      $249 = 0; //@line 11607
      $250 = 0; //@line 11607
      break;
     } else {
      $249 = $232; //@line 11611
      $250 = $233; //@line 11611
     }
    } else if (!(HEAP32[$1 >> 2] | 0)) {
     $249 = 0; //@line 11617
     $250 = 0; //@line 11617
    } else {
     HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11621
     $249 = 0; //@line 11622
     $250 = 0; //@line 11622
    } while (0);
    $245 = _bitshift64Shl($211 | 0, $213 | 0, 2) | 0; //@line 11626
    $247 = _i64Add($245 | 0, tempRet0 | 0, -32, -1) | 0; //@line 11628
    $251 = _i64Add($247 | 0, tempRet0 | 0, $249 | 0, $250 | 0) | 0; //@line 11630
    $252 = tempRet0; //@line 11631
    if (!$x$3$lcssa$i) {
     $$0 = +($sign$0 | 0) * 0.0; //@line 11636
     STACKTOP = sp; //@line 11637
     return +$$0;
    }
    if (($252 | 0) > 0 | ($252 | 0) == 0 & $251 >>> 0 > (0 - $emin$0$ph | 0) >>> 0) {
     HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 11647
     $$0 = +($sign$0 | 0) * 1.7976931348623157e+308 * 1.7976931348623157e+308; //@line 11651
     STACKTOP = sp; //@line 11652
     return +$$0;
    }
    $266 = $emin$0$ph + -106 | 0; //@line 11654
    $268 = (($266 | 0) < 0) << 31 >> 31; //@line 11656
    if (($252 | 0) < ($268 | 0) | ($252 | 0) == ($268 | 0) & $251 >>> 0 < $266 >>> 0) {
     HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 11664
     $$0 = +($sign$0 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308; //@line 11668
     STACKTOP = sp; //@line 11669
     return +$$0;
    }
    if (($x$3$lcssa$i | 0) > -1) {
     $283 = $251; //@line 11673
     $284 = $252; //@line 11673
     $x$48$i = $x$3$lcssa$i; //@line 11673
     $y$39$i = $y$0$i; //@line 11673
     while (1) {
      $280 = $x$48$i << 1; //@line 11676
      if (!($y$39$i >= .5)) {
       $$pn$i = $y$39$i; //@line 11678
       $x$5$i = $280; //@line 11678
      } else {
       $$pn$i = $y$39$i + -1.0; //@line 11682
       $x$5$i = $280 | 1; //@line 11682
      }
      $y$4$i = $y$39$i + $$pn$i; //@line 11684
      $285 = _i64Add($283 | 0, $284 | 0, -1, -1) | 0; //@line 11685
      $286 = tempRet0; //@line 11686
      if (($x$5$i | 0) > -1) {
       $283 = $285; //@line 11689
       $284 = $286; //@line 11689
       $x$48$i = $x$5$i; //@line 11689
       $y$39$i = $y$4$i; //@line 11689
      } else {
       $292 = $285; //@line 11691
       $293 = $286; //@line 11691
       $x$4$lcssa$i = $x$5$i; //@line 11691
       $y$3$lcssa$i = $y$4$i; //@line 11691
       break;
      }
     }
    } else {
     $292 = $251; //@line 11696
     $293 = $252; //@line 11696
     $x$4$lcssa$i = $x$3$lcssa$i; //@line 11696
     $y$3$lcssa$i = $y$0$i; //@line 11696
    }
    $290 = _i64Subtract(32, 0, $emin$0$ph | 0, (($emin$0$ph | 0) < 0) << 31 >> 31 | 0) | 0; //@line 11700
    $294 = _i64Add($292 | 0, $293 | 0, $290 | 0, tempRet0 | 0) | 0; //@line 11702
    $295 = tempRet0; //@line 11703
    if (0 > ($295 | 0) | 0 == ($295 | 0) & $bits$0$ph >>> 0 > $294 >>> 0) $$02$i = ($294 | 0) < 0 ? 0 : $294; //@line 11712
 else $$02$i = $bits$0$ph; //@line 11714
    do if (($$02$i | 0) < 53) {
     $305 = +($sign$0 | 0); //@line 11721
     $306 = +_copysignl(+(+_scalbn(1.0, 84 - $$02$i | 0)), +$305); //@line 11722
     if (!(($$02$i | 0) < 32 & $y$3$lcssa$i != 0.0)) {
      $$pre$phi$iZ2D = $305; //@line 11727
      $bias$07$i = $306; //@line 11727
      $x$6$i = $x$4$lcssa$i; //@line 11727
      $y$5$i = $y$3$lcssa$i; //@line 11727
      break;
     }
     $309 = $x$4$lcssa$i & 1; //@line 11730
     $$pre$phi$iZ2D = $305; //@line 11735
     $bias$07$i = $306; //@line 11735
     $x$6$i = ($309 ^ 1) + $x$4$lcssa$i | 0; //@line 11735
     $y$5$i = ($309 | 0) == 0 ? 0.0 : $y$3$lcssa$i; //@line 11735
    } else {
     $$pre$phi$iZ2D = +($sign$0 | 0); //@line 11738
     $bias$07$i = 0.0; //@line 11738
     $x$6$i = $x$4$lcssa$i; //@line 11738
     $y$5$i = $y$3$lcssa$i; //@line 11738
    } while (0);
    $317 = $$pre$phi$iZ2D * $y$5$i + ($bias$07$i + $$pre$phi$iZ2D * +($x$6$i >>> 0)) - $bias$07$i; //@line 11746
    if (!($317 != 0.0)) HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 11750
    $$0 = +_scalbnl($317, $292); //@line 11753
    STACKTOP = sp; //@line 11754
    return +$$0;
   } else $c$6 = $c$5; //@line 11756
 while (0);
   $sum$i = $emin$0$ph + $bits$0$ph | 0; //@line 11759
   $325 = 0 - $sum$i | 0; //@line 11760
   $$08$i = $c$6; //@line 11761
   $gotdig$0$i9 = 0; //@line 11761
   while (1) {
    if (($$08$i | 0) == 46) {
     label = 139; //@line 11764
     break;
    } else if (($$08$i | 0) != 48) {
     $$2$i = $$08$i; //@line 11767
     $716 = 0; //@line 11767
     $717 = 0; //@line 11767
     $gotdig$2$i11 = $gotdig$0$i9; //@line 11767
     $gotrad$0$i12 = 0; //@line 11767
     break;
    }
    $326 = HEAP32[$0 >> 2] | 0; //@line 11770
    if ($326 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $326 + 1; //@line 11775
     $$08$i = HEAPU8[$326 >> 0] | 0; //@line 11778
     $gotdig$0$i9 = 1; //@line 11778
     continue;
    } else {
     $$08$i = ___shgetc($f) | 0; //@line 11782
     $gotdig$0$i9 = 1; //@line 11782
     continue;
    }
   }
   L168 : do if ((label | 0) == 139) {
    $333 = HEAP32[$0 >> 2] | 0; //@line 11788
    if ($333 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $333 + 1; //@line 11793
     $$1$ph$i = HEAPU8[$333 >> 0] | 0; //@line 11796
    } else $$1$ph$i = ___shgetc($f) | 0; //@line 11799
    if (($$1$ph$i | 0) == 48) {
     $349 = -1; //@line 11803
     $350 = -1; //@line 11803
     while (1) {
      $341 = HEAP32[$0 >> 2] | 0; //@line 11805
      if ($341 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
       HEAP32[$0 >> 2] = $341 + 1; //@line 11810
       $$1$be$i = HEAPU8[$341 >> 0] | 0; //@line 11813
      } else $$1$be$i = ___shgetc($f) | 0; //@line 11816
      if (($$1$be$i | 0) != 48) {
       $$2$i = $$1$be$i; //@line 11820
       $716 = $349; //@line 11820
       $717 = $350; //@line 11820
       $gotdig$2$i11 = 1; //@line 11820
       $gotrad$0$i12 = 1; //@line 11820
       break L168;
      }
      $351 = _i64Add($349 | 0, $350 | 0, -1, -1) | 0; //@line 11823
      $349 = $351; //@line 11825
      $350 = tempRet0; //@line 11825
     }
    } else {
     $$2$i = $$1$ph$i; //@line 11828
     $716 = 0; //@line 11828
     $717 = 0; //@line 11828
     $gotdig$2$i11 = $gotdig$0$i9; //@line 11828
     $gotrad$0$i12 = 1; //@line 11828
    }
   } while (0);
   HEAP32[$x$i >> 2] = 0; //@line 11832
   $353 = $$2$i + -48 | 0; //@line 11833
   $355 = ($$2$i | 0) == 46; //@line 11835
   L182 : do if ($353 >>> 0 < 10 | $355) {
    $356 = $x$i + 496 | 0; //@line 11839
    $$397$i = $$2$i; //@line 11840
    $358 = 0; //@line 11840
    $359 = 0; //@line 11840
    $718 = $355; //@line 11840
    $719 = $353; //@line 11840
    $720 = $716; //@line 11840
    $721 = $717; //@line 11840
    $gotdig$393$i = $gotdig$2$i11; //@line 11840
    $gotrad$194$i = $gotrad$0$i12; //@line 11840
    $j$096$i = 0; //@line 11840
    $k$095$i = 0; //@line 11840
    $lnz$092$i = 0; //@line 11840
    while (1) {
     do if ($718) if (!$gotrad$194$i) {
      $722 = $358; //@line 11846
      $723 = $359; //@line 11846
      $724 = $358; //@line 11846
      $725 = $359; //@line 11846
      $gotdig$4$i = $gotdig$393$i; //@line 11846
      $gotrad$2$i = 1; //@line 11846
      $j$2$i = $j$096$i; //@line 11846
      $k$2$i = $k$095$i; //@line 11846
      $lnz$2$i = $lnz$092$i; //@line 11846
     } else {
      $$388$i = $$397$i; //@line 11848
      $405 = $720; //@line 11848
      $406 = $721; //@line 11848
      $421 = $358; //@line 11848
      $424 = $359; //@line 11848
      $gotdig$381$i = $gotdig$393$i; //@line 11848
      $j$086$i = $j$096$i; //@line 11848
      $k$084$i = $k$095$i; //@line 11848
      $lnz$079$i = $lnz$092$i; //@line 11848
      break L182;
     } else {
      $360 = _i64Add($358 | 0, $359 | 0, 1, 0) | 0; //@line 11853
      $361 = tempRet0; //@line 11854
      $362 = ($$397$i | 0) != 48; //@line 11855
      if (($k$095$i | 0) >= 125) {
       if (!$362) {
        $722 = $720; //@line 11858
        $723 = $721; //@line 11858
        $724 = $360; //@line 11858
        $725 = $361; //@line 11858
        $gotdig$4$i = $gotdig$393$i; //@line 11858
        $gotrad$2$i = $gotrad$194$i; //@line 11858
        $j$2$i = $j$096$i; //@line 11858
        $k$2$i = $k$095$i; //@line 11858
        $lnz$2$i = $lnz$092$i; //@line 11858
        break;
       }
       HEAP32[$356 >> 2] = HEAP32[$356 >> 2] | 1; //@line 11863
       $722 = $720; //@line 11864
       $723 = $721; //@line 11864
       $724 = $360; //@line 11864
       $725 = $361; //@line 11864
       $gotdig$4$i = $gotdig$393$i; //@line 11864
       $gotrad$2$i = $gotrad$194$i; //@line 11864
       $j$2$i = $j$096$i; //@line 11864
       $k$2$i = $k$095$i; //@line 11864
       $lnz$2$i = $lnz$092$i; //@line 11864
       break;
      }
      $364 = $x$i + ($k$095$i << 2) | 0; //@line 11869
      if (!$j$096$i) $storemerge$i = $719; //@line 11871
 else $storemerge$i = $$397$i + -48 + ((HEAP32[$364 >> 2] | 0) * 10 | 0) | 0; //@line 11877
      HEAP32[$364 >> 2] = $storemerge$i; //@line 11879
      $369 = $j$096$i + 1 | 0; //@line 11880
      $370 = ($369 | 0) == 9; //@line 11881
      $722 = $720; //@line 11885
      $723 = $721; //@line 11885
      $724 = $360; //@line 11885
      $725 = $361; //@line 11885
      $gotdig$4$i = 1; //@line 11885
      $gotrad$2$i = $gotrad$194$i; //@line 11885
      $j$2$i = $370 ? 0 : $369; //@line 11885
      $k$2$i = ($370 & 1) + $k$095$i | 0; //@line 11885
      $lnz$2$i = $362 ? $360 : $lnz$092$i; //@line 11885
     } while (0);
     $374 = HEAP32[$0 >> 2] | 0; //@line 11888
     if ($374 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
      HEAP32[$0 >> 2] = $374 + 1; //@line 11893
      $$3$be$i = HEAPU8[$374 >> 0] | 0; //@line 11896
     } else $$3$be$i = ___shgetc($f) | 0; //@line 11899
     $719 = $$3$be$i + -48 | 0; //@line 11901
     $718 = ($$3$be$i | 0) == 46; //@line 11903
     if (!($719 >>> 0 < 10 | $718)) {
      $$3$lcssa$i = $$3$be$i; //@line 11908
      $386 = $724; //@line 11908
      $387 = $722; //@line 11908
      $389 = $725; //@line 11908
      $390 = $723; //@line 11908
      $gotdig$3$lcssa$i = $gotdig$4$i; //@line 11908
      $gotrad$1$lcssa$i = $gotrad$2$i; //@line 11908
      $j$0$lcssa$i = $j$2$i; //@line 11908
      $k$0$lcssa$i = $k$2$i; //@line 11908
      $lnz$0$lcssa$i = $lnz$2$i; //@line 11908
      label = 162; //@line 11909
      break;
     } else {
      $$397$i = $$3$be$i; //@line 11906
      $358 = $724; //@line 11906
      $359 = $725; //@line 11906
      $720 = $722; //@line 11906
      $721 = $723; //@line 11906
      $gotdig$393$i = $gotdig$4$i; //@line 11906
      $gotrad$194$i = $gotrad$2$i; //@line 11906
      $j$096$i = $j$2$i; //@line 11906
      $k$095$i = $k$2$i; //@line 11906
      $lnz$092$i = $lnz$2$i; //@line 11906
     }
    }
   } else {
    $$3$lcssa$i = $$2$i; //@line 11914
    $386 = 0; //@line 11914
    $387 = $716; //@line 11914
    $389 = 0; //@line 11914
    $390 = $717; //@line 11914
    $gotdig$3$lcssa$i = $gotdig$2$i11; //@line 11914
    $gotrad$1$lcssa$i = $gotrad$0$i12; //@line 11914
    $j$0$lcssa$i = 0; //@line 11914
    $k$0$lcssa$i = 0; //@line 11914
    $lnz$0$lcssa$i = 0; //@line 11914
    label = 162; //@line 11915
   } while (0);
   if ((label | 0) == 162) {
    $384 = ($gotrad$1$lcssa$i | 0) == 0; //@line 11919
    $$388$i = $$3$lcssa$i; //@line 11922
    $405 = $384 ? $386 : $387; //@line 11922
    $406 = $384 ? $389 : $390; //@line 11922
    $421 = $386; //@line 11922
    $424 = $389; //@line 11922
    $gotdig$381$i = $gotdig$3$lcssa$i; //@line 11922
    $j$086$i = $j$0$lcssa$i; //@line 11922
    $k$084$i = $k$0$lcssa$i; //@line 11922
    $lnz$079$i = $lnz$0$lcssa$i; //@line 11922
   }
   $391 = ($gotdig$381$i | 0) != 0; //@line 11924
   if ($391) if (($$388$i | 32 | 0) == 101) {
    $394 = _scanexp($f, $pok) | 0; //@line 11929
    $395 = tempRet0; //@line 11930
    do if (($394 | 0) == 0 & ($395 | 0) == -2147483648) if ($39) {
     ___shlim($f, 0); //@line 11937
     $$0 = 0.0; //@line 11938
     STACKTOP = sp; //@line 11939
     return +$$0;
    } else {
     if (!(HEAP32[$1 >> 2] | 0)) {
      $403 = 0; //@line 11944
      $404 = 0; //@line 11944
      break;
     }
     HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11949
     $403 = 0; //@line 11950
     $404 = 0; //@line 11950
     break;
    } else {
     $403 = $394; //@line 11954
     $404 = $395; //@line 11954
    } while (0);
    $407 = _i64Add($403 | 0, $404 | 0, $405 | 0, $406 | 0) | 0; //@line 11957
    $420 = $407; //@line 11959
    $423 = tempRet0; //@line 11959
   } else label = 171; //@line 11961
 else label = 171; //@line 11964
   if ((label | 0) == 171) if (($$388$i | 0) > -1) if (!(HEAP32[$1 >> 2] | 0)) {
    $420 = $405; //@line 11972
    $423 = $406; //@line 11972
   } else {
    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 11976
    $420 = $405; //@line 11977
    $423 = $406; //@line 11977
   } else {
    $420 = $405; //@line 11980
    $423 = $406; //@line 11980
   }
   if (!$391) {
    HEAP32[(___errno_location() | 0) >> 2] = 22; //@line 11985
    ___shlim($f, 0); //@line 11986
    $$0 = 0.0; //@line 11987
    STACKTOP = sp; //@line 11988
    return +$$0;
   }
   $415 = HEAP32[$x$i >> 2] | 0; //@line 11990
   if (!$415) {
    $$0 = +($sign$0 | 0) * 0.0; //@line 11995
    STACKTOP = sp; //@line 11996
    return +$$0;
   }
   do if (($420 | 0) == ($421 | 0) & ($423 | 0) == ($424 | 0) & (($424 | 0) < 0 | ($424 | 0) == 0 & $421 >>> 0 < 10)) {
    if ($bits$0$ph >>> 0 <= 30) if ($415 >>> $bits$0$ph) break;
    $$0 = +($sign$0 | 0) * +($415 >>> 0); //@line 12020
    STACKTOP = sp; //@line 12021
    return +$$0;
   } while (0);
   $437 = ($emin$0$ph | 0) / -2 | 0; //@line 12024
   $439 = (($437 | 0) < 0) << 31 >> 31; //@line 12026
   if (($423 | 0) > ($439 | 0) | ($423 | 0) == ($439 | 0) & $420 >>> 0 > $437 >>> 0) {
    HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 12034
    $$0 = +($sign$0 | 0) * 1.7976931348623157e+308 * 1.7976931348623157e+308; //@line 12038
    STACKTOP = sp; //@line 12039
    return +$$0;
   }
   $449 = $emin$0$ph + -106 | 0; //@line 12041
   $451 = (($449 | 0) < 0) << 31 >> 31; //@line 12043
   if (($423 | 0) < ($451 | 0) | ($423 | 0) == ($451 | 0) & $420 >>> 0 < $449 >>> 0) {
    HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 12051
    $$0 = +($sign$0 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308; //@line 12055
    STACKTOP = sp; //@line 12056
    return +$$0;
   }
   if (!$j$086$i) $k$3$i = $k$084$i; //@line 12060
 else {
    if (($j$086$i | 0) < 9) {
     $463 = $x$i + ($k$084$i << 2) | 0; //@line 12064
     $465 = HEAP32[$463 >> 2] | 0; //@line 12066
     $j$371$i = $j$086$i; //@line 12066
     do {
      $465 = $465 * 10 | 0; //@line 12068
      $j$371$i = $j$371$i + 1 | 0; //@line 12069
     } while (($j$371$i | 0) != 9);
     HEAP32[$463 >> 2] = $465; //@line 12077
    }
    $k$3$i = $k$084$i + 1 | 0; //@line 12080
   }
   do if (($lnz$079$i | 0) < 9) if (($lnz$079$i | 0) <= ($420 | 0) & ($420 | 0) < 18) {
    if (($420 | 0) == 9) {
     $$0 = +($sign$0 | 0) * +((HEAP32[$x$i >> 2] | 0) >>> 0); //@line 12095
     STACKTOP = sp; //@line 12096
     return +$$0;
    }
    if (($420 | 0) < 9) {
     $$0 = +($sign$0 | 0) * +((HEAP32[$x$i >> 2] | 0) >>> 0) / +(HEAP32[12528 + (8 - $420 << 2) >> 2] | 0); //@line 12109
     STACKTOP = sp; //@line 12110
     return +$$0;
    }
    $487 = $bits$0$ph + 27 + (Math_imul($420, -3) | 0) | 0; //@line 12114
    $$pre$i17 = HEAP32[$x$i >> 2] | 0; //@line 12116
    if (($487 | 0) <= 30) if ($$pre$i17 >>> $487) break;
    $$0 = +($sign$0 | 0) * +($$pre$i17 >>> 0) * +(HEAP32[12528 + ($420 + -10 << 2) >> 2] | 0); //@line 12132
    STACKTOP = sp; //@line 12133
    return +$$0;
   } while (0);
   $499 = ($420 | 0) % 9 | 0; //@line 12137
   if (!$499) {
    $a$2$ph40$i = 0; //@line 12140
    $e2$0$ph$i = 0; //@line 12140
    $rp$2$ph38$i = $420; //@line 12140
    $z$1$ph39$i = $k$3$i; //@line 12140
   } else {
    $503 = ($420 | 0) > -1 ? $499 : $499 + 9 | 0; //@line 12144
    $506 = HEAP32[12528 + (8 - $503 << 2) >> 2] | 0; //@line 12147
    if (!$k$3$i) {
     $a$0$lcssa161$i = 0; //@line 12150
     $rp$0$lcssa162$i = $420; //@line 12150
     $z$0$i = 0; //@line 12150
    } else {
     $508 = 1e9 / ($506 | 0) | 0; //@line 12152
     $a$061$i = 0; //@line 12153
     $carry$063$i = 0; //@line 12153
     $k$462$i = 0; //@line 12153
     $rp$060$i = $420; //@line 12153
     while (1) {
      $509 = $x$i + ($k$462$i << 2) | 0; //@line 12155
      $510 = HEAP32[$509 >> 2] | 0; //@line 12156
      $513 = (($510 >>> 0) / ($506 >>> 0) | 0) + $carry$063$i | 0; //@line 12159
      HEAP32[$509 >> 2] = $513; //@line 12160
      $carry$063$i = Math_imul(($510 >>> 0) % ($506 >>> 0) | 0, $508) | 0; //@line 12161
      $k$462$i$looptemp = $k$462$i;
      $k$462$i = $k$462$i + 1 | 0; //@line 12165
      if (($k$462$i$looptemp | 0) == ($a$061$i | 0) & ($513 | 0) == 0) {
       $a$1$i = $k$462$i & 127; //@line 12169
       $rp$1$i18 = $rp$060$i + -9 | 0; //@line 12169
      } else {
       $a$1$i = $a$061$i; //@line 12171
       $rp$1$i18 = $rp$060$i; //@line 12171
      }
      if (($k$462$i | 0) == ($k$3$i | 0)) break; else {
       $a$061$i = $a$1$i; //@line 12177
       $rp$060$i = $rp$1$i18; //@line 12177
      }
     }
     if (!$carry$063$i) {
      $a$0$lcssa161$i = $a$1$i; //@line 12182
      $rp$0$lcssa162$i = $rp$1$i18; //@line 12182
      $z$0$i = $k$3$i; //@line 12182
     } else {
      HEAP32[$x$i + ($k$3$i << 2) >> 2] = $carry$063$i; //@line 12186
      $a$0$lcssa161$i = $a$1$i; //@line 12187
      $rp$0$lcssa162$i = $rp$1$i18; //@line 12187
      $z$0$i = $k$3$i + 1 | 0; //@line 12187
     }
    }
    $a$2$ph40$i = $a$0$lcssa161$i; //@line 12192
    $e2$0$ph$i = 0; //@line 12192
    $rp$2$ph38$i = 9 - $503 + $rp$0$lcssa162$i | 0; //@line 12192
    $z$1$ph39$i = $z$0$i; //@line 12192
   }
   L280 : while (1) {
    $527 = $x$i + ($a$2$ph40$i << 2) | 0; //@line 12196
    if (($rp$2$ph38$i | 0) < 18) {
     $e2$0$us$i = $e2$0$ph$i; //@line 12198
     $z$1$us$i = $z$1$ph39$i; //@line 12198
     while (1) {
      $carry1$0$us$i = 0; //@line 12201
      $k$5$in$us$i = $z$1$us$i + 127 | 0; //@line 12201
      $z$2$us$i = $z$1$us$i; //@line 12201
      while (1) {
       $k$5$us$i = $k$5$in$us$i & 127; //@line 12203
       $530 = $x$i + ($k$5$us$i << 2) | 0; //@line 12204
       $532 = _bitshift64Shl(HEAP32[$530 >> 2] | 0, 0, 29) | 0; //@line 12206
       $534 = _i64Add($532 | 0, tempRet0 | 0, $carry1$0$us$i | 0, 0) | 0; //@line 12208
       $535 = tempRet0; //@line 12209
       if ($535 >>> 0 > 0 | ($535 | 0) == 0 & $534 >>> 0 > 1e9) {
        $541 = ___udivdi3($534 | 0, $535 | 0, 1e9, 0) | 0; //@line 12216
        $543 = ___uremdi3($534 | 0, $535 | 0, 1e9, 0) | 0; //@line 12218
        $$sink$off0$us$i = $543; //@line 12220
        $carry1$1$us$i = $541; //@line 12220
       } else {
        $$sink$off0$us$i = $534; //@line 12222
        $carry1$1$us$i = 0; //@line 12222
       }
       HEAP32[$530 >> 2] = $$sink$off0$us$i; //@line 12224
       $548 = ($k$5$us$i | 0) == ($a$2$ph40$i | 0); //@line 12228
       if (($k$5$us$i | 0) != ($z$2$us$i + 127 & 127 | 0) | $548) $z$3$us$i = $z$2$us$i; //@line 12231
 else $z$3$us$i = ($$sink$off0$us$i | 0) == 0 ? $k$5$us$i : $z$2$us$i; //@line 12235
       if ($548) break; else {
        $carry1$0$us$i = $carry1$1$us$i; //@line 12241
        $k$5$in$us$i = $k$5$us$i + -1 | 0; //@line 12241
        $z$2$us$i = $z$3$us$i; //@line 12241
       }
      }
      $551 = $e2$0$us$i + -29 | 0; //@line 12244
      if (!$carry1$1$us$i) {
       $e2$0$us$i = $551; //@line 12247
       $z$1$us$i = $z$3$us$i; //@line 12247
      } else {
       $$lcssa43$i = $551; //@line 12249
       $carry1$1$lcssa$lcssa$i = $carry1$1$us$i; //@line 12249
       $z$3$lcssa$lcssa$i = $z$3$us$i; //@line 12249
       break;
      }
     }
    } else {
     if (($rp$2$ph38$i | 0) == 18) {
      $e2$0$us44$i = $e2$0$ph$i; //@line 12256
      $z$1$us45$i = $z$1$ph39$i; //@line 12256
     } else {
      $a$3$ph$i = $a$2$ph40$i; //@line 12258
      $e2$1$ph$i = $e2$0$ph$i; //@line 12258
      $rp$3$ph33$i = $rp$2$ph38$i; //@line 12258
      $z$5$ph$i = $z$1$ph39$i; //@line 12258
      break;
     }
     while (1) {
      if ((HEAP32[$527 >> 2] | 0) >>> 0 >= 9007199) {
       $a$3$ph$i = $a$2$ph40$i; //@line 12265
       $e2$1$ph$i = $e2$0$us44$i; //@line 12265
       $rp$3$ph33$i = 18; //@line 12265
       $z$5$ph$i = $z$1$us45$i; //@line 12265
       break L280;
      }
      $carry1$0$us49$i = 0; //@line 12269
      $k$5$in$us48$i = $z$1$us45$i + 127 | 0; //@line 12269
      $z$2$us47$i = $z$1$us45$i; //@line 12269
      while (1) {
       $k$5$us50$i = $k$5$in$us48$i & 127; //@line 12271
       $556 = $x$i + ($k$5$us50$i << 2) | 0; //@line 12272
       $558 = _bitshift64Shl(HEAP32[$556 >> 2] | 0, 0, 29) | 0; //@line 12274
       $560 = _i64Add($558 | 0, tempRet0 | 0, $carry1$0$us49$i | 0, 0) | 0; //@line 12276
       $561 = tempRet0; //@line 12277
       if ($561 >>> 0 > 0 | ($561 | 0) == 0 & $560 >>> 0 > 1e9) {
        $567 = ___udivdi3($560 | 0, $561 | 0, 1e9, 0) | 0; //@line 12284
        $569 = ___uremdi3($560 | 0, $561 | 0, 1e9, 0) | 0; //@line 12286
        $$sink$off0$us53$i = $569; //@line 12288
        $carry1$1$us54$i = $567; //@line 12288
       } else {
        $$sink$off0$us53$i = $560; //@line 12290
        $carry1$1$us54$i = 0; //@line 12290
       }
       HEAP32[$556 >> 2] = $$sink$off0$us53$i; //@line 12292
       $574 = ($k$5$us50$i | 0) == ($a$2$ph40$i | 0); //@line 12296
       if (($k$5$us50$i | 0) != ($z$2$us47$i + 127 & 127 | 0) | $574) $z$3$us57$i = $z$2$us47$i; //@line 12299
 else $z$3$us57$i = ($$sink$off0$us53$i | 0) == 0 ? $k$5$us50$i : $z$2$us47$i; //@line 12303
       if ($574) break; else {
        $carry1$0$us49$i = $carry1$1$us54$i; //@line 12309
        $k$5$in$us48$i = $k$5$us50$i + -1 | 0; //@line 12309
        $z$2$us47$i = $z$3$us57$i; //@line 12309
       }
      }
      $577 = $e2$0$us44$i + -29 | 0; //@line 12312
      if (!$carry1$1$us54$i) {
       $e2$0$us44$i = $577; //@line 12315
       $z$1$us45$i = $z$3$us57$i; //@line 12315
      } else {
       $$lcssa43$i = $577; //@line 12317
       $carry1$1$lcssa$lcssa$i = $carry1$1$us54$i; //@line 12317
       $z$3$lcssa$lcssa$i = $z$3$us57$i; //@line 12317
       break;
      }
     }
    }
    $581 = $a$2$ph40$i + 127 & 127; //@line 12324
    if (($581 | 0) == ($z$3$lcssa$lcssa$i | 0)) {
     $584 = $z$3$lcssa$lcssa$i + 127 & 127; //@line 12328
     $589 = $x$i + (($z$3$lcssa$lcssa$i + 126 & 127) << 2) | 0; //@line 12333
     HEAP32[$589 >> 2] = HEAP32[$589 >> 2] | HEAP32[$x$i + ($584 << 2) >> 2]; //@line 12336
     $z$4$i = $584; //@line 12337
    } else $z$4$i = $z$3$lcssa$lcssa$i; //@line 12339
    HEAP32[$x$i + ($581 << 2) >> 2] = $carry1$1$lcssa$lcssa$i; //@line 12342
    $a$2$ph40$i = $581; //@line 12343
    $e2$0$ph$i = $$lcssa43$i; //@line 12343
    $rp$2$ph38$i = $rp$2$ph38$i + 9 | 0; //@line 12343
    $z$1$ph39$i = $z$4$i; //@line 12343
   }
   L311 : while (1) {
    $627 = $z$5$ph$i + 1 & 127; //@line 12347
    $632 = $x$i + (($z$5$ph$i + 127 & 127) << 2) | 0; //@line 12350
    $a$3$i$ph = $a$3$ph$i; //@line 12351
    $e2$1$i$ph = $e2$1$ph$i; //@line 12351
    $rp$3$i$ph = $rp$3$ph33$i; //@line 12351
    while (1) {
     $605 = ($rp$3$i$ph | 0) == 18; //@line 12353
     $$14$i = ($rp$3$i$ph | 0) > 27 ? 9 : 1; //@line 12355
     $a$3$i = $a$3$i$ph; //@line 12356
     $e2$1$i = $e2$1$i$ph; //@line 12356
     while (1) {
      $i$025$i = 0; //@line 12358
      while (1) {
       $596 = $i$025$i + $a$3$i & 127; //@line 12361
       if (($596 | 0) == ($z$5$ph$i | 0)) {
        $i$1$i = 2; //@line 12364
        break;
       }
       $599 = HEAP32[$x$i + ($596 << 2) >> 2] | 0; //@line 12368
       $601 = HEAP32[12520 + ($i$025$i << 2) >> 2] | 0; //@line 12370
       if ($599 >>> 0 < $601 >>> 0) {
        $i$1$i = 2; //@line 12373
        break;
       }
       $594 = $i$025$i + 1 | 0; //@line 12377
       if ($599 >>> 0 > $601 >>> 0) {
        $i$1$i = $i$025$i; //@line 12379
        break;
       }
       if (($594 | 0) < 2) $i$025$i = $594; //@line 12384
 else {
        $i$1$i = $594; //@line 12386
        break;
       }
      }
      if (($i$1$i | 0) == 2 & $605) break L311;
      $608 = $$14$i + $e2$1$i | 0; //@line 12395
      if (($a$3$i | 0) == ($z$5$ph$i | 0)) {
       $a$3$i = $z$5$ph$i; //@line 12398
       $e2$1$i = $608; //@line 12398
      } else break;
     }
     $611 = (1 << $$14$i) + -1 | 0; //@line 12404
     $612 = 1e9 >>> $$14$i; //@line 12405
     $a$427$i = $a$3$i; //@line 12406
     $carry3$030$i = 0; //@line 12406
     $k$628$i = $a$3$i; //@line 12406
     $rp$426$i = $rp$3$i$ph; //@line 12406
     do {
      $613 = $x$i + ($k$628$i << 2) | 0; //@line 12408
      $614 = HEAP32[$613 >> 2] | 0; //@line 12409
      $617 = ($614 >>> $$14$i) + $carry3$030$i | 0; //@line 12412
      HEAP32[$613 >> 2] = $617; //@line 12413
      $carry3$030$i = Math_imul($614 & $611, $612) | 0; //@line 12414
      $or$cond15$i = ($k$628$i | 0) == ($a$427$i | 0) & ($617 | 0) == 0; //@line 12417
      $k$628$i = $k$628$i + 1 & 127; //@line 12419
      $rp$426$i = $or$cond15$i ? $rp$426$i + -9 | 0 : $rp$426$i; //@line 12421
      $a$427$i = $or$cond15$i ? $k$628$i : $a$427$i; //@line 12422
     } while (($k$628$i | 0) != ($z$5$ph$i | 0));
     if (!$carry3$030$i) {
      $a$3$i$ph = $a$427$i; //@line 12432
      $e2$1$i$ph = $608; //@line 12432
      $rp$3$i$ph = $rp$426$i; //@line 12432
      continue;
     }
     if (($627 | 0) != ($a$427$i | 0)) break;
     HEAP32[$632 >> 2] = HEAP32[$632 >> 2] | 1; //@line 12441
     $a$3$i$ph = $a$427$i; //@line 12442
     $e2$1$i$ph = $608; //@line 12442
     $rp$3$i$ph = $rp$426$i; //@line 12442
    }
    HEAP32[$x$i + ($z$5$ph$i << 2) >> 2] = $carry3$030$i; //@line 12445
    $a$3$ph$i = $a$427$i; //@line 12446
    $e2$1$ph$i = $608; //@line 12446
    $rp$3$ph33$i = $rp$426$i; //@line 12446
    $z$5$ph$i = $627; //@line 12446
   }
   $606 = $a$3$i & 127; //@line 12448
   if (($606 | 0) == ($z$5$ph$i | 0)) {
    HEAP32[$x$i + ($627 + -1 << 2) >> 2] = 0; //@line 12453
    $z$7$i = $627; //@line 12454
   } else $z$7$i = $z$5$ph$i; //@line 12456
   $640 = +((HEAP32[$x$i + ($606 << 2) >> 2] | 0) >>> 0); //@line 12460
   $642 = $a$3$i + 1 & 127; //@line 12462
   if (($642 | 0) == ($z$7$i | 0)) {
    $703 = $z$7$i + 1 & 127; //@line 12466
    HEAP32[$x$i + ($703 + -1 << 2) >> 2] = 0; //@line 12469
    $z$7$1$i = $703; //@line 12470
   } else $z$7$1$i = $z$7$i; //@line 12472
   $667 = +($sign$0 | 0); //@line 12479
   $649 = $667 * ($640 * 1.0e9 + +((HEAP32[$x$i + ($642 << 2) >> 2] | 0) >>> 0)); //@line 12480
   $687 = $e2$1$i + 53 | 0; //@line 12481
   $645 = $687 - $emin$0$ph | 0; //@line 12482
   if (($645 | 0) < ($bits$0$ph | 0)) {
    $$09$i = ($645 | 0) < 0 ? 0 : $645; //@line 12487
    $denormal$0$i = 1; //@line 12487
   } else {
    $$09$i = $bits$0$ph; //@line 12489
    $denormal$0$i = 0; //@line 12489
   }
   if (($$09$i | 0) < 53) {
    $650 = +_copysignl(+(+_scalbn(1.0, 105 - $$09$i | 0)), +$649); //@line 12495
    $653 = +_fmodl(+$649, +(+_scalbn(1.0, 53 - $$09$i | 0))); //@line 12498
    $bias$0$i = $650; //@line 12501
    $frac$0$i = $653; //@line 12501
    $y$1$i23 = $650 + ($649 - $653); //@line 12501
   } else {
    $bias$0$i = 0.0; //@line 12503
    $frac$0$i = 0.0; //@line 12503
    $y$1$i23 = $649; //@line 12503
   }
   $657 = $a$3$i + 2 & 127; //@line 12506
   do if (($657 | 0) == ($z$7$1$i | 0)) $frac$2$i = $frac$0$i; //@line 12510
 else {
    $660 = HEAP32[$x$i + ($657 << 2) >> 2] | 0; //@line 12513
    do if ($660 >>> 0 < 5e8) {
     if (!$660) if (($a$3$i + 3 & 127 | 0) == ($z$7$1$i | 0)) {
      $frac$1$i = $frac$0$i; //@line 12523
      break;
     }
     $frac$1$i = $667 * .25 + $frac$0$i; //@line 12529
    } else {
     if ($660 >>> 0 > 5e8) {
      $frac$1$i = $667 * .75 + $frac$0$i; //@line 12535
      break;
     }
     if (($a$3$i + 3 & 127 | 0) == ($z$7$1$i | 0)) {
      $frac$1$i = $667 * .5 + $frac$0$i; //@line 12544
      break;
     } else {
      $frac$1$i = $667 * .75 + $frac$0$i; //@line 12549
      break;
     }
    } while (0);
    if ((53 - $$09$i | 0) <= 1) {
     $frac$2$i = $frac$1$i; //@line 12557
     break;
    }
    if (+_fmodl(+$frac$1$i, 1.0) != 0.0) {
     $frac$2$i = $frac$1$i; //@line 12563
     break;
    }
    $frac$2$i = $frac$1$i + 1.0; //@line 12567
   } while (0);
   $685 = $y$1$i23 + $frac$2$i - $bias$0$i; //@line 12571
   do if (($687 & 2147483647 | 0) > (-2 - $sum$i | 0)) {
    if (!(+Math_abs(+$685) >= 9007199254740992.0)) {
     $denormal$2$i = $denormal$0$i; //@line 12580
     $e2$2$i = $e2$1$i; //@line 12580
     $y$2$i24 = $685; //@line 12580
    } else {
     $denormal$2$i = ($denormal$0$i | 0) != 0 & ($$09$i | 0) == ($645 | 0) ? 0 : $denormal$0$i; //@line 12588
     $e2$2$i = $e2$1$i + 1 | 0; //@line 12588
     $y$2$i24 = $685 * .5; //@line 12588
    }
    if (($e2$2$i + 50 | 0) <= ($325 | 0)) if (!(($denormal$2$i | 0) != 0 & $frac$2$i != 0.0)) {
     $e2$3$i = $e2$2$i; //@line 12597
     $y$3$i = $y$2$i24; //@line 12597
     break;
    }
    HEAP32[(___errno_location() | 0) >> 2] = 34; //@line 12602
    $e2$3$i = $e2$2$i; //@line 12603
    $y$3$i = $y$2$i24; //@line 12603
   } else {
    $e2$3$i = $e2$1$i; //@line 12605
    $y$3$i = $685; //@line 12605
   } while (0);
   $$0 = +_scalbnl($y$3$i, $e2$3$i); //@line 12609
   STACKTOP = sp; //@line 12610
   return +$$0;
  } else if (($i$3 | 0) == 3) {
   $68 = HEAP32[$0 >> 2] | 0; //@line 12612
   if ($68 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $68 + 1; //@line 12617
    $76 = HEAPU8[$68 >> 0] | 0; //@line 12620
   } else $76 = ___shgetc($f) | 0; //@line 12623
   if (($76 | 0) == 40) $i$4 = 1; //@line 12627
 else {
    if (!(HEAP32[$1 >> 2] | 0)) {
     $$0 = nan; //@line 12632
     STACKTOP = sp; //@line 12633
     return +$$0;
    }
    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12637
    $$0 = nan; //@line 12638
    STACKTOP = sp; //@line 12639
    return +$$0;
   }
   while (1) {
    $81 = HEAP32[$0 >> 2] | 0; //@line 12642
    if ($81 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $81 + 1; //@line 12647
     $89 = HEAPU8[$81 >> 0] | 0; //@line 12650
    } else $89 = ___shgetc($f) | 0; //@line 12653
    if (!(($89 + -48 | 0) >>> 0 < 10 | ($89 + -65 | 0) >>> 0 < 26)) if (!(($89 + -97 | 0) >>> 0 < 26 | ($89 | 0) == 95)) break;
    $i$4 = $i$4 + 1 | 0; //@line 12670
   }
   if (($89 | 0) == 41) {
    $$0 = nan; //@line 12674
    STACKTOP = sp; //@line 12675
    return +$$0;
   }
   $98 = (HEAP32[$1 >> 2] | 0) == 0; //@line 12678
   if (!$98) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12682
   if ($39) {
    HEAP32[(___errno_location() | 0) >> 2] = 22; //@line 12686
    ___shlim($f, 0); //@line 12687
    $$0 = 0.0; //@line 12688
    STACKTOP = sp; //@line 12689
    return +$$0;
   }
   if (($i$4 | 0) == 0 | $98) {
    $$0 = nan; //@line 12694
    STACKTOP = sp; //@line 12695
    return +$$0;
   } else $$in = $i$4; //@line 12697
   do {
    $$in = $$in + -1 | 0; //@line 12700
    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12703
   } while (($$in | 0) != 0);
   $$0 = nan; //@line 12706
   STACKTOP = sp; //@line 12712
   return +$$0;
  } else {
   if (HEAP32[$1 >> 2] | 0) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12719
   HEAP32[(___errno_location() | 0) >> 2] = 22; //@line 12722
   ___shlim($f, 0); //@line 12723
   $$0 = 0.0; //@line 12724
   STACKTOP = sp; //@line 12725
   return +$$0;
  }
 } while (0);
 if ((label | 0) == 23) {
  $42 = (HEAP32[$1 >> 2] | 0) == 0; //@line 12731
  if (!$42) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12735
  if (!($i$0$lcssa >>> 0 < 4 | ($pok | 0) == 0 | $42)) {
   $i$166 = $i$0$lcssa; //@line 12742
   do {
    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12746
    $i$166 = $i$166 + -1 | 0; //@line 12747
   } while ($i$166 >>> 0 > 3);
  }
 }
 $$0 = +($sign$0 | 0) * inf; //@line 12760
 STACKTOP = sp; //@line 12761
 return +$$0;
}
function _llex($ls, $seminfo) {
 $ls = $ls | 0;
 $seminfo = $seminfo | 0;
 var $$0 = 0, $$be$i = 0, $$be21$i = 0, $$in$i$i = 0, $$in$i$i$i = 0, $$in$i4$i$i = 0, $$ph$i = 0, $$pr28 = 0, $$pre$i10 = 0, $$pre$i17$i = 0, $0 = 0, $10 = 0, $100 = 0, $105 = 0, $106 = 0, $107 = 0, $110 = 0, $111 = 0, $116 = 0, $118 = 0, $119 = 0, $122 = 0, $123 = 0, $128 = 0, $129 = 0, $130 = 0, $133 = 0, $134 = 0, $139 = 0, $141 = 0, $142 = 0, $145 = 0, $146 = 0, $15 = 0, $151 = 0, $152 = 0, $153 = 0, $156 = 0, $157 = 0, $16 = 0, $162 = 0, $164 = 0, $165 = 0, $168 = 0, $169 = 0, $17 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $179 = 0, $180 = 0, $183 = 0, $186 = 0, $188 = 0, $189 = 0, $191 = 0, $193 = 0, $194 = 0, $195 = 0, $198 = 0, $199 = 0, $20 = 0, $204 = 0, $206 = 0, $207 = 0, $208 = 0, $21 = 0, $211 = 0, $212 = 0, $217 = 0, $219 = 0, $220 = 0, $223 = 0, $224 = 0, $229 = 0, $239 = 0, $240 = 0, $242 = 0, $243 = 0, $246 = 0, $247 = 0, $252 = 0, $258 = 0, $259 = 0, $26 = 0, $262 = 0, $263 = 0, $268 = 0, $28 = 0, $280 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $293 = 0, $294 = 0, $299 = 0, $3 = 0, $300 = 0, $303 = 0, $304 = 0, $307 = 0, $308 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $318 = 0, $319 = 0, $32 = 0, $322 = 0, $324 = 0, $326 = 0, $329 = 0, $33 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $336 = 0, $337 = 0, $340 = 0, $342 = 0, $344 = 0, $346 = 0, $348 = 0, $350 = 0, $351 = 0, $352 = 0, $355 = 0, $356 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $366 = 0, $367 = 0, $370 = 0, $373 = 0, $375 = 0, $377 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $384 = 0, $385 = 0, $390 = 0, $391 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $414 = 0, $415 = 0, $427 = 0, $428 = 0, $429 = 0, $431 = 0, $432 = 0, $435 = 0, $438 = 0, $440 = 0, $442 = 0, $444 = 0, $445 = 0, $446 = 0, $449 = 0, $450 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $461 = 0, $462 = 0, $465 = 0, $468 = 0, $47 = 0, $470 = 0, $473 = 0, $475 = 0, $476 = 0, $477 = 0, $480 = 0, $481 = 0, $486 = 0, $489 = 0, $490 = 0, $491 = 0, $493 = 0, $494 = 0, $497 = 0, $5 = 0, $50 = 0, $500 = 0, $502 = 0, $505 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $512 = 0, $513 = 0, $518 = 0, $524 = 0, $525 = 0, $526 = 0, $528 = 0, $529 = 0, $532 = 0, $535 = 0, $537 = 0, $539 = 0, $541 = 0, $543 = 0, $544 = 0, $545 = 0, $548 = 0, $549 = 0, $554 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $562 = 0, $563 = 0, $566 = 0, $569 = 0, $57 = 0, $571 = 0, $574 = 0, $576 = 0, $577 = 0, $578 = 0, $581 = 0, $582 = 0, $587 = 0, $588 = 0, $590 = 0, $592 = 0, $593 = 0, $594 = 0, $596 = 0, $597 = 0, $6 = 0, $60 = 0, $600 = 0, $602 = 0, $604 = 0, $607 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $614 = 0, $615 = 0, $620 = 0, $623 = 0, $624 = 0, $625 = 0, $627 = 0, $628 = 0, $631 = 0, $633 = 0, $635 = 0, $638 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $645 = 0, $646 = 0, $65 = 0, $651 = 0, $653 = 0, $659 = 0, $660 = 0, $661 = 0, $663 = 0, $664 = 0, $665 = 0, $667 = 0, $669 = 0, $671 = 0, $674 = 0, $676 = 0, $677 = 0, $678 = 0, $681 = 0, $682 = 0, $687 = 0, $689 = 0, $691 = 0, $693 = 0, $695 = 0, $697 = 0, $698 = 0, $699 = 0, $70 = 0, $702 = 0, $706 = 0, $707 = 0, $710 = 0, $713 = 0, $716 = 0, $72 = 0, $720 = 0, $721 = 0, $724 = 0, $727 = 0, $73 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $741 = 0, $742 = 0, $745 = 0, $747 = 0, $749 = 0, $751 = 0, $753 = 0, $755 = 0, $756 = 0, $757 = 0, $76 = 0, $760 = 0, $761 = 0, $766 = 0, $77 = 0, $772 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $792 = 0, $793 = 0, $809 = 0, $813 = 0, $814 = 0, $817 = 0, $818 = 0, $82 = 0, $823 = 0, $824 = 0, $825 = 0, $83 = 0, $84 = 0, $87 = 0, $88 = 0, $9 = 0, $93 = 0, $95 = 0, $96 = 0, $99 = 0, $c$0$i = 0, $c$1$i = 0, $c$i$i = 0, $expo$0$ph$i = 0, $i$0$lcssa$i$i = 0, $i$01$i$i = 0, $i$03$i$i = 0, $ls$idx$val$i = 0, $ls$idx$val$i$i = 0, $ls$idx$val$idx$val$i = 0, $ls$idx$val$idx$val$i$i = 0, $ls$idx$val$idx1$val$i = 0, $ls$idx$val$idx3$val$i$i = 0, $ls$idx1$val$i$i = 0, $ls$idx1$val$idx$val$i$i = 0, $ls$idx1$val$idx2$val$i$i = 0, $r$0$lcssa$i$i = 0, $r$02$i$i = 0, $r$04$i$i = 0, $ts$0$i = 0, $ts$0$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 3214
 STACKTOP = STACKTOP + 16 | 0; //@line 3215
 $c$i$i = sp; //@line 3216
 $0 = $ls + 60 | 0; //@line 3217
 HEAP32[(HEAP32[$0 >> 2] | 0) + 4 >> 2] = 0; //@line 3220
 $3 = $ls + 56 | 0; //@line 3221
 L1 : while (1) {
  $4 = HEAP32[$ls >> 2] | 0; //@line 3224
  L3 : while (1) {
   switch ($4 | 0) {
   case 11:
   case 9:
   case 12:
   case 32:
    break;
   case 13:
   case 10:
    {
     label = 4; //@line 3231
     break L3;
     break;
    }
   case 61:
    {
     label = 29; //@line 3236
     break L1;
     break;
    }
   case 60:
    {
     label = 37; //@line 3241
     break L1;
     break;
    }
   case 62:
    {
     label = 45; //@line 3246
     break L1;
     break;
    }
   case 91:
    {
     label = 25; //@line 3251
     break L1;
     break;
    }
   case 45:
    {
     break L3;
     break;
    }
   case 46:
    {
     label = 162; //@line 3260
     break L1;
     break;
    }
   case 126:
    {
     label = 53; //@line 3265
     break L1;
     break;
    }
   case 58:
    {
     label = 61; //@line 3270
     break L1;
     break;
    }
   case 39:
   case 34:
    {
     label = 69; //@line 3275
     break L1;
     break;
    }
   case 57:
   case 56:
   case 55:
   case 54:
   case 53:
   case 52:
   case 51:
   case 50:
   case 49:
   case 48:
    {
     $539 = $4; //@line 3280
     break L1;
     break;
    }
   case -1:
    {
     $$0 = 286; //@line 3285
     label = 308; //@line 3286
     break L1;
     break;
    }
   default:
    {
     label = 284; //@line 3291
     break L1;
    }
   }
   $5 = HEAP32[$3 >> 2] | 0; //@line 3295
   $6 = HEAP32[$5 >> 2] | 0; //@line 3296
   HEAP32[$5 >> 2] = $6 + -1; //@line 3298
   if (!$6) $15 = _luaZ_fill($5) | 0; //@line 3302
 else {
    $9 = $5 + 4 | 0; //@line 3304
    $10 = HEAP32[$9 >> 2] | 0; //@line 3305
    HEAP32[$9 >> 2] = $10 + 1; //@line 3307
    $15 = HEAPU8[$10 >> 0] | 0; //@line 3310
   }
   HEAP32[$ls >> 2] = $15; //@line 3312
   $4 = $15; //@line 3313
  }
  if ((label | 0) == 4) {
   label = 0; //@line 3316
   _inclinenumber($ls); //@line 3317
   continue;
  }
  $16 = HEAP32[$3 >> 2] | 0; //@line 3320
  $17 = HEAP32[$16 >> 2] | 0; //@line 3321
  HEAP32[$16 >> 2] = $17 + -1; //@line 3323
  if (!$17) $26 = _luaZ_fill($16) | 0; //@line 3327
 else {
   $20 = $16 + 4 | 0; //@line 3329
   $21 = HEAP32[$20 >> 2] | 0; //@line 3330
   HEAP32[$20 >> 2] = $21 + 1; //@line 3332
   $26 = HEAPU8[$21 >> 0] | 0; //@line 3335
  }
  HEAP32[$ls >> 2] = $26; //@line 3337
  if (($26 | 0) != 45) {
   $$0 = 45; //@line 3340
   label = 308; //@line 3341
   break;
  }
  $28 = HEAP32[$3 >> 2] | 0; //@line 3344
  $29 = HEAP32[$28 >> 2] | 0; //@line 3345
  HEAP32[$28 >> 2] = $29 + -1; //@line 3347
  if (!$29) $38 = _luaZ_fill($28) | 0; //@line 3351
 else {
   $32 = $28 + 4 | 0; //@line 3353
   $33 = HEAP32[$32 >> 2] | 0; //@line 3354
   HEAP32[$32 >> 2] = $33 + 1; //@line 3356
   $38 = HEAPU8[$33 >> 0] | 0; //@line 3359
  }
  HEAP32[$ls >> 2] = $38; //@line 3361
  do if (($38 | 0) == 91) {
   $40 = _skip_sep($ls) | 0; //@line 3365
   HEAP32[(HEAP32[$0 >> 2] | 0) + 4 >> 2] = 0; //@line 3368
   if (($40 | 0) > -1) {
    _read_long_string($ls, 0, $40); //@line 3371
    HEAP32[(HEAP32[$0 >> 2] | 0) + 4 >> 2] = 0; //@line 3374
    continue L1;
   } else {
    $824 = HEAP32[$ls >> 2] | 0; //@line 3378
    break;
   }
  } else $824 = $38; //@line 3382
 while (0);
  while (1) {
   if (($824 | 0) == -1 | ($824 | 0) == 13 | ($824 | 0) == 10) continue L1;
   $46 = HEAP32[$3 >> 2] | 0; //@line 3389
   $47 = HEAP32[$46 >> 2] | 0; //@line 3390
   HEAP32[$46 >> 2] = $47 + -1; //@line 3392
   if (!$47) $56 = _luaZ_fill($46) | 0; //@line 3396
 else {
    $50 = $46 + 4 | 0; //@line 3398
    $51 = HEAP32[$50 >> 2] | 0; //@line 3399
    HEAP32[$50 >> 2] = $51 + 1; //@line 3401
    $56 = HEAPU8[$51 >> 0] | 0; //@line 3404
   }
   HEAP32[$ls >> 2] = $56; //@line 3406
   $824 = $56; //@line 3407
  }
 }
 switch (label | 0) {
 case 25:
  {
   $57 = _skip_sep($ls) | 0; //@line 3412
   if (($57 | 0) > -1) {
    _read_long_string($ls, $seminfo, $57); //@line 3415
    $$0 = 289; //@line 3416
    STACKTOP = sp; //@line 3417
    return $$0 | 0; //@line 3417
   }
   if (($57 | 0) == -1) {
    $$0 = 91; //@line 3421
    STACKTOP = sp; //@line 3422
    return $$0 | 0; //@line 3422
   } else _lexerror($ls, 5792, 289); //@line 3424
   break;
  }
 case 29:
  {
   $60 = HEAP32[$3 >> 2] | 0; //@line 3430
   $61 = HEAP32[$60 >> 2] | 0; //@line 3431
   HEAP32[$60 >> 2] = $61 + -1; //@line 3433
   if (!$61) $70 = _luaZ_fill($60) | 0; //@line 3437
 else {
    $64 = $60 + 4 | 0; //@line 3439
    $65 = HEAP32[$64 >> 2] | 0; //@line 3440
    HEAP32[$64 >> 2] = $65 + 1; //@line 3442
    $70 = HEAPU8[$65 >> 0] | 0; //@line 3445
   }
   HEAP32[$ls >> 2] = $70; //@line 3447
   if (($70 | 0) != 61) {
    $$0 = 61; //@line 3450
    STACKTOP = sp; //@line 3451
    return $$0 | 0; //@line 3451
   }
   $72 = HEAP32[$3 >> 2] | 0; //@line 3453
   $73 = HEAP32[$72 >> 2] | 0; //@line 3454
   HEAP32[$72 >> 2] = $73 + -1; //@line 3456
   if (!$73) $82 = _luaZ_fill($72) | 0; //@line 3460
 else {
    $76 = $72 + 4 | 0; //@line 3462
    $77 = HEAP32[$76 >> 2] | 0; //@line 3463
    HEAP32[$76 >> 2] = $77 + 1; //@line 3465
    $82 = HEAPU8[$77 >> 0] | 0; //@line 3468
   }
   HEAP32[$ls >> 2] = $82; //@line 3470
   $$0 = 281; //@line 3471
   STACKTOP = sp; //@line 3472
   return $$0 | 0; //@line 3472
  }
 case 37:
  {
   $83 = HEAP32[$3 >> 2] | 0; //@line 3476
   $84 = HEAP32[$83 >> 2] | 0; //@line 3477
   HEAP32[$83 >> 2] = $84 + -1; //@line 3479
   if (!$84) $93 = _luaZ_fill($83) | 0; //@line 3483
 else {
    $87 = $83 + 4 | 0; //@line 3485
    $88 = HEAP32[$87 >> 2] | 0; //@line 3486
    HEAP32[$87 >> 2] = $88 + 1; //@line 3488
    $93 = HEAPU8[$88 >> 0] | 0; //@line 3491
   }
   HEAP32[$ls >> 2] = $93; //@line 3493
   if (($93 | 0) != 61) {
    $$0 = 60; //@line 3496
    STACKTOP = sp; //@line 3497
    return $$0 | 0; //@line 3497
   }
   $95 = HEAP32[$3 >> 2] | 0; //@line 3499
   $96 = HEAP32[$95 >> 2] | 0; //@line 3500
   HEAP32[$95 >> 2] = $96 + -1; //@line 3502
   if (!$96) $105 = _luaZ_fill($95) | 0; //@line 3506
 else {
    $99 = $95 + 4 | 0; //@line 3508
    $100 = HEAP32[$99 >> 2] | 0; //@line 3509
    HEAP32[$99 >> 2] = $100 + 1; //@line 3511
    $105 = HEAPU8[$100 >> 0] | 0; //@line 3514
   }
   HEAP32[$ls >> 2] = $105; //@line 3516
   $$0 = 283; //@line 3517
   STACKTOP = sp; //@line 3518
   return $$0 | 0; //@line 3518
  }
 case 45:
  {
   $106 = HEAP32[$3 >> 2] | 0; //@line 3522
   $107 = HEAP32[$106 >> 2] | 0; //@line 3523
   HEAP32[$106 >> 2] = $107 + -1; //@line 3525
   if (!$107) $116 = _luaZ_fill($106) | 0; //@line 3529
 else {
    $110 = $106 + 4 | 0; //@line 3531
    $111 = HEAP32[$110 >> 2] | 0; //@line 3532
    HEAP32[$110 >> 2] = $111 + 1; //@line 3534
    $116 = HEAPU8[$111 >> 0] | 0; //@line 3537
   }
   HEAP32[$ls >> 2] = $116; //@line 3539
   if (($116 | 0) != 61) {
    $$0 = 62; //@line 3542
    STACKTOP = sp; //@line 3543
    return $$0 | 0; //@line 3543
   }
   $118 = HEAP32[$3 >> 2] | 0; //@line 3545
   $119 = HEAP32[$118 >> 2] | 0; //@line 3546
   HEAP32[$118 >> 2] = $119 + -1; //@line 3548
   if (!$119) $128 = _luaZ_fill($118) | 0; //@line 3552
 else {
    $122 = $118 + 4 | 0; //@line 3554
    $123 = HEAP32[$122 >> 2] | 0; //@line 3555
    HEAP32[$122 >> 2] = $123 + 1; //@line 3557
    $128 = HEAPU8[$123 >> 0] | 0; //@line 3560
   }
   HEAP32[$ls >> 2] = $128; //@line 3562
   $$0 = 282; //@line 3563
   STACKTOP = sp; //@line 3564
   return $$0 | 0; //@line 3564
  }
 case 53:
  {
   $129 = HEAP32[$3 >> 2] | 0; //@line 3568
   $130 = HEAP32[$129 >> 2] | 0; //@line 3569
   HEAP32[$129 >> 2] = $130 + -1; //@line 3571
   if (!$130) $139 = _luaZ_fill($129) | 0; //@line 3575
 else {
    $133 = $129 + 4 | 0; //@line 3577
    $134 = HEAP32[$133 >> 2] | 0; //@line 3578
    HEAP32[$133 >> 2] = $134 + 1; //@line 3580
    $139 = HEAPU8[$134 >> 0] | 0; //@line 3583
   }
   HEAP32[$ls >> 2] = $139; //@line 3585
   if (($139 | 0) != 61) {
    $$0 = 126; //@line 3588
    STACKTOP = sp; //@line 3589
    return $$0 | 0; //@line 3589
   }
   $141 = HEAP32[$3 >> 2] | 0; //@line 3591
   $142 = HEAP32[$141 >> 2] | 0; //@line 3592
   HEAP32[$141 >> 2] = $142 + -1; //@line 3594
   if (!$142) $151 = _luaZ_fill($141) | 0; //@line 3598
 else {
    $145 = $141 + 4 | 0; //@line 3600
    $146 = HEAP32[$145 >> 2] | 0; //@line 3601
    HEAP32[$145 >> 2] = $146 + 1; //@line 3603
    $151 = HEAPU8[$146 >> 0] | 0; //@line 3606
   }
   HEAP32[$ls >> 2] = $151; //@line 3608
   $$0 = 284; //@line 3609
   STACKTOP = sp; //@line 3610
   return $$0 | 0; //@line 3610
  }
 case 61:
  {
   $152 = HEAP32[$3 >> 2] | 0; //@line 3614
   $153 = HEAP32[$152 >> 2] | 0; //@line 3615
   HEAP32[$152 >> 2] = $153 + -1; //@line 3617
   if (!$153) $162 = _luaZ_fill($152) | 0; //@line 3621
 else {
    $156 = $152 + 4 | 0; //@line 3623
    $157 = HEAP32[$156 >> 2] | 0; //@line 3624
    HEAP32[$156 >> 2] = $157 + 1; //@line 3626
    $162 = HEAPU8[$157 >> 0] | 0; //@line 3629
   }
   HEAP32[$ls >> 2] = $162; //@line 3631
   if (($162 | 0) != 58) {
    $$0 = 58; //@line 3634
    STACKTOP = sp; //@line 3635
    return $$0 | 0; //@line 3635
   }
   $164 = HEAP32[$3 >> 2] | 0; //@line 3637
   $165 = HEAP32[$164 >> 2] | 0; //@line 3638
   HEAP32[$164 >> 2] = $165 + -1; //@line 3640
   if (!$165) $174 = _luaZ_fill($164) | 0; //@line 3644
 else {
    $168 = $164 + 4 | 0; //@line 3646
    $169 = HEAP32[$168 >> 2] | 0; //@line 3647
    HEAP32[$168 >> 2] = $169 + 1; //@line 3649
    $174 = HEAPU8[$169 >> 0] | 0; //@line 3652
   }
   HEAP32[$ls >> 2] = $174; //@line 3654
   $$0 = 285; //@line 3655
   STACKTOP = sp; //@line 3656
   return $$0 | 0; //@line 3656
  }
 case 69:
  {
   $175 = HEAP32[$0 >> 2] | 0; //@line 3660
   $176 = $175 + 4 | 0; //@line 3661
   $177 = HEAP32[$176 >> 2] | 0; //@line 3662
   $179 = $175 + 8 | 0; //@line 3664
   $180 = HEAP32[$179 >> 2] | 0; //@line 3665
   do if (($177 + 1 | 0) >>> 0 > $180 >>> 0) {
    if ($180 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 3671
    $183 = $180 << 1; //@line 3674
    $186 = HEAP32[$ls + 52 >> 2] | 0; //@line 3677
    if (($183 | 0) == -2) _luaM_toobig($186); //@line 3679
 else {
     $188 = _luaM_realloc_($186, HEAP32[$175 >> 2] | 0, $180, $183) | 0; //@line 3683
     HEAP32[$175 >> 2] = $188; //@line 3684
     HEAP32[$179 >> 2] = $183; //@line 3685
     $191 = HEAP32[$176 >> 2] | 0; //@line 3687
     $193 = $188; //@line 3687
     break;
    }
   } else {
    $191 = $177; //@line 3692
    $193 = HEAP32[$175 >> 2] | 0; //@line 3692
   } while (0);
   $189 = $4 & 255; //@line 3695
   HEAP32[$176 >> 2] = $191 + 1; //@line 3697
   HEAP8[$193 + $191 >> 0] = $189; //@line 3699
   $194 = HEAP32[$3 >> 2] | 0; //@line 3700
   $195 = HEAP32[$194 >> 2] | 0; //@line 3701
   HEAP32[$194 >> 2] = $195 + -1; //@line 3703
   if (!$195) $204 = _luaZ_fill($194) | 0; //@line 3707
 else {
    $198 = $194 + 4 | 0; //@line 3709
    $199 = HEAP32[$198 >> 2] | 0; //@line 3710
    HEAP32[$198 >> 2] = $199 + 1; //@line 3712
    $204 = HEAPU8[$199 >> 0] | 0; //@line 3715
   }
   HEAP32[$ls >> 2] = $204; //@line 3717
   L178 : do if (($204 | 0) != ($4 | 0)) {
    $206 = $ls + 52 | 0; //@line 3721
    $346 = $204; //@line 3722
    L180 : while (1) {
     L182 : do if (($346 | 0) == -1) {
      label = 82; //@line 3726
      break L180;
     } else if (($346 | 0) == 13 | ($346 | 0) == 10) {
      label = 83; //@line 3729
      break L180;
     } else if (($346 | 0) == 92) {
      $207 = HEAP32[$3 >> 2] | 0; //@line 3732
      $208 = HEAP32[$207 >> 2] | 0; //@line 3733
      HEAP32[$207 >> 2] = $208 + -1; //@line 3735
      if (!$208) $217 = _luaZ_fill($207) | 0; //@line 3739
 else {
       $211 = $207 + 4 | 0; //@line 3741
       $212 = HEAP32[$211 >> 2] | 0; //@line 3742
       HEAP32[$211 >> 2] = $212 + 1; //@line 3744
       $217 = HEAPU8[$212 >> 0] | 0; //@line 3747
      }
      HEAP32[$ls >> 2] = $217; //@line 3749
      do switch ($217 | 0) {
      case 39:
      case 34:
      case 92:
       {
        $c$0$i = $217; //@line 3753
        label = 124; //@line 3754
        break;
       }
      case 122:
       {
        $242 = HEAP32[$3 >> 2] | 0; //@line 3758
        $243 = HEAP32[$242 >> 2] | 0; //@line 3759
        HEAP32[$242 >> 2] = $243 + -1; //@line 3761
        if (!$243) $252 = _luaZ_fill($242) | 0; //@line 3765
 else {
         $246 = $242 + 4 | 0; //@line 3767
         $247 = HEAP32[$246 >> 2] | 0; //@line 3768
         HEAP32[$246 >> 2] = $247 + 1; //@line 3770
         $252 = HEAPU8[$247 >> 0] | 0; //@line 3773
        }
        HEAP32[$ls >> 2] = $252; //@line 3775
        if (!(HEAP8[$252 + 2697 >> 0] & 8)) {
         $$be21$i = $252; //@line 3782
         break L182;
        } else $825 = $252; //@line 3785
        while (1) {
         if (($825 | 0) == 13 | ($825 | 0) == 10) {
          _inclinenumber($ls); //@line 3789
          $$be$i = HEAP32[$ls >> 2] | 0; //@line 3791
         } else {
          $258 = HEAP32[$3 >> 2] | 0; //@line 3793
          $259 = HEAP32[$258 >> 2] | 0; //@line 3794
          HEAP32[$258 >> 2] = $259 + -1; //@line 3796
          if (!$259) $268 = _luaZ_fill($258) | 0; //@line 3800
 else {
           $262 = $258 + 4 | 0; //@line 3802
           $263 = HEAP32[$262 >> 2] | 0; //@line 3803
           HEAP32[$262 >> 2] = $263 + 1; //@line 3805
           $268 = HEAPU8[$263 >> 0] | 0; //@line 3808
          }
          HEAP32[$ls >> 2] = $268; //@line 3810
          $$be$i = $268; //@line 3811
         }
         if (!(HEAP8[$$be$i + 2697 >> 0] & 8)) {
          $$be21$i = $$be$i; //@line 3819
          break L182;
         } else $825 = $$be$i; //@line 3822
        }
        break;
       }
      case 97:
       {
        $c$0$i = 7; //@line 3828
        label = 124; //@line 3829
        break;
       }
      case 13:
      case 10:
       {
        _inclinenumber($ls); //@line 3833
        $c$1$i = 10; //@line 3834
        break;
       }
      case -1:
       {
        $$be21$i = -1; //@line 3838
        break L182;
        break;
       }
      case 98:
       {
        $c$0$i = 8; //@line 3843
        label = 124; //@line 3844
        break;
       }
      case 102:
       {
        $c$0$i = 12; //@line 3848
        label = 124; //@line 3849
        break;
       }
      case 110:
       {
        $c$0$i = 10; //@line 3853
        label = 124; //@line 3854
        break;
       }
      case 114:
       {
        $c$0$i = 13; //@line 3858
        label = 124; //@line 3859
        break;
       }
      case 116:
       {
        $c$0$i = 9; //@line 3863
        label = 124; //@line 3864
        break;
       }
      case 118:
       {
        $c$0$i = 11; //@line 3868
        label = 124; //@line 3869
        break;
       }
      case 120:
       {
        HEAP32[$c$i$i >> 2] = 120; //@line 3873
        $i$03$i$i = 1; //@line 3874
        $r$04$i$i = 0; //@line 3874
        while (1) {
         $219 = HEAP32[$3 >> 2] | 0; //@line 3876
         $220 = HEAP32[$219 >> 2] | 0; //@line 3877
         HEAP32[$219 >> 2] = $220 + -1; //@line 3879
         if (!$220) $229 = _luaZ_fill($219) | 0; //@line 3883
 else {
          $223 = $219 + 4 | 0; //@line 3885
          $224 = HEAP32[$223 >> 2] | 0; //@line 3886
          HEAP32[$223 >> 2] = $224 + 1; //@line 3888
          $229 = HEAPU8[$224 >> 0] | 0; //@line 3891
         }
         HEAP32[$ls >> 2] = $229; //@line 3893
         HEAP32[$c$i$i + ($i$03$i$i << 2) >> 2] = $229; //@line 3895
         if (!(HEAP8[$229 + 2697 >> 0] & 16)) {
          label = 100; //@line 3902
          break L180;
         }
         $239 = (_luaO_hexavalue($229) | 0) + ($r$04$i$i << 4) | 0; //@line 3907
         $240 = $i$03$i$i + 1 | 0; //@line 3908
         if (($240 | 0) < 3) {
          $i$03$i$i = $240; //@line 3911
          $r$04$i$i = $239; //@line 3911
         } else {
          $c$0$i = $239; //@line 3913
          label = 124; //@line 3914
          break;
         }
        }
        break;
       }
      default:
       {
        if (!(HEAP8[$217 + 2697 >> 0] & 2)) {
         label = 116; //@line 3927
         break L180;
        } else {
         $280 = $217; //@line 3930
         $i$01$i$i = 0; //@line 3930
         $r$02$i$i = 0; //@line 3930
        }
        while (1) {
         if (!(HEAP8[$280 + 2697 >> 0] & 2)) {
          $i$0$lcssa$i$i = $i$01$i$i; //@line 3939
          $r$0$lcssa$i$i = $r$02$i$i; //@line 3939
          break;
         }
         HEAP32[$c$i$i + ($i$01$i$i << 2) >> 2] = $280; //@line 3943
         $288 = $280 + -48 + ($r$02$i$i * 10 | 0) | 0; //@line 3946
         $289 = HEAP32[$3 >> 2] | 0; //@line 3947
         $290 = HEAP32[$289 >> 2] | 0; //@line 3948
         HEAP32[$289 >> 2] = $290 + -1; //@line 3950
         if (!$290) $299 = _luaZ_fill($289) | 0; //@line 3954
 else {
          $293 = $289 + 4 | 0; //@line 3956
          $294 = HEAP32[$293 >> 2] | 0; //@line 3957
          HEAP32[$293 >> 2] = $294 + 1; //@line 3959
          $299 = HEAPU8[$294 >> 0] | 0; //@line 3962
         }
         HEAP32[$ls >> 2] = $299; //@line 3964
         $300 = $i$01$i$i + 1 | 0; //@line 3965
         if (($300 | 0) < 3) {
          $280 = $299; //@line 3968
          $i$01$i$i = $300; //@line 3968
          $r$02$i$i = $288; //@line 3968
         } else {
          $i$0$lcssa$i$i = $300; //@line 3970
          $r$0$lcssa$i$i = $288; //@line 3970
          break;
         }
        }
        if (($r$0$lcssa$i$i | 0) > 255) {
         label = 123; //@line 3976
         break L180;
        } else $c$1$i = $r$0$lcssa$i$i; //@line 3979
       }
      } while (0);
      if ((label | 0) == 124) {
       label = 0; //@line 3985
       $303 = HEAP32[$3 >> 2] | 0; //@line 3986
       $304 = HEAP32[$303 >> 2] | 0; //@line 3987
       HEAP32[$303 >> 2] = $304 + -1; //@line 3989
       if (!$304) $313 = _luaZ_fill($303) | 0; //@line 3993
 else {
        $307 = $303 + 4 | 0; //@line 3995
        $308 = HEAP32[$307 >> 2] | 0; //@line 3996
        HEAP32[$307 >> 2] = $308 + 1; //@line 3998
        $313 = HEAPU8[$308 >> 0] | 0; //@line 4001
       }
       HEAP32[$ls >> 2] = $313; //@line 4003
       $c$1$i = $c$0$i; //@line 4004
      }
      $314 = HEAP32[$0 >> 2] | 0; //@line 4006
      $315 = $314 + 4 | 0; //@line 4007
      $316 = HEAP32[$315 >> 2] | 0; //@line 4008
      $318 = $314 + 8 | 0; //@line 4010
      $319 = HEAP32[$318 >> 2] | 0; //@line 4011
      if (($316 + 1 | 0) >>> 0 > $319 >>> 0) {
       if ($319 >>> 0 > 2147483645) {
        label = 131; //@line 4016
        break L180;
       }
       $322 = $319 << 1; //@line 4019
       $324 = HEAP32[$206 >> 2] | 0; //@line 4021
       if (($322 | 0) == -2) {
        label = 133; //@line 4023
        break L180;
       }
       $326 = _luaM_realloc_($324, HEAP32[$314 >> 2] | 0, $319, $322) | 0; //@line 4027
       HEAP32[$314 >> 2] = $326; //@line 4028
       HEAP32[$318 >> 2] = $322; //@line 4029
       $329 = HEAP32[$315 >> 2] | 0; //@line 4031
       $331 = $326; //@line 4031
      } else {
       $329 = $316; //@line 4034
       $331 = HEAP32[$314 >> 2] | 0; //@line 4034
      }
      HEAP32[$315 >> 2] = $329 + 1; //@line 4038
      HEAP8[$331 + $329 >> 0] = $c$1$i; //@line 4040
      $$be21$i = HEAP32[$ls >> 2] | 0; //@line 4042
     } else {
      $332 = HEAP32[$0 >> 2] | 0; //@line 4044
      $333 = $332 + 4 | 0; //@line 4045
      $334 = HEAP32[$333 >> 2] | 0; //@line 4046
      $336 = $332 + 8 | 0; //@line 4048
      $337 = HEAP32[$336 >> 2] | 0; //@line 4049
      if (($334 + 1 | 0) >>> 0 > $337 >>> 0) {
       if ($337 >>> 0 > 2147483645) {
        label = 139; //@line 4054
        break L180;
       }
       $340 = $337 << 1; //@line 4057
       $342 = HEAP32[$206 >> 2] | 0; //@line 4059
       if (($340 | 0) == -2) {
        label = 141; //@line 4061
        break L180;
       }
       $344 = _luaM_realloc_($342, HEAP32[$332 >> 2] | 0, $337, $340) | 0; //@line 4065
       HEAP32[$332 >> 2] = $344; //@line 4066
       HEAP32[$336 >> 2] = $340; //@line 4067
       $348 = HEAP32[$333 >> 2] | 0; //@line 4069
       $350 = $344; //@line 4069
      } else {
       $348 = $334; //@line 4072
       $350 = HEAP32[$332 >> 2] | 0; //@line 4072
      }
      HEAP32[$333 >> 2] = $348 + 1; //@line 4076
      HEAP8[$350 + $348 >> 0] = $346; //@line 4078
      $351 = HEAP32[$3 >> 2] | 0; //@line 4079
      $352 = HEAP32[$351 >> 2] | 0; //@line 4080
      HEAP32[$351 >> 2] = $352 + -1; //@line 4082
      if (!$352) $361 = _luaZ_fill($351) | 0; //@line 4086
 else {
       $355 = $351 + 4 | 0; //@line 4088
       $356 = HEAP32[$355 >> 2] | 0; //@line 4089
       HEAP32[$355 >> 2] = $356 + 1; //@line 4091
       $361 = HEAPU8[$356 >> 0] | 0; //@line 4094
      }
      HEAP32[$ls >> 2] = $361; //@line 4096
      $$be21$i = $361; //@line 4097
     } while (0);
     if (($$be21$i | 0) == ($4 | 0)) break L178; else $346 = $$be21$i; //@line 4104
    }
    if ((label | 0) == 82) _lexerror($ls, 5920, 286); //@line 4108
 else if ((label | 0) == 83) _lexerror($ls, 5920, 289); //@line 4112
 else if ((label | 0) == 100) _escerror($ls, $c$i$i, $i$03$i$i + 1 | 0, 6e3); //@line 4117
 else if ((label | 0) == 116) _escerror($ls, $ls, 1, 5944); //@line 4121
 else if ((label | 0) == 123) _escerror($ls, $c$i$i, $i$0$lcssa$i$i, 5968); //@line 4125
 else if ((label | 0) == 131) _lexerror($ls, 5888, 0); //@line 4129
 else if ((label | 0) == 133) _luaM_toobig($324); //@line 4133
 else if ((label | 0) == 139) _lexerror($ls, 5888, 0); //@line 4137
 else if ((label | 0) == 141) _luaM_toobig($342); //@line 4141
   } while (0);
   $362 = HEAP32[$0 >> 2] | 0; //@line 4146
   $363 = $362 + 4 | 0; //@line 4147
   $364 = HEAP32[$363 >> 2] | 0; //@line 4148
   $366 = $362 + 8 | 0; //@line 4150
   $367 = HEAP32[$366 >> 2] | 0; //@line 4151
   do if (($364 + 1 | 0) >>> 0 > $367 >>> 0) {
    if ($367 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4157
    $370 = $367 << 1; //@line 4160
    $373 = HEAP32[$ls + 52 >> 2] | 0; //@line 4163
    if (($370 | 0) == -2) _luaM_toobig($373); //@line 4165
 else {
     $375 = _luaM_realloc_($373, HEAP32[$362 >> 2] | 0, $367, $370) | 0; //@line 4169
     HEAP32[$362 >> 2] = $375; //@line 4170
     HEAP32[$366 >> 2] = $370; //@line 4171
     $377 = HEAP32[$363 >> 2] | 0; //@line 4173
     $379 = $375; //@line 4173
     break;
    }
   } else {
    $377 = $364; //@line 4178
    $379 = HEAP32[$362 >> 2] | 0; //@line 4178
   } while (0);
   HEAP32[$363 >> 2] = $377 + 1; //@line 4182
   HEAP8[$379 + $377 >> 0] = $189; //@line 4184
   $380 = HEAP32[$3 >> 2] | 0; //@line 4185
   $381 = HEAP32[$380 >> 2] | 0; //@line 4186
   HEAP32[$380 >> 2] = $381 + -1; //@line 4188
   if (!$381) $390 = _luaZ_fill($380) | 0; //@line 4192
 else {
    $384 = $380 + 4 | 0; //@line 4194
    $385 = HEAP32[$384 >> 2] | 0; //@line 4195
    HEAP32[$384 >> 2] = $385 + 1; //@line 4197
    $390 = HEAPU8[$385 >> 0] | 0; //@line 4200
   }
   HEAP32[$ls >> 2] = $390; //@line 4202
   $391 = HEAP32[$0 >> 2] | 0; //@line 4203
   $398 = HEAP32[$ls + 52 >> 2] | 0; //@line 4210
   $399 = _luaS_newlstr($398, (HEAP32[$391 >> 2] | 0) + 1 | 0, (HEAP32[$391 + 4 >> 2] | 0) + -2 | 0) | 0; //@line 4211
   $400 = $398 + 8 | 0; //@line 4212
   $401 = HEAP32[$400 >> 2] | 0; //@line 4213
   HEAP32[$400 >> 2] = $401 + 16; //@line 4215
   HEAP32[$401 >> 2] = $399; //@line 4216
   HEAP32[$401 + 8 >> 2] = HEAPU8[$399 + 4 >> 0] | 64; //@line 4222
   $414 = _luaH_set($398, HEAP32[(HEAP32[$ls + 48 >> 2] | 0) + 4 >> 2] | 0, (HEAP32[$400 >> 2] | 0) + -16 | 0) | 0; //@line 4229
   $415 = $414 + 8 | 0; //@line 4230
   if (!(HEAP32[$415 >> 2] | 0)) {
    HEAP32[$414 >> 2] = 1; //@line 4234
    HEAP32[$415 >> 2] = 1; //@line 4235
    if ((HEAP32[(HEAP32[$398 + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) {
     _luaC_step($398); //@line 4242
     $ts$0$i$i = $399; //@line 4243
    } else $ts$0$i$i = $399; //@line 4245
   } else $ts$0$i$i = HEAP32[$414 + 16 >> 2] | 0; //@line 4250
   HEAP32[$400 >> 2] = (HEAP32[$400 >> 2] | 0) + -16; //@line 4254
   HEAP32[$seminfo >> 2] = $ts$0$i$i; //@line 4255
   $$0 = 289; //@line 4256
   STACKTOP = sp; //@line 4257
   return $$0 | 0; //@line 4257
  }
 case 162:
  {
   $427 = HEAP32[$0 >> 2] | 0; //@line 4261
   $428 = $427 + 4 | 0; //@line 4262
   $429 = HEAP32[$428 >> 2] | 0; //@line 4263
   $431 = $427 + 8 | 0; //@line 4265
   $432 = HEAP32[$431 >> 2] | 0; //@line 4266
   do if (($429 + 1 | 0) >>> 0 > $432 >>> 0) {
    if ($432 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4272
    $435 = $432 << 1; //@line 4275
    $438 = HEAP32[$ls + 52 >> 2] | 0; //@line 4278
    if (($435 | 0) == -2) _luaM_toobig($438); //@line 4280
 else {
     $440 = _luaM_realloc_($438, HEAP32[$427 >> 2] | 0, $432, $435) | 0; //@line 4284
     HEAP32[$427 >> 2] = $440; //@line 4285
     HEAP32[$431 >> 2] = $435; //@line 4286
     $442 = HEAP32[$428 >> 2] | 0; //@line 4288
     $444 = $440; //@line 4288
     break;
    }
   } else {
    $442 = $429; //@line 4293
    $444 = HEAP32[$427 >> 2] | 0; //@line 4293
   } while (0);
   HEAP32[$428 >> 2] = $442 + 1; //@line 4297
   HEAP8[$444 + $442 >> 0] = 46; //@line 4299
   $445 = HEAP32[$3 >> 2] | 0; //@line 4300
   $446 = HEAP32[$445 >> 2] | 0; //@line 4301
   HEAP32[$445 >> 2] = $446 + -1; //@line 4303
   if (!$446) $$pr28 = _luaZ_fill($445) | 0; //@line 4307
 else {
    $449 = $445 + 4 | 0; //@line 4309
    $450 = HEAP32[$449 >> 2] | 0; //@line 4310
    HEAP32[$449 >> 2] = $450 + 1; //@line 4312
    $$pr28 = HEAPU8[$450 >> 0] | 0; //@line 4315
   }
   HEAP32[$ls >> 2] = $$pr28; //@line 4317
   if ($$pr28) if (_memchr(5824, $$pr28, 2) | 0) {
    $457 = HEAP32[$0 >> 2] | 0; //@line 4323
    $458 = $457 + 4 | 0; //@line 4324
    $459 = HEAP32[$458 >> 2] | 0; //@line 4325
    $461 = $457 + 8 | 0; //@line 4327
    $462 = HEAP32[$461 >> 2] | 0; //@line 4328
    do if (($459 + 1 | 0) >>> 0 > $462 >>> 0) {
     if ($462 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4334
     $465 = $462 << 1; //@line 4337
     $468 = HEAP32[$ls + 52 >> 2] | 0; //@line 4340
     if (($465 | 0) == -2) _luaM_toobig($468); //@line 4342
 else {
      $470 = _luaM_realloc_($468, HEAP32[$457 >> 2] | 0, $462, $465) | 0; //@line 4346
      HEAP32[$457 >> 2] = $470; //@line 4347
      HEAP32[$461 >> 2] = $465; //@line 4348
      $473 = HEAP32[$458 >> 2] | 0; //@line 4350
      $475 = $470; //@line 4350
      break;
     }
    } else {
     $473 = $459; //@line 4355
     $475 = HEAP32[$457 >> 2] | 0; //@line 4355
    } while (0);
    HEAP32[$458 >> 2] = $473 + 1; //@line 4360
    HEAP8[$475 + $473 >> 0] = $$pr28; //@line 4362
    $476 = HEAP32[$3 >> 2] | 0; //@line 4363
    $477 = HEAP32[$476 >> 2] | 0; //@line 4364
    HEAP32[$476 >> 2] = $477 + -1; //@line 4366
    if (!$477) $486 = _luaZ_fill($476) | 0; //@line 4370
 else {
     $480 = $476 + 4 | 0; //@line 4372
     $481 = HEAP32[$480 >> 2] | 0; //@line 4373
     HEAP32[$480 >> 2] = $481 + 1; //@line 4375
     $486 = HEAPU8[$481 >> 0] | 0; //@line 4378
    }
    HEAP32[$ls >> 2] = $486; //@line 4380
    if (!$486) {
     $$0 = 279; //@line 4383
     STACKTOP = sp; //@line 4384
     return $$0 | 0; //@line 4384
    }
    if (!(_memchr(5824, $486, 2) | 0)) {
     $$0 = 279; //@line 4389
     STACKTOP = sp; //@line 4390
     return $$0 | 0; //@line 4390
    }
    $489 = HEAP32[$0 >> 2] | 0; //@line 4392
    $490 = $489 + 4 | 0; //@line 4393
    $491 = HEAP32[$490 >> 2] | 0; //@line 4394
    $493 = $489 + 8 | 0; //@line 4396
    $494 = HEAP32[$493 >> 2] | 0; //@line 4397
    do if (($491 + 1 | 0) >>> 0 > $494 >>> 0) {
     if ($494 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4403
     $497 = $494 << 1; //@line 4406
     $500 = HEAP32[$ls + 52 >> 2] | 0; //@line 4409
     if (($497 | 0) == -2) _luaM_toobig($500); //@line 4411
 else {
      $502 = _luaM_realloc_($500, HEAP32[$489 >> 2] | 0, $494, $497) | 0; //@line 4415
      HEAP32[$489 >> 2] = $502; //@line 4416
      HEAP32[$493 >> 2] = $497; //@line 4417
      $505 = HEAP32[$490 >> 2] | 0; //@line 4419
      $507 = $502; //@line 4419
      break;
     }
    } else {
     $505 = $491; //@line 4424
     $507 = HEAP32[$489 >> 2] | 0; //@line 4424
    } while (0);
    HEAP32[$490 >> 2] = $505 + 1; //@line 4429
    HEAP8[$507 + $505 >> 0] = $486; //@line 4431
    $508 = HEAP32[$3 >> 2] | 0; //@line 4432
    $509 = HEAP32[$508 >> 2] | 0; //@line 4433
    HEAP32[$508 >> 2] = $509 + -1; //@line 4435
    if (!$509) $518 = _luaZ_fill($508) | 0; //@line 4439
 else {
     $512 = $508 + 4 | 0; //@line 4441
     $513 = HEAP32[$512 >> 2] | 0; //@line 4442
     HEAP32[$512 >> 2] = $513 + 1; //@line 4444
     $518 = HEAPU8[$513 >> 0] | 0; //@line 4447
    }
    HEAP32[$ls >> 2] = $518; //@line 4449
    $$0 = 280; //@line 4450
    STACKTOP = sp; //@line 4451
    return $$0 | 0; //@line 4451
   }
   if (!(HEAP8[$$pr28 + 2697 >> 0] & 2)) {
    $$0 = 46; //@line 4460
    STACKTOP = sp; //@line 4461
    return $$0 | 0; //@line 4461
   } else $539 = $$pr28; //@line 4463
   break;
  }
 case 284:
  {
   if (!(HEAP8[$4 + 2697 >> 0] & 1)) {
    $813 = HEAP32[$3 >> 2] | 0; //@line 4474
    $814 = HEAP32[$813 >> 2] | 0; //@line 4475
    HEAP32[$813 >> 2] = $814 + -1; //@line 4477
    if (!$814) $823 = _luaZ_fill($813) | 0; //@line 4481
 else {
     $817 = $813 + 4 | 0; //@line 4483
     $818 = HEAP32[$817 >> 2] | 0; //@line 4484
     HEAP32[$817 >> 2] = $818 + 1; //@line 4486
     $823 = HEAPU8[$818 >> 0] | 0; //@line 4489
    }
    HEAP32[$ls >> 2] = $823; //@line 4491
    $$0 = $4; //@line 4492
    STACKTOP = sp; //@line 4493
    return $$0 | 0; //@line 4493
   }
   $736 = $ls + 52 | 0; //@line 4495
   $751 = $4; //@line 4496
   while (1) {
    $737 = HEAP32[$0 >> 2] | 0; //@line 4498
    $738 = $737 + 4 | 0; //@line 4499
    $739 = HEAP32[$738 >> 2] | 0; //@line 4500
    $741 = $737 + 8 | 0; //@line 4502
    $742 = HEAP32[$741 >> 2] | 0; //@line 4503
    if (($739 + 1 | 0) >>> 0 > $742 >>> 0) {
     if ($742 >>> 0 > 2147483645) {
      label = 289; //@line 4508
      break;
     }
     $745 = $742 << 1; //@line 4511
     $747 = HEAP32[$736 >> 2] | 0; //@line 4513
     if (($745 | 0) == -2) {
      label = 291; //@line 4515
      break;
     }
     $749 = _luaM_realloc_($747, HEAP32[$737 >> 2] | 0, $742, $745) | 0; //@line 4519
     HEAP32[$737 >> 2] = $749; //@line 4520
     HEAP32[$741 >> 2] = $745; //@line 4521
     $753 = HEAP32[$738 >> 2] | 0; //@line 4523
     $755 = $749; //@line 4523
    } else {
     $753 = $739; //@line 4526
     $755 = HEAP32[$737 >> 2] | 0; //@line 4526
    }
    HEAP32[$738 >> 2] = $753 + 1; //@line 4530
    HEAP8[$755 + $753 >> 0] = $751; //@line 4532
    $756 = HEAP32[$3 >> 2] | 0; //@line 4533
    $757 = HEAP32[$756 >> 2] | 0; //@line 4534
    HEAP32[$756 >> 2] = $757 + -1; //@line 4536
    if (!$757) $766 = _luaZ_fill($756) | 0; //@line 4540
 else {
     $760 = $756 + 4 | 0; //@line 4542
     $761 = HEAP32[$760 >> 2] | 0; //@line 4543
     HEAP32[$760 >> 2] = $761 + 1; //@line 4545
     $766 = HEAPU8[$761 >> 0] | 0; //@line 4548
    }
    HEAP32[$ls >> 2] = $766; //@line 4550
    if (!(HEAP8[$766 + 2697 >> 0] & 3)) {
     label = 297; //@line 4557
     break;
    } else $751 = $766; //@line 4560
   }
   if ((label | 0) == 289) _lexerror($ls, 5888, 0); //@line 4564
 else if ((label | 0) == 291) _luaM_toobig($747); //@line 4568
 else if ((label | 0) == 297) {
    $772 = HEAP32[$0 >> 2] | 0; //@line 4572
    $776 = HEAP32[$736 >> 2] | 0; //@line 4576
    $777 = _luaS_newlstr($776, HEAP32[$772 >> 2] | 0, HEAP32[$772 + 4 >> 2] | 0) | 0; //@line 4577
    $778 = $776 + 8 | 0; //@line 4578
    $779 = HEAP32[$778 >> 2] | 0; //@line 4579
    HEAP32[$778 >> 2] = $779 + 16; //@line 4581
    HEAP32[$779 >> 2] = $777; //@line 4582
    HEAP32[$779 + 8 >> 2] = HEAPU8[$777 + 4 >> 0] | 64; //@line 4588
    $792 = _luaH_set($776, HEAP32[(HEAP32[$ls + 48 >> 2] | 0) + 4 >> 2] | 0, (HEAP32[$778 >> 2] | 0) + -16 | 0) | 0; //@line 4595
    $793 = $792 + 8 | 0; //@line 4596
    if (!(HEAP32[$793 >> 2] | 0)) {
     HEAP32[$792 >> 2] = 1; //@line 4600
     HEAP32[$793 >> 2] = 1; //@line 4601
     if ((HEAP32[(HEAP32[$776 + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) {
      _luaC_step($776); //@line 4608
      $ts$0$i = $777; //@line 4609
     } else $ts$0$i = $777; //@line 4611
    } else $ts$0$i = HEAP32[$792 + 16 >> 2] | 0; //@line 4616
    HEAP32[$778 >> 2] = (HEAP32[$778 >> 2] | 0) + -16; //@line 4620
    HEAP32[$seminfo >> 2] = $ts$0$i; //@line 4621
    if ((HEAP8[$ts$0$i + 4 >> 0] | 0) != 4) {
     $$0 = 288; //@line 4626
     STACKTOP = sp; //@line 4627
     return $$0 | 0; //@line 4627
    }
    $809 = HEAP8[$ts$0$i + 6 >> 0] | 0; //@line 4630
    if (!($809 << 24 >> 24)) {
     $$0 = 288; //@line 4633
     STACKTOP = sp; //@line 4634
     return $$0 | 0; //@line 4634
    }
    $$0 = $809 & 255 | 256; //@line 4638
    STACKTOP = sp; //@line 4639
    return $$0 | 0; //@line 4639
   }
   break;
  }
 case 308:
  {
   STACKTOP = sp; //@line 4644
   return $$0 | 0; //@line 4644
  }
 }
 $524 = HEAP32[$0 >> 2] | 0; //@line 4648
 $525 = $524 + 4 | 0; //@line 4649
 $526 = HEAP32[$525 >> 2] | 0; //@line 4650
 $528 = $524 + 8 | 0; //@line 4652
 $529 = HEAP32[$528 >> 2] | 0; //@line 4653
 do if (($526 + 1 | 0) >>> 0 > $529 >>> 0) {
  if ($529 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4659
  $532 = $529 << 1; //@line 4662
  $535 = HEAP32[$ls + 52 >> 2] | 0; //@line 4665
  if (($532 | 0) == -2) _luaM_toobig($535); //@line 4667
 else {
   $537 = _luaM_realloc_($535, HEAP32[$524 >> 2] | 0, $529, $532) | 0; //@line 4671
   HEAP32[$524 >> 2] = $537; //@line 4672
   HEAP32[$528 >> 2] = $532; //@line 4673
   $541 = HEAP32[$525 >> 2] | 0; //@line 4675
   $543 = $537; //@line 4675
   break;
  }
 } else {
  $541 = $526; //@line 4680
  $543 = HEAP32[$524 >> 2] | 0; //@line 4680
 } while (0);
 HEAP32[$525 >> 2] = $541 + 1; //@line 4685
 HEAP8[$543 + $541 >> 0] = $539; //@line 4687
 $544 = HEAP32[$3 >> 2] | 0; //@line 4688
 $545 = HEAP32[$544 >> 2] | 0; //@line 4689
 HEAP32[$544 >> 2] = $545 + -1; //@line 4691
 if (!$545) $554 = _luaZ_fill($544) | 0; //@line 4695
 else {
  $548 = $544 + 4 | 0; //@line 4697
  $549 = HEAP32[$548 >> 2] | 0; //@line 4698
  HEAP32[$548 >> 2] = $549 + 1; //@line 4700
  $554 = HEAPU8[$549 >> 0] | 0; //@line 4703
 }
 HEAP32[$ls >> 2] = $554; //@line 4705
 if (($539 | 0) == 48) if (!$554) {
  $$ph$i = 0; //@line 4710
  $expo$0$ph$i = 5832; //@line 4710
 } else if (!(_memchr(5840, $554, 3) | 0)) {
  $$ph$i = $554; //@line 4715
  $expo$0$ph$i = 5832; //@line 4715
 } else {
  $558 = HEAP32[$0 >> 2] | 0; //@line 4717
  $559 = $558 + 4 | 0; //@line 4718
  $560 = HEAP32[$559 >> 2] | 0; //@line 4719
  $562 = $558 + 8 | 0; //@line 4721
  $563 = HEAP32[$562 >> 2] | 0; //@line 4722
  do if (($560 + 1 | 0) >>> 0 > $563 >>> 0) {
   if ($563 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 4728
   $566 = $563 << 1; //@line 4731
   $569 = HEAP32[$ls + 52 >> 2] | 0; //@line 4734
   if (($566 | 0) == -2) _luaM_toobig($569); //@line 4736
 else {
    $571 = _luaM_realloc_($569, HEAP32[$558 >> 2] | 0, $563, $566) | 0; //@line 4740
    HEAP32[$558 >> 2] = $571; //@line 4741
    HEAP32[$562 >> 2] = $566; //@line 4742
    $574 = HEAP32[$559 >> 2] | 0; //@line 4744
    $576 = $571; //@line 4744
    break;
   }
  } else {
   $574 = $560; //@line 4749
   $576 = HEAP32[$558 >> 2] | 0; //@line 4749
  } while (0);
  HEAP32[$559 >> 2] = $574 + 1; //@line 4754
  HEAP8[$576 + $574 >> 0] = $554; //@line 4756
  $577 = HEAP32[$3 >> 2] | 0; //@line 4757
  $578 = HEAP32[$577 >> 2] | 0; //@line 4758
  HEAP32[$577 >> 2] = $578 + -1; //@line 4760
  if (!$578) $587 = _luaZ_fill($577) | 0; //@line 4764
 else {
   $581 = $577 + 4 | 0; //@line 4766
   $582 = HEAP32[$581 >> 2] | 0; //@line 4767
   HEAP32[$581 >> 2] = $582 + 1; //@line 4769
   $587 = HEAPU8[$582 >> 0] | 0; //@line 4772
  }
  HEAP32[$ls >> 2] = $587; //@line 4774
  $$ph$i = $587; //@line 4775
  $expo$0$ph$i = 5848; //@line 4775
 } else {
  $$ph$i = $554; //@line 4779
  $expo$0$ph$i = 5832; //@line 4779
 }
 $588 = $ls + 52 | 0; //@line 4781
 $590 = $$ph$i; //@line 4782
 while (1) {
  if (!$590) $653 = 0; //@line 4786
 else if (!(_memchr($expo$0$ph$i, $590, 3) | 0)) $653 = $590; //@line 4791
 else {
   $592 = HEAP32[$0 >> 2] | 0; //@line 4793
   $593 = $592 + 4 | 0; //@line 4794
   $594 = HEAP32[$593 >> 2] | 0; //@line 4795
   $596 = $592 + 8 | 0; //@line 4797
   $597 = HEAP32[$596 >> 2] | 0; //@line 4798
   if (($594 + 1 | 0) >>> 0 > $597 >>> 0) {
    if ($597 >>> 0 > 2147483645) {
     label = 228; //@line 4803
     break;
    }
    $600 = $597 << 1; //@line 4806
    $602 = HEAP32[$588 >> 2] | 0; //@line 4808
    if (($600 | 0) == -2) {
     label = 230; //@line 4810
     break;
    }
    $604 = _luaM_realloc_($602, HEAP32[$592 >> 2] | 0, $597, $600) | 0; //@line 4814
    HEAP32[$592 >> 2] = $604; //@line 4815
    HEAP32[$596 >> 2] = $600; //@line 4816
    $607 = HEAP32[$593 >> 2] | 0; //@line 4818
    $609 = $604; //@line 4818
   } else {
    $607 = $594; //@line 4821
    $609 = HEAP32[$592 >> 2] | 0; //@line 4821
   }
   HEAP32[$593 >> 2] = $607 + 1; //@line 4825
   HEAP8[$609 + $607 >> 0] = $590; //@line 4827
   $610 = HEAP32[$3 >> 2] | 0; //@line 4828
   $611 = HEAP32[$610 >> 2] | 0; //@line 4829
   HEAP32[$610 >> 2] = $611 + -1; //@line 4831
   if (!$611) $620 = _luaZ_fill($610) | 0; //@line 4835
 else {
    $614 = $610 + 4 | 0; //@line 4837
    $615 = HEAP32[$614 >> 2] | 0; //@line 4838
    HEAP32[$614 >> 2] = $615 + 1; //@line 4840
    $620 = HEAPU8[$615 >> 0] | 0; //@line 4843
   }
   HEAP32[$ls >> 2] = $620; //@line 4845
   if (!$620) $653 = 0; //@line 4848
 else if (!(_memchr(5856, $620, 3) | 0)) $653 = $620; //@line 4853
 else {
    $623 = HEAP32[$0 >> 2] | 0; //@line 4855
    $624 = $623 + 4 | 0; //@line 4856
    $625 = HEAP32[$624 >> 2] | 0; //@line 4857
    $627 = $623 + 8 | 0; //@line 4859
    $628 = HEAP32[$627 >> 2] | 0; //@line 4860
    if (($625 + 1 | 0) >>> 0 > $628 >>> 0) {
     if ($628 >>> 0 > 2147483645) {
      label = 240; //@line 4865
      break;
     }
     $631 = $628 << 1; //@line 4868
     $633 = HEAP32[$588 >> 2] | 0; //@line 4870
     if (($631 | 0) == -2) {
      label = 242; //@line 4872
      break;
     }
     $635 = _luaM_realloc_($633, HEAP32[$623 >> 2] | 0, $628, $631) | 0; //@line 4876
     HEAP32[$623 >> 2] = $635; //@line 4877
     HEAP32[$627 >> 2] = $631; //@line 4878
     $638 = HEAP32[$624 >> 2] | 0; //@line 4880
     $640 = $635; //@line 4880
    } else {
     $638 = $625; //@line 4883
     $640 = HEAP32[$623 >> 2] | 0; //@line 4883
    }
    HEAP32[$624 >> 2] = $638 + 1; //@line 4887
    HEAP8[$640 + $638 >> 0] = $620; //@line 4889
    $641 = HEAP32[$3 >> 2] | 0; //@line 4890
    $642 = HEAP32[$641 >> 2] | 0; //@line 4891
    HEAP32[$641 >> 2] = $642 + -1; //@line 4893
    if (!$642) $651 = _luaZ_fill($641) | 0; //@line 4897
 else {
     $645 = $641 + 4 | 0; //@line 4899
     $646 = HEAP32[$645 >> 2] | 0; //@line 4900
     HEAP32[$645 >> 2] = $646 + 1; //@line 4902
     $651 = HEAPU8[$646 >> 0] | 0; //@line 4905
    }
    HEAP32[$ls >> 2] = $651; //@line 4907
    $653 = $651; //@line 4908
   }
  }
  $659 = HEAP32[$0 >> 2] | 0; //@line 4920
  $660 = $659 + 4 | 0; //@line 4921
  $661 = HEAP32[$660 >> 2] | 0; //@line 4922
  $663 = $659 + 8 | 0; //@line 4924
  $664 = HEAP32[$663 >> 2] | 0; //@line 4925
  $665 = ($661 + 1 | 0) >>> 0 > $664 >>> 0; //@line 4926
  if (!((HEAP8[$653 + 2697 >> 0] & 16) != 0 | ($653 | 0) == 46)) {
   label = 260; //@line 4928
   break;
  }
  if ($665) {
   if ($664 >>> 0 > 2147483645) {
    label = 252; //@line 4934
    break;
   }
   $667 = $664 << 1; //@line 4937
   $669 = HEAP32[$588 >> 2] | 0; //@line 4939
   if (($667 | 0) == -2) {
    label = 254; //@line 4941
    break;
   }
   $671 = _luaM_realloc_($669, HEAP32[$659 >> 2] | 0, $664, $667) | 0; //@line 4945
   HEAP32[$659 >> 2] = $671; //@line 4946
   HEAP32[$663 >> 2] = $667; //@line 4947
   $674 = HEAP32[$660 >> 2] | 0; //@line 4949
   $676 = $671; //@line 4949
  } else {
   $674 = $661; //@line 4952
   $676 = HEAP32[$659 >> 2] | 0; //@line 4952
  }
  HEAP32[$660 >> 2] = $674 + 1; //@line 4956
  HEAP8[$676 + $674 >> 0] = $653; //@line 4958
  $677 = HEAP32[$3 >> 2] | 0; //@line 4959
  $678 = HEAP32[$677 >> 2] | 0; //@line 4960
  HEAP32[$677 >> 2] = $678 + -1; //@line 4962
  if (!$678) $687 = _luaZ_fill($677) | 0; //@line 4966
 else {
   $681 = $677 + 4 | 0; //@line 4968
   $682 = HEAP32[$681 >> 2] | 0; //@line 4969
   HEAP32[$681 >> 2] = $682 + 1; //@line 4971
   $687 = HEAPU8[$682 >> 0] | 0; //@line 4974
  }
  HEAP32[$ls >> 2] = $687; //@line 4976
  $590 = $687; //@line 4977
 }
 if ((label | 0) == 228) _lexerror($ls, 5888, 0); //@line 4980
 else if ((label | 0) == 230) _luaM_toobig($602); //@line 4984
 else if ((label | 0) == 240) _lexerror($ls, 5888, 0); //@line 4988
 else if ((label | 0) == 242) _luaM_toobig($633); //@line 4992
 else if ((label | 0) == 252) _lexerror($ls, 5888, 0); //@line 4996
 else if ((label | 0) == 254) _luaM_toobig($669); //@line 5000
 else if ((label | 0) == 260) {
  do if ($665) {
   if ($664 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 5008
   $689 = $664 << 1; //@line 5011
   $691 = HEAP32[$588 >> 2] | 0; //@line 5013
   if (($689 | 0) == -2) _luaM_toobig($691); //@line 5015
 else {
    $693 = _luaM_realloc_($691, HEAP32[$659 >> 2] | 0, $664, $689) | 0; //@line 5019
    HEAP32[$659 >> 2] = $693; //@line 5020
    HEAP32[$663 >> 2] = $689; //@line 5021
    $695 = HEAP32[$660 >> 2] | 0; //@line 5023
    $697 = $693; //@line 5023
    break;
   }
  } else {
   $695 = $661; //@line 5028
   $697 = HEAP32[$659 >> 2] | 0; //@line 5028
  } while (0);
  HEAP32[$660 >> 2] = $695 + 1; //@line 5032
  HEAP8[$697 + $695 >> 0] = 0; //@line 5034
  $698 = $ls + 76 | 0; //@line 5035
  $699 = HEAP8[$698 >> 0] | 0; //@line 5036
  $ls$idx$val$i = HEAP32[$0 >> 2] | 0; //@line 5037
  $ls$idx$val$idx$val$i = HEAP32[$ls$idx$val$i >> 2] | 0; //@line 5038
  $ls$idx$val$idx1$val$i = HEAP32[$ls$idx$val$i + 4 >> 2] | 0; //@line 5040
  if (!$ls$idx$val$idx1$val$i) {
   $706 = $ls$idx$val$idx$val$i; //@line 5043
   $707 = -1; //@line 5043
  } else {
   $$in$i$i = $ls$idx$val$idx1$val$i; //@line 5045
   do {
    $$in$i$i = $$in$i$i + -1 | 0; //@line 5047
    $702 = $ls$idx$val$idx$val$i + $$in$i$i | 0; //@line 5048
    if ((HEAP8[$702 >> 0] | 0) == 46) HEAP8[$702 >> 0] = $699; //@line 5052
   } while (($$in$i$i | 0) != 0);
   $$pre$i10 = HEAP32[$0 >> 2] | 0; //@line 5061
   $706 = HEAP32[$$pre$i10 >> 2] | 0; //@line 5066
   $707 = (HEAP32[$$pre$i10 + 4 >> 2] | 0) + -1 | 0; //@line 5066
  }
  if (_luaO_str2d($706, $707, $seminfo) | 0) {
   $$0 = 287; //@line 5071
   STACKTOP = sp; //@line 5072
   return $$0 | 0; //@line 5072
  }
  $710 = HEAP8[$698 >> 0] | 0; //@line 5074
  $713 = HEAP8[HEAP32[(_localeconv() | 0) >> 2] >> 0] | 0; //@line 5077
  HEAP8[$698 >> 0] = $713; //@line 5078
  $ls$idx1$val$i$i = HEAP32[$0 >> 2] | 0; //@line 5079
  $ls$idx1$val$idx$val$i$i = HEAP32[$ls$idx1$val$i$i >> 2] | 0; //@line 5080
  $ls$idx1$val$idx2$val$i$i = HEAP32[$ls$idx1$val$i$i + 4 >> 2] | 0; //@line 5082
  if (!$ls$idx1$val$idx2$val$i$i) {
   $720 = $ls$idx1$val$idx$val$i$i; //@line 5085
   $721 = -1; //@line 5085
  } else {
   $$in$i$i$i = $ls$idx1$val$idx2$val$i$i; //@line 5087
   do {
    $$in$i$i$i = $$in$i$i$i + -1 | 0; //@line 5089
    $716 = $ls$idx1$val$idx$val$i$i + $$in$i$i$i | 0; //@line 5090
    if ((HEAP8[$716 >> 0] | 0) == $710 << 24 >> 24) HEAP8[$716 >> 0] = $713; //@line 5094
   } while (($$in$i$i$i | 0) != 0);
   $$pre$i17$i = HEAP32[$0 >> 2] | 0; //@line 5103
   $720 = HEAP32[$$pre$i17$i >> 2] | 0; //@line 5108
   $721 = (HEAP32[$$pre$i17$i + 4 >> 2] | 0) + -1 | 0; //@line 5108
  }
  if (_luaO_str2d($720, $721, $seminfo) | 0) {
   $$0 = 287; //@line 5113
   STACKTOP = sp; //@line 5114
   return $$0 | 0; //@line 5114
  }
  $724 = HEAP8[$698 >> 0] | 0; //@line 5116
  $ls$idx$val$i$i = HEAP32[$0 >> 2] | 0; //@line 5117
  $ls$idx$val$idx$val$i$i = HEAP32[$ls$idx$val$i$i >> 2] | 0; //@line 5118
  $ls$idx$val$idx3$val$i$i = HEAP32[$ls$idx$val$i$i + 4 >> 2] | 0; //@line 5120
  if (!$ls$idx$val$idx3$val$i$i) _lexerror($ls, 5864, 287); //@line 5123
 else $$in$i4$i$i = $ls$idx$val$idx3$val$i$i; //@line 5126
  do {
   $$in$i4$i$i = $$in$i4$i$i + -1 | 0; //@line 5129
   $727 = $ls$idx$val$idx$val$i$i + $$in$i4$i$i | 0; //@line 5130
   if ((HEAP8[$727 >> 0] | 0) == $724 << 24 >> 24) HEAP8[$727 >> 0] = 46; //@line 5134
  } while (($$in$i4$i$i | 0) != 0);
  _lexerror($ls, 5864, 287); //@line 5143
 }
 return 0; //@line 5146
}
function _luaV_execute($L) {
 $L = $L | 0;
 var $$pre$phi$iZ2D = 0, $$pre151 = 0, $$pre153 = 0, $$sum = 0, $$sum10 = 0, $$sum13 = 0, $$sum14 = 0, $$sum19 = 0, $$sum3 = 0, $$sum47 = 0, $$sum6 = 0, $$sum7 = 0, $$sum8 = 0, $$sum9 = 0, $0 = 0, $100 = 0, $1017 = 0, $1018 = 0, $1028 = 0, $1029 = 0, $1038 = 0, $1042 = 0, $1046 = 0, $1051 = 0, $1052 = 0, $1060 = 0, $1061 = 0, $107 = 0, $109 = 0, $11 = 0, $114 = 0, $115 = 0, $12 = 0, $122 = 0, $125 = 0, $127 = 0, $132 = 0, $133 = 0, $15 = 0, $155 = 0, $156 = 0, $16 = 0, $161 = 0, $162 = 0, $174 = 0, $18 = 0, $181 = 0, $185 = 0, $19 = 0, $192 = 0, $198 = 0, $2 = 0, $20 = 0, $204 = 0, $21 = 0, $211 = 0, $212 = 0, $216 = 0, $218 = 0, $219 = 0, $224 = 0, $225 = 0, $229 = 0, $23 = 0, $235 = 0, $24 = 0, $244 = 0, $250 = 0, $257 = 0, $258 = 0, $260 = 0, $262 = 0, $263 = 0, $267 = 0, $276 = 0, $277 = 0, $279 = 0, $28 = 0, $284 = 0, $285 = 0, $29 = 0, $292 = 0, $299 = 0, $3 = 0, $301 = 0, $307 = 0, $315 = 0, $319 = 0, $32 = 0, $327 = 0, $33 = 0, $333 = 0, $341 = 0, $345 = 0, $353 = 0, $359 = 0, $367 = 0, $37 = 0, $371 = 0, $379 = 0, $385 = 0, $39 = 0, $393 = 0, $397 = 0, $4 = 0, $405 = 0, $411 = 0, $419 = 0, $423 = 0, $426 = 0.0, $427 = 0.0, $434 = 0, $440 = 0, $448 = 0, $452 = 0, $460 = 0, $461 = 0, $469 = 0, $471 = 0, $478 = 0, $483 = 0, $485 = 0, $489 = 0, $49 = 0, $491 = 0, $492 = 0, $497 = 0, $498 = 0, $5 = 0, $50 = 0, $51 = 0, $511 = 0, $513 = 0, $522 = 0, $528 = 0, $536 = 0, $539 = 0, $545 = 0, $547 = 0, $549 = 0, $55 = 0, $551 = 0, $558 = 0, $560 = 0, $566 = 0, $573 = 0, $574 = 0, $576 = 0, $577 = 0, $579 = 0, $58 = 0, $581 = 0, $588 = 0, $590 = 0, $596 = 0, $6 = 0, $60 = 0, $603 = 0, $604 = 0, $606 = 0, $607 = 0, $609 = 0, $61 = 0, $611 = 0, $618 = 0, $623 = 0, $624 = 0, $633 = 0, $634 = 0, $636 = 0, $643 = 0, $644 = 0, $645 = 0, $649 = 0, $65 = 0, $650 = 0, $659 = 0, $664 = 0, $665 = 0, $670 = 0, $671 = 0, $673 = 0, $680 = 0, $681 = 0, $683 = 0, $692 = 0, $693 = 0, $698 = 0, $7 = 0, $704 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $717 = 0, $726 = 0, $727 = 0, $732 = 0, $733 = 0, $74 = 0, $745 = 0, $75 = 0, $754 = 0, $759 = 0, $764 = 0, $771 = 0, $776 = 0, $781 = 0.0, $783 = 0.0, $785 = 0.0, $79 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $803 = 0, $81 = 0, $811 = 0, $812 = 0, $816 = 0, $82 = 0, $823 = 0, $824 = 0, $828 = 0, $83 = 0, $84 = 0, $842 = 0, $845 = 0, $85 = 0, $850 = 0, $851 = 0, $86 = 0, $860 = 0, $865 = 0, $866 = 0, $873 = 0, $878 = 0, $879 = 0, $889 = 0, $89 = 0, $891 = 0, $893 = 0, $898 = 0, $9 = 0, $90 = 0, $901 = 0, $906 = 0, $907 = 0, $916 = 0, $918 = 0, $92 = 0, $927 = 0, $931 = 0, $934 = 0, $939 = 0, $94 = 0, $940 = 0, $962 = 0, $963 = 0, $964 = 0, $967 = 0, $975 = 0, $986 = 0, $987 = 0, $99 = 0, $991 = 0, $997 = 0, $aux$0101 = 0, $b$0 = 0, $b85$0 = 0, $base$0 = 0, $base$1 = 0, $base$2 = 0, $base$3 = 0, $c83$0 = 0, $ci$0 = 0, $i$0 = 0, $i$01$i = 0, $i$01$i59 = 0, $j$067 = 0, $last$069 = 0, $n$0 = 0, $n$168 = 0, $num$i = 0, $num$i51 = 0, $num$i54 = 0, $ra$0 = 0, $ra$1 = 0, $ra$2 = 0, $storemerge$in = 0, $storemerge38$in = 0, $storemerge42$in = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 3188
 STACKTOP = STACKTOP + 32 | 0; //@line 3189
 $vararg_buffer3 = sp + 24 | 0; //@line 3190
 $num$i54 = sp + 16 | 0; //@line 3191
 $num$i51 = sp + 8 | 0; //@line 3192
 $num$i = sp; //@line 3193
 $0 = $L + 16 | 0; //@line 3194
 $2 = $L + 40 | 0; //@line 3196
 $3 = $L + 12 | 0; //@line 3197
 $4 = $L + 8 | 0; //@line 3198
 $5 = $L + 24 | 0; //@line 3199
 $6 = $L + 48 | 0; //@line 3200
 $7 = $L + 20 | 0; //@line 3201
 $8 = $L + 6 | 0; //@line 3202
 $9 = $L + 44 | 0; //@line 3203
 $ci$0 = HEAP32[$0 >> 2] | 0; //@line 3204
 L1 : while (1) {
  $11 = HEAP32[HEAP32[$ci$0 >> 2] >> 2] | 0; //@line 3207
  $12 = $11 + 12 | 0; //@line 3208
  $15 = HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] | 0; //@line 3211
  $16 = $ci$0 + 24 | 0; //@line 3212
  $18 = $ci$0 + 28 | 0; //@line 3214
  $19 = $11 + 16 | 0; //@line 3215
  $20 = $ci$0 + 4 | 0; //@line 3216
  $base$0 = HEAP32[$16 >> 2] | 0; //@line 3217
  L3 : while (1) {
   $21 = HEAP32[$18 >> 2] | 0; //@line 3219
   HEAP32[$18 >> 2] = $21 + 4; //@line 3221
   $23 = HEAP32[$21 >> 2] | 0; //@line 3222
   $24 = HEAP8[$2 >> 0] | 0; //@line 3223
   do if (!($24 & 12)) $base$1 = $base$0; //@line 3228
 else {
    $28 = (HEAP32[$6 >> 2] | 0) + -1 | 0; //@line 3231
    HEAP32[$6 >> 2] = $28; //@line 3232
    $29 = ($28 | 0) == 0; //@line 3233
    if (!$29) if (!($24 & 4)) {
     $base$1 = $base$0; //@line 3238
     break;
    }
    $32 = HEAP32[$0 >> 2] | 0; //@line 3242
    $33 = $24 & 255; //@line 3243
    if (($33 & 8 | 0) == 0 | $29 ^ 1) $1061 = 0; //@line 3249
 else {
     HEAP32[$6 >> 2] = HEAP32[$9 >> 2]; //@line 3252
     $1061 = 1; //@line 3253
    }
    $37 = $32 + 18 | 0; //@line 3255
    $39 = HEAPU8[$37 >> 0] | 0; //@line 3257
    if (!($39 & 128)) {
     if ($1061) _luaD_hook($L, 3, -1); //@line 3262
     do if (!($33 & 4)) $$pre$phi$iZ2D = $32 + 28 | 0; //@line 3269
 else {
      $49 = HEAP32[(HEAP32[HEAP32[$32 >> 2] >> 2] | 0) + 12 >> 2] | 0; //@line 3274
      $50 = $32 + 28 | 0; //@line 3275
      $51 = HEAP32[$50 >> 2] | 0; //@line 3276
      $55 = HEAP32[$49 + 12 >> 2] | 0; //@line 3280
      $58 = ($51 - $55 >> 2) + -1 | 0; //@line 3283
      $60 = HEAP32[$49 + 20 >> 2] | 0; //@line 3285
      $61 = ($60 | 0) == 0; //@line 3286
      if ($61) $74 = 0; //@line 3288
 else $74 = HEAP32[$60 + ($58 << 2) >> 2] | 0; //@line 3292
      if ($58) {
       $65 = HEAP32[$7 >> 2] | 0; //@line 3296
       if ($51 >>> 0 > $65 >>> 0) {
        if ($61) $75 = 0; //@line 3300
 else $75 = HEAP32[$60 + (($65 - $55 >> 2) + -1 << 2) >> 2] | 0; //@line 3308
        if (($74 | 0) == ($75 | 0)) {
         $$pre$phi$iZ2D = $50; //@line 3312
         break;
        }
       }
      }
      _luaD_hook($L, 2, $74); //@line 3317
      $$pre$phi$iZ2D = $50; //@line 3318
     } while (0);
     HEAP32[$7 >> 2] = HEAP32[$$pre$phi$iZ2D >> 2]; //@line 3322
     if ((HEAP8[$8 >> 0] | 0) == 1) {
      label = 23; //@line 3326
      break L1;
     }
    } else HEAP8[$37 >> 0] = $39 & 127; //@line 3332
    $base$1 = HEAP32[$16 >> 2] | 0; //@line 3335
   } while (0);
   $89 = $23 >>> 6 & 255; //@line 3339
   $90 = $base$1 + ($89 << 4) | 0; //@line 3340
   do switch ($23 & 63 | 0) {
   case 27:
    {
     $623 = HEAP32[$base$1 + ($89 << 4) + 8 >> 2] | 0; //@line 3348
     $624 = ($623 | 0) == 0; //@line 3349
     if (!($23 & 8372224)) {
      if (!$624) if (($623 | 0) == 1) {
       if (HEAP32[$90 >> 2] | 0) label = 192; //@line 3357
      } else label = 192; //@line 3360
     } else if ($624) label = 192; //@line 3365
 else if (($623 | 0) == 1) if (!(HEAP32[$90 >> 2] | 0)) label = 192; //@line 3372
     if ((label | 0) == 192) {
      label = 0; //@line 3378
      HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + 4; //@line 3381
      $base$0 = $base$1; //@line 3382
      continue L3;
     }
     $633 = HEAP32[$18 >> 2] | 0; //@line 3385
     $634 = HEAP32[$633 >> 2] | 0; //@line 3386
     $636 = $634 >>> 6 & 255; //@line 3388
     if (!$636) $643 = $633; //@line 3391
 else {
      _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($636 + -1 << 4) | 0); //@line 3396
      $643 = HEAP32[$18 >> 2] | 0; //@line 3398
     }
     HEAP32[$18 >> 2] = $643 + (($634 >>> 14) + -131070 << 2); //@line 3403
     $base$0 = $base$1; //@line 3404
     continue L3;
     break;
    }
   case 26:
    {
     $590 = $23 >>> 23; //@line 3409
     if (!($590 & 256)) $603 = $base$1 + ($590 << 4) | 0; //@line 3414
 else $603 = $15 + (($590 & 255) << 4) | 0; //@line 3418
     $596 = $23 >>> 14; //@line 3420
     if (!($596 & 256)) $604 = $base$1 + (($596 & 511) << 4) | 0; //@line 3426
 else $604 = $15 + (($596 & 255) << 4) | 0; //@line 3430
     $606 = (_luaV_lessequal($L, $603, $604) | 0) == ($89 | 0); //@line 3433
     $607 = HEAP32[$18 >> 2] | 0; //@line 3434
     if ($606) {
      $609 = HEAP32[$607 >> 2] | 0; //@line 3436
      $611 = $609 >>> 6 & 255; //@line 3438
      if (!$611) $618 = $607; //@line 3441
 else {
       _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($611 + -1 << 4) | 0); //@line 3446
       $618 = HEAP32[$18 >> 2] | 0; //@line 3448
      }
      $storemerge$in = $618 + (($609 >>> 14) + -131070 << 2) | 0; //@line 3453
     } else $storemerge$in = $607 + 4 | 0; //@line 3456
     HEAP32[$18 >> 2] = $storemerge$in; //@line 3458
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3460
     continue L3;
     break;
    }
   case 14:
    {
     $327 = $23 >>> 23; //@line 3465
     if (!($327 & 256)) $341 = $base$1 + ($327 << 4) | 0; //@line 3470
 else $341 = $15 + (($327 & 255) << 4) | 0; //@line 3474
     $333 = $23 >>> 14; //@line 3476
     if (!($333 & 256)) $345 = $base$1 + (($333 & 511) << 4) | 0; //@line 3482
 else $345 = $15 + (($333 & 255) << 4) | 0; //@line 3486
     if ((HEAP32[$341 + 8 >> 2] | 0) == 3) if ((HEAP32[$345 + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = +HEAPF64[$341 >> 3] - +HEAPF64[$345 >> 3]; //@line 3499
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 3501
      $base$0 = $base$1; //@line 3502
      continue L3;
     }
     _luaV_arith($L, $90, $341, $345, 7); //@line 3506
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3508
     continue L3;
     break;
    }
   case 1:
    {
     $107 = $23 >>> 14; //@line 3513
     $109 = $15 + ($107 << 4) | 0; //@line 3515
     $114 = HEAP32[$109 + 4 >> 2] | 0; //@line 3520
     $115 = $90; //@line 3521
     HEAP32[$115 >> 2] = HEAP32[$109 >> 2]; //@line 3523
     HEAP32[$115 + 4 >> 2] = $114; //@line 3526
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = HEAP32[$15 + ($107 << 4) + 8 >> 2]; //@line 3530
     $base$0 = $base$1; //@line 3531
     continue L3;
     break;
    }
   case 4:
    {
     $b$0 = $23 >>> 23; //@line 3537
     $ra$0 = $90; //@line 3537
     while (1) {
      HEAP32[$ra$0 + 8 >> 2] = 0; //@line 3541
      if (!$b$0) {
       $base$0 = $base$1; //@line 3545
       continue L3;
      } else {
       $b$0 = $b$0 + -1 | 0; //@line 3548
       $ra$0 = $ra$0 + 16 | 0; //@line 3548
      }
     }
     break;
    }
   case 21:
    {
     _luaV_objlen($L, $90, $base$1 + ($23 >>> 23 << 4) | 0); //@line 3556
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3558
     continue L3;
     break;
    }
   case 13:
    {
     $301 = $23 >>> 23; //@line 3563
     if (!($301 & 256)) $315 = $base$1 + ($301 << 4) | 0; //@line 3568
 else $315 = $15 + (($301 & 255) << 4) | 0; //@line 3572
     $307 = $23 >>> 14; //@line 3574
     if (!($307 & 256)) $319 = $base$1 + (($307 & 511) << 4) | 0; //@line 3580
 else $319 = $15 + (($307 & 255) << 4) | 0; //@line 3584
     if ((HEAP32[$315 + 8 >> 2] | 0) == 3) if ((HEAP32[$319 + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = +HEAPF64[$315 >> 3] + +HEAPF64[$319 >> 3]; //@line 3597
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 3599
      $base$0 = $base$1; //@line 3600
      continue L3;
     }
     _luaV_arith($L, $90, $315, $319, 6); //@line 3604
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3606
     continue L3;
     break;
    }
   case 3:
    {
     HEAP32[$90 >> 2] = $23 >>> 23; //@line 3612
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 1; //@line 3614
     if (!($23 & 8372224)) {
      $base$0 = $base$1; //@line 3618
      continue L3;
     }
     HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + 4; //@line 3623
     $base$0 = $base$1; //@line 3624
     continue L3;
     break;
    }
   case 6:
    {
     $174 = $23 >>> 14; //@line 3634
     if (!($174 & 256)) $181 = $base$1 + (($174 & 511) << 4) | 0; //@line 3640
 else $181 = $15 + (($174 & 255) << 4) | 0; //@line 3644
     _luaV_gettable($L, HEAP32[(HEAP32[$19 + ($23 >>> 23 << 2) >> 2] | 0) + 8 >> 2] | 0, $181, $90); //@line 3646
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3648
     continue L3;
     break;
    }
   case 11:
    {
     $260 = $23 >>> 23; //@line 3653
     $262 = $23 >>> 14 & 511; //@line 3655
     $263 = _luaH_new($L) | 0; //@line 3656
     HEAP32[$90 >> 2] = $263; //@line 3657
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 69; //@line 3659
     if ($262 | $260) {
      $267 = _luaO_fb2int($260) | 0; //@line 3663
      _luaH_resize($L, $263, $267, _luaO_fb2int($262) | 0); //@line 3665
     }
     if ((HEAP32[(HEAP32[$3 >> 2] | 0) + 12 >> 2] | 0) > 0) {
      HEAP32[$4 >> 2] = $base$1 + ($89 + 1 << 4); //@line 3674
      _luaC_step($L); //@line 3675
      HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 3677
     }
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3680
     continue L3;
     break;
    }
   case 7:
    {
     $185 = $23 >>> 14; //@line 3687
     if (!($185 & 256)) $192 = $base$1 + (($185 & 511) << 4) | 0; //@line 3693
 else $192 = $15 + (($185 & 255) << 4) | 0; //@line 3697
     _luaV_gettable($L, $base$1 + ($23 >>> 23 << 4) | 0, $192, $90); //@line 3699
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3701
     continue L3;
     break;
    }
   case 20:
    {
     $469 = $23 >>> 23; //@line 3706
     $471 = HEAP32[$base$1 + ($469 << 4) + 8 >> 2] | 0; //@line 3708
     if (!$471) $478 = 1; //@line 3711
 else if (($471 | 0) == 1) $478 = (HEAP32[$base$1 + ($469 << 4) >> 2] | 0) == 0; //@line 3718
 else $478 = 0; //@line 3720
     HEAP32[$90 >> 2] = $478 & 1; //@line 3724
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 1; //@line 3726
     $base$0 = $base$1; //@line 3727
     continue L3;
     break;
    }
   case 10:
    {
     $244 = $23 >>> 23; //@line 3732
     if (!($244 & 256)) $257 = $base$1 + ($244 << 4) | 0; //@line 3737
 else $257 = $15 + (($244 & 255) << 4) | 0; //@line 3741
     $250 = $23 >>> 14; //@line 3743
     if (!($250 & 256)) $258 = $base$1 + (($250 & 511) << 4) | 0; //@line 3749
 else $258 = $15 + (($250 & 255) << 4) | 0; //@line 3753
     _luaV_settable($L, $90, $257, $258); //@line 3755
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3757
     continue L3;
     break;
    }
   case 17:
    {
     $405 = $23 >>> 23; //@line 3762
     if (!($405 & 256)) $419 = $base$1 + ($405 << 4) | 0; //@line 3767
 else $419 = $15 + (($405 & 255) << 4) | 0; //@line 3771
     $411 = $23 >>> 14; //@line 3773
     if (!($411 & 256)) $423 = $base$1 + (($411 & 511) << 4) | 0; //@line 3779
 else $423 = $15 + (($411 & 255) << 4) | 0; //@line 3783
     if ((HEAP32[$419 + 8 >> 2] | 0) == 3) if ((HEAP32[$423 + 8 >> 2] | 0) == 3) {
      $426 = +HEAPF64[$419 >> 3]; //@line 3793
      $427 = +HEAPF64[$423 >> 3]; //@line 3794
      HEAPF64[$90 >> 3] = $426 - $427 * +Math_floor(+($426 / $427)); //@line 3799
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 3801
      $base$0 = $base$1; //@line 3802
      continue L3;
     }
     _luaV_arith($L, $90, $419, $423, 10); //@line 3806
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3808
     continue L3;
     break;
    }
   case 25:
    {
     $560 = $23 >>> 23; //@line 3813
     if (!($560 & 256)) $573 = $base$1 + ($560 << 4) | 0; //@line 3818
 else $573 = $15 + (($560 & 255) << 4) | 0; //@line 3822
     $566 = $23 >>> 14; //@line 3824
     if (!($566 & 256)) $574 = $base$1 + (($566 & 511) << 4) | 0; //@line 3830
 else $574 = $15 + (($566 & 255) << 4) | 0; //@line 3834
     $576 = (_luaV_lessthan($L, $573, $574) | 0) == ($89 | 0); //@line 3837
     $577 = HEAP32[$18 >> 2] | 0; //@line 3838
     if ($576) {
      $579 = HEAP32[$577 >> 2] | 0; //@line 3840
      $581 = $579 >>> 6 & 255; //@line 3842
      if (!$581) $588 = $577; //@line 3845
 else {
       _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($581 + -1 << 4) | 0); //@line 3850
       $588 = HEAP32[$18 >> 2] | 0; //@line 3852
      }
      $storemerge38$in = $588 + (($579 >>> 14) + -131070 << 2) | 0; //@line 3857
     } else $storemerge38$in = $577 + 4 | 0; //@line 3860
     HEAP32[$18 >> 2] = $storemerge38$in; //@line 3862
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3864
     continue L3;
     break;
    }
   case 23:
    {
     if ($89) _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($89 + -1 << 4) | 0); //@line 3874
     HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + (($23 >>> 14) + -131071 << 2); //@line 3880
     $base$0 = $base$1; //@line 3881
     continue L3;
     break;
    }
   case 24:
    {
     $522 = $23 >>> 23; //@line 3886
     if (!($522 & 256)) $536 = $base$1 + ($522 << 4) | 0; //@line 3891
 else $536 = $15 + (($522 & 255) << 4) | 0; //@line 3895
     $528 = $23 >>> 14; //@line 3897
     if (!($528 & 256)) $539 = $base$1 + (($528 & 511) << 4) | 0; //@line 3903
 else $539 = $15 + (($528 & 255) << 4) | 0; //@line 3907
     if ((HEAP32[$536 + 8 >> 2] | 0) == (HEAP32[$539 + 8 >> 2] | 0)) $545 = (_luaV_equalobj_($L, $536, $539) | 0) != 0; //@line 3917
 else $545 = 0; //@line 3919
     $547 = HEAP32[$18 >> 2] | 0; //@line 3923
     if (($545 & 1 | 0) == ($89 | 0)) {
      $549 = HEAP32[$547 >> 2] | 0; //@line 3925
      $551 = $549 >>> 6 & 255; //@line 3927
      if (!$551) $558 = $547; //@line 3930
 else {
       _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($551 + -1 << 4) | 0); //@line 3935
       $558 = HEAP32[$18 >> 2] | 0; //@line 3937
      }
      $storemerge42$in = $558 + (($549 >>> 14) + -131070 << 2) | 0; //@line 3942
     } else $storemerge42$in = $547 + 4 | 0; //@line 3945
     HEAP32[$18 >> 2] = $storemerge42$in; //@line 3947
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 3949
     continue L3;
     break;
    }
   case 22:
    {
     $483 = $23 >>> 23; //@line 3954
     $485 = $23 >>> 14 & 511; //@line 3956
     HEAP32[$4 >> 2] = $base$1 + ($485 + 1 << 4); //@line 3959
     _luaV_concat($L, 1 - $483 + $485 | 0); //@line 3962
     $489 = HEAP32[$16 >> 2] | 0; //@line 3963
     $491 = $489 + ($483 << 4) | 0; //@line 3965
     $492 = $491; //@line 3966
     $497 = HEAP32[$492 + 4 >> 2] | 0; //@line 3971
     $498 = $489 + ($89 << 4) | 0; //@line 3972
     HEAP32[$498 >> 2] = HEAP32[$492 >> 2]; //@line 3974
     HEAP32[$498 + 4 >> 2] = $497; //@line 3977
     HEAP32[$489 + ($89 << 4) + 8 >> 2] = HEAP32[$489 + ($483 << 4) + 8 >> 2]; //@line 3981
     if ((HEAP32[(HEAP32[$3 >> 2] | 0) + 12 >> 2] | 0) > 0) {
      if ($89 >>> 0 < $483 >>> 0) $511 = $491; //@line 3989
 else $511 = $489 + ($89 + 1 << 4) | 0; //@line 3993
      HEAP32[$4 >> 2] = $511; //@line 3995
      _luaC_step($L); //@line 3996
      HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 3998
     }
     $513 = HEAP32[$16 >> 2] | 0; //@line 4000
     HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 4002
     $base$0 = $513; //@line 4003
     continue L3;
     break;
    }
   case 28:
    {
     $644 = $23 >>> 23; //@line 4008
     $645 = $base$1 + ($644 << 4) | 0; //@line 4009
     $649 = HEAP32[$base$1 + ($644 << 4) + 8 >> 2] | 0; //@line 4013
     $650 = ($649 | 0) == 0; //@line 4014
     if (!($23 & 8372224)) {
      if (!$650) if (($649 | 0) == 1) {
       if (HEAP32[$645 >> 2] | 0) label = 203; //@line 4022
      } else label = 203; //@line 4025
     } else if ($650) label = 203; //@line 4030
 else if (($649 | 0) == 1) if (!(HEAP32[$645 >> 2] | 0)) label = 203; //@line 4037
     if ((label | 0) == 203) {
      label = 0; //@line 4043
      HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + 4; //@line 4046
      $base$0 = $base$1; //@line 4047
      continue L3;
     }
     $659 = $645; //@line 4050
     $664 = HEAP32[$659 + 4 >> 2] | 0; //@line 4055
     $665 = $90; //@line 4056
     HEAP32[$665 >> 2] = HEAP32[$659 >> 2]; //@line 4058
     HEAP32[$665 + 4 >> 2] = $664; //@line 4061
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = $649; //@line 4063
     $670 = HEAP32[$18 >> 2] | 0; //@line 4064
     $671 = HEAP32[$670 >> 2] | 0; //@line 4065
     $673 = $671 >>> 6 & 255; //@line 4067
     if (!$673) $680 = $670; //@line 4070
 else {
      _luaF_close($L, (HEAP32[$16 >> 2] | 0) + ($673 + -1 << 4) | 0); //@line 4075
      $680 = HEAP32[$18 >> 2] | 0; //@line 4077
     }
     HEAP32[$18 >> 2] = $680 + (($671 >>> 14) + -131070 << 2); //@line 4082
     $base$0 = $base$1; //@line 4083
     continue L3;
     break;
    }
   case 29:
    {
     $681 = $23 >>> 23; //@line 4088
     $683 = $23 >>> 14 & 511; //@line 4090
     if ($681) HEAP32[$4 >> 2] = $base$1 + ($89 + $681 << 4); //@line 4096
     if (!(_luaD_precall($L, $90, $683 + -1 | 0) | 0)) {
      label = 213; //@line 4101
      break L3;
     }
     if ($683) HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 4107
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4110
     continue L3;
     break;
    }
   case 30:
    {
     $698 = $23 >>> 23; //@line 4115
     if ($698) HEAP32[$4 >> 2] = $base$1 + ($89 + $698 << 4); //@line 4120
     if (!(_luaD_precall($L, $90, -1) | 0)) {
      label = 218; //@line 4125
      break L3;
     }
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4129
     continue L3;
     break;
    }
   case 18:
    {
     $434 = $23 >>> 23; //@line 4134
     if (!($434 & 256)) $448 = $base$1 + ($434 << 4) | 0; //@line 4139
 else $448 = $15 + (($434 & 255) << 4) | 0; //@line 4143
     $440 = $23 >>> 14; //@line 4145
     if (!($440 & 256)) $452 = $base$1 + (($440 & 511) << 4) | 0; //@line 4151
 else $452 = $15 + (($440 & 255) << 4) | 0; //@line 4155
     if ((HEAP32[$448 + 8 >> 2] | 0) == 3) if ((HEAP32[$452 + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = +Math_pow(+(+HEAPF64[$448 >> 3]), +(+HEAPF64[$452 >> 3])); //@line 4168
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 4170
      $base$0 = $base$1; //@line 4171
      continue L3;
     }
     _luaV_arith($L, $90, $448, $452, 11); //@line 4175
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4177
     continue L3;
     break;
    }
   case 12:
    {
     $276 = $23 >>> 23; //@line 4182
     $277 = $base$1 + ($276 << 4) | 0; //@line 4183
     $$sum47 = $89 + 1 | 0; //@line 4184
     $279 = $277; //@line 4186
     $284 = HEAP32[$279 + 4 >> 2] | 0; //@line 4191
     $285 = $base$1 + ($$sum47 << 4) | 0; //@line 4192
     HEAP32[$285 >> 2] = HEAP32[$279 >> 2]; //@line 4194
     HEAP32[$285 + 4 >> 2] = $284; //@line 4197
     HEAP32[$base$1 + ($$sum47 << 4) + 8 >> 2] = HEAP32[$base$1 + ($276 << 4) + 8 >> 2]; //@line 4201
     $292 = $23 >>> 14; //@line 4202
     if (!($292 & 256)) $299 = $base$1 + (($292 & 511) << 4) | 0; //@line 4208
 else $299 = $15 + (($292 & 255) << 4) | 0; //@line 4212
     _luaV_gettable($L, $277, $299, $90); //@line 4214
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4216
     continue L3;
     break;
    }
   case 0:
    {
     $92 = $23 >>> 23; //@line 4221
     $94 = $base$1 + ($92 << 4) | 0; //@line 4223
     $99 = HEAP32[$94 + 4 >> 2] | 0; //@line 4228
     $100 = $90; //@line 4229
     HEAP32[$100 >> 2] = HEAP32[$94 >> 2]; //@line 4231
     HEAP32[$100 + 4 >> 2] = $99; //@line 4234
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = HEAP32[$base$1 + ($92 << 4) + 8 >> 2]; //@line 4238
     $base$0 = $base$1; //@line 4239
     continue L3;
     break;
    }
   case 15:
    {
     $353 = $23 >>> 23; //@line 4244
     if (!($353 & 256)) $367 = $base$1 + ($353 << 4) | 0; //@line 4249
 else $367 = $15 + (($353 & 255) << 4) | 0; //@line 4253
     $359 = $23 >>> 14; //@line 4255
     if (!($359 & 256)) $371 = $base$1 + (($359 & 511) << 4) | 0; //@line 4261
 else $371 = $15 + (($359 & 255) << 4) | 0; //@line 4265
     if ((HEAP32[$367 + 8 >> 2] | 0) == 3) if ((HEAP32[$371 + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = +HEAPF64[$367 >> 3] * +HEAPF64[$371 >> 3]; //@line 4278
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 4280
      $base$0 = $base$1; //@line 4281
      continue L3;
     }
     _luaV_arith($L, $90, $367, $371, 8); //@line 4285
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4287
     continue L3;
     break;
    }
   case 16:
    {
     $379 = $23 >>> 23; //@line 4292
     if (!($379 & 256)) $393 = $base$1 + ($379 << 4) | 0; //@line 4297
 else $393 = $15 + (($379 & 255) << 4) | 0; //@line 4301
     $385 = $23 >>> 14; //@line 4303
     if (!($385 & 256)) $397 = $base$1 + (($385 & 511) << 4) | 0; //@line 4309
 else $397 = $15 + (($385 & 255) << 4) | 0; //@line 4313
     if ((HEAP32[$393 + 8 >> 2] | 0) == 3) if ((HEAP32[$397 + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = +HEAPF64[$393 >> 3] / +HEAPF64[$397 >> 3]; //@line 4326
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 4328
      $base$0 = $base$1; //@line 4329
      continue L3;
     }
     _luaV_arith($L, $90, $393, $397, 9); //@line 4333
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4335
     continue L3;
     break;
    }
   case 5:
    {
     $155 = HEAP32[(HEAP32[$19 + ($23 >>> 23 << 2) >> 2] | 0) + 8 >> 2] | 0; //@line 4344
     $156 = $155; //@line 4345
     $161 = HEAP32[$156 + 4 >> 2] | 0; //@line 4350
     $162 = $90; //@line 4351
     HEAP32[$162 >> 2] = HEAP32[$156 >> 2]; //@line 4353
     HEAP32[$162 + 4 >> 2] = $161; //@line 4356
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = HEAP32[$155 + 8 >> 2]; //@line 4360
     $base$0 = $base$1; //@line 4361
     continue L3;
     break;
    }
   case 19:
    {
     $460 = $23 >>> 23; //@line 4366
     $461 = $base$1 + ($460 << 4) | 0; //@line 4367
     if ((HEAP32[$base$1 + ($460 << 4) + 8 >> 2] | 0) == 3) {
      HEAPF64[$90 >> 3] = -+HEAPF64[$461 >> 3]; //@line 4374
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 4376
      $base$0 = $base$1; //@line 4377
      continue L3;
     } else {
      _luaV_arith($L, $90, $461, $461, 12); //@line 4380
      $base$0 = HEAP32[$16 >> 2] | 0; //@line 4382
      continue L3;
     }
     break;
    }
   case 2:
    {
     $122 = HEAP32[$18 >> 2] | 0; //@line 4388
     HEAP32[$18 >> 2] = $122 + 4; //@line 4390
     $125 = (HEAP32[$122 >> 2] | 0) >>> 6; //@line 4392
     $127 = $15 + ($125 << 4) | 0; //@line 4394
     $132 = HEAP32[$127 + 4 >> 2] | 0; //@line 4399
     $133 = $90; //@line 4400
     HEAP32[$133 >> 2] = HEAP32[$127 >> 2]; //@line 4402
     HEAP32[$133 + 4 >> 2] = $132; //@line 4405
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = HEAP32[$15 + ($125 << 4) + 8 >> 2]; //@line 4409
     $base$0 = $base$1; //@line 4410
     continue L3;
     break;
    }
   case 8:
    {
     $198 = $23 >>> 23; //@line 4419
     if (!($198 & 256)) $211 = $base$1 + ($198 << 4) | 0; //@line 4424
 else $211 = $15 + (($198 & 255) << 4) | 0; //@line 4428
     $204 = $23 >>> 14; //@line 4430
     if (!($204 & 256)) $212 = $base$1 + (($204 & 511) << 4) | 0; //@line 4436
 else $212 = $15 + (($204 & 255) << 4) | 0; //@line 4440
     _luaV_settable($L, HEAP32[(HEAP32[$19 + ($89 << 2) >> 2] | 0) + 8 >> 2] | 0, $211, $212); //@line 4442
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4444
     continue L3;
     break;
    }
   case 9:
    {
     $216 = HEAP32[$19 + ($23 >>> 23 << 2) >> 2] | 0; //@line 4451
     $218 = HEAP32[$216 + 8 >> 2] | 0; //@line 4453
     $219 = $90; //@line 4454
     $224 = HEAP32[$219 + 4 >> 2] | 0; //@line 4459
     $225 = $218; //@line 4460
     HEAP32[$225 >> 2] = HEAP32[$219 >> 2]; //@line 4462
     HEAP32[$225 + 4 >> 2] = $224; //@line 4465
     $229 = $base$1 + ($89 << 4) + 8 | 0; //@line 4466
     HEAP32[$218 + 8 >> 2] = HEAP32[$229 >> 2]; //@line 4469
     if (!(HEAP32[$229 >> 2] & 64)) {
      $base$0 = $base$1; //@line 4474
      continue L3;
     }
     $235 = HEAP32[$90 >> 2] | 0; //@line 4477
     if (!(HEAP8[$235 + 5 >> 0] & 3)) {
      $base$0 = $base$1; //@line 4483
      continue L3;
     }
     if (!(HEAP8[$216 + 5 >> 0] & 4)) {
      $base$0 = $base$1; //@line 4491
      continue L3;
     }
     _luaC_barrier_($L, $216, $235); //@line 4494
     $base$0 = $base$1; //@line 4495
     continue L3;
     break;
    }
   case 31:
    {
     label = 223; //@line 4500
     break L3;
     break;
    }
   case 32:
    {
     $781 = +HEAPF64[$base$1 + ($89 + 2 << 4) >> 3]; //@line 4507
     $783 = $781 + +HEAPF64[$90 >> 3]; //@line 4509
     $785 = +HEAPF64[$base$1 + ($89 + 1 << 4) >> 3]; //@line 4512
     if ($781 > 0.0) {
      if (!($783 <= $785)) {
       $base$0 = $base$1; //@line 4517
       continue L3;
      }
     } else if (!($785 <= $783)) {
      $base$0 = $base$1; //@line 4523
      continue L3;
     }
     HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + (($23 >>> 14) + -131071 << 2); //@line 4531
     HEAPF64[$90 >> 3] = $783; //@line 4532
     HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 3; //@line 4534
     $$sum19 = $89 + 3 | 0; //@line 4535
     HEAPF64[$base$1 + ($$sum19 << 4) >> 3] = $783; //@line 4537
     HEAP32[$base$1 + ($$sum19 << 4) + 8 >> 2] = 3; //@line 4539
     $base$0 = $base$1; //@line 4540
     continue L3;
     break;
    }
   case 33:
    {
     $$sum13 = $89 + 1 | 0; //@line 4545
     $796 = $base$1 + ($$sum13 << 4) | 0; //@line 4546
     $$sum14 = $89 + 2 | 0; //@line 4547
     $797 = $base$1 + ($$sum14 << 4) | 0; //@line 4548
     $798 = $base$1 + ($89 << 4) + 8 | 0; //@line 4549
     $799 = HEAP32[$798 >> 2] | 0; //@line 4550
     if (($799 | 0) != 3) {
      if (($799 & 15 | 0) != 4) {
       label = 239; //@line 4556
       break L1;
      }
      $803 = HEAP32[$90 >> 2] | 0; //@line 4559
      if (!(_luaO_str2d($803 + 16 | 0, HEAP32[$803 + 12 >> 2] | 0, $num$i) | 0)) {
       label = 239; //@line 4566
       break L1;
      }
      HEAPF64[$90 >> 3] = +HEAPF64[$num$i >> 3]; //@line 4570
      HEAP32[$798 >> 2] = 3; //@line 4571
      if (!$90) {
       label = 239; //@line 4574
       break L1;
      }
     }
     $811 = $base$1 + ($$sum13 << 4) + 8 | 0; //@line 4578
     $812 = HEAP32[$811 >> 2] | 0; //@line 4579
     if (($812 | 0) != 3) {
      if (($812 & 15 | 0) != 4) {
       label = 244; //@line 4585
       break L1;
      }
      $816 = HEAP32[$796 >> 2] | 0; //@line 4588
      if (!(_luaO_str2d($816 + 16 | 0, HEAP32[$816 + 12 >> 2] | 0, $num$i51) | 0)) {
       label = 244; //@line 4595
       break L1;
      }
      HEAPF64[$796 >> 3] = +HEAPF64[$num$i51 >> 3]; //@line 4599
      HEAP32[$811 >> 2] = 3; //@line 4600
     }
     $823 = $base$1 + ($$sum14 << 4) + 8 | 0; //@line 4602
     $824 = HEAP32[$823 >> 2] | 0; //@line 4603
     if (($824 | 0) != 3) {
      if (($824 & 15 | 0) != 4) {
       label = 249; //@line 4609
       break L1;
      }
      $828 = HEAP32[$797 >> 2] | 0; //@line 4612
      if (!(_luaO_str2d($828 + 16 | 0, HEAP32[$828 + 12 >> 2] | 0, $num$i54) | 0)) {
       label = 249; //@line 4619
       break L1;
      }
      HEAPF64[$797 >> 3] = +HEAPF64[$num$i54 >> 3]; //@line 4623
      HEAP32[$823 >> 2] = 3; //@line 4624
     }
     HEAPF64[$90 >> 3] = +HEAPF64[$90 >> 3] - +HEAPF64[$797 >> 3]; //@line 4629
     HEAP32[$798 >> 2] = 3; //@line 4630
     HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + (($23 >>> 14) + -131071 << 2); //@line 4635
     $base$0 = $base$1; //@line 4636
     continue L3;
     break;
    }
   case 34:
    {
     $$sum6 = $89 + 3 | 0; //@line 4641
     $842 = $base$1 + ($$sum6 << 4) | 0; //@line 4642
     $$sum7 = $89 + 2 | 0; //@line 4643
     $$sum8 = $89 + 5 | 0; //@line 4645
     $845 = $base$1 + ($$sum7 << 4) | 0; //@line 4647
     $850 = HEAP32[$845 + 4 >> 2] | 0; //@line 4652
     $851 = $base$1 + ($$sum8 << 4) | 0; //@line 4653
     HEAP32[$851 >> 2] = HEAP32[$845 >> 2]; //@line 4655
     HEAP32[$851 + 4 >> 2] = $850; //@line 4658
     HEAP32[$base$1 + ($$sum8 << 4) + 8 >> 2] = HEAP32[$base$1 + ($$sum7 << 4) + 8 >> 2]; //@line 4662
     $$sum9 = $89 + 1 | 0; //@line 4663
     $$sum10 = $89 + 4 | 0; //@line 4665
     $860 = $base$1 + ($$sum9 << 4) | 0; //@line 4667
     $865 = HEAP32[$860 + 4 >> 2] | 0; //@line 4672
     $866 = $base$1 + ($$sum10 << 4) | 0; //@line 4673
     HEAP32[$866 >> 2] = HEAP32[$860 >> 2]; //@line 4675
     HEAP32[$866 + 4 >> 2] = $865; //@line 4678
     HEAP32[$base$1 + ($$sum10 << 4) + 8 >> 2] = HEAP32[$base$1 + ($$sum9 << 4) + 8 >> 2]; //@line 4682
     $873 = $90; //@line 4683
     $878 = HEAP32[$873 + 4 >> 2] | 0; //@line 4688
     $879 = $842; //@line 4689
     HEAP32[$879 >> 2] = HEAP32[$873 >> 2]; //@line 4691
     HEAP32[$879 + 4 >> 2] = $878; //@line 4694
     HEAP32[$base$1 + ($$sum6 << 4) + 8 >> 2] = HEAP32[$base$1 + ($89 << 4) + 8 >> 2]; //@line 4698
     HEAP32[$4 >> 2] = $base$1 + ($89 + 6 << 4); //@line 4701
     _luaD_call($L, $842, $23 >>> 14 & 511, 1); //@line 4704
     $889 = HEAP32[$16 >> 2] | 0; //@line 4705
     HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 4707
     $891 = HEAP32[$18 >> 2] | 0; //@line 4708
     HEAP32[$18 >> 2] = $891 + 4; //@line 4710
     $893 = HEAP32[$891 >> 2] | 0; //@line 4711
     $base$2 = $889; //@line 4715
     $i$0 = $893; //@line 4715
     $ra$1 = $889 + (($893 >>> 6 & 255) << 4) | 0; //@line 4715
     break;
    }
   case 35:
    {
     $base$2 = $base$1; //@line 4719
     $i$0 = $23; //@line 4719
     $ra$1 = $90; //@line 4719
     break;
    }
   case 36:
    {
     $916 = $23 >>> 23; //@line 4723
     $918 = $23 >>> 14 & 511; //@line 4725
     if (!$916) $n$0 = ((HEAP32[$4 >> 2] | 0) - $90 >> 4) + -1 | 0; //@line 4734
 else $n$0 = $916; //@line 4736
     if (!$918) {
      $927 = HEAP32[$18 >> 2] | 0; //@line 4740
      HEAP32[$18 >> 2] = $927 + 4; //@line 4742
      $c83$0 = (HEAP32[$927 >> 2] | 0) >>> 6; //@line 4745
     } else $c83$0 = $918; //@line 4747
     $931 = HEAP32[$90 >> 2] | 0; //@line 4749
     $934 = $n$0 + -50 + ($c83$0 * 50 | 0) | 0; //@line 4752
     if (($934 | 0) > (HEAP32[$931 + 28 >> 2] | 0)) _luaH_resizearray($L, $931, $934); //@line 4757
     if (($n$0 | 0) > 0) {
      $939 = $931 + 5 | 0; //@line 4761
      $last$069 = $934; //@line 4762
      $n$168 = $n$0; //@line 4762
      do {
       $$sum3 = $n$168 + $89 | 0; //@line 4764
       $940 = $base$1 + ($$sum3 << 4) | 0; //@line 4765
       _luaH_setint($L, $931, $last$069, $940); //@line 4767
       $last$069 = $last$069 + -1 | 0; //@line 4766
       if (HEAP32[$base$1 + ($$sum3 << 4) + 8 >> 2] & 64) if (HEAP8[(HEAP32[$940 >> 2] | 0) + 5 >> 0] & 3) if (HEAP8[$939 >> 0] & 4) _luaC_barrierback_($L, $931); //@line 4783
       $n$168 = $n$168 + -1 | 0; //@line 4787
      } while (($n$168 | 0) > 0);
     }
     HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 4797
     $base$0 = $base$1; //@line 4798
     continue L3;
     break;
    }
   case 37:
    {
     $962 = HEAP32[(HEAP32[(HEAP32[$12 >> 2] | 0) + 16 >> 2] | 0) + ($23 >>> 14 << 2) >> 2] | 0; //@line 4808
     $963 = $962 + 32 | 0; //@line 4809
     $964 = HEAP32[$963 >> 2] | 0; //@line 4810
     $$pre151 = HEAP32[$962 + 40 >> 2] | 0; //@line 4813
     $$pre153 = HEAP32[$962 + 28 >> 2] | 0; //@line 4815
     L323 : do if (!$964) label = 276; //@line 4818
 else {
      if (($$pre151 | 0) > 0) {
       $967 = $964 + 16 | 0; //@line 4822
       $i$01$i = 0; //@line 4823
       do {
        $975 = HEAPU8[$$pre153 + ($i$01$i << 3) + 5 >> 0] | 0; //@line 4830
        if (!(HEAP8[$$pre153 + ($i$01$i << 3) + 4 >> 0] | 0)) $986 = HEAP32[(HEAP32[$19 + ($975 << 2) >> 2] | 0) + 8 >> 2] | 0; //@line 4836
 else $986 = $base$1 + ($975 << 4) | 0; //@line 4839
        if ((HEAP32[(HEAP32[$967 + ($i$01$i << 2) >> 2] | 0) + 8 >> 2] | 0) != ($986 | 0)) {
         label = 276; //@line 4848
         break L323;
        }
        $i$01$i = $i$01$i + 1 | 0; //@line 4846
       } while (($i$01$i | 0) < ($$pre151 | 0));
      }
      HEAP32[$90 >> 2] = $964; //@line 4859
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 70; //@line 4861
     } while (0);
     if ((label | 0) == 276) {
      label = 0; //@line 4865
      $987 = _luaF_newLclosure($L, $$pre151) | 0; //@line 4866
      HEAP32[$987 + 12 >> 2] = $962; //@line 4868
      HEAP32[$90 >> 2] = $987; //@line 4869
      HEAP32[$base$1 + ($89 << 4) + 8 >> 2] = 70; //@line 4871
      if (($$pre151 | 0) > 0) {
       $991 = $987 + 16 | 0; //@line 4874
       $i$01$i59 = 0; //@line 4875
       do {
        $997 = HEAPU8[$$pre153 + ($i$01$i59 << 3) + 5 >> 0] | 0; //@line 4882
        if (!(HEAP8[$$pre153 + ($i$01$i59 << 3) + 4 >> 0] | 0)) HEAP32[$991 + ($i$01$i59 << 2) >> 2] = HEAP32[$19 + ($997 << 2) >> 2]; //@line 4887
 else HEAP32[$991 + ($i$01$i59 << 2) >> 2] = _luaF_findupval($L, $base$1 + ($997 << 4) | 0) | 0; //@line 4892
        $i$01$i59 = $i$01$i59 + 1 | 0; //@line 4894
       } while (($i$01$i59 | 0) != ($$pre151 | 0));
      }
      if (HEAP8[$962 + 5 >> 0] & 4) _luaC_barrierproto_($L, $962, $987); //@line 4908
      HEAP32[$963 >> 2] = $987; //@line 4910
     }
     if ((HEAP32[(HEAP32[$3 >> 2] | 0) + 12 >> 2] | 0) > 0) {
      HEAP32[$4 >> 2] = $base$1 + ($89 + 1 << 4); //@line 4919
      _luaC_step($L); //@line 4920
      HEAP32[$4 >> 2] = HEAP32[$20 >> 2]; //@line 4922
     }
     $base$0 = HEAP32[$16 >> 2] | 0; //@line 4925
     continue L3;
     break;
    }
   case 38:
    {
     $1017 = $23 >>> 23; //@line 4930
     $1018 = $1017 + -1 | 0; //@line 4931
     $1028 = ($base$1 - (HEAP32[$ci$0 >> 2] | 0) >> 4) - (HEAPU8[(HEAP32[$12 >> 2] | 0) + 76 >> 0] | 0) | 0; //@line 4941
     $1029 = $1028 + -1 | 0; //@line 4942
     if (!$1017) {
      if (((HEAP32[$5 >> 2] | 0) - (HEAP32[$4 >> 2] | 0) >> 4 | 0) <= ($1029 | 0)) _luaD_growstack($L, $1029); //@line 4953
      $1038 = HEAP32[$16 >> 2] | 0; //@line 4955
      HEAP32[$4 >> 2] = $1038 + ($1029 + $89 << 4); //@line 4959
      $b85$0 = $1029; //@line 4960
      $base$3 = $1038; //@line 4960
      $ra$2 = $1038 + ($89 << 4) | 0; //@line 4960
     } else {
      $b85$0 = $1018; //@line 4962
      $base$3 = $base$1; //@line 4962
      $ra$2 = $90; //@line 4962
     }
     if (($b85$0 | 0) <= 0) {
      $base$0 = $base$3; //@line 4966
      continue L3;
     }
     $1042 = 1 - $1028 | 0; //@line 4969
     $j$067 = 0; //@line 4970
     while (1) {
      if (($j$067 | 0) < ($1029 | 0)) {
       $$sum = $j$067 + $1042 | 0; //@line 4974
       $1046 = $base$3 + ($$sum << 4) | 0; //@line 4977
       $1051 = HEAP32[$1046 + 4 >> 2] | 0; //@line 4982
       $1052 = $ra$2 + ($j$067 << 4) | 0; //@line 4983
       HEAP32[$1052 >> 2] = HEAP32[$1046 >> 2]; //@line 4985
       HEAP32[$1052 + 4 >> 2] = $1051; //@line 4988
       HEAP32[$ra$2 + ($j$067 << 4) + 8 >> 2] = HEAP32[$base$3 + ($$sum << 4) + 8 >> 2]; //@line 4992
      } else HEAP32[$ra$2 + ($j$067 << 4) + 8 >> 2] = 0; //@line 4995
      $1060 = $j$067 + 1 | 0; //@line 4997
      if (($1060 | 0) == ($b85$0 | 0)) {
       $base$0 = $base$3; //@line 5000
       continue L3;
      } else $j$067 = $1060; //@line 5003
     }
     break;
    }
   default:
    {
     $base$0 = $base$1; //@line 5009
     continue L3;
    }
   } while (0);
   $898 = HEAP32[$ra$1 + 24 >> 2] | 0; //@line 5015
   if (!$898) {
    $base$0 = $base$2; //@line 5018
    continue;
   }
   $901 = $ra$1 + 16 | 0; //@line 5022
   $906 = HEAP32[$901 + 4 >> 2] | 0; //@line 5027
   $907 = $ra$1; //@line 5028
   HEAP32[$907 >> 2] = HEAP32[$901 >> 2]; //@line 5030
   HEAP32[$907 + 4 >> 2] = $906; //@line 5033
   HEAP32[$ra$1 + 8 >> 2] = $898; //@line 5035
   HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + (($i$0 >>> 14) + -131071 << 2); //@line 5040
   $base$0 = $base$2; //@line 5041
  }
  if ((label | 0) == 213) {
   label = 0; //@line 5044
   $692 = HEAP32[$0 >> 2] | 0; //@line 5045
   $693 = $692 + 18 | 0; //@line 5046
   HEAP8[$693 >> 0] = HEAPU8[$693 >> 0] | 4; //@line 5051
   $ci$0 = $692; //@line 5052
   continue;
  } else if ((label | 0) == 218) {
   label = 0; //@line 5056
   $704 = HEAP32[$0 >> 2] | 0; //@line 5057
   $706 = HEAP32[$704 + 8 >> 2] | 0; //@line 5059
   $707 = HEAP32[$704 >> 2] | 0; //@line 5060
   $708 = HEAP32[$706 >> 2] | 0; //@line 5061
   $709 = $704 + 24 | 0; //@line 5062
   $717 = (HEAP32[$709 >> 2] | 0) + (HEAPU8[(HEAP32[(HEAP32[$707 >> 2] | 0) + 12 >> 2] | 0) + 76 >> 0] << 4) | 0; //@line 5070
   if ((HEAP32[(HEAP32[$12 >> 2] | 0) + 56 >> 2] | 0) > 0) _luaF_close($L, HEAP32[$706 + 24 >> 2] | 0); //@line 5078
   if ($707 >>> 0 < $717 >>> 0) {
    $727 = $707; //@line 5082
    $aux$0101 = 0; //@line 5082
    do {
     $726 = $727; //@line 5085
     $732 = HEAP32[$726 + 4 >> 2] | 0; //@line 5090
     $733 = $708 + ($aux$0101 << 4) | 0; //@line 5091
     HEAP32[$733 >> 2] = HEAP32[$726 >> 2]; //@line 5093
     HEAP32[$733 + 4 >> 2] = $732; //@line 5096
     HEAP32[$708 + ($aux$0101 << 4) + 8 >> 2] = HEAP32[$707 + ($aux$0101 << 4) + 8 >> 2]; //@line 5100
     $aux$0101 = $aux$0101 + 1 | 0; //@line 5101
     $727 = $707 + ($aux$0101 << 4) | 0; //@line 5102
    } while ($727 >>> 0 < $717 >>> 0);
   }
   $745 = $707; //@line 5113
   HEAP32[$706 + 24 >> 2] = $708 + ((HEAP32[$709 >> 2] | 0) - $745 >> 4 << 4); //@line 5119
   $754 = $708 + ((HEAP32[$4 >> 2] | 0) - $745 >> 4 << 4) | 0; //@line 5124
   HEAP32[$4 >> 2] = $754; //@line 5125
   HEAP32[$706 + 4 >> 2] = $754; //@line 5127
   HEAP32[$706 + 28 >> 2] = HEAP32[$704 + 28 >> 2]; //@line 5131
   $759 = $706 + 18 | 0; //@line 5132
   HEAP8[$759 >> 0] = HEAPU8[$759 >> 0] | 64; //@line 5137
   HEAP32[$0 >> 2] = $706; //@line 5138
   $ci$0 = $706; //@line 5139
   continue;
  } else if ((label | 0) == 223) {
   label = 0; //@line 5143
   $764 = $23 >>> 23; //@line 5144
   if ($764) HEAP32[$4 >> 2] = $base$1 + ($764 + -1 + $89 << 4); //@line 5150
   if ((HEAP32[(HEAP32[$12 >> 2] | 0) + 56 >> 2] | 0) > 0) _luaF_close($L, $base$1); //@line 5157
   $771 = _luaD_poscall($L, $90) | 0; //@line 5159
   if (!(HEAP8[$ci$0 + 18 >> 0] & 4)) {
    label = 228; //@line 5165
    break;
   }
   $776 = HEAP32[$0 >> 2] | 0; //@line 5168
   if (!$771) {
    $ci$0 = $776; //@line 5171
    continue;
   }
   HEAP32[$4 >> 2] = HEAP32[$776 + 4 >> 2]; //@line 5176
   $ci$0 = $776; //@line 5177
   continue;
  }
 }
 if ((label | 0) == 23) {
  if (!$1061) {
   $79 = HEAP32[$$pre$phi$iZ2D >> 2] | 0; //@line 5183
   $80 = $79 + -4 | 0; //@line 5184
   HEAP32[$$pre$phi$iZ2D >> 2] = $80; //@line 5185
   $81 = HEAP8[$37 >> 0] | 0; //@line 5186
   $82 = $81 & 255; //@line 5187
   $83 = $82 | 128; //@line 5188
   $84 = $83 & 255; //@line 5189
   HEAP8[$37 >> 0] = $84; //@line 5190
   $85 = HEAP32[$4 >> 2] | 0; //@line 5191
   $86 = $85 + -16 | 0; //@line 5192
   HEAP32[$32 >> 2] = $86; //@line 5193
   _luaD_throw($L, 1); //@line 5194
  }
  HEAP32[$6 >> 2] = 1; //@line 5197
  $79 = HEAP32[$$pre$phi$iZ2D >> 2] | 0; //@line 5198
  $80 = $79 + -4 | 0; //@line 5199
  HEAP32[$$pre$phi$iZ2D >> 2] = $80; //@line 5200
  $81 = HEAP8[$37 >> 0] | 0; //@line 5201
  $82 = $81 & 255; //@line 5202
  $83 = $82 | 128; //@line 5203
  $84 = $83 & 255; //@line 5204
  HEAP8[$37 >> 0] = $84; //@line 5205
  $85 = HEAP32[$4 >> 2] | 0; //@line 5206
  $86 = $85 + -16 | 0; //@line 5207
  HEAP32[$32 >> 2] = $86; //@line 5208
  _luaD_throw($L, 1); //@line 5209
 } else if ((label | 0) == 228) {
  STACKTOP = sp; //@line 5213
  return;
 } else if ((label | 0) == 239) _luaG_runerror($L, 11896, $vararg_buffer3); //@line 5216
 else if ((label | 0) == 244) _luaG_runerror($L, 11936, $vararg_buffer3); //@line 5220
 else if ((label | 0) == 249) _luaG_runerror($L, 11968, $vararg_buffer3); //@line 5224
}
function _statement($ls) {
 $ls = $ls | 0;
 var $$$i$i = 0, $$$i$i$i = 0, $$idx$val$idx$val$pre$i$i36 = 0, $$idx1$val$idx$val$idx$val$pre$i$i40 = 0, $$idx2$i$i32 = 0, $$pre = 0, $0 = 0, $1 = 0, $100 = 0, $110 = 0, $12 = 0, $120 = 0, $130 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $140 = 0, $15 = 0, $154 = 0, $156 = 0, $159 = 0, $16 = 0, $163 = 0, $167 = 0, $169 = 0, $17 = 0, $172 = 0, $173 = 0, $177 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $189 = 0, $190 = 0, $192 = 0, $195 = 0, $198 = 0, $2 = 0, $20 = 0, $208 = 0, $21 = 0, $212 = 0, $215 = 0, $224 = 0, $231 = 0, $239 = 0, $240 = 0, $245 = 0, $249 = 0, $252 = 0, $254 = 0, $258 = 0, $259 = 0, $262 = 0, $284 = 0, $285 = 0, $286 = 0, $29 = 0, $292 = 0, $295 = 0, $296 = 0, $301 = 0, $304 = 0, $305 = 0, $308 = 0, $311 = 0, $320 = 0, $325 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $340 = 0, $341 = 0, $345 = 0, $346 = 0, $351 = 0, $357 = 0, $360 = 0, $364 = 0, $365 = 0, $370 = 0, $371 = 0, $372 = 0, $377 = 0, $379 = 0, $380 = 0, $39 = 0, $397 = 0, $398 = 0, $4 = 0, $404 = 0, $405 = 0, $408 = 0, $420 = 0, $424 = 0, $43 = 0, $436 = 0, $450 = 0, $451 = 0, $453 = 0, $457 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $470 = 0, $472 = 0, $473 = 0, $48 = 0, $483 = 0, $484 = 0, $492 = 0, $496 = 0, $501 = 0, $56 = 0, $6 = 0, $66 = 0, $70 = 0, $78 = 0, $88 = 0, $9 = 0, $92 = 0, $e$i = 0, $e$i51 = 0, $first$0$i = 0, $i$0$ph1$i$i = 0, $i$02$i$i = 0, $ismethod$0$i$i = 0, $key$i$i$i = 0, $label$0$i = 0, $ls$idx = 0, $ls$idx$val = 0, $ls$idx$val$i = 0, $ls$idx$val$i$i = 0, $ls$idx$val$i$i$i = 0, $ls$idx$val$i$i$i4 = 0, $ls$idx$val$i$i12 = 0, $ls$idx$val$i$i15 = 0, $ls$idx$val$i29 = 0, $ls$idx1 = 0, $ls$idx1$val$i = 0, $ls$idx1$val$i110 = 0, $n$0$i$i$lcssa = 0, $n$0$i$i56$lcssa = 0, $n$0$i$i5695 = 0, $n$0$i$i85 = 0, $n$0$i$lcssa = 0, $n$0$i77 = 0, $nret$0$i = 0, $nvars$0$i$i$lcssa = 0, $nvars$0$i$i79 = 0, $nvars$0$i90 = 0, $vararg_buffer6 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 9107
 STACKTOP = STACKTOP + 112 | 0; //@line 9108
 $vararg_buffer6 = sp + 72 | 0; //@line 9109
 $e$i51 = sp + 48 | 0; //@line 9110
 $e$i = sp + 24 | 0; //@line 9111
 $key$i$i$i = sp; //@line 9112
 $0 = $ls + 4 | 0; //@line 9113
 $1 = HEAP32[$0 >> 2] | 0; //@line 9114
 $ls$idx = $ls + 48 | 0; //@line 9115
 $ls$idx$val = HEAP32[$ls$idx >> 2] | 0; //@line 9116
 $ls$idx1 = $ls + 52 | 0; //@line 9117
 $2 = (HEAP32[$ls$idx1 >> 2] | 0) + 38 | 0; //@line 9119
 $4 = (HEAP16[$2 >> 1] | 0) + 1 << 16 >> 16; //@line 9121
 HEAP16[$2 >> 1] = $4; //@line 9122
 if (($4 & 65535) > 200) {
  $6 = $ls$idx$val + 12 | 0; //@line 9125
  $9 = HEAP32[(HEAP32[$6 >> 2] | 0) + 52 >> 2] | 0; //@line 9128
  $12 = HEAP32[(HEAP32[$ls$idx$val >> 2] | 0) + 64 >> 2] | 0; //@line 9131
  if (!$12) {
   $15 = 9408; //@line 9134
   HEAP32[$vararg_buffer6 >> 2] = 9216; //@line 9135
   $vararg_ptr4 = $vararg_buffer6 + 4 | 0; //@line 9136
   HEAP32[$vararg_ptr4 >> 2] = 200; //@line 9137
   $vararg_ptr5 = $vararg_buffer6 + 8 | 0; //@line 9138
   HEAP32[$vararg_ptr5 >> 2] = $15; //@line 9139
   $16 = _luaO_pushfstring($9, 9448, $vararg_buffer6) | 0; //@line 9140
   $17 = HEAP32[$6 >> 2] | 0; //@line 9141
   _luaX_syntaxerror($17, $16); //@line 9142
  }
  HEAP32[$vararg_buffer6 >> 2] = $12; //@line 9145
  $15 = _luaO_pushfstring($9, 9424, $vararg_buffer6) | 0; //@line 9147
  HEAP32[$vararg_buffer6 >> 2] = 9216; //@line 9148
  $vararg_ptr4 = $vararg_buffer6 + 4 | 0; //@line 9149
  HEAP32[$vararg_ptr4 >> 2] = 200; //@line 9150
  $vararg_ptr5 = $vararg_buffer6 + 8 | 0; //@line 9151
  HEAP32[$vararg_ptr5 >> 2] = $15; //@line 9152
  $16 = _luaO_pushfstring($9, 9448, $vararg_buffer6) | 0; //@line 9153
  $17 = HEAP32[$6 >> 2] | 0; //@line 9154
  _luaX_syntaxerror($17, $16); //@line 9155
 }
 $18 = $ls + 16 | 0; //@line 9158
 L8 : do switch (HEAP32[$18 >> 2] | 0) {
 case 266:
 case 258:
  {
   $450 = _luaK_jump($ls$idx$val) | 0; //@line 9163
   $451 = HEAP32[$0 >> 2] | 0; //@line 9164
   $453 = (HEAP32[$18 >> 2] | 0) == 266; //@line 9166
   _luaX_next($ls); //@line 9167
   do if ($453) if ((HEAP32[$18 >> 2] | 0) == 288) {
    $457 = HEAP32[$ls + 24 >> 2] | 0; //@line 9174
    _luaX_next($ls); //@line 9175
    $label$0$i = $457; //@line 9176
    break;
   } else _error_expected($ls, 288); //@line 9179
 else $label$0$i = _luaS_new(HEAP32[$ls$idx1 >> 2] | 0, 9160) | 0; //@line 9185
 while (0);
   $461 = HEAP32[$ls + 64 >> 2] | 0; //@line 9189
   $462 = $461 + 12 | 0; //@line 9190
   $463 = $461 + 16 | 0; //@line 9191
   $464 = HEAP32[$463 >> 2] | 0; //@line 9192
   $465 = $461 + 20 | 0; //@line 9193
   if (($464 | 0) < (HEAP32[$465 >> 2] | 0)) $472 = HEAP32[$462 >> 2] | 0; //@line 9198
 else {
    $470 = _luaM_growaux_(HEAP32[$ls$idx1 >> 2] | 0, HEAP32[$462 >> 2] | 0, $465, 16, 32767, 9168) | 0; //@line 9202
    HEAP32[$462 >> 2] = $470; //@line 9203
    $472 = $470; //@line 9204
   }
   HEAP32[$472 + ($464 << 4) >> 2] = $label$0$i; //@line 9207
   $473 = HEAP32[$462 >> 2] | 0; //@line 9208
   HEAP32[$473 + ($464 << 4) + 8 >> 2] = $451; //@line 9210
   HEAP8[$473 + ($464 << 4) + 12 >> 0] = HEAP8[(HEAP32[$ls$idx >> 2] | 0) + 46 >> 0] | 0; //@line 9215
   HEAP32[(HEAP32[$462 >> 2] | 0) + ($464 << 4) + 4 >> 2] = $450; //@line 9218
   HEAP32[$463 >> 2] = (HEAP32[$463 >> 2] | 0) + 1; //@line 9221
   _findlabel($ls, $464) | 0; //@line 9222
   break;
  }
 case 267:
  {
   HEAP32[$e$i51 >> 2] = -1; //@line 9226
   _test_then_block($ls, $e$i51); //@line 9227
   while (1) {
    $20 = HEAP32[$18 >> 2] | 0; //@line 9229
    if (($20 | 0) == 260) {
     label = 10; //@line 9231
     break;
    } else if (($20 | 0) != 261) break;
    _test_then_block($ls, $e$i51); //@line 9236
   }
   if ((label | 0) == 10) {
    _luaX_next($ls); //@line 9239
    $21 = HEAP32[$ls$idx >> 2] | 0; //@line 9240
    HEAP8[$vararg_buffer6 + 10 >> 0] = 0; //@line 9242
    HEAP8[$vararg_buffer6 + 8 >> 0] = HEAP8[$21 + 46 >> 0] | 0; //@line 9246
    $29 = HEAP32[(HEAP32[$21 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 9250
    HEAP16[$vararg_buffer6 + 4 >> 1] = HEAP32[$29 + 28 >> 2]; //@line 9255
    HEAP16[$vararg_buffer6 + 6 >> 1] = HEAP32[$29 + 16 >> 2]; //@line 9260
    HEAP8[$vararg_buffer6 + 9 >> 0] = 0; //@line 9262
    $39 = $21 + 16 | 0; //@line 9263
    HEAP32[$vararg_buffer6 >> 2] = HEAP32[$39 >> 2]; //@line 9265
    HEAP32[$39 >> 2] = $vararg_buffer6; //@line 9266
    L27 : do {
     $ls$idx$val$i$i$i = HEAP32[$18 >> 2] | 0; //@line 9268
     switch ($ls$idx$val$i$i$i | 0) {
     case 277:
     case 286:
     case 262:
     case 261:
     case 260:
      {
       break L27;
       break;
      }
     default:
      {}
     }
     _statement($ls); //@line 9278
    } while (($ls$idx$val$i$i$i | 0) != 274);
    _leaveblock($21); //@line 9283
   }
   _check_match($ls, 262, 267, $1); //@line 9285
   _luaK_patchtohere($ls$idx$val, HEAP32[$e$i51 >> 2] | 0); //@line 9287
   break;
  }
 case 259:
  {
   _luaX_next($ls); //@line 9291
   $92 = HEAP32[$ls$idx >> 2] | 0; //@line 9292
   HEAP8[$vararg_buffer6 + 10 >> 0] = 0; //@line 9294
   HEAP8[$vararg_buffer6 + 8 >> 0] = HEAP8[$92 + 46 >> 0] | 0; //@line 9298
   $100 = HEAP32[(HEAP32[$92 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 9302
   HEAP16[$vararg_buffer6 + 4 >> 1] = HEAP32[$100 + 28 >> 2]; //@line 9307
   HEAP16[$vararg_buffer6 + 6 >> 1] = HEAP32[$100 + 16 >> 2]; //@line 9312
   HEAP8[$vararg_buffer6 + 9 >> 0] = 0; //@line 9314
   $110 = $92 + 16 | 0; //@line 9315
   HEAP32[$vararg_buffer6 >> 2] = HEAP32[$110 >> 2]; //@line 9317
   HEAP32[$110 >> 2] = $vararg_buffer6; //@line 9318
   L33 : do {
    $ls$idx$val$i$i = HEAP32[$18 >> 2] | 0; //@line 9320
    switch ($ls$idx$val$i$i | 0) {
    case 277:
    case 286:
    case 262:
    case 261:
    case 260:
     {
      break L33;
      break;
     }
    default:
     {}
    }
    _statement($ls); //@line 9330
   } while (($ls$idx$val$i$i | 0) != 274);
   _leaveblock($92); //@line 9335
   _check_match($ls, 262, 259, $1); //@line 9336
   break;
  }
 case 278:
  {
   _luaX_next($ls); //@line 9340
   $43 = _luaK_getlabel($ls$idx$val) | 0; //@line 9341
   _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 9342
   if ((HEAP32[$vararg_buffer6 >> 2] | 0) == 1) HEAP32[$vararg_buffer6 >> 2] = 3; //@line 9346
   _luaK_goiftrue(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 9349
   $48 = HEAP32[$vararg_buffer6 + 20 >> 2] | 0; //@line 9351
   HEAP8[$e$i51 + 10 >> 0] = 1; //@line 9353
   HEAP8[$e$i51 + 8 >> 0] = HEAP8[$ls$idx$val + 46 >> 0] | 0; //@line 9357
   $56 = HEAP32[(HEAP32[$ls$idx$val + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 9361
   HEAP16[$e$i51 + 4 >> 1] = HEAP32[$56 + 28 >> 2]; //@line 9366
   HEAP16[$e$i51 + 6 >> 1] = HEAP32[$56 + 16 >> 2]; //@line 9371
   HEAP8[$e$i51 + 9 >> 0] = 0; //@line 9373
   $66 = $ls$idx$val + 16 | 0; //@line 9374
   HEAP32[$e$i51 >> 2] = HEAP32[$66 >> 2]; //@line 9376
   HEAP32[$66 >> 2] = $e$i51; //@line 9377
   if ((HEAP32[$18 >> 2] | 0) != 259) _error_expected($ls, 259); //@line 9381
   _luaX_next($ls); //@line 9384
   $70 = HEAP32[$ls$idx >> 2] | 0; //@line 9385
   HEAP8[$vararg_buffer6 + 10 >> 0] = 0; //@line 9387
   HEAP8[$vararg_buffer6 + 8 >> 0] = HEAP8[$70 + 46 >> 0] | 0; //@line 9391
   $78 = HEAP32[(HEAP32[$70 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 9395
   HEAP16[$vararg_buffer6 + 4 >> 1] = HEAP32[$78 + 28 >> 2]; //@line 9400
   HEAP16[$vararg_buffer6 + 6 >> 1] = HEAP32[$78 + 16 >> 2]; //@line 9405
   HEAP8[$vararg_buffer6 + 9 >> 0] = 0; //@line 9407
   $88 = $70 + 16 | 0; //@line 9408
   HEAP32[$vararg_buffer6 >> 2] = HEAP32[$88 >> 2]; //@line 9410
   HEAP32[$88 >> 2] = $vararg_buffer6; //@line 9411
   L51 : do {
    $ls$idx$val$i$i$i4 = HEAP32[$18 >> 2] | 0; //@line 9413
    switch ($ls$idx$val$i$i$i4 | 0) {
    case 277:
    case 286:
    case 262:
    case 261:
    case 260:
     {
      break L51;
      break;
     }
    default:
     {}
    }
    _statement($ls); //@line 9423
   } while (($ls$idx$val$i$i$i4 | 0) != 274);
   _leaveblock($70); //@line 9428
   _luaK_patchlist($ls$idx$val, _luaK_jump($ls$idx$val) | 0, $43); //@line 9430
   _check_match($ls, 262, 278, $1); //@line 9431
   _leaveblock($ls$idx$val); //@line 9432
   _luaK_patchtohere($ls$idx$val, $48); //@line 9433
   break;
  }
 case 59:
  {
   _luaX_next($ls); //@line 9437
   break;
  }
 case 285:
  {
   _luaX_next($ls); //@line 9441
   if ((HEAP32[$18 >> 2] | 0) != 288) _error_expected($ls, 288); //@line 9445
   $336 = HEAP32[$ls + 24 >> 2] | 0; //@line 9449
   _luaX_next($ls); //@line 9450
   $337 = HEAP32[$ls$idx >> 2] | 0; //@line 9451
   $338 = $ls + 64 | 0; //@line 9452
   $339 = HEAP32[$338 >> 2] | 0; //@line 9453
   $340 = $339 + 24 | 0; //@line 9454
   $341 = $337 + 16 | 0; //@line 9455
   $345 = HEAP16[(HEAP32[$341 >> 2] | 0) + 4 >> 1] | 0; //@line 9459
   $346 = $339 + 28 | 0; //@line 9460
   L60 : do if (($345 | 0) < (HEAP32[$346 >> 2] | 0)) {
    $i$02$i$i = $345; //@line 9465
    while (1) {
     $351 = $i$02$i$i + 1 | 0; //@line 9472
     if (_luaS_eqstr($336, HEAP32[(HEAP32[$340 >> 2] | 0) + ($i$02$i$i << 4) >> 2] | 0) | 0) break;
     if (($351 | 0) < (HEAP32[$346 >> 2] | 0)) $i$02$i$i = $351; //@line 9479
 else break L60;
    }
    $357 = $337 + 12 | 0; //@line 9484
    $360 = HEAP32[(HEAP32[$357 >> 2] | 0) + 52 >> 2] | 0; //@line 9487
    $364 = HEAP32[(HEAP32[$340 >> 2] | 0) + ($i$02$i$i << 4) + 8 >> 2] | 0; //@line 9491
    HEAP32[$vararg_buffer6 >> 2] = $336 + 16; //@line 9492
    HEAP32[$vararg_buffer6 + 4 >> 2] = $364; //@line 9494
    $365 = _luaO_pushfstring($360, 9536, $vararg_buffer6) | 0; //@line 9495
    _semerror(HEAP32[$357 >> 2] | 0, $365); //@line 9497
   } while (0);
   if ((HEAP32[$18 >> 2] | 0) != 285) _error_expected($ls, 285); //@line 9504
   _luaX_next($ls); //@line 9507
   $370 = HEAP32[$337 + 20 >> 2] | 0; //@line 9509
   $371 = HEAP32[$346 >> 2] | 0; //@line 9510
   $372 = $339 + 32 | 0; //@line 9511
   if (($371 | 0) < (HEAP32[$372 >> 2] | 0)) $379 = HEAP32[$340 >> 2] | 0; //@line 9516
 else {
    $377 = _luaM_growaux_(HEAP32[$ls$idx1 >> 2] | 0, HEAP32[$340 >> 2] | 0, $372, 16, 32767, 9168) | 0; //@line 9520
    HEAP32[$340 >> 2] = $377; //@line 9521
    $379 = $377; //@line 9522
   }
   HEAP32[$379 + ($371 << 4) >> 2] = $336; //@line 9525
   $380 = HEAP32[$340 >> 2] | 0; //@line 9526
   HEAP32[$380 + ($371 << 4) + 8 >> 2] = $1; //@line 9528
   HEAP8[$380 + ($371 << 4) + 12 >> 0] = HEAP8[(HEAP32[$ls$idx >> 2] | 0) + 46 >> 0] | 0; //@line 9533
   HEAP32[(HEAP32[$340 >> 2] | 0) + ($371 << 4) + 4 >> 2] = $370; //@line 9536
   HEAP32[$346 >> 2] = (HEAP32[$346 >> 2] | 0) + 1; //@line 9539
   L74 : while (1) {
    switch (HEAP32[$18 >> 2] | 0) {
    case 285:
    case 59:
     break;
    case 286:
    case 262:
    case 261:
    case 260:
     {
      label = 108; //@line 9547
      break L74;
      break;
     }
    default:
     break L74;
    }
    _statement($ls); //@line 9555
   }
   if ((label | 0) == 108) HEAP8[(HEAP32[$340 >> 2] | 0) + ($371 << 4) + 12 >> 0] = HEAP8[(HEAP32[$341 >> 2] | 0) + 8 >> 0] | 0; //@line 9563
   $397 = (HEAP32[$340 >> 2] | 0) + ($371 << 4) | 0; //@line 9566
   $398 = HEAP32[$338 >> 2] | 0; //@line 9567
   $404 = HEAP16[(HEAP32[(HEAP32[$ls$idx >> 2] | 0) + 16 >> 2] | 0) + 6 >> 1] | 0; //@line 9573
   $405 = $398 + 16 | 0; //@line 9574
   if (($404 | 0) < (HEAP32[$405 >> 2] | 0)) {
    $408 = $398 + 12 | 0; //@line 9578
    $i$0$ph1$i$i = $404; //@line 9579
    do {
     while (1) {
      if (!(_luaS_eqstr(HEAP32[(HEAP32[$408 >> 2] | 0) + ($i$0$ph1$i$i << 4) >> 2] | 0, HEAP32[$397 >> 2] | 0) | 0)) break;
      _closegoto($ls, $i$0$ph1$i$i, $397); //@line 9591
      if (($i$0$ph1$i$i | 0) >= (HEAP32[$405 >> 2] | 0)) break L8;
     }
     $i$0$ph1$i$i = $i$0$ph1$i$i + 1 | 0; //@line 9598
    } while (($i$0$ph1$i$i | 0) < (HEAP32[$405 >> 2] | 0));
   }
   break;
  }
 case 274:
  {
   _luaX_next($ls); //@line 9611
   $420 = HEAP32[$ls$idx >> 2] | 0; //@line 9612
   L88 : do switch (HEAP32[$18 >> 2] | 0) {
   case 59:
   case 277:
   case 286:
   case 262:
   case 261:
   case 260:
    {
     $first$0$i = 0; //@line 9617
     $nret$0$i = 0; //@line 9617
     break;
    }
   default:
    {
     _subexpr($ls, $e$i51, 0) | 0; //@line 9621
     if ((HEAP32[$18 >> 2] | 0) == 44) {
      $n$0$i$i5695 = 1; //@line 9625
      while (1) {
       _luaX_next($ls); //@line 9627
       _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $e$i51); //@line 9629
       _subexpr($ls, $e$i51, 0) | 0; //@line 9630
       $424 = $n$0$i$i5695 + 1 | 0; //@line 9631
       if ((HEAP32[$18 >> 2] | 0) == 44) $n$0$i$i5695 = $424; //@line 9635
 else {
        $n$0$i$i56$lcssa = $424; //@line 9637
        break;
       }
      }
     } else $n$0$i$i56$lcssa = 1; //@line 9642
     if (((HEAP32[$e$i51 >> 2] | 0) + -12 | 0) >>> 0 < 2) {
      _luaK_setreturns($420, $e$i51, -1); //@line 9648
      if ((HEAP32[$e$i51 >> 2] | 0) == 12 & ($n$0$i$i56$lcssa | 0) == 1) {
       $436 = (HEAP32[(HEAP32[$420 >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$e$i51 + 8 >> 2] << 2) | 0; //@line 9659
       HEAP32[$436 >> 2] = HEAP32[$436 >> 2] & -64 | 30; //@line 9663
      }
      $first$0$i = HEAPU8[$420 + 46 >> 0] | 0; //@line 9668
      $nret$0$i = -1; //@line 9668
      break L88;
     } else if (($n$0$i$i56$lcssa | 0) == 1) {
      $first$0$i = _luaK_exp2anyreg($420, $e$i51) | 0; //@line 9674
      $nret$0$i = 1; //@line 9674
      break L88;
     } else {
      _luaK_exp2nextreg($420, $e$i51); //@line 9677
      $first$0$i = HEAPU8[$420 + 46 >> 0] | 0; //@line 9681
      $nret$0$i = $n$0$i$i56$lcssa; //@line 9681
      break L88;
     }
    }
   } while (0);
   _luaK_ret($420, $first$0$i, $nret$0$i); //@line 9688
   if ((HEAP32[$18 >> 2] | 0) == 59) _luaX_next($ls); //@line 9692
   break;
  }
 case 273:
  {
   $190 = _luaK_getlabel($ls$idx$val) | 0; //@line 9697
   HEAP8[$e$i51 + 10 >> 0] = 1; //@line 9699
   $192 = $ls$idx$val + 46 | 0; //@line 9700
   HEAP8[$e$i51 + 8 >> 0] = HEAP8[$192 >> 0] | 0; //@line 9703
   $195 = $ls$idx$val + 12 | 0; //@line 9704
   $198 = HEAP32[(HEAP32[$195 >> 2] | 0) + 64 >> 2] | 0; //@line 9707
   HEAP16[$e$i51 + 4 >> 1] = HEAP32[$198 + 28 >> 2]; //@line 9712
   HEAP16[$e$i51 + 6 >> 1] = HEAP32[$198 + 16 >> 2]; //@line 9717
   HEAP8[$e$i51 + 9 >> 0] = 0; //@line 9719
   $208 = $ls$idx$val + 16 | 0; //@line 9720
   HEAP32[$e$i51 >> 2] = HEAP32[$208 >> 2]; //@line 9722
   HEAP32[$208 >> 2] = $e$i51; //@line 9723
   HEAP8[$e$i + 10 >> 0] = 0; //@line 9725
   $212 = $e$i + 8 | 0; //@line 9727
   HEAP8[$212 >> 0] = HEAP8[$192 >> 0] | 0; //@line 9728
   $215 = HEAP32[(HEAP32[$195 >> 2] | 0) + 64 >> 2] | 0; //@line 9731
   HEAP16[$e$i + 4 >> 1] = HEAP32[$215 + 28 >> 2]; //@line 9736
   HEAP16[$e$i + 6 >> 1] = HEAP32[$215 + 16 >> 2]; //@line 9741
   $224 = $e$i + 9 | 0; //@line 9742
   HEAP8[$224 >> 0] = 0; //@line 9743
   HEAP32[$e$i >> 2] = HEAP32[$208 >> 2]; //@line 9745
   HEAP32[$208 >> 2] = $e$i; //@line 9746
   _luaX_next($ls); //@line 9747
   L106 : do {
    $ls$idx$val$i$i15 = HEAP32[$18 >> 2] | 0; //@line 9749
    switch ($ls$idx$val$i$i15 | 0) {
    case 277:
    case 286:
    case 262:
    case 261:
    case 260:
     {
      break L106;
      break;
     }
    default:
     {}
    }
    _statement($ls); //@line 9759
   } while (($ls$idx$val$i$i15 | 0) != 274);
   _check_match($ls, 277, 273, $1); //@line 9764
   _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 9765
   if ((HEAP32[$vararg_buffer6 >> 2] | 0) == 1) HEAP32[$vararg_buffer6 >> 2] = 3; //@line 9769
   _luaK_goiftrue(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 9772
   $231 = HEAP32[$vararg_buffer6 + 20 >> 2] | 0; //@line 9774
   if (HEAP8[$224 >> 0] | 0) _luaK_patchclose($ls$idx$val, $231, HEAPU8[$212 >> 0] | 0); //@line 9780
   _leaveblock($ls$idx$val); //@line 9782
   _luaK_patchlist($ls$idx$val, $231, $190); //@line 9783
   _leaveblock($ls$idx$val); //@line 9784
   break;
  }
 case 265:
  {
   _luaX_next($ls); //@line 9788
   if ((HEAP32[$18 >> 2] | 0) != 288) _error_expected($ls, 288); //@line 9792
   $239 = HEAP32[$ls + 24 >> 2] | 0; //@line 9796
   _luaX_next($ls); //@line 9797
   $240 = HEAP32[$ls$idx >> 2] | 0; //@line 9798
   if (!(_singlevaraux($240, $239, $vararg_buffer6, 1) | 0)) {
    _singlevaraux($240, HEAP32[$ls + 72 >> 2] | 0, $vararg_buffer6, 1) | 0; //@line 9804
    $245 = _luaK_stringK(HEAP32[$ls$idx >> 2] | 0, $239) | 0; //@line 9806
    HEAP32[$key$i$i$i + 16 >> 2] = -1; //@line 9808
    HEAP32[$key$i$i$i + 20 >> 2] = -1; //@line 9810
    HEAP32[$key$i$i$i >> 2] = 4; //@line 9811
    HEAP32[$key$i$i$i + 8 >> 2] = $245; //@line 9813
    _luaK_indexed($240, $vararg_buffer6, $key$i$i$i); //@line 9814
   }
   while (1) {
    $249 = HEAP32[$18 >> 2] | 0; //@line 9817
    if (($249 | 0) == 58) {
     label = 70; //@line 9819
     break;
    } else if (($249 | 0) != 46) {
     $ismethod$0$i$i = 0; //@line 9822
     break;
    }
    _fieldsel($ls, $vararg_buffer6); //@line 9825
   }
   if ((label | 0) == 70) {
    _fieldsel($ls, $vararg_buffer6); //@line 9828
    $ismethod$0$i$i = 1; //@line 9829
   }
   _body($ls, $e$i51, $ismethod$0$i$i, $1); //@line 9831
   _luaK_storevar(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6, $e$i51); //@line 9833
   _luaK_fixline(HEAP32[$ls$idx >> 2] | 0, $1); //@line 9835
   break;
  }
 case 269:
  {
   _luaX_next($ls); //@line 9839
   $252 = HEAP32[$18 >> 2] | 0; //@line 9840
   if (($252 | 0) == 265) {
    _luaX_next($ls); //@line 9843
    $254 = HEAP32[$ls$idx >> 2] | 0; //@line 9844
    if ((HEAP32[$18 >> 2] | 0) == 288) {
     $258 = HEAP32[$ls + 24 >> 2] | 0; //@line 9849
     _luaX_next($ls); //@line 9850
     _new_localvar($ls, $258); //@line 9851
     $ls$idx$val$i = HEAP32[$ls$idx >> 2] | 0; //@line 9852
     $259 = $ls$idx$val$i + 46 | 0; //@line 9853
     $262 = (HEAPU8[$259 >> 0] | 0) + 1 | 0; //@line 9856
     HEAP8[$259 >> 0] = $262; //@line 9858
     HEAP32[(HEAP32[(HEAP32[$ls$idx$val$i >> 2] | 0) + 24 >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[(HEAP32[$ls$idx$val$i + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0) + (($262 & 255) + -1 + (HEAP32[$ls$idx$val$i + 40 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$ls$idx$val$i + 20 >> 2]; //@line 9878
     _body($ls, $vararg_buffer6, 0, HEAP32[$0 >> 2] | 0); //@line 9880
     HEAP32[(HEAP32[(HEAP32[$254 >> 2] | 0) + 24 >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[(HEAP32[$254 + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0) + ((HEAP32[$254 + 40 >> 2] | 0) + (HEAP32[$vararg_buffer6 + 8 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$254 + 20 >> 2]; //@line 9900
     break L8;
    } else _error_expected($ls, 288); //@line 9903
   }
   if (($252 | 0) != 288) _error_expected($ls, 288); //@line 9909
   $284 = $ls + 24 | 0; //@line 9912
   $nvars$0$i90 = 1; //@line 9913
   while (1) {
    $285 = HEAP32[$284 >> 2] | 0; //@line 9915
    _luaX_next($ls); //@line 9916
    _new_localvar($ls, $285); //@line 9917
    $286 = HEAP32[$18 >> 2] | 0; //@line 9918
    if (($286 | 0) == 61) {
     label = 81; //@line 9920
     break;
    } else if (($286 | 0) != 44) {
     label = 83; //@line 9923
     break;
    }
    _luaX_next($ls); //@line 9926
    if ((HEAP32[$18 >> 2] | 0) == 288) $nvars$0$i90 = $nvars$0$i90 + 1 | 0; //@line 9931
 else {
     label = 78; //@line 9933
     break;
    }
   }
   do if ((label | 0) == 78) _error_expected($ls, 288); //@line 9939
 else if ((label | 0) == 81) {
    _luaX_next($ls); //@line 9943
    _subexpr($ls, $e$i, 0) | 0; //@line 9944
    if ((HEAP32[$18 >> 2] | 0) == 44) {
     $n$0$i$i85 = 1; //@line 9948
     while (1) {
      _luaX_next($ls); //@line 9950
      _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $e$i); //@line 9952
      _subexpr($ls, $e$i, 0) | 0; //@line 9953
      $292 = $n$0$i$i85 + 1 | 0; //@line 9954
      if ((HEAP32[$18 >> 2] | 0) == 44) $n$0$i$i85 = $292; //@line 9958
 else {
       $n$0$i$i$lcssa = $292; //@line 9960
       break;
      }
     }
    } else $n$0$i$i$lcssa = 1; //@line 9965
    $$pre = HEAP32[$e$i >> 2] | 0; //@line 9967
    $ls$idx1$val$i = HEAP32[$ls$idx >> 2] | 0; //@line 9968
    $295 = $nvars$0$i90 - $n$0$i$i$lcssa | 0; //@line 9969
    if (!$$pre) {
     $301 = $295; //@line 9971
     $ls$idx1$val$i110 = $ls$idx1$val$i; //@line 9971
     label = 88; //@line 9972
     break;
    } else if (!(($$pre | 0) == 13 | ($$pre | 0) == 12)) {
     _luaK_exp2nextreg($ls$idx1$val$i, $e$i); //@line 9975
     $301 = $295; //@line 9976
     $ls$idx1$val$i110 = $ls$idx1$val$i; //@line 9976
     label = 88; //@line 9977
     break;
    }
    $296 = $295 + 1 | 0; //@line 9980
    $$$i$i = ($296 | 0) < 0 ? 0 : $296; //@line 9982
    _luaK_setreturns($ls$idx1$val$i, $e$i, $$$i$i); //@line 9983
    if (($$$i$i | 0) > 1) _luaK_reserveregs($ls$idx1$val$i, $$$i$i + -1 | 0); //@line 9987
   } else if ((label | 0) == 83) {
    HEAP32[$e$i >> 2] = 0; //@line 9991
    $301 = $nvars$0$i90; //@line 9993
    $ls$idx1$val$i110 = HEAP32[$ls$idx >> 2] | 0; //@line 9993
    label = 88; //@line 9994
   } while (0);
   if ((label | 0) == 88) if (($301 | 0) > 0) {
    $304 = HEAPU8[$ls$idx1$val$i110 + 48 >> 0] | 0; //@line 10002
    _luaK_reserveregs($ls$idx1$val$i110, $301); //@line 10003
    _luaK_nil($ls$idx1$val$i110, $304, $301); //@line 10004
   }
   $ls$idx$val$i29 = HEAP32[$ls$idx >> 2] | 0; //@line 10007
   $305 = $ls$idx$val$i29 + 46 | 0; //@line 10008
   $308 = (HEAPU8[$305 >> 0] | 0) + $nvars$0$i90 | 0; //@line 10011
   HEAP8[$305 >> 0] = $308; //@line 10013
   if ($nvars$0$i90) {
    $311 = $ls$idx$val$i29 + 20 | 0; //@line 10016
    $$idx2$i$i32 = $ls$idx$val$i29 + 40 | 0; //@line 10018
    $$idx$val$idx$val$pre$i$i36 = HEAP32[(HEAP32[$ls$idx$val$i29 >> 2] | 0) + 24 >> 2] | 0; //@line 10022
    $$idx1$val$idx$val$idx$val$pre$i$i40 = HEAP32[HEAP32[(HEAP32[$ls$idx$val$i29 + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0; //@line 10025
    HEAP32[$$idx$val$idx$val$pre$i$i36 + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i$i40 + (($308 & 255) - $nvars$0$i90 + (HEAP32[$$idx2$i$i32 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$311 >> 2]; //@line 10035
    $320 = $nvars$0$i90 + -1 | 0; //@line 10036
    if ($320) {
     $325 = $320; //@line 10039
     do {
      HEAP32[$$idx$val$idx$val$pre$i$i36 + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i$i40 + ((HEAPU8[$305 >> 0] | 0) - $325 + (HEAP32[$$idx2$i$i32 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$311 >> 2]; //@line 10051
      $325 = $325 + -1 | 0; //@line 10052
     } while (($325 | 0) != 0);
    }
   }
   break;
  }
 case 264:
  {
   HEAP8[$e$i51 + 10 >> 0] = 1; //@line 10066
   HEAP8[$e$i51 + 8 >> 0] = HEAP8[$ls$idx$val + 46 >> 0] | 0; //@line 10070
   $120 = HEAP32[(HEAP32[$ls$idx$val + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 10074
   HEAP16[$e$i51 + 4 >> 1] = HEAP32[$120 + 28 >> 2]; //@line 10079
   HEAP16[$e$i51 + 6 >> 1] = HEAP32[$120 + 16 >> 2]; //@line 10084
   HEAP8[$e$i51 + 9 >> 0] = 0; //@line 10086
   $130 = $ls$idx$val + 16 | 0; //@line 10087
   HEAP32[$e$i51 >> 2] = HEAP32[$130 >> 2]; //@line 10089
   HEAP32[$130 >> 2] = $e$i51; //@line 10090
   _luaX_next($ls); //@line 10091
   if ((HEAP32[$18 >> 2] | 0) != 288) _error_expected($ls, 288); //@line 10095
   $134 = $ls + 24 | 0; //@line 10098
   $135 = HEAP32[$134 >> 2] | 0; //@line 10099
   _luaX_next($ls); //@line 10100
   $136 = HEAP32[$18 >> 2] | 0; //@line 10101
   if (($136 | 0) == 268 | ($136 | 0) == 44) {
    $156 = HEAP32[$ls$idx >> 2] | 0; //@line 10103
    $159 = HEAPU8[$156 + 48 >> 0] | 0; //@line 10106
    _new_localvar($ls, _luaX_newstring($ls, 9600, 15) | 0); //@line 10108
    _new_localvar($ls, _luaX_newstring($ls, 9616, 11) | 0); //@line 10110
    _new_localvar($ls, _luaX_newstring($ls, 9632, 13) | 0); //@line 10112
    _new_localvar($ls, $135); //@line 10113
    $163 = HEAP32[$18 >> 2] | 0; //@line 10114
    do if (($163 | 0) == 44) {
     $nvars$0$i$i79 = 4; //@line 10118
     while (1) {
      _luaX_next($ls); //@line 10120
      if ((HEAP32[$18 >> 2] | 0) != 288) {
       label = 40; //@line 10124
       break;
      }
      $167 = HEAP32[$134 >> 2] | 0; //@line 10127
      _luaX_next($ls); //@line 10128
      _new_localvar($ls, $167); //@line 10129
      $169 = HEAP32[$18 >> 2] | 0; //@line 10131
      if (($169 | 0) == 44) $nvars$0$i$i79 = $nvars$0$i$i79 + 1 | 0; //@line 10134
 else {
       label = 42; //@line 10136
       break;
      }
     }
     if ((label | 0) == 40) _error_expected($ls, 288); //@line 10141
 else if ((label | 0) == 42) {
      $172 = $169; //@line 10146
      $nvars$0$i$i$lcssa = $nvars$0$i$i79 + -2 | 0; //@line 10146
      break;
     }
    } else {
     $172 = $163; //@line 10150
     $nvars$0$i$i$lcssa = 1; //@line 10150
    } while (0);
    if (($172 | 0) != 268) _error_expected($ls, 268); //@line 10155
    _luaX_next($ls); //@line 10158
    $173 = HEAP32[$0 >> 2] | 0; //@line 10159
    _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 10160
    if ((HEAP32[$18 >> 2] | 0) == 44) {
     $n$0$i77 = 1; //@line 10164
     while (1) {
      _luaX_next($ls); //@line 10166
      _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 10168
      _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 10169
      $177 = $n$0$i77 + 1 | 0; //@line 10170
      if ((HEAP32[$18 >> 2] | 0) == 44) $n$0$i77 = $177; //@line 10174
 else {
       $n$0$i$lcssa = $177; //@line 10176
       break;
      }
     }
    } else $n$0$i$lcssa = 1; //@line 10181
    $ls$idx$val$i$i12 = HEAP32[$ls$idx >> 2] | 0; //@line 10183
    $180 = 3 - $n$0$i$lcssa | 0; //@line 10184
    $181 = HEAP32[$vararg_buffer6 >> 2] | 0; //@line 10185
    if (($181 | 0) == 13 | ($181 | 0) == 12) {
     $182 = $180 + 1 | 0; //@line 10187
     $$$i$i$i = ($182 | 0) < 0 ? 0 : $182; //@line 10189
     _luaK_setreturns($ls$idx$val$i$i12, $vararg_buffer6, $$$i$i$i); //@line 10190
     if (($$$i$i$i | 0) > 1) _luaK_reserveregs($ls$idx$val$i$i12, $$$i$i$i + -1 | 0); //@line 10194
    } else if (!$181) label = 51; //@line 10197
 else {
     _luaK_exp2nextreg($ls$idx$val$i$i12, $vararg_buffer6); //@line 10199
     label = 51; //@line 10200
    }
    if ((label | 0) == 51) if (($180 | 0) > 0) {
     $189 = HEAPU8[$ls$idx$val$i$i12 + 48 >> 0] | 0; //@line 10207
     _luaK_reserveregs($ls$idx$val$i$i12, $180); //@line 10208
     _luaK_nil($ls$idx$val$i$i12, $189, $180); //@line 10209
    }
    _luaK_checkstack($156, 3); //@line 10212
    _forbody($ls, $159, $173, $nvars$0$i$i$lcssa, 0); //@line 10213
   } else if (($136 | 0) == 61) {
    $137 = HEAP32[$ls$idx >> 2] | 0; //@line 10215
    $138 = $137 + 48 | 0; //@line 10216
    $140 = HEAPU8[$138 >> 0] | 0; //@line 10218
    _new_localvar($ls, _luaX_newstring($ls, 9648, 11) | 0); //@line 10220
    _new_localvar($ls, _luaX_newstring($ls, 9664, 11) | 0); //@line 10222
    _new_localvar($ls, _luaX_newstring($ls, 9680, 10) | 0); //@line 10224
    _new_localvar($ls, $135); //@line 10225
    if ((HEAP32[$18 >> 2] | 0) != 61) _error_expected($ls, 61); //@line 10229
    _luaX_next($ls); //@line 10232
    _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 10233
    _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 10235
    if ((HEAP32[$18 >> 2] | 0) != 44) _error_expected($ls, 44); //@line 10239
    _luaX_next($ls); //@line 10242
    _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 10243
    _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 10245
    if ((HEAP32[$18 >> 2] | 0) == 44) {
     _luaX_next($ls); //@line 10249
     _subexpr($ls, $vararg_buffer6, 0) | 0; //@line 10250
     _luaK_exp2nextreg(HEAP32[$ls$idx >> 2] | 0, $vararg_buffer6); //@line 10252
    } else {
     $154 = HEAPU8[$138 >> 0] | 0; //@line 10255
     _luaK_codek($137, $154, _luaK_numberK($137, 1.0) | 0) | 0; //@line 10257
     _luaK_reserveregs($137, 1); //@line 10258
    }
    _forbody($ls, $140, $1, 1, 1); //@line 10260
   } else _luaX_syntaxerror($ls, 9576); //@line 10262
   _check_match($ls, 262, 264, $1); //@line 10265
   _leaveblock($ls$idx$val); //@line 10266
   break;
  }
 default:
  {
   $483 = $vararg_buffer6 + 8 | 0; //@line 10270
   _suffixedexp($ls, $483); //@line 10271
   $484 = HEAP32[$18 >> 2] | 0; //@line 10272
   if (($484 | 0) == 44 | ($484 | 0) == 61) {
    HEAP32[$vararg_buffer6 >> 2] = 0; //@line 10274
    _assignment($ls, $vararg_buffer6, 1); //@line 10275
    break L8;
   }
   if ((HEAP32[$483 >> 2] | 0) == 12) {
    $492 = (HEAP32[(HEAP32[$ls$idx$val >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$vararg_buffer6 + 16 >> 2] << 2) | 0; //@line 10286
    HEAP32[$492 >> 2] = HEAP32[$492 >> 2] & -8372225 | 16384; //@line 10290
    break L8;
   } else _luaX_syntaxerror($ls, 9200); //@line 10293
  }
 } while (0);
 $496 = HEAP32[$ls$idx >> 2] | 0; //@line 10299
 HEAP8[$496 + 48 >> 0] = HEAP8[$496 + 46 >> 0] | 0; //@line 10303
 $501 = (HEAP32[$ls$idx1 >> 2] | 0) + 38 | 0; //@line 10305
 HEAP16[$501 >> 1] = (HEAP16[$501 >> 1] | 0) + -1 << 16 >> 16; //@line 10308
 STACKTOP = sp; //@line 10309
 return;
}
function _match($ms, $s, $p) {
 $ms = $ms | 0;
 $s = $s | 0;
 $p = $p | 0;
 var $$$i36 = 0, $$$i4 = 0, $$$i44 = 0, $$$i52 = 0, $$$i7 = 0, $$0$i = 0, $$0$i$i = 0, $$0$i$i25 = 0, $$0$i$i27 = 0, $$0$i$i32 = 0, $$0$i12 = 0, $$0$i15 = 0, $$0$i2 = 0, $$0$i5 = 0, $$0$ph$be = 0, $$0$ph125 = 0, $$01$be = 0, $$01$be$i = 0, $$01$be$i10 = 0, $$01$be$i39 = 0, $$01$be$i47 = 0, $$01$be$i55 = 0, $$01$i = 0, $$01$i20 = 0, $$01$i2970 = 0, $$01$ph$be = 0, $$01$ph124 = 0, $$01110 = 0, $$012$i = 0, $$012$i37 = 0, $$012$i45 = 0, $$012$i53 = 0, $$012$i8 = 0, $$013$i = 0, $$013$i$phi = 0, $$1 = 0, $$1$i = 0, $$1$i19 = 0, $$2 = 0, $$p$i = 0, $$p$i35 = 0, $$p$i43 = 0, $$p$i51 = 0, $$p$i6 = 0, $$pre$phi181Z2D = 0, $$pre180 = 0, $0 = 0, $10 = 0, $103 = 0, $11 = 0, $115 = 0, $116 = 0, $117 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $123 = 0, $124 = 0, $126 = 0, $127 = 0, $13 = 0, $132 = 0, $14 = 0, $141 = 0, $142 = 0, $144 = 0, $145 = 0, $146 = 0, $148 = 0, $149 = 0, $15 = 0, $151 = 0, $152 = 0, $157 = 0, $166 = 0, $167 = 0, $172 = 0, $174 = 0, $176 = 0, $182 = 0, $187 = 0, $19 = 0, $197 = 0, $199 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $218 = 0, $220 = 0, $221 = 0, $222 = 0, $224 = 0, $225 = 0, $227 = 0, $228 = 0, $233 = 0, $244 = 0, $246 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $253 = 0, $254 = 0, $255 = 0, $258 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $270 = 0, $271 = 0, $272 = 0, $274 = 0, $275 = 0, $277 = 0, $278 = 0, $283 = 0, $29 = 0, $294 = 0, $300 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $311 = 0, $312 = 0, $313 = 0, $315 = 0, $316 = 0, $318 = 0, $319 = 0, $324 = 0, $336 = 0, $342 = 0, $343 = 0, $35 = 0, $39 = 0, $5 = 0, $52 = 0, $53 = 0, $55 = 0, $57 = 0, $6 = 0, $61 = 0, $62 = 0, $64 = 0, $68 = 0, $72 = 0, $73 = 0, $75 = 0, $76 = 0, $78 = 0, $8 = 0, $80 = 0, $86 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $cont$0$be$i = 0, $cont$04$i = 0, $i$0$i$lcssa = 0, $i$0$i$lcssa185 = 0, $i$0$i64 = 0, $i$1$i62 = 0, $level$0$i$i = 0, $level$0$in$i$i = 0, $ms$idx = 0, $ms$idx$val$i = 0, $ms$idx$val$i176 = 0, $ms$idx$val$i63 = 0, $vararg_buffer19 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 15015
 STACKTOP = STACKTOP + 16 | 0; //@line 15016
 $vararg_buffer19 = sp; //@line 15017
 $0 = HEAP32[$ms >> 2] | 0; //@line 15018
 HEAP32[$ms >> 2] = $0 + -1; //@line 15020
 if (!$0) _luaL_error(HEAP32[$ms + 16 >> 2] | 0, 10128, $vararg_buffer19) | 0; //@line 15025
 $5 = $ms + 12 | 0; //@line 15027
 $6 = HEAP32[$5 >> 2] | 0; //@line 15028
 L4 : do if (($6 | 0) == ($p | 0)) $$2 = $s; //@line 15032
 else {
  $ms$idx = $ms + 8 | 0; //@line 15034
  $8 = $ms + 16 | 0; //@line 15035
  $9 = $ms + 4 | 0; //@line 15036
  $10 = $ms + 20 | 0; //@line 15037
  $$0$ph125 = $s; //@line 15038
  $$01$ph124 = $p; //@line 15038
  $342 = $6; //@line 15038
  L6 : while (1) {
   $11 = $$0$ph125 + 1 | 0; //@line 15040
   $12 = $$0$ph125 + -1 | 0; //@line 15041
   $$01110 = $$01$ph124; //@line 15042
   $57 = $342; //@line 15042
   L8 : while (1) {
    $13 = HEAP8[$$01110 >> 0] | 0; //@line 15044
    $14 = $13 << 24 >> 24; //@line 15045
    L10 : do if (($14 | 0) == 36) {
     $55 = $$01110 + 1 | 0; //@line 15048
     if (($55 | 0) == ($57 | 0)) {
      label = 23; //@line 15051
      break L6;
     } else {
      $$01$i = $55; //@line 15054
      $$pre$phi181Z2D = $55; //@line 15054
      label = 89; //@line 15055
     }
    } else if (($14 | 0) == 41) {
     label = 16; //@line 15058
     break L6;
    } else if (($14 | 0) == 37) {
     $61 = $$01110 + 1 | 0; //@line 15061
     $62 = HEAP8[$61 >> 0] | 0; //@line 15062
     switch ($62 << 24 >> 24 | 0) {
     case 57:
     case 56:
     case 55:
     case 54:
     case 53:
     case 52:
     case 51:
     case 50:
     case 49:
     case 48:
      {
       label = 69; //@line 15066
       break L8;
       break;
      }
     case 98:
      {
       label = 25; //@line 15071
       break L8;
       break;
      }
     case 102:
      break;
     default:
      {
       if (($61 | 0) == ($57 | 0)) _luaL_error(HEAP32[$8 >> 2] | 0, 10224, $vararg_buffer19) | 0; //@line 15082
       $$01$i = $$01110 + 2 | 0; //@line 15085
       $$pre$phi181Z2D = $61; //@line 15085
       label = 89; //@line 15086
       break L10;
      }
     }
     $86 = $$01110 + 2 | 0; //@line 15090
     if ((HEAP8[$86 >> 0] | 0) == 91) $92 = 91; //@line 15094
 else {
      _luaL_error(HEAP32[$8 >> 2] | 0, 10152, $vararg_buffer19) | 0; //@line 15097
      $92 = HEAP8[$86 >> 0] | 0; //@line 15099
     }
     $90 = $$01110 + 3 | 0; //@line 15101
     $91 = $92 << 24 >> 24; //@line 15102
     if (($91 | 0) == 37) {
      if (($90 | 0) == (HEAP32[$5 >> 2] | 0)) _luaL_error(HEAP32[$8 >> 2] | 0, 10224, $vararg_buffer19) | 0; //@line 15108
      $$01$i20 = $$01110 + 4 | 0; //@line 15111
     } else if (($91 | 0) == 91) {
      $$0$i15 = (HEAP8[$90 >> 0] | 0) == 94 ? $$01110 + 4 | 0 : $90; //@line 15117
      while (1) {
       if (($$0$i15 | 0) == (HEAP32[$5 >> 2] | 0)) _luaL_error(HEAP32[$8 >> 2] | 0, 10264, $vararg_buffer19) | 0; //@line 15123
       $103 = $$0$i15 + 1 | 0; //@line 15125
       if ((HEAP8[$$0$i15 >> 0] | 0) == 37) $$1$i19 = $103 >>> 0 < (HEAP32[$5 >> 2] | 0) >>> 0 ? $$0$i15 + 2 | 0 : $103; //@line 15133
 else $$1$i19 = $103; //@line 15135
       if ((HEAP8[$$1$i19 >> 0] | 0) == 93) break; else $$0$i15 = $$1$i19; //@line 15142
      }
      $$01$i20 = $$1$i19 + 1 | 0; //@line 15146
     } else $$01$i20 = $90; //@line 15148
     if (($$0$ph125 | 0) == (HEAP32[$9 >> 2] | 0)) $116 = 0; //@line 15153
 else $116 = HEAP8[$12 >> 0] | 0; //@line 15156
     $115 = $116 & 255; //@line 15158
     $117 = $$01$i20 + -1 | 0; //@line 15159
     $119 = (HEAP8[$90 >> 0] | 0) == 94; //@line 15161
     $$p$i6 = $119 ? $90 : $86; //@line 15162
     $120 = $119 & 1; //@line 15163
     $$$i7 = $120 ^ 1; //@line 15164
     $121 = $$p$i6 + 1 | 0; //@line 15165
     L53 : do if ($121 >>> 0 < $117 >>> 0) {
      $$012$i8 = $$p$i6; //@line 15169
      $124 = $121; //@line 15169
      while (1) {
       $123 = HEAP8[$124 >> 0] | 0; //@line 15171
       $126 = $$012$i8 + 2 | 0; //@line 15173
       $127 = HEAP8[$126 >> 0] | 0; //@line 15174
       do if ($123 << 24 >> 24 == 37) if (!(_match_class($115, $127 & 255) | 0)) $$01$be$i10 = $126; //@line 15181
 else {
        $$0$i12 = $$$i7; //@line 15183
        break L53;
       } else {
        if ($127 << 24 >> 24 == 45) {
         $132 = $$012$i8 + 3 | 0; //@line 15189
         if ($132 >>> 0 < $117 >>> 0) {
          if (($123 & 255) > ($116 & 255)) {
           $$01$be$i10 = $132; //@line 15194
           break;
          }
          if ((HEAPU8[$132 >> 0] | 0) < ($116 & 255)) {
           $$01$be$i10 = $132; //@line 15200
           break;
          } else {
           $$0$i12 = $$$i7; //@line 15203
           break L53;
          }
         }
        }
        if ($123 << 24 >> 24 == $116 << 24 >> 24) {
         $$0$i12 = $$$i7; //@line 15210
         break L53;
        } else $$01$be$i10 = $124; //@line 15213
       } while (0);
       $124 = $$01$be$i10 + 1 | 0; //@line 15217
       if ($124 >>> 0 >= $117 >>> 0) {
        $$0$i12 = $120; //@line 15222
        break;
       } else $$012$i8 = $$01$be$i10; //@line 15220
      }
     } else $$0$i12 = $120; //@line 15227
 while (0);
     if ($$0$i12) {
      $$2 = 0; //@line 15232
      break L4;
     }
     $141 = HEAP8[$$0$ph125 >> 0] | 0; //@line 15235
     $142 = $141 & 255; //@line 15236
     $144 = (HEAP8[$90 >> 0] | 0) == 94; //@line 15238
     $$p$i = $144 ? $90 : $86; //@line 15239
     $145 = $144 & 1; //@line 15240
     $$$i4 = $145 ^ 1; //@line 15241
     $146 = $$p$i + 1 | 0; //@line 15242
     L67 : do if ($146 >>> 0 < $117 >>> 0) {
      $$012$i = $$p$i; //@line 15246
      $149 = $146; //@line 15246
      while (1) {
       $148 = HEAP8[$149 >> 0] | 0; //@line 15248
       $151 = $$012$i + 2 | 0; //@line 15250
       $152 = HEAP8[$151 >> 0] | 0; //@line 15251
       do if ($148 << 24 >> 24 == 37) if (!(_match_class($142, $152 & 255) | 0)) $$01$be$i = $151; //@line 15258
 else {
        $$0$i5 = $$$i4; //@line 15260
        break L67;
       } else {
        if ($152 << 24 >> 24 == 45) {
         $157 = $$012$i + 3 | 0; //@line 15266
         if ($157 >>> 0 < $117 >>> 0) {
          if (($148 & 255) > ($141 & 255)) {
           $$01$be$i = $157; //@line 15271
           break;
          }
          if ((HEAPU8[$157 >> 0] | 0) < ($141 & 255)) {
           $$01$be$i = $157; //@line 15277
           break;
          } else {
           $$0$i5 = $$$i4; //@line 15280
           break L67;
          }
         }
        }
        if ($148 << 24 >> 24 == $141 << 24 >> 24) {
         $$0$i5 = $$$i4; //@line 15287
         break L67;
        } else $$01$be$i = $149; //@line 15290
       } while (0);
       $149 = $$01$be$i + 1 | 0; //@line 15294
       if ($149 >>> 0 >= $117 >>> 0) {
        $$0$i5 = $145; //@line 15299
        break;
       } else $$012$i = $$01$be$i; //@line 15297
      }
     } else $$0$i5 = $145; //@line 15304
 while (0);
     if (!$$0$i5) {
      $$2 = 0; //@line 15309
      break L4;
     } else $$01$be = $$01$i20; //@line 15312
    } else if (($14 | 0) == 40) {
     label = 7; //@line 15315
     break L6;
    } else {
     $$pre180 = $$01110 + 1 | 0; //@line 15318
     if ($13 << 24 >> 24 == 91) {
      $$0$i2 = (HEAP8[$$pre180 >> 0] | 0) == 94 ? $$01110 + 2 | 0 : $$pre180; //@line 15325
      $197 = $57; //@line 15325
      while (1) {
       if (($$0$i2 | 0) == ($197 | 0)) _luaL_error(HEAP32[$8 >> 2] | 0, 10264, $vararg_buffer19) | 0; //@line 15330
       $199 = $$0$i2 + 1 | 0; //@line 15332
       if ((HEAP8[$$0$i2 >> 0] | 0) == 37) $$1$i = $199 >>> 0 < (HEAP32[$5 >> 2] | 0) >>> 0 ? $$0$i2 + 2 | 0 : $199; //@line 15340
 else $$1$i = $199; //@line 15342
       if ((HEAP8[$$1$i >> 0] | 0) == 93) break;
       $$0$i2 = $$1$i; //@line 15350
       $197 = HEAP32[$5 >> 2] | 0; //@line 15350
      }
      $$01$i = $$1$i + 1 | 0; //@line 15353
      $$pre$phi181Z2D = $$pre180; //@line 15353
      label = 89; //@line 15354
     } else {
      $$01$i = $$pre180; //@line 15356
      $$pre$phi181Z2D = $$pre180; //@line 15356
      label = 89; //@line 15357
     }
    } while (0);
    L80 : do if ((label | 0) == 89) {
     label = 0; //@line 15363
     do if ((HEAP32[$ms$idx >> 2] | 0) >>> 0 > $$0$ph125 >>> 0) {
      $210 = HEAP8[$$0$ph125 >> 0] | 0; //@line 15368
      $211 = $210 & 255; //@line 15369
      $212 = HEAP8[$$01110 >> 0] | 0; //@line 15370
      $213 = $212 << 24 >> 24; //@line 15371
      L85 : do if (($213 | 0) == 46) $249 = HEAP8[$$01$i >> 0] | 0; //@line 15375
 else if (($213 | 0) == 37) {
       $$0$i = _match_class($211, HEAPU8[$$pre$phi181Z2D >> 0] | 0) | 0; //@line 15380
       label = 104; //@line 15381
      } else if (($213 | 0) == 91) {
       $218 = $$01$i + -1 | 0; //@line 15383
       $220 = (HEAP8[$$pre$phi181Z2D >> 0] | 0) == 94; //@line 15385
       $$p$i35 = $220 ? $$pre$phi181Z2D : $$01110; //@line 15386
       $221 = $220 & 1; //@line 15387
       $$$i36 = $221 ^ 1; //@line 15388
       $222 = $$p$i35 + 1 | 0; //@line 15389
       if ($222 >>> 0 < $218 >>> 0) {
        $$012$i37 = $$p$i35; //@line 15392
        $225 = $222; //@line 15392
        while (1) {
         $224 = HEAP8[$225 >> 0] | 0; //@line 15394
         $227 = $$012$i37 + 2 | 0; //@line 15396
         $228 = HEAP8[$227 >> 0] | 0; //@line 15397
         do if ($224 << 24 >> 24 == 37) if (!(_match_class($211, $228 & 255) | 0)) $$01$be$i39 = $227; //@line 15404
 else {
          $$0$i = $$$i36; //@line 15406
          label = 104; //@line 15407
          break L85;
         } else {
          if ($228 << 24 >> 24 == 45) {
           $233 = $$012$i37 + 3 | 0; //@line 15413
           if ($233 >>> 0 < $218 >>> 0) {
            if (($224 & 255) > ($210 & 255)) {
             $$01$be$i39 = $233; //@line 15418
             break;
            }
            if ((HEAPU8[$233 >> 0] | 0) < ($210 & 255)) {
             $$01$be$i39 = $233; //@line 15424
             break;
            } else {
             $$0$i = $$$i36; //@line 15427
             label = 104; //@line 15428
             break L85;
            }
           }
          }
          if ($224 << 24 >> 24 == $210 << 24 >> 24) {
           $$0$i = $$$i36; //@line 15435
           label = 104; //@line 15436
           break L85;
          } else $$01$be$i39 = $225; //@line 15439
         } while (0);
         $225 = $$01$be$i39 + 1 | 0; //@line 15443
         if ($225 >>> 0 >= $218 >>> 0) {
          $$0$i = $221; //@line 15448
          label = 104; //@line 15449
          break;
         } else $$012$i37 = $$01$be$i39; //@line 15446
        }
       } else {
        $$0$i = $221; //@line 15454
        label = 104; //@line 15455
       }
      } else {
       $$0$i = $212 << 24 >> 24 == $210 << 24 >> 24 & 1; //@line 15460
       label = 104; //@line 15461
      } while (0);
      if ((label | 0) == 104) {
       label = 0; //@line 15465
       $244 = HEAP8[$$01$i >> 0] | 0; //@line 15467
       if (!$$0$i) {
        $343 = $244; //@line 15469
        break;
       } else $249 = $244; //@line 15472
      }
      $248 = $249 << 24 >> 24; //@line 15475
      if (($248 | 0) == 45) {
       label = 109; //@line 15477
       break L6;
      } else if (($248 | 0) == 42) {
       label = 112; //@line 15480
       break L6;
      } else if (($248 | 0) == 43) {
       $$1 = $11; //@line 15483
       break L6;
      } else if (($248 | 0) != 63) {
       $$0$ph$be = $11; //@line 15486
       $$01$ph$be = $$01$i; //@line 15486
       break L8;
      }
      $254 = $$01$i + 1 | 0; //@line 15489
      $255 = _match($ms, $11, $254) | 0; //@line 15490
      if (!$255) {
       $$01$be = $254; //@line 15493
       break L80;
      } else {
       $$2 = $255; //@line 15496
       break L4;
      }
     } else $343 = HEAP8[$$01$i >> 0] | 0; //@line 15501
 while (0);
     if (!($343 << 24 >> 24 == 45 | $343 << 24 >> 24 == 63 | $343 << 24 >> 24 == 42)) {
      $$2 = 0; //@line 15505
      break L4;
     }
     $$01$be = $$01$i + 1 | 0; //@line 15509
    } while (0);
    $246 = HEAP32[$5 >> 2] | 0; //@line 15512
    if (($$01$be | 0) == ($246 | 0)) {
     $$2 = $$0$ph125; //@line 15515
     break L4;
    } else {
     $$01110 = $$01$be; //@line 15518
     $57 = $246; //@line 15518
    }
   }
   if ((label | 0) == 25) {
    label = 0; //@line 15522
    $64 = $$01110 + 2 | 0; //@line 15523
    if (($57 + -1 | 0) >>> 0 <= $64 >>> 0) _luaL_error(HEAP32[$8 >> 2] | 0, 10296, $vararg_buffer19) | 0; //@line 15528
    $68 = HEAP8[$$0$ph125 >> 0] | 0; //@line 15530
    if ($68 << 24 >> 24 != (HEAP8[$64 >> 0] | 0)) {
     $$2 = 0; //@line 15534
     break L4;
    }
    $72 = HEAP8[$$01110 + 3 >> 0] | 0; //@line 15538
    $73 = HEAP32[$ms$idx >> 2] | 0; //@line 15539
    if ($11 >>> 0 < $73 >>> 0) {
     $$013$i = $$0$ph125; //@line 15542
     $76 = $11; //@line 15542
     $cont$04$i = 1; //@line 15542
    } else {
     $$2 = 0; //@line 15544
     break L4;
    }
    while (1) {
     $75 = HEAP8[$76 >> 0] | 0; //@line 15548
     if ($75 << 24 >> 24 == $72 << 24 >> 24) {
      $78 = $cont$04$i + -1 | 0; //@line 15551
      if (!$78) break; else $cont$0$be$i = $78; //@line 15556
     } else $cont$0$be$i = ($75 << 24 >> 24 == $68 << 24 >> 24 & 1) + $cont$04$i | 0; //@line 15562
     $80 = $76 + 1 | 0; //@line 15564
     if ($80 >>> 0 < $73 >>> 0) {
      $$013$i$phi = $76; //@line 15567
      $76 = $80; //@line 15567
      $cont$04$i = $cont$0$be$i; //@line 15567
      $$013$i = $$013$i$phi; //@line 15567
     } else {
      $$2 = 0; //@line 15569
      break L4;
     }
    }
    $$0$ph$be = $$013$i + 2 | 0; //@line 15575
    $$01$ph$be = $$01110 + 4 | 0; //@line 15575
   } else if ((label | 0) == 69) {
    label = 0; //@line 15578
    $166 = $62 & 255; //@line 15579
    $167 = $166 + -49 | 0; //@line 15580
    if (($167 | 0) < 0) label = 72; //@line 15583
 else if (($167 | 0) < (HEAP32[$10 >> 2] | 0)) {
     $172 = HEAP32[$ms + ($167 << 3) + 28 >> 2] | 0; //@line 15589
     if (($172 | 0) == -1) label = 72; //@line 15592
 else {
      $$0$i$i = $167; //@line 15594
      $182 = $172; //@line 15594
     }
    } else label = 72; //@line 15597
    if ((label | 0) == 72) {
     label = 0; //@line 15601
     $174 = HEAP32[$8 >> 2] | 0; //@line 15602
     HEAP32[$vararg_buffer19 >> 2] = $166 + -48; //@line 15604
     $176 = _luaL_error($174, 10192, $vararg_buffer19) | 0; //@line 15605
     $$0$i$i = $176; //@line 15608
     $182 = HEAP32[$ms + ($176 << 3) + 28 >> 2] | 0; //@line 15608
    }
    if (((HEAP32[$ms$idx >> 2] | 0) - $$0$ph125 | 0) >>> 0 < $182 >>> 0) {
     $$2 = 0; //@line 15616
     break L4;
    }
    if (_memcmp(HEAP32[$ms + ($$0$i$i << 3) + 24 >> 2] | 0, $$0$ph125, $182) | 0) {
     $$2 = 0; //@line 15624
     break L4;
    }
    $187 = $$0$ph125 + $182 | 0; //@line 15627
    if (!$187) {
     $$2 = 0; //@line 15630
     break L4;
    }
    $$0$ph$be = $187; //@line 15634
    $$01$ph$be = $$01110 + 2 | 0; //@line 15634
   }
   $342 = HEAP32[$5 >> 2] | 0; //@line 15636
   if (($$01$ph$be | 0) == ($342 | 0)) {
    $$2 = $$0$ph$be; //@line 15639
    break L4;
   } else {
    $$0$ph125 = $$0$ph$be; //@line 15642
    $$01$ph124 = $$01$ph$be; //@line 15642
   }
  }
  if ((label | 0) == 7) {
   $15 = $$01110 + 1 | 0; //@line 15646
   if ((HEAP8[$15 >> 0] | 0) == 41) {
    $19 = HEAP32[$10 >> 2] | 0; //@line 15651
    if (($19 | 0) > 31) _luaL_error(HEAP32[$8 >> 2] | 0, 10056, $vararg_buffer19) | 0; //@line 15655
    HEAP32[$ms + ($19 << 3) + 24 >> 2] = $$0$ph125; //@line 15658
    HEAP32[$ms + ($19 << 3) + 28 >> 2] = -2; //@line 15660
    HEAP32[$10 >> 2] = $19 + 1; //@line 15662
    $25 = _match($ms, $$0$ph125, $$01110 + 2 | 0) | 0; //@line 15663
    if ($25) {
     $$2 = $25; //@line 15666
     break;
    }
    HEAP32[$10 >> 2] = (HEAP32[$10 >> 2] | 0) + -1; //@line 15671
    $$2 = 0; //@line 15672
    break;
   } else {
    $29 = HEAP32[$10 >> 2] | 0; //@line 15675
    if (($29 | 0) > 31) _luaL_error(HEAP32[$8 >> 2] | 0, 10056, $vararg_buffer19) | 0; //@line 15679
    HEAP32[$ms + ($29 << 3) + 24 >> 2] = $$0$ph125; //@line 15682
    HEAP32[$ms + ($29 << 3) + 28 >> 2] = -1; //@line 15684
    HEAP32[$10 >> 2] = $29 + 1; //@line 15686
    $35 = _match($ms, $$0$ph125, $15) | 0; //@line 15687
    if ($35) {
     $$2 = $35; //@line 15690
     break;
    }
    HEAP32[$10 >> 2] = (HEAP32[$10 >> 2] | 0) + -1; //@line 15695
    $$2 = 0; //@line 15696
    break;
   }
  } else if ((label | 0) == 16) {
   $39 = $$01110 + 1 | 0; //@line 15701
   $level$0$in$i$i = HEAP32[$10 >> 2] | 0; //@line 15703
   while (1) {
    $level$0$i$i = $level$0$in$i$i + -1 | 0; //@line 15705
    if (($level$0$in$i$i | 0) <= 0) {
     label = 19; //@line 15708
     break;
    }
    if ((HEAP32[$ms + ($level$0$i$i << 3) + 28 >> 2] | 0) == -1) {
     $$0$i$i25 = $level$0$i$i; //@line 15715
     break;
    } else $level$0$in$i$i = $level$0$i$i; //@line 15718
   }
   if ((label | 0) == 19) $$0$i$i25 = _luaL_error(HEAP32[$8 >> 2] | 0, 10344, $vararg_buffer19) | 0; //@line 15724
   $52 = $ms + ($$0$i$i25 << 3) + 28 | 0; //@line 15731
   HEAP32[$52 >> 2] = $$0$ph125 - (HEAP32[$ms + ($$0$i$i25 << 3) + 24 >> 2] | 0); //@line 15732
   $53 = _match($ms, $$0$ph125, $39) | 0; //@line 15733
   if ($53) {
    $$2 = $53; //@line 15736
    break;
   }
   HEAP32[$52 >> 2] = -1; //@line 15739
   $$2 = 0; //@line 15740
   break;
  } else if ((label | 0) == 23) {
   $$2 = ($$0$ph125 | 0) == (HEAP32[$ms$idx >> 2] | 0) ? $$0$ph125 : 0; //@line 15747
   break;
  } else if ((label | 0) == 109) {
   $250 = $$01$i + 1 | 0; //@line 15751
   $251 = _match($ms, $$0$ph125, $250) | 0; //@line 15752
   if ($251) {
    $$2 = $251; //@line 15755
    break;
   }
   $253 = $$01$i + -1 | 0; //@line 15758
   $$01$i2970 = $$0$ph125; //@line 15759
   while (1) {
    if ((HEAP32[$ms$idx >> 2] | 0) >>> 0 <= $$01$i2970 >>> 0) {
     $$2 = 0; //@line 15764
     break L4;
    }
    $303 = HEAP8[$$01$i2970 >> 0] | 0; //@line 15767
    $304 = $303 & 255; //@line 15768
    $305 = HEAP8[$$01110 >> 0] | 0; //@line 15769
    $306 = $305 << 24 >> 24; //@line 15770
    L139 : do if (($306 | 0) == 37) {
     $$0$i$i32 = _match_class($304, HEAPU8[$$pre$phi181Z2D >> 0] | 0) | 0; //@line 15776
     label = 147; //@line 15777
    } else if (($306 | 0) == 91) {
     $311 = (HEAP8[$$pre$phi181Z2D >> 0] | 0) == 94; //@line 15780
     $$p$i51 = $311 ? $$pre$phi181Z2D : $$01110; //@line 15781
     $312 = $311 & 1; //@line 15782
     $$$i52 = $312 ^ 1; //@line 15783
     $313 = $$p$i51 + 1 | 0; //@line 15784
     if ($313 >>> 0 < $253 >>> 0) {
      $$012$i53 = $$p$i51; //@line 15787
      $316 = $313; //@line 15787
      while (1) {
       $315 = HEAP8[$316 >> 0] | 0; //@line 15789
       $318 = $$012$i53 + 2 | 0; //@line 15791
       $319 = HEAP8[$318 >> 0] | 0; //@line 15792
       do if ($315 << 24 >> 24 == 37) if (!(_match_class($304, $319 & 255) | 0)) $$01$be$i55 = $318; //@line 15799
 else {
        $$0$i$i32 = $$$i52; //@line 15801
        label = 147; //@line 15802
        break L139;
       } else {
        if ($319 << 24 >> 24 == 45) {
         $324 = $$012$i53 + 3 | 0; //@line 15808
         if ($324 >>> 0 < $253 >>> 0) {
          if (($315 & 255) > ($303 & 255)) {
           $$01$be$i55 = $324; //@line 15813
           break;
          }
          if ((HEAPU8[$324 >> 0] | 0) < ($303 & 255)) {
           $$01$be$i55 = $324; //@line 15819
           break;
          } else {
           $$0$i$i32 = $$$i52; //@line 15822
           label = 147; //@line 15823
           break L139;
          }
         }
        }
        if ($315 << 24 >> 24 == $303 << 24 >> 24) {
         $$0$i$i32 = $$$i52; //@line 15830
         label = 147; //@line 15831
         break L139;
        } else $$01$be$i55 = $316; //@line 15834
       } while (0);
       $316 = $$01$be$i55 + 1 | 0; //@line 15838
       if ($316 >>> 0 >= $253 >>> 0) {
        $$0$i$i32 = $312; //@line 15843
        label = 147; //@line 15844
        break;
       } else $$012$i53 = $$01$be$i55; //@line 15841
      }
     } else {
      $$0$i$i32 = $312; //@line 15849
      label = 147; //@line 15850
     }
    } else if (($306 | 0) != 46) {
     $$0$i$i32 = $305 << 24 >> 24 == $303 << 24 >> 24 & 1; //@line 15855
     label = 147; //@line 15856
    } while (0);
    if ((label | 0) == 147) {
     label = 0; //@line 15860
     if (!$$0$i$i32) {
      $$2 = 0; //@line 15863
      break L4;
     }
    }
    $$01$i2970 = $$01$i2970 + 1 | 0; //@line 15867
    $336 = _match($ms, $$01$i2970, $250) | 0; //@line 15868
    if ($336) {
     $$2 = $336; //@line 15873
     break L4;
    }
   }
  } else if ((label | 0) == 112) $$1 = $$0$ph125; //@line 15879
  $ms$idx$val$i63 = HEAP32[$ms$idx >> 2] | 0; //@line 15881
  if ($ms$idx$val$i63 >>> 0 > $$1 >>> 0) {
   $258 = $$01$i + -1 | 0; //@line 15884
   $262 = $$1; //@line 15885
   $i$0$i64 = 0; //@line 15885
   $ms$idx$val$i176 = $ms$idx$val$i63; //@line 15885
   while (1) {
    $261 = HEAP8[$262 >> 0] | 0; //@line 15887
    $263 = $261 & 255; //@line 15888
    $264 = HEAP8[$$01110 >> 0] | 0; //@line 15889
    $265 = $264 << 24 >> 24; //@line 15890
    L183 : do if (($265 | 0) == 37) {
     $$0$i$i27 = _match_class($263, HEAPU8[$$pre$phi181Z2D >> 0] | 0) | 0; //@line 15896
     label = 129; //@line 15897
    } else if (($265 | 0) == 91) {
     $270 = (HEAP8[$$pre$phi181Z2D >> 0] | 0) == 94; //@line 15900
     $$p$i43 = $270 ? $$pre$phi181Z2D : $$01110; //@line 15901
     $271 = $270 & 1; //@line 15902
     $$$i44 = $271 ^ 1; //@line 15903
     $272 = $$p$i43 + 1 | 0; //@line 15904
     if ($272 >>> 0 < $258 >>> 0) {
      $$012$i45 = $$p$i43; //@line 15907
      $275 = $272; //@line 15907
      while (1) {
       $274 = HEAP8[$275 >> 0] | 0; //@line 15909
       $277 = $$012$i45 + 2 | 0; //@line 15911
       $278 = HEAP8[$277 >> 0] | 0; //@line 15912
       do if ($274 << 24 >> 24 == 37) if (!(_match_class($263, $278 & 255) | 0)) $$01$be$i47 = $277; //@line 15919
 else {
        $$0$i$i27 = $$$i44; //@line 15921
        label = 129; //@line 15922
        break L183;
       } else {
        if ($278 << 24 >> 24 == 45) {
         $283 = $$012$i45 + 3 | 0; //@line 15928
         if ($283 >>> 0 < $258 >>> 0) {
          if (($274 & 255) > ($261 & 255)) {
           $$01$be$i47 = $283; //@line 15933
           break;
          }
          if ((HEAPU8[$283 >> 0] | 0) < ($261 & 255)) {
           $$01$be$i47 = $283; //@line 15939
           break;
          } else {
           $$0$i$i27 = $$$i44; //@line 15942
           label = 129; //@line 15943
           break L183;
          }
         }
        }
        if ($274 << 24 >> 24 == $261 << 24 >> 24) {
         $$0$i$i27 = $$$i44; //@line 15950
         label = 129; //@line 15951
         break L183;
        } else $$01$be$i47 = $275; //@line 15954
       } while (0);
       $275 = $$01$be$i47 + 1 | 0; //@line 15958
       if ($275 >>> 0 >= $258 >>> 0) {
        $$0$i$i27 = $271; //@line 15963
        label = 129; //@line 15964
        break;
       } else $$012$i45 = $$01$be$i47; //@line 15961
      }
     } else {
      $$0$i$i27 = $271; //@line 15969
      label = 129; //@line 15970
     }
    } else if (($265 | 0) == 46) $ms$idx$val$i = $ms$idx$val$i176; //@line 15973
 else {
     $$0$i$i27 = $264 << 24 >> 24 == $261 << 24 >> 24 & 1; //@line 15977
     label = 129; //@line 15978
    } while (0);
    if ((label | 0) == 129) {
     label = 0; //@line 15982
     if (!$$0$i$i27) {
      $i$0$i$lcssa = $i$0$i64; //@line 15985
      break;
     }
     $ms$idx$val$i = HEAP32[$ms$idx >> 2] | 0; //@line 15989
    }
    $294 = $i$0$i64 + 1 | 0; //@line 15991
    $262 = $$1 + $294 | 0; //@line 15992
    if ($ms$idx$val$i >>> 0 <= $262 >>> 0) {
     $i$0$i$lcssa = $294; //@line 15997
     break;
    } else {
     $i$0$i64 = $294; //@line 15995
     $ms$idx$val$i176 = $ms$idx$val$i; //@line 15995
    }
   }
   if (($i$0$i$lcssa | 0) > -1) $i$0$i$lcssa185 = $i$0$i$lcssa; //@line 16003
 else {
    $$2 = 0; //@line 16005
    break;
   }
  } else $i$0$i$lcssa185 = 0; //@line 16009
  $260 = $$01$i + 1 | 0; //@line 16011
  $i$1$i62 = $i$0$i$lcssa185; //@line 16012
  while (1) {
   $300 = _match($ms, $$1 + $i$1$i62 | 0, $260) | 0; //@line 16015
   if ($300) {
    $$2 = $300; //@line 16018
    break L4;
   }
   if (($i$1$i62 | 0) > 0) $i$1$i62 = $i$1$i62 + -1 | 0; //@line 16024
 else {
    $$2 = 0; //@line 16026
    break;
   }
  }
 } while (0);
 HEAP32[$ms >> 2] = (HEAP32[$ms >> 2] | 0) + 1; //@line 16034
 STACKTOP = sp; //@line 16035
 return $$2 | 0; //@line 16035
}
function _DumpFunction($f, $D) {
 $f = $f | 0;
 $D = $D | 0;
 var $$ph = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $104 = 0, $105 = 0, $106 = 0, $11 = 0, $110 = 0, $114 = 0, $120 = 0, $121 = 0, $127 = 0, $135 = 0, $142 = 0, $145 = 0, $147 = 0, $153 = 0, $155 = 0, $160 = 0, $161 = 0, $163 = 0, $169 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $178 = 0, $18 = 0, $182 = 0, $184 = 0, $187 = 0, $191 = 0, $193 = 0, $197 = 0, $2 = 0, $200 = 0, $206 = 0, $212 = 0, $215 = 0, $217 = 0, $22 = 0, $230 = 0, $231 = 0, $232 = 0, $234 = 0, $237 = 0, $239 = 0, $245 = 0, $250 = 0, $252 = 0, $258 = 0, $260 = 0, $261 = 0, $262 = 0, $265 = 0, $268 = 0, $272 = 0, $28 = 0, $280 = 0, $287 = 0, $288 = 0, $292 = 0, $296 = 0, $298 = 0, $3 = 0, $301 = 0, $305 = 0, $310 = 0, $312 = 0, $318 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $325 = 0, $328 = 0, $332 = 0, $340 = 0, $347 = 0, $349 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $360 = 0, $38 = 0, $4 = 0, $42 = 0, $48 = 0, $5 = 0, $52 = 0, $58 = 0, $6 = 0, $60 = 0, $62 = 0, $64 = 0, $65 = 0, $68 = 0, $7 = 0, $70 = 0, $73 = 0, $78 = 0, $80 = 0, $87 = 0, $89 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $i$0$i20 = 0, $i$013$i = 0, $i$03$i = 0, $i$1$i19 = 0, $i$112$i = 0, $size$i$i = 0, $size$i$i10 = 0, $size1$i$i = 0, $size1$i$i11 = 0, $size1$i9$i = 0, $x$i1$i = 0, $x$i1$i12 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 17615
 STACKTOP = STACKTOP + 64 | 0; //@line 17616
 $0 = sp + 24 | 0; //@line 17617
 $size$i$i10 = sp + 8 | 0; //@line 17618
 $size1$i$i11 = sp + 16 | 0; //@line 17619
 $1 = sp; //@line 17620
 $x$i1$i12 = sp + 60 | 0; //@line 17621
 $2 = sp + 12 | 0; //@line 17622
 $x$i1$i = sp + 52 | 0; //@line 17623
 $3 = sp + 56 | 0; //@line 17624
 $4 = sp + 36 | 0; //@line 17625
 $size1$i9$i = sp + 40 | 0; //@line 17626
 $5 = sp + 44 | 0; //@line 17627
 $6 = sp + 20 | 0; //@line 17628
 $7 = sp + 32 | 0; //@line 17629
 $size$i$i = sp + 48 | 0; //@line 17630
 $size1$i$i = sp + 28 | 0; //@line 17631
 HEAP32[$0 >> 2] = HEAP32[$f + 64 >> 2]; //@line 17634
 $10 = $D + 16 | 0; //@line 17635
 $11 = HEAP32[$10 >> 2] | 0; //@line 17636
 if (!$11) {
  $18 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17644
  HEAP32[$10 >> 2] = $18; //@line 17645
  $22 = $18; //@line 17646
 } else $22 = $11; //@line 17648
 HEAP32[$0 >> 2] = HEAP32[$f + 68 >> 2]; //@line 17652
 if (!$22) {
  $28 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17660
  HEAP32[$10 >> 2] = $28; //@line 17661
  $32 = $28; //@line 17662
 } else $32 = $22; //@line 17664
 HEAP8[$0 >> 0] = HEAP8[$f + 76 >> 0] | 0; //@line 17668
 if (!$32) {
  $38 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 1, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17676
  HEAP32[$10 >> 2] = $38; //@line 17677
  $42 = $38; //@line 17678
 } else $42 = $32; //@line 17680
 HEAP8[$0 >> 0] = HEAP8[$f + 77 >> 0] | 0; //@line 17684
 if (!$42) {
  $48 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 1, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17692
  HEAP32[$10 >> 2] = $48; //@line 17693
  $52 = $48; //@line 17694
 } else $52 = $42; //@line 17696
 HEAP8[$0 >> 0] = HEAP8[$f + 78 >> 0] | 0; //@line 17700
 if (!$52) {
  $58 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 1, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17708
  HEAP32[$10 >> 2] = $58; //@line 17709
  $64 = $58; //@line 17710
 } else $64 = $52; //@line 17712
 $60 = HEAP32[$f + 12 >> 2] | 0; //@line 17715
 $62 = HEAP32[$f + 48 >> 2] | 0; //@line 17717
 HEAP32[$4 >> 2] = $62; //@line 17718
 if (!$64) {
  $65 = $D + 4 | 0; //@line 17721
  $68 = $D + 8 | 0; //@line 17724
  $70 = FUNCTION_TABLE_iiiii[HEAP32[$65 >> 2] & 31](HEAP32[$D >> 2] | 0, $4, 4, HEAP32[$68 >> 2] | 0) | 0; //@line 17726
  HEAP32[$10 >> 2] = $70; //@line 17727
  if (!$70) {
   $78 = FUNCTION_TABLE_iiiii[HEAP32[$65 >> 2] & 31](HEAP32[$D >> 2] | 0, $60, $62 << 2, HEAP32[$68 >> 2] | 0) | 0; //@line 17734
   HEAP32[$10 >> 2] = $78; //@line 17735
   $80 = HEAP32[$f + 44 >> 2] | 0; //@line 17737
   HEAP32[$2 >> 2] = $80; //@line 17738
   if (!$78) {
    $87 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $2, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17746
    HEAP32[$10 >> 2] = $87; //@line 17747
    $349 = $87; //@line 17748
    $89 = $80; //@line 17748
   } else {
    $349 = $78; //@line 17750
    $89 = $80; //@line 17750
   }
  } else {
   $$ph = $70; //@line 17753
   label = 13; //@line 17754
  }
 } else {
  $$ph = $64; //@line 17757
  label = 13; //@line 17758
 }
 if ((label | 0) == 13) {
  $73 = HEAP32[$f + 44 >> 2] | 0; //@line 17762
  HEAP32[$2 >> 2] = $73; //@line 17763
  $349 = $$ph; //@line 17764
  $89 = $73; //@line 17764
 }
 if (($89 | 0) > 0) {
  $90 = $f + 8 | 0; //@line 17768
  $91 = $D + 4 | 0; //@line 17769
  $92 = $D + 8 | 0; //@line 17770
  $100 = $349; //@line 17771
  $i$0$i20 = 0; //@line 17771
  while (1) {
   $93 = HEAP32[$90 >> 2] | 0; //@line 17773
   $94 = $93 + ($i$0$i20 << 4) | 0; //@line 17774
   $95 = $93 + ($i$0$i20 << 4) + 8 | 0; //@line 17775
   $96 = HEAP32[$95 >> 2] | 0; //@line 17776
   HEAP8[$0 >> 0] = $96 & 15; //@line 17779
   if (!$100) {
    $104 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 1, HEAP32[$92 >> 2] | 0) | 0; //@line 17785
    HEAP32[$10 >> 2] = $104; //@line 17786
    $106 = HEAP32[$95 >> 2] | 0; //@line 17788
    $110 = $104; //@line 17788
   } else {
    $106 = $96; //@line 17790
    $110 = $100; //@line 17790
   }
   $105 = $106 & 15; //@line 17792
   do if (($105 | 0) == 1) {
    HEAP8[$x$i1$i12 >> 0] = HEAP32[$94 >> 2]; //@line 17797
    if (!$110) {
     $114 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i12, 1, HEAP32[$92 >> 2] | 0) | 0; //@line 17803
     HEAP32[$10 >> 2] = $114; //@line 17804
     $350 = $114; //@line 17805
    } else $350 = $110; //@line 17807
   } else if (($105 | 0) == 3) {
    HEAPF64[$1 >> 3] = +HEAPF64[$94 >> 3]; //@line 17811
    if (!$110) {
     $120 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $1, 8, HEAP32[$92 >> 2] | 0) | 0; //@line 17817
     HEAP32[$10 >> 2] = $120; //@line 17818
     $350 = $120; //@line 17819
    } else $350 = $110; //@line 17821
   } else if (($105 | 0) == 4) {
    $121 = HEAP32[$94 >> 2] | 0; //@line 17824
    if (!$121) {
     HEAP32[$size$i$i10 >> 2] = 0; //@line 17827
     if ($110) {
      $350 = $110; //@line 17830
      break;
     }
     $127 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $size$i$i10, 4, HEAP32[$92 >> 2] | 0) | 0; //@line 17836
     HEAP32[$10 >> 2] = $127; //@line 17837
     $350 = $127; //@line 17838
     break;
    }
    HEAP32[$size1$i$i11 >> 2] = (HEAP32[$121 + 12 >> 2] | 0) + 1; //@line 17844
    if (!$110) {
     $135 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $size1$i$i11, 4, HEAP32[$92 >> 2] | 0) | 0; //@line 17850
     HEAP32[$10 >> 2] = $135; //@line 17851
     if (!$135) {
      $142 = FUNCTION_TABLE_iiiii[HEAP32[$91 >> 2] & 31](HEAP32[$D >> 2] | 0, $121 + 16 | 0, HEAP32[$size1$i$i11 >> 2] | 0, HEAP32[$92 >> 2] | 0) | 0; //@line 17859
      HEAP32[$10 >> 2] = $142; //@line 17860
      $350 = $142; //@line 17861
     } else $350 = $135; //@line 17863
    } else $350 = $110; //@line 17866
   } else $350 = $110; //@line 17869
 while (0);
   $i$0$i20 = $i$0$i20 + 1 | 0; //@line 17872
   if (($i$0$i20 | 0) == ($89 | 0)) {
    $147 = $350; //@line 17875
    break;
   } else $100 = $350; //@line 17878
  }
 } else $147 = $349; //@line 17882
 $145 = HEAP32[$f + 56 >> 2] | 0; //@line 17885
 HEAP32[$0 >> 2] = $145; //@line 17886
 if (!$147) {
  $153 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $0, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17894
  HEAP32[$10 >> 2] = $153; //@line 17895
  $351 = $153; //@line 17896
 } else $351 = $147; //@line 17898
 if (($145 | 0) > 0) {
  $155 = $f + 16 | 0; //@line 17902
  $i$1$i19 = 0; //@line 17903
  do {
   _DumpFunction(HEAP32[(HEAP32[$155 >> 2] | 0) + ($i$1$i19 << 2) >> 2] | 0, $D); //@line 17908
   $i$1$i19 = $i$1$i19 + 1 | 0; //@line 17909
  } while (($i$1$i19 | 0) != ($145 | 0));
  $163 = HEAP32[$10 >> 2] | 0; //@line 17918
 } else $163 = $351; //@line 17920
 $160 = $f + 40 | 0; //@line 17922
 $161 = HEAP32[$160 >> 2] | 0; //@line 17923
 HEAP32[$3 >> 2] = $161; //@line 17924
 if (!$163) {
  $169 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $3, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 17932
  HEAP32[$10 >> 2] = $169; //@line 17933
  $352 = $169; //@line 17934
 } else $352 = $163; //@line 17936
 if (($161 | 0) > 0) {
  $171 = $f + 28 | 0; //@line 17940
  $172 = $D + 4 | 0; //@line 17941
  $173 = $D + 8 | 0; //@line 17942
  $178 = $352; //@line 17943
  $i$03$i = 0; //@line 17943
  while (1) {
   $174 = HEAP32[$171 >> 2] | 0; //@line 17945
   HEAP8[$x$i1$i >> 0] = HEAP8[$174 + ($i$03$i << 3) + 4 >> 0] | 0; //@line 17948
   if (!$178) {
    $182 = FUNCTION_TABLE_iiiii[HEAP32[$172 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 1, HEAP32[$173 >> 2] | 0) | 0; //@line 17954
    HEAP32[$10 >> 2] = $182; //@line 17955
    $184 = HEAP32[$171 >> 2] | 0; //@line 17957
    $187 = $182; //@line 17957
   } else {
    $184 = $174; //@line 17959
    $187 = $178; //@line 17959
   }
   HEAP8[$x$i1$i >> 0] = HEAP8[$184 + ($i$03$i << 3) + 5 >> 0] | 0; //@line 17963
   if (!$187) {
    $191 = FUNCTION_TABLE_iiiii[HEAP32[$172 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 1, HEAP32[$173 >> 2] | 0) | 0; //@line 17969
    HEAP32[$10 >> 2] = $191; //@line 17970
    $353 = $191; //@line 17971
   } else $353 = $187; //@line 17973
   $i$03$i = $i$03$i + 1 | 0; //@line 17975
   if (($i$03$i | 0) == ($161 | 0)) {
    $200 = $353; //@line 17978
    break;
   } else $178 = $353; //@line 17981
  }
 } else $200 = $352; //@line 17985
 $193 = $D + 12 | 0; //@line 17987
 if (!(HEAP32[$193 >> 2] | 0)) {
  $197 = HEAP32[$f + 36 >> 2] | 0; //@line 17992
  if (!$197) {
   $206 = $size$i$i; //@line 17995
   $354 = $size1$i$i; //@line 17995
   label = 50; //@line 17996
  } else {
   HEAP32[$size1$i$i >> 2] = (HEAP32[$197 + 12 >> 2] | 0) + 1; //@line 18001
   if (!$200) {
    $212 = $D + 4 | 0; //@line 18004
    $215 = $D + 8 | 0; //@line 18007
    $217 = FUNCTION_TABLE_iiiii[HEAP32[$212 >> 2] & 31](HEAP32[$D >> 2] | 0, $size1$i$i, 4, HEAP32[$215 >> 2] | 0) | 0; //@line 18009
    HEAP32[$10 >> 2] = $217; //@line 18010
    if (!$217) {
     HEAP32[$10 >> 2] = FUNCTION_TABLE_iiiii[HEAP32[$212 >> 2] & 31](HEAP32[$D >> 2] | 0, $197 + 16 | 0, HEAP32[$size1$i$i >> 2] | 0, HEAP32[$215 >> 2] | 0) | 0; //@line 18019
     $355 = $size1$i$i; //@line 18020
     $356 = $size$i$i; //@line 18020
    } else {
     $355 = $size1$i$i; //@line 18022
     $356 = $size$i$i; //@line 18022
    }
   } else {
    $355 = $size1$i$i; //@line 18025
    $356 = $size$i$i; //@line 18025
   }
  }
 } else {
  $206 = $size$i$i; //@line 18029
  $354 = $size1$i$i; //@line 18029
  label = 50; //@line 18030
 }
 if ((label | 0) == 50) {
  HEAP32[$size$i$i >> 2] = 0; //@line 18033
  if (!$200) {
   HEAP32[$10 >> 2] = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $206, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 18042
   $355 = $354; //@line 18043
   $356 = $206; //@line 18043
  } else {
   $355 = $354; //@line 18045
   $356 = $206; //@line 18045
  }
 }
 if (!(HEAP32[$193 >> 2] | 0)) $231 = HEAP32[$f + 52 >> 2] | 0; //@line 18053
 else $231 = 0; //@line 18055
 $230 = HEAP32[$f + 20 >> 2] | 0; //@line 18058
 HEAP32[$7 >> 2] = $231; //@line 18059
 $232 = HEAP32[$10 >> 2] | 0; //@line 18060
 if (!$232) {
  $234 = $D + 4 | 0; //@line 18063
  $237 = $D + 8 | 0; //@line 18066
  $239 = FUNCTION_TABLE_iiiii[HEAP32[$234 >> 2] & 31](HEAP32[$D >> 2] | 0, $7, 4, HEAP32[$237 >> 2] | 0) | 0; //@line 18068
  HEAP32[$10 >> 2] = $239; //@line 18069
  if (!$239) {
   $245 = FUNCTION_TABLE_iiiii[HEAP32[$234 >> 2] & 31](HEAP32[$D >> 2] | 0, $230, $231 << 2, HEAP32[$237 >> 2] | 0) | 0; //@line 18076
   HEAP32[$10 >> 2] = $245; //@line 18077
   $252 = $245; //@line 18078
  } else $252 = $239; //@line 18080
 } else $252 = $232; //@line 18083
 if (!(HEAP32[$193 >> 2] | 0)) $250 = HEAP32[$f + 60 >> 2] | 0; //@line 18090
 else $250 = 0; //@line 18092
 HEAP32[$6 >> 2] = $250; //@line 18094
 if (!$252) {
  $258 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $6, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 18102
  HEAP32[$10 >> 2] = $258; //@line 18103
  $357 = $258; //@line 18104
 } else $357 = $252; //@line 18106
 if (($250 | 0) > 0) {
  $260 = $f + 24 | 0; //@line 18110
  $261 = $D + 4 | 0; //@line 18111
  $262 = $D + 8 | 0; //@line 18112
  $268 = $357; //@line 18113
  $i$013$i = 0; //@line 18113
  while (1) {
   $265 = HEAP32[(HEAP32[$260 >> 2] | 0) + ($i$013$i * 12 | 0) >> 2] | 0; //@line 18117
   do if (!$265) {
    HEAP32[$x$i1$i >> 2] = 0; //@line 18121
    if ($268) {
     $292 = $268; //@line 18124
     break;
    }
    $272 = FUNCTION_TABLE_iiiii[HEAP32[$261 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 4, HEAP32[$262 >> 2] | 0) | 0; //@line 18130
    HEAP32[$10 >> 2] = $272; //@line 18131
    $292 = $272; //@line 18132
   } else {
    HEAP32[$size1$i9$i >> 2] = (HEAP32[$265 + 12 >> 2] | 0) + 1; //@line 18137
    if ($268) {
     $292 = $268; //@line 18140
     break;
    }
    $280 = FUNCTION_TABLE_iiiii[HEAP32[$261 >> 2] & 31](HEAP32[$D >> 2] | 0, $size1$i9$i, 4, HEAP32[$262 >> 2] | 0) | 0; //@line 18146
    HEAP32[$10 >> 2] = $280; //@line 18147
    if ($280) {
     $292 = $280; //@line 18150
     break;
    }
    $287 = FUNCTION_TABLE_iiiii[HEAP32[$261 >> 2] & 31](HEAP32[$D >> 2] | 0, $265 + 16 | 0, HEAP32[$size1$i9$i >> 2] | 0, HEAP32[$262 >> 2] | 0) | 0; //@line 18158
    HEAP32[$10 >> 2] = $287; //@line 18159
    $292 = $287; //@line 18160
   } while (0);
   $288 = HEAP32[$260 >> 2] | 0; //@line 18163
   HEAP32[$x$i1$i >> 2] = HEAP32[$288 + ($i$013$i * 12 | 0) + 4 >> 2]; //@line 18166
   if (!$292) {
    $296 = FUNCTION_TABLE_iiiii[HEAP32[$261 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 4, HEAP32[$262 >> 2] | 0) | 0; //@line 18172
    HEAP32[$10 >> 2] = $296; //@line 18173
    $298 = HEAP32[$260 >> 2] | 0; //@line 18175
    $301 = $296; //@line 18175
   } else {
    $298 = $288; //@line 18177
    $301 = $292; //@line 18177
   }
   HEAP32[$x$i1$i >> 2] = HEAP32[$298 + ($i$013$i * 12 | 0) + 8 >> 2]; //@line 18181
   if (!$301) {
    $305 = FUNCTION_TABLE_iiiii[HEAP32[$261 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 4, HEAP32[$262 >> 2] | 0) | 0; //@line 18187
    HEAP32[$10 >> 2] = $305; //@line 18188
    $358 = $305; //@line 18189
   } else $358 = $301; //@line 18191
   $i$013$i = $i$013$i + 1 | 0; //@line 18193
   if (($i$013$i | 0) == ($250 | 0)) {
    $312 = $358; //@line 18196
    break;
   } else $268 = $358; //@line 18199
  }
 } else $312 = $357; //@line 18203
 if (!(HEAP32[$193 >> 2] | 0)) $310 = HEAP32[$160 >> 2] | 0; //@line 18209
 else $310 = 0; //@line 18211
 HEAP32[$5 >> 2] = $310; //@line 18213
 if (!$312) {
  $318 = FUNCTION_TABLE_iiiii[HEAP32[$D + 4 >> 2] & 31](HEAP32[$D >> 2] | 0, $5, 4, HEAP32[$D + 8 >> 2] | 0) | 0; //@line 18221
  HEAP32[$10 >> 2] = $318; //@line 18222
  $359 = $318; //@line 18223
 } else $359 = $312; //@line 18225
 if (($310 | 0) <= 0) {
  STACKTOP = sp; //@line 18229
  return;
 }
 $320 = $f + 28 | 0; //@line 18231
 $321 = $D + 4 | 0; //@line 18232
 $322 = $D + 8 | 0; //@line 18233
 $328 = $359; //@line 18234
 $i$112$i = 0; //@line 18234
 while (1) {
  $325 = HEAP32[(HEAP32[$320 >> 2] | 0) + ($i$112$i << 3) >> 2] | 0; //@line 18238
  do if (!$325) {
   HEAP32[$x$i1$i >> 2] = 0; //@line 18242
   if ($328) {
    $360 = $328; //@line 18245
    break;
   }
   $332 = FUNCTION_TABLE_iiiii[HEAP32[$321 >> 2] & 31](HEAP32[$D >> 2] | 0, $x$i1$i, 4, HEAP32[$322 >> 2] | 0) | 0; //@line 18251
   HEAP32[$10 >> 2] = $332; //@line 18252
   $360 = $332; //@line 18253
  } else {
   HEAP32[$size1$i9$i >> 2] = (HEAP32[$325 + 12 >> 2] | 0) + 1; //@line 18258
   if ($328) {
    $360 = $328; //@line 18261
    break;
   }
   $340 = FUNCTION_TABLE_iiiii[HEAP32[$321 >> 2] & 31](HEAP32[$D >> 2] | 0, $size1$i9$i, 4, HEAP32[$322 >> 2] | 0) | 0; //@line 18267
   HEAP32[$10 >> 2] = $340; //@line 18268
   if ($340) {
    $360 = $340; //@line 18271
    break;
   }
   $347 = FUNCTION_TABLE_iiiii[HEAP32[$321 >> 2] & 31](HEAP32[$D >> 2] | 0, $325 + 16 | 0, HEAP32[$size1$i9$i >> 2] | 0, HEAP32[$322 >> 2] | 0) | 0; //@line 18279
   HEAP32[$10 >> 2] = $347; //@line 18280
   $360 = $347; //@line 18281
  } while (0);
  $i$112$i = $i$112$i + 1 | 0; //@line 18284
  if (($i$112$i | 0) == ($310 | 0)) break; else $328 = $360; //@line 18289
 }
 STACKTOP = sp; //@line 18292
 return;
}
function _strstr($h, $n) {
 $h = $h | 0;
 $n = $n | 0;
 var $$0 = 0, $$0$lcssa$i = 0, $$0$lcssa$i15 = 0, $$0$lcssa$i7 = 0, $$01$i = 0, $$02$i = 0, $$02$i11 = 0, $$02$i5 = 0, $$02$us$i = 0, $$lcssa$i = 0, $$lcssa$i14 = 0, $$mem$0$us$i = 0, $$pr$i = 0, $$pr$us$i = 0, $0 = 0, $105 = 0, $106 = 0, $110 = 0, $113 = 0, $12 = 0, $120 = 0, $122 = 0, $127 = 0, $129 = 0, $132 = 0, $136 = 0, $140 = 0, $145 = 0, $147 = 0, $148 = 0, $151 = 0, $155 = 0, $163 = 0, $165 = 0, $169 = 0, $17 = 0, $173 = 0, $174 = 0, $175 = 0, $177 = 0, $180 = 0, $188 = 0, $197 = 0, $198 = 0, $204 = 0, $207 = 0, $225 = 0, $228 = 0, $229 = 0, $23 = 0, $237 = 0, $246 = 0, $251 = 0, $254 = 0, $26 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $3 = 0, $32 = 0, $34 = 0, $35 = 0, $38 = 0, $47 = 0, $56 = 0, $58 = 0, $59 = 0, $6 = 0, $63 = 0, $66 = 0, $67 = 0, $8 = 0, $81 = 0, $9 = 0, $92 = 0, $95 = 0, $96 = 0, $99 = 0, $byteset$i = 0, $hw$0$in2$i = 0, $hw$03$i = 0, $hw$03$i10 = 0, $ip$0$ph78$i = 0, $ip$0$ph78146$i = 0, $ip$0$ph81$i = 0, $ip$1$ip$0$i = 0, $ip$1$ph58$i = 0, $ip$1$ph61$i = 0, $jp$0$ph22$ph72$i = 0, $jp$0$ph2266$i = 0, $jp$0$ph82$i = 0, $jp$1$ph11$ph52$i = 0, $jp$1$ph1146$i = 0, $jp$1$ph62$i = 0, $k$030$i = 0, $k$117$i = 0, $k$37$i = 0, $k$37$us$i = 0, $k$4$i = 0, $k$4$us$i = 0, $l$039$i = 0, $mem$0$us$i = 0, $p$0$ph$ph70$i = 0, $p$0$ph$ph70150$i = 0, $p$0$ph$ph73$i = 0, $p$1$p$0$i = 0, $p$1$ph$ph50$i = 0, $p$1$ph$ph53$i = 0, $p$3155$i = 0, $shift$i = 0, $z$0$i = 0, $z$0$us$i = 0, $z$1$i = 0, $z$1$us$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5851
 STACKTOP = STACKTOP + 1056 | 0; //@line 5852
 $byteset$i = sp + 1024 | 0; //@line 5853
 $shift$i = sp; //@line 5854
 $0 = HEAP8[$n >> 0] | 0; //@line 5855
 if (!($0 << 24 >> 24)) {
  $$0 = $h; //@line 5858
  STACKTOP = sp; //@line 5859
  return $$0 | 0; //@line 5859
 }
 $3 = _strchr($h, $0 << 24 >> 24) | 0; //@line 5862
 if (!$3) {
  $$0 = 0; //@line 5865
  STACKTOP = sp; //@line 5866
  return $$0 | 0; //@line 5866
 }
 $6 = HEAP8[$n + 1 >> 0] | 0; //@line 5869
 if (!($6 << 24 >> 24)) {
  $$0 = $3; //@line 5872
  STACKTOP = sp; //@line 5873
  return $$0 | 0; //@line 5873
 }
 $8 = $3 + 1 | 0; //@line 5875
 $9 = HEAP8[$8 >> 0] | 0; //@line 5876
 if (!($9 << 24 >> 24)) {
  $$0 = 0; //@line 5879
  STACKTOP = sp; //@line 5880
  return $$0 | 0; //@line 5880
 }
 $12 = HEAP8[$n + 2 >> 0] | 0; //@line 5883
 if (!($12 << 24 >> 24)) {
  $17 = $6 & 255 | ($0 & 255) << 8; //@line 5889
  $$01$i = $8; //@line 5895
  $270 = $9; //@line 5895
  $hw$0$in2$i = HEAPU8[$3 >> 0] << 8 | $9 & 255; //@line 5895
  while (1) {
   $23 = $hw$0$in2$i & 65535; //@line 5897
   if (($23 | 0) == ($17 | 0)) {
    $$0$lcssa$i = $$01$i; //@line 5900
    $32 = $270; //@line 5900
    break;
   }
   $26 = $$01$i + 1 | 0; //@line 5904
   $27 = HEAP8[$26 >> 0] | 0; //@line 5905
   if (!($27 << 24 >> 24)) {
    $$0$lcssa$i = $26; //@line 5910
    $32 = 0; //@line 5910
    break;
   } else {
    $$01$i = $26; //@line 5913
    $270 = $27; //@line 5913
    $hw$0$in2$i = $27 & 255 | $23 << 8; //@line 5913
   }
  }
  $$0 = $32 << 24 >> 24 == 0 ? 0 : $$0$lcssa$i + -1 | 0; //@line 5919
  STACKTOP = sp; //@line 5920
  return $$0 | 0; //@line 5920
 }
 $34 = $3 + 2 | 0; //@line 5922
 $35 = HEAP8[$34 >> 0] | 0; //@line 5923
 if (!($35 << 24 >> 24)) {
  $$0 = 0; //@line 5926
  STACKTOP = sp; //@line 5927
  return $$0 | 0; //@line 5927
 }
 $38 = HEAP8[$n + 3 >> 0] | 0; //@line 5930
 if (!($38 << 24 >> 24)) {
  $47 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8; //@line 5940
  $56 = ($35 & 255) << 8 | ($9 & 255) << 16 | HEAPU8[$3 >> 0] << 24; //@line 5949
  if (($56 | 0) == ($47 | 0)) {
   $$0$lcssa$i7 = $34; //@line 5952
   $$lcssa$i = 0; //@line 5952
  } else {
   $$02$i5 = $34; //@line 5954
   $hw$03$i = $56; //@line 5954
   while (1) {
    $58 = $$02$i5 + 1 | 0; //@line 5956
    $59 = HEAP8[$58 >> 0] | 0; //@line 5957
    $hw$03$i = ($59 & 255 | $hw$03$i) << 8; //@line 5960
    $63 = $59 << 24 >> 24 == 0; //@line 5961
    if ($63 | ($hw$03$i | 0) == ($47 | 0)) {
     $$0$lcssa$i7 = $58; //@line 5965
     $$lcssa$i = $63; //@line 5965
     break;
    } else $$02$i5 = $58; //@line 5968
   }
  }
  $$0 = $$lcssa$i ? 0 : $$0$lcssa$i7 + -2 | 0; //@line 5974
  STACKTOP = sp; //@line 5975
  return $$0 | 0; //@line 5975
 }
 $66 = $3 + 3 | 0; //@line 5977
 $67 = HEAP8[$66 >> 0] | 0; //@line 5978
 if (!($67 << 24 >> 24)) {
  $$0 = 0; //@line 5981
  STACKTOP = sp; //@line 5982
  return $$0 | 0; //@line 5982
 }
 if (!(HEAP8[$n + 4 >> 0] | 0)) {
  $81 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8 | $38 & 255; //@line 5997
  $92 = ($35 & 255) << 8 | ($9 & 255) << 16 | $67 & 255 | HEAPU8[$3 >> 0] << 24; //@line 6008
  if (($92 | 0) == ($81 | 0)) {
   $$0$lcssa$i15 = $66; //@line 6011
   $$lcssa$i14 = 0; //@line 6011
  } else {
   $$02$i11 = $66; //@line 6013
   $hw$03$i10 = $92; //@line 6013
   while (1) {
    $95 = $$02$i11 + 1 | 0; //@line 6016
    $96 = HEAP8[$95 >> 0] | 0; //@line 6017
    $hw$03$i10 = $96 & 255 | $hw$03$i10 << 8; //@line 6019
    $99 = $96 << 24 >> 24 == 0; //@line 6020
    if ($99 | ($hw$03$i10 | 0) == ($81 | 0)) {
     $$0$lcssa$i15 = $95; //@line 6024
     $$lcssa$i14 = $99; //@line 6024
     break;
    } else $$02$i11 = $95; //@line 6027
   }
  }
  $$0 = $$lcssa$i14 ? 0 : $$0$lcssa$i15 + -3 | 0; //@line 6033
  STACKTOP = sp; //@line 6034
  return $$0 | 0; //@line 6034
 }
 HEAP32[$byteset$i + 0 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 4 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 8 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 12 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 16 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 20 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 24 >> 2] = 0; //@line 6036
 HEAP32[$byteset$i + 28 >> 2] = 0; //@line 6036
 $106 = $0; //@line 6037
 $l$039$i = 0; //@line 6037
 while (1) {
  if (!(HEAP8[$3 + $l$039$i >> 0] | 0)) {
   $$0 = 0; //@line 6043
   label = 79; //@line 6044
   break;
  }
  $105 = $106 & 255; //@line 6047
  $110 = $byteset$i + ($105 >>> 5 << 2) | 0; //@line 6051
  HEAP32[$110 >> 2] = HEAP32[$110 >> 2] | 1 << ($105 & 31); //@line 6054
  $113 = $l$039$i + 1 | 0; //@line 6055
  HEAP32[$shift$i + ($105 << 2) >> 2] = $113; //@line 6057
  $106 = HEAP8[$n + $113 >> 0] | 0; //@line 6059
  if (!($106 << 24 >> 24)) break; else $l$039$i = $113; //@line 6064
 }
 if ((label | 0) == 79) {
  STACKTOP = sp; //@line 6068
  return $$0 | 0; //@line 6068
 }
 L49 : do if ($113 >>> 0 > 1) {
  $271 = 1; //@line 6073
  $ip$0$ph81$i = -1; //@line 6073
  $jp$0$ph82$i = 0; //@line 6073
  L50 : while (1) {
   $272 = $271; //@line 6075
   $jp$0$ph22$ph72$i = $jp$0$ph82$i; //@line 6075
   $p$0$ph$ph73$i = 1; //@line 6075
   while (1) {
    $273 = $272; //@line 6077
    $jp$0$ph2266$i = $jp$0$ph22$ph72$i; //@line 6077
    L54 : while (1) {
     $120 = $273; //@line 6079
     $k$030$i = 1; //@line 6079
     while (1) {
      $127 = HEAP8[$n + ($k$030$i + $ip$0$ph81$i) >> 0] | 0; //@line 6083
      $129 = HEAP8[$n + $120 >> 0] | 0; //@line 6085
      if ($127 << 24 >> 24 != $129 << 24 >> 24) break L54;
      if (($k$030$i | 0) == ($p$0$ph$ph73$i | 0)) break;
      $k$030$i = $k$030$i + 1 | 0; //@line 6091
      $122 = $k$030$i + $jp$0$ph2266$i | 0; //@line 6095
      if ($122 >>> 0 >= $113 >>> 0) {
       $ip$0$ph78$i = $ip$0$ph81$i; //@line 6100
       $p$0$ph$ph70$i = $p$0$ph$ph73$i; //@line 6100
       break L50;
      } else $120 = $122; //@line 6098
     }
     $132 = $jp$0$ph2266$i + $p$0$ph$ph73$i | 0; //@line 6104
     $273 = $132 + 1 | 0; //@line 6105
     if ($273 >>> 0 >= $113 >>> 0) {
      $ip$0$ph78$i = $ip$0$ph81$i; //@line 6110
      $p$0$ph$ph70$i = $p$0$ph$ph73$i; //@line 6110
      break L50;
     } else $jp$0$ph2266$i = $132; //@line 6108
    }
    $136 = $120 - $ip$0$ph81$i | 0; //@line 6115
    if (($127 & 255) <= ($129 & 255)) break;
    $272 = $120 + 1 | 0; //@line 6119
    if ($272 >>> 0 >= $113 >>> 0) {
     $ip$0$ph78$i = $ip$0$ph81$i; //@line 6124
     $p$0$ph$ph70$i = $136; //@line 6124
     break L50;
    } else {
     $jp$0$ph22$ph72$i = $120; //@line 6122
     $p$0$ph$ph73$i = $136; //@line 6122
    }
   }
   $271 = $jp$0$ph2266$i + 2 | 0; //@line 6129
   if ($271 >>> 0 >= $113 >>> 0) {
    $ip$0$ph78$i = $jp$0$ph2266$i; //@line 6134
    $p$0$ph$ph70$i = 1; //@line 6134
    break;
   } else {
    $ip$0$ph81$i = $jp$0$ph2266$i; //@line 6132
    $jp$0$ph82$i = $jp$0$ph2266$i + 1 | 0; //@line 6132
   }
  }
  $274 = 1; //@line 6138
  $ip$1$ph61$i = -1; //@line 6138
  $jp$1$ph62$i = 0; //@line 6138
  while (1) {
   $276 = $274; //@line 6140
   $jp$1$ph11$ph52$i = $jp$1$ph62$i; //@line 6140
   $p$1$ph$ph53$i = 1; //@line 6140
   while (1) {
    $275 = $276; //@line 6142
    $jp$1$ph1146$i = $jp$1$ph11$ph52$i; //@line 6142
    L69 : while (1) {
     $147 = $275; //@line 6144
     $k$117$i = 1; //@line 6144
     while (1) {
      $145 = HEAP8[$n + ($k$117$i + $ip$1$ph61$i) >> 0] | 0; //@line 6148
      $148 = HEAP8[$n + $147 >> 0] | 0; //@line 6150
      if ($145 << 24 >> 24 != $148 << 24 >> 24) break L69;
      if (($k$117$i | 0) == ($p$1$ph$ph53$i | 0)) break;
      $k$117$i = $k$117$i + 1 | 0; //@line 6156
      $140 = $k$117$i + $jp$1$ph1146$i | 0; //@line 6160
      if ($140 >>> 0 >= $113 >>> 0) {
       $ip$0$ph78146$i = $ip$0$ph78$i; //@line 6165
       $ip$1$ph58$i = $ip$1$ph61$i; //@line 6165
       $p$0$ph$ph70150$i = $p$0$ph$ph70$i; //@line 6165
       $p$1$ph$ph50$i = $p$1$ph$ph53$i; //@line 6165
       break L49;
      } else $147 = $140; //@line 6163
     }
     $151 = $jp$1$ph1146$i + $p$1$ph$ph53$i | 0; //@line 6169
     $275 = $151 + 1 | 0; //@line 6170
     if ($275 >>> 0 >= $113 >>> 0) {
      $ip$0$ph78146$i = $ip$0$ph78$i; //@line 6175
      $ip$1$ph58$i = $ip$1$ph61$i; //@line 6175
      $p$0$ph$ph70150$i = $p$0$ph$ph70$i; //@line 6175
      $p$1$ph$ph50$i = $p$1$ph$ph53$i; //@line 6175
      break L49;
     } else $jp$1$ph1146$i = $151; //@line 6173
    }
    $155 = $147 - $ip$1$ph61$i | 0; //@line 6180
    if (($145 & 255) >= ($148 & 255)) break;
    $276 = $147 + 1 | 0; //@line 6184
    if ($276 >>> 0 >= $113 >>> 0) {
     $ip$0$ph78146$i = $ip$0$ph78$i; //@line 6189
     $ip$1$ph58$i = $ip$1$ph61$i; //@line 6189
     $p$0$ph$ph70150$i = $p$0$ph$ph70$i; //@line 6189
     $p$1$ph$ph50$i = $155; //@line 6189
     break L49;
    } else {
     $jp$1$ph11$ph52$i = $147; //@line 6187
     $p$1$ph$ph53$i = $155; //@line 6187
    }
   }
   $274 = $jp$1$ph1146$i + 2 | 0; //@line 6194
   if ($274 >>> 0 >= $113 >>> 0) {
    $ip$0$ph78146$i = $ip$0$ph78$i; //@line 6199
    $ip$1$ph58$i = $jp$1$ph1146$i; //@line 6199
    $p$0$ph$ph70150$i = $p$0$ph$ph70$i; //@line 6199
    $p$1$ph$ph50$i = 1; //@line 6199
    break;
   } else {
    $ip$1$ph61$i = $jp$1$ph1146$i; //@line 6197
    $jp$1$ph62$i = $jp$1$ph1146$i + 1 | 0; //@line 6197
   }
  }
 } else {
  $ip$0$ph78146$i = -1; //@line 6204
  $ip$1$ph58$i = -1; //@line 6204
  $p$0$ph$ph70150$i = 1; //@line 6204
  $p$1$ph$ph50$i = 1; //@line 6204
 } while (0);
 $163 = ($ip$1$ph58$i + 1 | 0) >>> 0 > ($ip$0$ph78146$i + 1 | 0) >>> 0; //@line 6209
 $p$1$p$0$i = $163 ? $p$1$ph$ph50$i : $p$0$ph$ph70150$i; //@line 6210
 $ip$1$ip$0$i = $163 ? $ip$1$ph58$i : $ip$0$ph78146$i; //@line 6211
 $165 = $ip$1$ip$0$i + 1 | 0; //@line 6213
 if (!(_memcmp($n, $n + $p$1$p$0$i | 0, $165) | 0)) {
  $173 = $113 - $p$1$p$0$i | 0; //@line 6217
  $174 = $113 | 63; //@line 6218
  if (($113 | 0) == ($p$1$p$0$i | 0)) {
   $228 = $174; //@line 6221
   $p$3155$i = $113; //@line 6221
  } else {
   $$02$us$i = $3; //@line 6223
   $mem$0$us$i = 0; //@line 6223
   $z$0$us$i = $3; //@line 6223
   L83 : while (1) {
    $177 = $$02$us$i; //@line 6226
    do if (($z$0$us$i - $177 | 0) >>> 0 < $113 >>> 0) {
     $180 = _memchr($z$0$us$i, 0, $174) | 0; //@line 6231
     if (!$180) {
      $z$1$us$i = $z$0$us$i + $174 | 0; //@line 6235
      break;
     } else if (($180 - $177 | 0) >>> 0 < $113 >>> 0) {
      $$0 = 0; //@line 6242
      label = 79; //@line 6243
      break L83;
     } else {
      $z$1$us$i = $180; //@line 6246
      break;
     }
    } else $z$1$us$i = $z$0$us$i; //@line 6251
 while (0);
    $188 = HEAPU8[$$02$us$i + $l$039$i >> 0] | 0; //@line 6256
    if (!(1 << ($188 & 31) & HEAP32[$byteset$i + ($188 >>> 5 << 2) >> 2])) {
     $$02$us$i = $$02$us$i + $113 | 0; //@line 6266
     $mem$0$us$i = 0; //@line 6266
     $z$0$us$i = $z$1$us$i; //@line 6266
     continue;
    }
    $197 = HEAP32[$shift$i + ($188 << 2) >> 2] | 0; //@line 6270
    $198 = $113 - $197 | 0; //@line 6271
    if (($113 | 0) != ($197 | 0)) {
     $$02$us$i = $$02$us$i + (($mem$0$us$i | 0) != 0 & $198 >>> 0 < $p$1$p$0$i >>> 0 ? $173 : $198) | 0; //@line 6279
     $mem$0$us$i = 0; //@line 6279
     $z$0$us$i = $z$1$us$i; //@line 6279
     continue;
    }
    $$mem$0$us$i = $165 >>> 0 > $mem$0$us$i >>> 0 ? $165 : $mem$0$us$i; //@line 6283
    $204 = HEAP8[$n + $$mem$0$us$i >> 0] | 0; //@line 6285
    L97 : do if (!($204 << 24 >> 24)) $k$4$us$i = $165; //@line 6289
 else {
     $$pr$us$i = $204; //@line 6291
     $k$37$us$i = $$mem$0$us$i; //@line 6291
     while (1) {
      $207 = $k$37$us$i + 1 | 0; //@line 6296
      if ($$pr$us$i << 24 >> 24 != (HEAP8[$$02$us$i + $k$37$us$i >> 0] | 0)) break;
      $$pr$us$i = HEAP8[$n + $207 >> 0] | 0; //@line 6301
      if (!($$pr$us$i << 24 >> 24)) {
       $k$4$us$i = $165; //@line 6304
       break L97;
      } else $k$37$us$i = $207; //@line 6307
     }
     $$02$us$i = $$02$us$i + ($k$37$us$i - $ip$1$ip$0$i) | 0; //@line 6312
     $mem$0$us$i = 0; //@line 6312
     $z$0$us$i = $z$1$us$i; //@line 6312
     continue L83;
    } while (0);
    do {
     if ($k$4$us$i >>> 0 <= $mem$0$us$i >>> 0) {
      $$0 = $$02$us$i; //@line 6319
      label = 79; //@line 6320
      break L83;
     }
     $k$4$us$i = $k$4$us$i + -1 | 0; //@line 6323
    } while ((HEAP8[$n + $k$4$us$i >> 0] | 0) == (HEAP8[$$02$us$i + $k$4$us$i >> 0] | 0));
    $$02$us$i = $$02$us$i + $p$1$p$0$i | 0; //@line 6336
    $mem$0$us$i = $173; //@line 6336
    $z$0$us$i = $z$1$us$i; //@line 6336
   }
   if ((label | 0) == 79) {
    STACKTOP = sp; //@line 6339
    return $$0 | 0; //@line 6339
   }
  }
 } else {
  $169 = $113 - $ip$1$ip$0$i + -1 | 0; //@line 6344
  $228 = $113 | 63; //@line 6349
  $p$3155$i = ($ip$1$ip$0$i >>> 0 > $169 >>> 0 ? $ip$1$ip$0$i : $169) + 1 | 0; //@line 6349
 }
 $175 = $n + $165 | 0; //@line 6351
 $$02$i = $3; //@line 6352
 $z$0$i = $3; //@line 6352
 L110 : while (1) {
  $225 = $$02$i; //@line 6355
  do if (($z$0$i - $225 | 0) >>> 0 < $113 >>> 0) {
   $229 = _memchr($z$0$i, 0, $228) | 0; //@line 6360
   if (!$229) {
    $z$1$i = $z$0$i + $228 | 0; //@line 6364
    break;
   } else if (($229 - $225 | 0) >>> 0 < $113 >>> 0) {
    $$0 = 0; //@line 6371
    label = 79; //@line 6372
    break L110;
   } else {
    $z$1$i = $229; //@line 6375
    break;
   }
  } else $z$1$i = $z$0$i; //@line 6380
 while (0);
  $237 = HEAPU8[$$02$i + $l$039$i >> 0] | 0; //@line 6385
  if (!(1 << ($237 & 31) & HEAP32[$byteset$i + ($237 >>> 5 << 2) >> 2])) {
   $$02$i = $$02$i + $113 | 0; //@line 6395
   $z$0$i = $z$1$i; //@line 6395
   continue;
  }
  $246 = HEAP32[$shift$i + ($237 << 2) >> 2] | 0; //@line 6399
  if (($113 | 0) != ($246 | 0)) {
   $$02$i = $$02$i + ($113 - $246) | 0; //@line 6404
   $z$0$i = $z$1$i; //@line 6404
   continue;
  }
  $251 = HEAP8[$175 >> 0] | 0; //@line 6407
  L124 : do if (!($251 << 24 >> 24)) $k$4$i = $165; //@line 6411
 else {
   $$pr$i = $251; //@line 6413
   $k$37$i = $165; //@line 6413
   while (1) {
    $254 = $k$37$i + 1 | 0; //@line 6418
    if ($$pr$i << 24 >> 24 != (HEAP8[$$02$i + $k$37$i >> 0] | 0)) break;
    $$pr$i = HEAP8[$n + $254 >> 0] | 0; //@line 6423
    if (!($$pr$i << 24 >> 24)) {
     $k$4$i = $165; //@line 6426
     break L124;
    } else $k$37$i = $254; //@line 6429
   }
   $$02$i = $$02$i + ($k$37$i - $ip$1$ip$0$i) | 0; //@line 6434
   $z$0$i = $z$1$i; //@line 6434
   continue L110;
  } while (0);
  do {
   if (!$k$4$i) {
    $$0 = $$02$i; //@line 6441
    label = 79; //@line 6442
    break L110;
   }
   $k$4$i = $k$4$i + -1 | 0; //@line 6445
  } while ((HEAP8[$n + $k$4$i >> 0] | 0) == (HEAP8[$$02$i + $k$4$i >> 0] | 0));
  $$02$i = $$02$i + $p$3155$i | 0; //@line 6458
  $z$0$i = $z$1$i; //@line 6458
 }
 if ((label | 0) == 79) {
  STACKTOP = sp; //@line 6461
  return $$0 | 0; //@line 6461
 }
 return 0; //@line 6463
}
function _singlestep($L) {
 $L = $L | 0;
 var $$0 = 0, $$02$i$i = 0, $$02$i20$i = 0, $0 = 0, $1 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $11 = 0, $114 = 0, $115 = 0, $12 = 0, $127 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $133 = 0, $136 = 0, $137 = 0, $138 = 0, $14 = 0, $141 = 0, $143 = 0, $144 = 0, $152 = 0, $156 = 0, $157 = 0, $171 = 0, $172 = 0, $183 = 0, $184 = 0, $189 = 0, $191 = 0, $192 = 0, $194 = 0, $197 = 0, $198 = 0, $2 = 0, $204 = 0, $210 = 0, $222 = 0, $227 = 0, $229 = 0, $230 = 0, $232 = 0, $235 = 0, $236 = 0, $242 = 0, $248 = 0, $25 = 0, $262 = 0, $268 = 0, $271 = 0, $274 = 0, $276 = 0, $279 = 0, $281 = 0, $287 = 0, $288 = 0, $289 = 0, $295 = 0, $296 = 0, $298 = 0, $300 = 0, $301 = 0, $304 = 0, $305 = 0, $310 = 0, $316 = 0, $32 = 0, $320 = 0, $322 = 0, $325 = 0, $33 = 0, $47 = 0, $48 = 0, $5 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $67 = 0, $7 = 0, $72 = 0, $80 = 0, $85 = 0, $92 = 0, $98 = 0, $99 = 0, $L$idx$val$i = 0, $changed$0$ph$i$i = 0, $changed$0$ph$i11$i = 0, $i$0$i$i = 0, $i$0$i1$i = 0, $i$0$lcssa = 0, $i$016 = 0, $lastnext$0$i$i = 0, $lastnext$1$ph5$us$i$i = 0, $lastnext$13$us$us$i$i = 0, $lastnext$13$us$us$i$i$phi = 0, $mt = 0, $n$01$i$i = 0, $n$01$i22$i = 0, $next$0$i$i = 0, $next$0$i14$i = 0, $next$0$ph$i$i = 0, $next$0$ph$i12$i = 0, $o$01$i$i = 0, $o$01$i$i2 = 0, $o$02$i$i = 0, $o$02$i$i3 = 0, $p$0$ph4$us$i$i = 0, $uv$03$i$i = 0, $uv$04$i$i = 0, label = 0, sp = 0, $next$0$i$i$looptemp = 0, $next$0$i14$i$looptemp = 0;
 sp = STACKTOP; //@line 19568
 STACKTOP = STACKTOP + 16 | 0; //@line 19569
 $mt = sp; //@line 19570
 $0 = $L + 12 | 0; //@line 19571
 $1 = HEAP32[$0 >> 2] | 0; //@line 19572
 $2 = $1 + 61 | 0; //@line 19573
 switch (HEAPU8[$2 >> 0] | 0) {
 case 0:
  {
   if (HEAP32[$1 + 84 >> 2] | 0) {
    $47 = $1 + 16 | 0; //@line 19582
    $48 = HEAP32[$47 >> 2] | 0; //@line 19583
    _propagatemark($1); //@line 19584
    $$0 = (HEAP32[$47 >> 2] | 0) - $48 | 0; //@line 19587
    STACKTOP = sp; //@line 19588
    return $$0 | 0; //@line 19588
   }
   HEAP8[$2 >> 0] = 1; //@line 19590
   $53 = $1 + 20 | 0; //@line 19593
   HEAP32[$53 >> 2] = HEAP32[$1 + 16 >> 2]; //@line 19594
   $54 = HEAP32[$0 >> 2] | 0; //@line 19595
   $55 = $54 + 16 | 0; //@line 19596
   $56 = HEAP32[$55 >> 2] | 0; //@line 19597
   if ($L) if (HEAP8[$L + 5 >> 0] & 3) _reallymarkobject($54, $L); //@line 19605
   if (HEAP32[$54 + 48 >> 2] & 64) {
    $67 = HEAP32[$54 + 40 >> 2] | 0; //@line 19614
    if (HEAP8[$67 + 5 >> 0] & 3) _reallymarkobject($54, $67); //@line 19620
   }
   _markmt($54); //@line 19623
   $72 = $54 + 112 | 0; //@line 19624
   $uv$03$i$i = HEAP32[$54 + 132 >> 2] | 0; //@line 19627
   if (($uv$03$i$i | 0) != ($72 | 0)) {
    $uv$04$i$i = $uv$03$i$i; //@line 19630
    do {
     if (!(HEAP8[$uv$04$i$i + 5 >> 0] & 7)) {
      $80 = HEAP32[$uv$04$i$i + 8 >> 2] | 0; //@line 19638
      if (HEAP32[$80 + 8 >> 2] & 64) {
       $85 = HEAP32[$80 >> 2] | 0; //@line 19644
       if (HEAP8[$85 + 5 >> 0] & 3) _reallymarkobject($54, $85); //@line 19650
      }
     }
     $uv$04$i$i = HEAP32[$uv$04$i$i + 20 >> 2] | 0; //@line 19656
    } while (($uv$04$i$i | 0) != ($72 | 0));
   }
   $92 = $54 + 84 | 0; //@line 19665
   if (HEAP32[$92 >> 2] | 0) do _propagatemark($54); //@line 19670
 while ((HEAP32[$92 >> 2] | 0) != 0);
   $98 = (HEAP32[$55 >> 2] | 0) - $56 | 0; //@line 19679
   $99 = $54 + 92 | 0; //@line 19680
   $100 = HEAP32[$99 >> 2] | 0; //@line 19681
   $101 = $54 + 88 | 0; //@line 19682
   $102 = HEAP32[$101 >> 2] | 0; //@line 19683
   $103 = $54 + 96 | 0; //@line 19684
   $104 = HEAP32[$103 >> 2] | 0; //@line 19685
   HEAP32[$103 >> 2] = 0; //@line 19686
   HEAP32[$101 >> 2] = 0; //@line 19687
   HEAP32[$99 >> 2] = 0; //@line 19688
   HEAP32[$92 >> 2] = $102; //@line 19689
   if ($102) do _propagatemark($54); //@line 19693
 while ((HEAP32[$92 >> 2] | 0) != 0);
   HEAP32[$92 >> 2] = $100; //@line 19701
   if ($100) do _propagatemark($54); //@line 19705
 while ((HEAP32[$92 >> 2] | 0) != 0);
   HEAP32[$92 >> 2] = $104; //@line 19713
   if ($104) do _propagatemark($54); //@line 19717
 while ((HEAP32[$92 >> 2] | 0) != 0);
   $114 = HEAP32[$55 >> 2] | 0; //@line 19725
   while (1) {
    $115 = HEAP32[$103 >> 2] | 0; //@line 19727
    HEAP32[$103 >> 2] = 0; //@line 19728
    $changed$0$ph$i$i = 0; //@line 19729
    $next$0$ph$i$i = $115; //@line 19729
    L42 : while (1) {
     $next$0$i$i = $next$0$ph$i$i; //@line 19731
     do {
      if (!$next$0$i$i) break L42;
      $next$0$i$i$looptemp = $next$0$i$i;
      $next$0$i$i = HEAP32[$next$0$i$i + 24 >> 2] | 0; //@line 19738
     } while ((_traverseephemeron($54, $next$0$i$i$looptemp) | 0) == 0);
     if (!(HEAP32[$92 >> 2] | 0)) {
      $changed$0$ph$i$i = 1; //@line 19750
      $next$0$ph$i$i = $next$0$i$i; //@line 19750
      continue;
     }
     while (1) {
      _propagatemark($54); //@line 19754
      if (!(HEAP32[$92 >> 2] | 0)) {
       $changed$0$ph$i$i = 1; //@line 19758
       $next$0$ph$i$i = $next$0$i$i; //@line 19758
       continue L42;
      }
     }
    }
    if (!$changed$0$ph$i$i) break;
   }
   _clearvalues($54, HEAP32[$99 >> 2] | 0, 0); //@line 19769
   $127 = $54 + 100 | 0; //@line 19770
   _clearvalues($54, HEAP32[$127 >> 2] | 0, 0); //@line 19772
   $129 = HEAP32[$99 >> 2] | 0; //@line 19773
   $130 = HEAP32[$127 >> 2] | 0; //@line 19774
   $131 = HEAP32[$55 >> 2] | 0; //@line 19775
   $L$idx$val$i = HEAP32[$0 >> 2] | 0; //@line 19776
   $lastnext$0$i$i = $L$idx$val$i + 104 | 0; //@line 19778
   while (1) {
    $133 = HEAP32[$lastnext$0$i$i >> 2] | 0; //@line 19780
    if (!$133) break; else $lastnext$0$i$i = $133; //@line 19785
   }
   $136 = $98 - $114 + $131 | 0; //@line 19789
   $137 = $L$idx$val$i + 72 | 0; //@line 19790
   $138 = HEAP32[$137 >> 2] | 0; //@line 19791
   L55 : do if ($138) {
    $325 = $138; //@line 19795
    $lastnext$1$ph5$us$i$i = $lastnext$0$i$i; //@line 19795
    $p$0$ph4$us$i$i = $137; //@line 19795
    while (1) {
     $141 = $325; //@line 19797
     $lastnext$13$us$us$i$i = $lastnext$1$ph5$us$i$i; //@line 19797
     while (1) {
      $143 = $141 + 5 | 0; //@line 19799
      $144 = HEAP8[$143 >> 0] | 0; //@line 19800
      if (!($144 & 3)) break;
      HEAP8[$143 >> 0] = $144 & 255 | 8; //@line 19809
      HEAP32[$p$0$ph4$us$i$i >> 2] = HEAP32[$141 >> 2]; //@line 19811
      HEAP32[$141 >> 2] = HEAP32[$lastnext$13$us$us$i$i >> 2]; //@line 19813
      HEAP32[$lastnext$13$us$us$i$i >> 2] = $141; //@line 19814
      $152 = HEAP32[$p$0$ph4$us$i$i >> 2] | 0; //@line 19815
      if (!$152) break L55; else {
       $lastnext$13$us$us$i$i$phi = $141; //@line 19820
       $141 = $152; //@line 19820
       $lastnext$13$us$us$i$i = $lastnext$13$us$us$i$i$phi; //@line 19820
      }
     }
     $325 = HEAP32[$141 >> 2] | 0; //@line 19823
     if (!$325) break; else {
      $lastnext$1$ph5$us$i$i = $lastnext$13$us$us$i$i; //@line 19828
      $p$0$ph4$us$i$i = $141; //@line 19828
     }
    }
   } while (0);
   $o$01$i$i2 = HEAP32[$54 + 104 >> 2] | 0; //@line 19834
   if ($o$01$i$i2) {
    $156 = $54 + 60 | 0; //@line 19837
    $o$02$i$i3 = $o$01$i$i2; //@line 19838
    do {
     $157 = $o$02$i$i3 + 5 | 0; //@line 19840
     HEAP8[$157 >> 0] = HEAPU8[$156 >> 0] & 3 | HEAPU8[$157 >> 0] & 184; //@line 19849
     _reallymarkobject($54, $o$02$i$i3); //@line 19850
     $o$02$i$i3 = HEAP32[$o$02$i$i3 >> 2] | 0; //@line 19851
    } while (($o$02$i$i3 | 0) != 0);
   }
   if (HEAP32[$92 >> 2] | 0) do _propagatemark($54); //@line 19864
 while ((HEAP32[$92 >> 2] | 0) != 0);
   $171 = HEAP32[$55 >> 2] | 0; //@line 19872
   while (1) {
    $172 = HEAP32[$103 >> 2] | 0; //@line 19874
    HEAP32[$103 >> 2] = 0; //@line 19875
    $changed$0$ph$i11$i = 0; //@line 19876
    $next$0$ph$i12$i = $172; //@line 19876
    L74 : while (1) {
     $next$0$i14$i = $next$0$ph$i12$i; //@line 19878
     do {
      if (!$next$0$i14$i) break L74;
      $next$0$i14$i$looptemp = $next$0$i14$i;
      $next$0$i14$i = HEAP32[$next$0$i14$i + 24 >> 2] | 0; //@line 19885
     } while ((_traverseephemeron($54, $next$0$i14$i$looptemp) | 0) == 0);
     if (!(HEAP32[$92 >> 2] | 0)) {
      $changed$0$ph$i11$i = 1; //@line 19897
      $next$0$ph$i12$i = $next$0$i14$i; //@line 19897
      continue;
     }
     while (1) {
      _propagatemark($54); //@line 19901
      if (!(HEAP32[$92 >> 2] | 0)) {
       $changed$0$ph$i11$i = 1; //@line 19905
       $next$0$ph$i12$i = $next$0$i14$i; //@line 19905
       continue L74;
      }
     }
    }
    if (!$changed$0$ph$i11$i) break;
   }
   $183 = $136 - $171 | 0; //@line 19915
   $184 = HEAP32[$103 >> 2] | 0; //@line 19916
   if ($184) {
    $$02$i$i = $184; //@line 19919
    do {
     $189 = 1 << HEAPU8[$$02$i$i + 7 >> 0]; //@line 19924
     $191 = HEAP32[$$02$i$i + 16 >> 2] | 0; //@line 19926
     $192 = $191 + ($189 << 5) | 0; //@line 19927
     if (($189 | 0) > 0) {
      $n$01$i$i = $191; //@line 19930
      do {
       $194 = $n$01$i$i + 8 | 0; //@line 19932
       do if (HEAP32[$194 >> 2] | 0) {
        $197 = $n$01$i$i + 24 | 0; //@line 19937
        $198 = HEAP32[$197 >> 2] | 0; //@line 19938
        if (!($198 & 64)) break;
        $204 = HEAP32[$n$01$i$i + 16 >> 2] | 0; //@line 19947
        if (($198 & 15 | 0) == 4) {
         if (!$204) break;
         if (!(HEAP8[$204 + 5 >> 0] & 3)) break;
         _reallymarkobject($54, $204); //@line 19960
         break;
        } else {
         $210 = $204 + 5 | 0; //@line 19963
         if (!(HEAP8[$210 >> 0] & 3)) break;
         HEAP32[$194 >> 2] = 0; //@line 19970
         if (!(HEAP8[$210 >> 0] & 3)) break;
         HEAP32[$197 >> 2] = 11; //@line 19977
         break;
        }
       } while (0);
       $n$01$i$i = $n$01$i$i + 32 | 0; //@line 19982
      } while ($n$01$i$i >>> 0 < $192 >>> 0);
     }
     $$02$i$i = HEAP32[$$02$i$i + 24 >> 2] | 0; //@line 19992
    } while (($$02$i$i | 0) != 0);
   }
   $222 = HEAP32[$127 >> 2] | 0; //@line 20001
   if ($222) {
    $$02$i20$i = $222; //@line 20004
    do {
     $227 = 1 << HEAPU8[$$02$i20$i + 7 >> 0]; //@line 20009
     $229 = HEAP32[$$02$i20$i + 16 >> 2] | 0; //@line 20011
     $230 = $229 + ($227 << 5) | 0; //@line 20012
     if (($227 | 0) > 0) {
      $n$01$i22$i = $229; //@line 20015
      do {
       $232 = $n$01$i22$i + 8 | 0; //@line 20017
       do if (HEAP32[$232 >> 2] | 0) {
        $235 = $n$01$i22$i + 24 | 0; //@line 20022
        $236 = HEAP32[$235 >> 2] | 0; //@line 20023
        if (!($236 & 64)) break;
        $242 = HEAP32[$n$01$i22$i + 16 >> 2] | 0; //@line 20032
        if (($236 & 15 | 0) == 4) {
         if (!$242) break;
         if (!(HEAP8[$242 + 5 >> 0] & 3)) break;
         _reallymarkobject($54, $242); //@line 20045
         break;
        } else {
         $248 = $242 + 5 | 0; //@line 20048
         if (!(HEAP8[$248 >> 0] & 3)) break;
         HEAP32[$232 >> 2] = 0; //@line 20055
         if (!(HEAP8[$248 >> 0] & 3)) break;
         HEAP32[$235 >> 2] = 11; //@line 20062
         break;
        }
       } while (0);
       $n$01$i22$i = $n$01$i22$i + 32 | 0; //@line 20067
      } while ($n$01$i22$i >>> 0 < $230 >>> 0);
     }
     $$02$i20$i = HEAP32[$$02$i20$i + 24 >> 2] | 0; //@line 20077
    } while (($$02$i20$i | 0) != 0);
   }
   _clearvalues($54, HEAP32[$99 >> 2] | 0, $129); //@line 20087
   _clearvalues($54, HEAP32[$127 >> 2] | 0, $130); //@line 20089
   $262 = $54 + 60 | 0; //@line 20090
   HEAP8[$262 >> 0] = HEAPU8[$262 >> 0] ^ 3; //@line 20095
   $268 = $183 + (HEAP32[$55 >> 2] | 0) | 0; //@line 20097
   HEAP32[$53 >> 2] = (HEAP32[$53 >> 2] | 0) + $268; //@line 20100
   $271 = HEAP32[$0 >> 2] | 0; //@line 20101
   HEAP8[$271 + 61 >> 0] = 2; //@line 20103
   HEAP32[$271 + 64 >> 2] = 0; //@line 20105
   $274 = $271 + 72 | 0; //@line 20106
   $i$0$i$i = 0; //@line 20107
   do {
    $i$0$i$i = $i$0$i$i + 1 | 0; //@line 20109
    $276 = _sweeplist($L, $274, 1) | 0; //@line 20110
   } while (($276 | 0) == ($274 | 0));
   HEAP32[$271 + 80 >> 2] = $276; //@line 20119
   $279 = $271 + 68 | 0; //@line 20120
   $i$0$i1$i = 0; //@line 20121
   do {
    $i$0$i1$i = $i$0$i1$i + 1 | 0; //@line 20123
    $281 = _sweeplist($L, $279, 1) | 0; //@line 20124
   } while (($281 | 0) == ($279 | 0));
   HEAP32[$271 + 76 >> 2] = $281; //@line 20134
   $$0 = (($i$0$i1$i + $i$0$i$i | 0) * 5 | 0) + $268 | 0; //@line 20137
   STACKTOP = sp; //@line 20138
   return $$0 | 0; //@line 20138
  }
 case 5:
  {
   $11 = $1 + 16 | 0; //@line 20145
   HEAP32[$11 >> 2] = HEAP32[$1 + 32 >> 2] << 2; //@line 20146
   $12 = $1 + 84 | 0; //@line 20147
   $13 = $1 + 172 | 0; //@line 20148
   HEAP32[$12 + 0 >> 2] = 0; //@line 20149
   HEAP32[$12 + 4 >> 2] = 0; //@line 20149
   HEAP32[$12 + 8 >> 2] = 0; //@line 20149
   HEAP32[$12 + 12 >> 2] = 0; //@line 20149
   HEAP32[$12 + 16 >> 2] = 0; //@line 20149
   $14 = HEAP32[$13 >> 2] | 0; //@line 20150
   if ($14) if (HEAP8[$14 + 5 >> 0] & 3) _reallymarkobject($1, $14); //@line 20158
   if (HEAP32[$1 + 48 >> 2] & 64) {
    $25 = HEAP32[$1 + 40 >> 2] | 0; //@line 20167
    if (HEAP8[$25 + 5 >> 0] & 3) _reallymarkobject($1, $25); //@line 20173
   }
   _markmt($1); //@line 20176
   $o$01$i$i = HEAP32[$1 + 104 >> 2] | 0; //@line 20178
   if ($o$01$i$i) {
    $32 = $1 + 60 | 0; //@line 20181
    $o$02$i$i = $o$01$i$i; //@line 20182
    do {
     $33 = $o$02$i$i + 5 | 0; //@line 20184
     HEAP8[$33 >> 0] = HEAPU8[$32 >> 0] & 3 | HEAPU8[$33 >> 0] & 184; //@line 20193
     _reallymarkobject($1, $o$02$i$i); //@line 20194
     $o$02$i$i = HEAP32[$o$02$i$i >> 2] | 0; //@line 20195
    } while (($o$02$i$i | 0) != 0);
   }
   HEAP8[$2 >> 0] = 0; //@line 20204
   $$0 = HEAP32[$11 >> 2] | 0; //@line 20206
   STACKTOP = sp; //@line 20207
   return $$0 | 0; //@line 20207
  }
 case 3:
  {
   $300 = $1 + 80 | 0; //@line 20211
   $301 = HEAP32[$300 >> 2] | 0; //@line 20212
   if (!$301) {
    HEAP8[$2 >> 0] = 4; //@line 20215
    $$0 = 0; //@line 20216
    STACKTOP = sp; //@line 20217
    return $$0 | 0; //@line 20217
   } else {
    HEAP32[$300 >> 2] = _sweeplist($L, $301, 80) | 0; //@line 20220
    $$0 = 400; //@line 20221
    STACKTOP = sp; //@line 20222
    return $$0 | 0; //@line 20222
   }
   break;
  }
 case 4:
  {
   $304 = $1 + 76 | 0; //@line 20227
   $305 = HEAP32[$304 >> 2] | 0; //@line 20228
   if ($305) {
    HEAP32[$304 >> 2] = _sweeplist($L, $305, 80) | 0; //@line 20232
    $$0 = 400; //@line 20233
    STACKTOP = sp; //@line 20234
    return $$0 | 0; //@line 20234
   }
   HEAP32[$mt >> 2] = HEAP32[$1 + 172 >> 2]; //@line 20238
   _sweeplist($L, $mt, 1) | 0; //@line 20239
   $310 = HEAP32[$0 >> 2] | 0; //@line 20240
   if ((HEAP8[$310 + 62 >> 0] | 0) != 1) {
    $316 = (HEAP32[$310 + 32 >> 2] | 0) / 2 | 0; //@line 20247
    if ((HEAP32[$310 + 28 >> 2] | 0) >>> 0 < $316 >>> 0) _luaS_resize($L, $316); //@line 20252
    $320 = $310 + 144 | 0; //@line 20254
    $322 = $310 + 152 | 0; //@line 20256
    HEAP32[$320 >> 2] = _luaM_realloc_($L, HEAP32[$320 >> 2] | 0, HEAP32[$322 >> 2] | 0, 0) | 0; //@line 20259
    HEAP32[$322 >> 2] = 0; //@line 20260
   }
   HEAP8[$2 >> 0] = 5; //@line 20262
   $$0 = 5; //@line 20263
   STACKTOP = sp; //@line 20264
   return $$0 | 0; //@line 20264
  }
 case 2:
  {
   $5 = $1 + 64 | 0; //@line 20268
   $6 = $1 + 32 | 0; //@line 20269
   $7 = $1 + 24 | 0; //@line 20270
   $i$016 = 0; //@line 20271
   while (1) {
    $287 = HEAP32[$5 >> 2] | 0; //@line 20273
    $288 = $287 + $i$016 | 0; //@line 20274
    $289 = HEAP32[$6 >> 2] | 0; //@line 20275
    if (($288 | 0) >= ($289 | 0)) {
     $296 = $287; //@line 20278
     $298 = $289; //@line 20278
     $i$0$lcssa = $i$016; //@line 20278
     break;
    }
    _sweeplist($L, (HEAP32[$7 >> 2] | 0) + ($288 << 2) | 0, -3) | 0; //@line 20283
    $i$016 = $i$016 + 1 | 0; //@line 20284
    if (($i$016 | 0) >= 80) {
     label = 96; //@line 20289
     break;
    }
   }
   if ((label | 0) == 96) {
    $296 = HEAP32[$5 >> 2] | 0; //@line 20296
    $298 = HEAP32[$6 >> 2] | 0; //@line 20296
    $i$0$lcssa = $i$016; //@line 20296
   }
   $295 = $296 + $i$0$lcssa | 0; //@line 20298
   HEAP32[$5 >> 2] = $295; //@line 20299
   if (($295 | 0) >= ($298 | 0)) HEAP8[$2 >> 0] = 3; //@line 20302
   $$0 = $i$0$lcssa * 5 | 0; //@line 20305
   STACKTOP = sp; //@line 20306
   return $$0 | 0; //@line 20306
  }
 default:
  {
   $$0 = 0; //@line 20310
   STACKTOP = sp; //@line 20311
   return $$0 | 0; //@line 20311
  }
 }
 return 0; //@line 20314
}
function _propagatemark($g) {
 $g = $g | 0;
 var $$lcssa$i = 0, $$lcssa$i13 = 0, $$lcssa$i4 = 0, $$ph7$i = 0, $$ph8$i = 0, $$pr6$i = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $108 = 0, $109 = 0, $115 = 0, $12 = 0, $122 = 0, $124 = 0, $125 = 0, $126 = 0, $128 = 0, $13 = 0, $131 = 0, $139 = 0, $145 = 0, $147 = 0, $166 = 0, $172 = 0, $173 = 0, $177 = 0, $184 = 0, $185 = 0, $191 = 0, $192 = 0, $2 = 0, $200 = 0, $206 = 0, $207 = 0, $21 = 0, $211 = 0, $213 = 0, $219 = 0, $22 = 0, $220 = 0, $222 = 0, $223 = 0, $229 = 0, $235 = 0, $237 = 0, $242 = 0, $244 = 0, $249 = 0, $251 = 0, $253 = 0, $264 = 0, $265 = 0, $272 = 0, $278 = 0, $279 = 0, $281 = 0, $282 = 0, $283 = 0, $285 = 0, $286 = 0, $292 = 0, $299 = 0, $300 = 0, $301 = 0, $303 = 0, $306 = 0, $314 = 0, $315 = 0, $316 = 0, $318 = 0, $321 = 0, $329 = 0, $332 = 0, $34 = 0, $340 = 0, $35 = 0, $350 = 0, $355 = 0, $358 = 0, $359 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $37 = 0, $38 = 0, $46 = 0, $48 = 0, $49 = 0, $53 = 0, $55 = 0, $58 = 0, $61 = 0, $69 = 0, $75 = 0, $80 = 0, $92 = 0, $94 = 0, $96 = 0, $ci$04$i = 0, $hasclears$0$lcssa$i$i = 0, $hasclears$04$i$i = 0, $hasclears$1$i$i = 0, $i$01$i = 0, $i$01$i1 = 0, $i$016$i = 0, $i$03$i$i = 0, $i$111$i = 0, $i$26$i = 0, $i$33$i = 0, $n$0$lcssa$i = 0, $n$01$i$i = 0, $n$02$i$i = 0, $n$03$i = 0, $n$1$i = 0, $o$0$lcssa$i = 0, $o$06$i = 0, $o$11$i = 0, $size$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 582
 $0 = $g + 84 | 0; //@line 583
 $1 = HEAP32[$0 >> 2] | 0; //@line 584
 $2 = $1 + 5 | 0; //@line 585
 HEAP8[$2 >> 0] = HEAPU8[$2 >> 0] | 4; //@line 590
 switch (HEAPU8[$1 + 4 >> 0] | 0) {
 case 8:
  {
   $211 = $1 + 60 | 0; //@line 596
   HEAP32[$0 >> 2] = HEAP32[$211 >> 2]; //@line 598
   $213 = $g + 88 | 0; //@line 599
   HEAP32[$211 >> 2] = HEAP32[$213 >> 2]; //@line 601
   HEAP32[$213 >> 2] = $1; //@line 602
   HEAP8[$2 >> 0] = HEAPU8[$2 >> 0] & 251; //@line 607
   $219 = $1 + 28 | 0; //@line 608
   $220 = HEAP32[$219 >> 2] | 0; //@line 609
   if (!$220) $size$0 = 1; //@line 612
 else {
    $222 = $1 + 8 | 0; //@line 614
    $223 = HEAP32[$222 >> 2] | 0; //@line 615
    if ($220 >>> 0 < $223 >>> 0) {
     $361 = $223; //@line 618
     $o$06$i = $220; //@line 618
     while (1) {
      if (!(HEAP32[$o$06$i + 8 >> 2] & 64)) $237 = $361; //@line 625
 else {
       $229 = HEAP32[$o$06$i >> 2] | 0; //@line 627
       if (!(HEAP8[$229 + 5 >> 0] & 3)) $237 = $361; //@line 633
 else {
        _reallymarkobject($g, $229); //@line 635
        $237 = HEAP32[$222 >> 2] | 0; //@line 637
       }
      }
      $235 = $o$06$i + 16 | 0; //@line 640
      if ($235 >>> 0 < $237 >>> 0) {
       $361 = $237; //@line 643
       $o$06$i = $235; //@line 643
      } else {
       $o$0$lcssa$i = $235; //@line 645
       break;
      }
     }
    } else $o$0$lcssa$i = $220; //@line 650
    if ((HEAP8[$g + 61 >> 0] | 0) == 1) {
     $242 = $1 + 32 | 0; //@line 657
     $244 = (HEAP32[$219 >> 2] | 0) + (HEAP32[$242 >> 2] << 4) | 0; //@line 659
     if ($o$0$lcssa$i >>> 0 < $244 >>> 0) {
      $o$11$i = $o$0$lcssa$i; //@line 662
      do {
       HEAP32[$o$11$i + 8 >> 2] = 0; //@line 665
       $o$11$i = $o$11$i + 16 | 0; //@line 666
      } while ($o$11$i >>> 0 < $244 >>> 0);
      $$pre$phi$iZ2D = $242; //@line 671
      $n$1$i = 0; //@line 671
     } else {
      $$pre$phi$iZ2D = $242; //@line 676
      $n$1$i = 0; //@line 676
     }
    } else {
     $249 = $1 + 72 | 0; //@line 679
     $251 = HEAP32[$1 + 16 >> 2] | 0; //@line 681
     if (($249 | 0) == ($251 | 0)) $n$0$lcssa$i = 0; //@line 684
 else {
      $ci$04$i = $249; //@line 686
      $n$03$i = 0; //@line 686
      while (1) {
       $253 = $n$03$i + 1 | 0; //@line 688
       $ci$04$i = HEAP32[$ci$04$i + 12 >> 2] | 0; //@line 690
       if (($ci$04$i | 0) == ($251 | 0)) {
        $n$0$lcssa$i = $253; //@line 693
        break;
       } else $n$03$i = $253; //@line 696
      }
     }
     $$pre$phi$iZ2D = $1 + 32 | 0; //@line 701
     $n$1$i = $n$0$lcssa$i; //@line 701
    }
    $size$0 = ($n$1$i * 40 | 0) + 112 + (HEAP32[$$pre$phi$iZ2D >> 2] << 4) | 0; //@line 708
   }
   break;
  }
 case 38:
  {
   HEAP32[$0 >> 2] = HEAP32[$1 + 8 >> 2]; //@line 715
   $191 = $1 + 6 | 0; //@line 716
   $192 = HEAP8[$191 >> 0] | 0; //@line 717
   if (!($192 << 24 >> 24)) $$lcssa$i4 = $192 & 255; //@line 721
 else {
    $360 = $192; //@line 723
    $i$01$i1 = 0; //@line 723
    while (1) {
     if (!(HEAP32[$1 + ($i$01$i1 << 4) + 24 >> 2] & 64)) $207 = $360; //@line 730
 else {
      $200 = HEAP32[$1 + ($i$01$i1 << 4) + 16 >> 2] | 0; //@line 733
      if (!(HEAP8[$200 + 5 >> 0] & 3)) $207 = $360; //@line 739
 else {
       _reallymarkobject($g, $200); //@line 741
       $207 = HEAP8[$191 >> 0] | 0; //@line 743
      }
     }
     $i$01$i1 = $i$01$i1 + 1 | 0; //@line 746
     $206 = $207 & 255; //@line 747
     if (($i$01$i1 | 0) >= ($206 | 0)) {
      $$lcssa$i4 = $206; //@line 752
      break;
     } else $360 = $207; //@line 750
    }
   }
   $size$0 = ($$lcssa$i4 << 4) + 16 | 0; //@line 759
   break;
  }
 case 5:
  {
   $10 = $1 + 24 | 0; //@line 763
   HEAP32[$0 >> 2] = HEAP32[$10 >> 2]; //@line 765
   $12 = $1 + 8 | 0; //@line 766
   $13 = HEAP32[$12 >> 2] | 0; //@line 767
   do if (!$13) label = 33; //@line 771
 else {
    if (!(HEAP8[$13 + 6 >> 0] & 8)) {
     $21 = _luaT_gettm($13, 3, HEAP32[$g + 196 >> 2] | 0) | 0; //@line 780
     $22 = HEAP32[$12 >> 2] | 0; //@line 781
     if (!$22) $$ph8$i = $21; //@line 784
 else {
      $$ph7$i = $21; //@line 786
      $$pr6$i = $22; //@line 786
      label = 5; //@line 787
     }
    } else {
     $$ph7$i = 0; //@line 790
     $$pr6$i = $13; //@line 790
     label = 5; //@line 791
    }
    if ((label | 0) == 5) if (!(HEAP8[$$pr6$i + 5 >> 0] & 3)) $$ph8$i = $$ph7$i; //@line 799
 else {
     _reallymarkobject($g, $$pr6$i); //@line 801
     $$ph8$i = $$ph7$i; //@line 802
    }
    if (!$$ph8$i) label = 33; //@line 807
 else if ((HEAP32[$$ph8$i + 8 >> 2] & 15 | 0) == 4) {
     $34 = (HEAP32[$$ph8$i >> 2] | 0) + 16 | 0; //@line 815
     $35 = _strchr($34, 107) | 0; //@line 816
     $37 = ($35 | 0) != 0; //@line 818
     $38 = (_strchr($34, 118) | 0) == 0; //@line 820
     if ($38 & ($37 ^ 1)) label = 33; //@line 823
 else {
      HEAP8[$2 >> 0] = HEAPU8[$2 >> 0] & 251; //@line 829
      if ($37) if ($38) {
       _traverseephemeron($g, $1) | 0; //@line 832
       break;
      } else {
       $96 = $g + 100 | 0; //@line 835
       HEAP32[$10 >> 2] = HEAP32[$96 >> 2]; //@line 838
       HEAP32[$96 >> 2] = $1; //@line 839
       break;
      }
      $46 = 1 << HEAPU8[$1 + 7 >> 0]; //@line 846
      $48 = HEAP32[$1 + 16 >> 2] | 0; //@line 848
      $49 = $48 + ($46 << 5) | 0; //@line 849
      $53 = (HEAP32[$1 + 28 >> 2] | 0) > 0 & 1; //@line 853
      if (($46 | 0) > 0) {
       $hasclears$04$i$i = $53; //@line 856
       $n$02$i$i = $48; //@line 856
       while (1) {
        $55 = $n$02$i$i + 8 | 0; //@line 858
        $58 = $n$02$i$i + 24 | 0; //@line 861
        $61 = (HEAP32[$58 >> 2] & 64 | 0) == 0; //@line 864
        do if (!(HEAP32[$55 >> 2] | 0)) if ($61) $hasclears$1$i$i = $hasclears$04$i$i; //@line 868
 else if (!(HEAP8[(HEAP32[$n$02$i$i + 16 >> 2] | 0) + 5 >> 0] & 3)) $hasclears$1$i$i = $hasclears$04$i$i; //@line 877
 else {
         HEAP32[$58 >> 2] = 11; //@line 879
         $hasclears$1$i$i = $hasclears$04$i$i; //@line 880
        } else {
         if (!$61) {
          $69 = HEAP32[$n$02$i$i + 16 >> 2] | 0; //@line 886
          if (HEAP8[$69 + 5 >> 0] & 3) _reallymarkobject($g, $69); //@line 892
         }
         if (!$hasclears$04$i$i) {
          $75 = HEAP32[$55 >> 2] | 0; //@line 897
          if (!($75 & 64)) $hasclears$1$i$i = 0; //@line 901
 else {
           $80 = HEAP32[$n$02$i$i >> 2] | 0; //@line 905
           if (($75 & 15 | 0) != 4) {
            $hasclears$1$i$i = (HEAP8[$80 + 5 >> 0] & 3) != 0 & 1; //@line 912
            break;
           }
           if (!$80) $hasclears$1$i$i = 0; //@line 917
 else if (!(HEAP8[$80 + 5 >> 0] & 3)) $hasclears$1$i$i = 0; //@line 924
 else {
            _reallymarkobject($g, $80); //@line 926
            $hasclears$1$i$i = 0; //@line 927
           }
          }
         } else $hasclears$1$i$i = $hasclears$04$i$i; //@line 932
        } while (0);
        $n$02$i$i = $n$02$i$i + 32 | 0; //@line 936
        if ($n$02$i$i >>> 0 >= $49 >>> 0) {
         $hasclears$0$lcssa$i$i = $hasclears$1$i$i; //@line 941
         break;
        } else $hasclears$04$i$i = $hasclears$1$i$i; //@line 939
       }
      } else $hasclears$0$lcssa$i$i = $53; //@line 946
      if (!$hasclears$0$lcssa$i$i) {
       $94 = $g + 88 | 0; //@line 950
       HEAP32[$10 >> 2] = HEAP32[$94 >> 2]; //@line 953
       HEAP32[$94 >> 2] = $1; //@line 954
       break;
      } else {
       $92 = $g + 92 | 0; //@line 957
       HEAP32[$10 >> 2] = HEAP32[$92 >> 2]; //@line 960
       HEAP32[$92 >> 2] = $1; //@line 961
       break;
      }
     }
    } else label = 33; //@line 966
   } while (0);
   if ((label | 0) == 33) {
    $102 = $1 + 16 | 0; //@line 976
    $103 = HEAP32[$102 >> 2] | 0; //@line 977
    $104 = $103 + (1 << HEAPU8[$1 + 7 >> 0] << 5) | 0; //@line 978
    $105 = $1 + 28 | 0; //@line 979
    $106 = HEAP32[$105 >> 2] | 0; //@line 980
    if (($106 | 0) > 0) {
     $108 = $1 + 12 | 0; //@line 983
     $358 = $106; //@line 984
     $i$03$i$i = 0; //@line 984
     while (1) {
      $109 = HEAP32[$108 >> 2] | 0; //@line 986
      if (!(HEAP32[$109 + ($i$03$i$i << 4) + 8 >> 2] & 64)) $122 = $358; //@line 992
 else {
       $115 = HEAP32[$109 + ($i$03$i$i << 4) >> 2] | 0; //@line 995
       if (!(HEAP8[$115 + 5 >> 0] & 3)) $122 = $358; //@line 1001
 else {
        _reallymarkobject($g, $115); //@line 1003
        $122 = HEAP32[$105 >> 2] | 0; //@line 1005
       }
      }
      $i$03$i$i = $i$03$i$i + 1 | 0; //@line 1008
      if (($i$03$i$i | 0) >= ($122 | 0)) break; else $358 = $122; //@line 1011
     }
     $124 = HEAP32[$102 >> 2] | 0; //@line 1017
    } else $124 = $103; //@line 1019
    if ($124 >>> 0 < $104 >>> 0) {
     $n$01$i$i = $124; //@line 1023
     do {
      $125 = $n$01$i$i + 8 | 0; //@line 1025
      $126 = HEAP32[$125 >> 2] | 0; //@line 1026
      $128 = $n$01$i$i + 24 | 0; //@line 1028
      $131 = (HEAP32[$128 >> 2] & 64 | 0) == 0; //@line 1031
      if (!$126) {
       if (!$131) if (HEAP8[(HEAP32[$n$01$i$i + 16 >> 2] | 0) + 5 >> 0] & 3) HEAP32[$128 >> 2] = 11; //@line 1041
      } else {
       if ($131) $145 = $126; //@line 1046
 else {
        $139 = HEAP32[$n$01$i$i + 16 >> 2] | 0; //@line 1049
        if (!(HEAP8[$139 + 5 >> 0] & 3)) $145 = $126; //@line 1055
 else {
         _reallymarkobject($g, $139); //@line 1057
         $145 = HEAP32[$125 >> 2] | 0; //@line 1059
        }
       }
       if ($145 & 64) {
        $147 = HEAP32[$n$01$i$i >> 2] | 0; //@line 1065
        if (HEAP8[$147 + 5 >> 0] & 3) _reallymarkobject($g, $147); //@line 1071
       }
      }
      $n$01$i$i = $n$01$i$i + 32 | 0; //@line 1075
     } while ($n$01$i$i >>> 0 < $104 >>> 0);
    }
   }
   $size$0 = (HEAP32[$1 + 28 >> 2] << 4) + 32 + (32 << HEAPU8[$1 + 7 >> 0]) | 0; //@line 1094
   break;
  }
 case 9:
  {
   HEAP32[$0 >> 2] = HEAP32[$1 + 72 >> 2]; //@line 1100
   $264 = $1 + 32 | 0; //@line 1101
   $265 = HEAP32[$264 >> 2] | 0; //@line 1102
   if ($265) if (HEAP8[$265 + 5 >> 0] & 3) HEAP32[$264 >> 2] = 0; //@line 1110
   $272 = HEAP32[$1 + 36 >> 2] | 0; //@line 1114
   if ($272) if (HEAP8[$272 + 5 >> 0] & 3) _reallymarkobject($g, $272); //@line 1122
   $278 = $1 + 44 | 0; //@line 1125
   $279 = HEAP32[$278 >> 2] | 0; //@line 1126
   if (($279 | 0) > 0) {
    $281 = $1 + 8 | 0; //@line 1129
    $362 = $279; //@line 1130
    $i$016$i = 0; //@line 1130
    while (1) {
     $286 = HEAP32[$281 >> 2] | 0; //@line 1132
     if (!(HEAP32[$286 + ($i$016$i << 4) + 8 >> 2] & 64)) $299 = $362; //@line 1138
 else {
      $292 = HEAP32[$286 + ($i$016$i << 4) >> 2] | 0; //@line 1141
      if (!(HEAP8[$292 + 5 >> 0] & 3)) $299 = $362; //@line 1147
 else {
       _reallymarkobject($g, $292); //@line 1149
       $299 = HEAP32[$278 >> 2] | 0; //@line 1151
      }
     }
     $i$016$i = $i$016$i + 1 | 0; //@line 1154
     if (($i$016$i | 0) >= ($299 | 0)) break; else $362 = $299; //@line 1157
    }
   }
   $282 = $1 + 40 | 0; //@line 1163
   $283 = HEAP32[$282 >> 2] | 0; //@line 1164
   if (($283 | 0) > 0) {
    $285 = $1 + 28 | 0; //@line 1167
    $363 = $283; //@line 1168
    $i$111$i = 0; //@line 1168
    while (1) {
     $306 = HEAP32[(HEAP32[$285 >> 2] | 0) + ($i$111$i << 3) >> 2] | 0; //@line 1172
     if (!$306) $314 = $363; //@line 1175
 else if (!(HEAP8[$306 + 5 >> 0] & 3)) $314 = $363; //@line 1182
 else {
      _reallymarkobject($g, $306); //@line 1184
      $314 = HEAP32[$282 >> 2] | 0; //@line 1186
     }
     $i$111$i = $i$111$i + 1 | 0; //@line 1189
     if (($i$111$i | 0) >= ($314 | 0)) break; else $363 = $314; //@line 1192
    }
   }
   $300 = $1 + 56 | 0; //@line 1198
   $301 = HEAP32[$300 >> 2] | 0; //@line 1199
   if (($301 | 0) > 0) {
    $303 = $1 + 16 | 0; //@line 1202
    $365 = $301; //@line 1203
    $i$26$i = 0; //@line 1203
    while (1) {
     $321 = HEAP32[(HEAP32[$303 >> 2] | 0) + ($i$26$i << 2) >> 2] | 0; //@line 1207
     if (!$321) $329 = $365; //@line 1210
 else if (!(HEAP8[$321 + 5 >> 0] & 3)) $329 = $365; //@line 1217
 else {
      _reallymarkobject($g, $321); //@line 1219
      $329 = HEAP32[$300 >> 2] | 0; //@line 1221
     }
     $i$26$i = $i$26$i + 1 | 0; //@line 1224
     if (($i$26$i | 0) >= ($329 | 0)) {
      $364 = $329; //@line 1229
      break;
     } else $365 = $329; //@line 1227
    }
   } else $364 = $301; //@line 1234
   $315 = $1 + 60 | 0; //@line 1236
   $316 = HEAP32[$315 >> 2] | 0; //@line 1237
   if (($316 | 0) > 0) {
    $318 = $1 + 24 | 0; //@line 1240
    $366 = $316; //@line 1241
    $i$33$i = 0; //@line 1241
    while (1) {
     $332 = HEAP32[(HEAP32[$318 >> 2] | 0) + ($i$33$i * 12 | 0) >> 2] | 0; //@line 1245
     if (!$332) $340 = $366; //@line 1248
 else if (!(HEAP8[$332 + 5 >> 0] & 3)) $340 = $366; //@line 1255
 else {
      _reallymarkobject($g, $332); //@line 1257
      $340 = HEAP32[$315 >> 2] | 0; //@line 1259
     }
     $i$33$i = $i$33$i + 1 | 0; //@line 1262
     if (($i$33$i | 0) >= ($340 | 0)) break; else $366 = $340; //@line 1265
    }
    $$lcssa$i13 = $340; //@line 1271
    $350 = HEAP32[$300 >> 2] | 0; //@line 1271
   } else {
    $$lcssa$i13 = $316; //@line 1273
    $350 = $364; //@line 1273
   }
   $size$0 = ($$lcssa$i13 * 12 | 0) + 80 + (HEAP32[$278 >> 2] << 4) + (HEAP32[$282 >> 2] << 3) + ((HEAP32[$1 + 48 >> 2] | 0) + $350 + (HEAP32[$1 + 52 >> 2] | 0) << 2) | 0; //@line 1291
   break;
  }
 case 6:
  {
   HEAP32[$0 >> 2] = HEAP32[$1 + 8 >> 2]; //@line 1297
   $166 = HEAP32[$1 + 12 >> 2] | 0; //@line 1299
   if ($166) if (HEAP8[$166 + 5 >> 0] & 3) _reallymarkobject($g, $166); //@line 1307
   $172 = $1 + 6 | 0; //@line 1310
   $173 = HEAP8[$172 >> 0] | 0; //@line 1311
   if (!($173 << 24 >> 24)) $$lcssa$i = $173 & 255; //@line 1315
 else {
    $359 = $173; //@line 1317
    $i$01$i = 0; //@line 1317
    while (1) {
     $177 = HEAP32[$1 + ($i$01$i << 2) + 16 >> 2] | 0; //@line 1320
     if (!$177) $185 = $359; //@line 1323
 else if (!(HEAP8[$177 + 5 >> 0] & 3)) $185 = $359; //@line 1330
 else {
      _reallymarkobject($g, $177); //@line 1332
      $185 = HEAP8[$172 >> 0] | 0; //@line 1334
     }
     $i$01$i = $i$01$i + 1 | 0; //@line 1337
     $184 = $185 & 255; //@line 1338
     if (($i$01$i | 0) >= ($184 | 0)) {
      $$lcssa$i = $184; //@line 1343
      break;
     } else $359 = $185; //@line 1341
    }
   }
   $size$0 = ($$lcssa$i << 2) + 16 | 0; //@line 1350
   break;
  }
 default:
  {
   STACKTOP = sp; //@line 1354
   return;
  }
 }
 $355 = $g + 16 | 0; //@line 1357
 HEAP32[$355 >> 2] = (HEAP32[$355 >> 2] | 0) + $size$0; //@line 1360
 STACKTOP = sp; //@line 1361
 return;
}
function _free($mem) {
 $mem = $mem | 0;
 var $$pre$phi68Z2D = 0, $$pre$phi70Z2D = 0, $$pre$phiZ2D = 0, $$sum2 = 0, $1 = 0, $104 = 0, $113 = 0, $114 = 0, $12 = 0, $122 = 0, $130 = 0, $135 = 0, $136 = 0, $139 = 0, $14 = 0, $141 = 0, $143 = 0, $15 = 0, $158 = 0, $163 = 0, $165 = 0, $168 = 0, $171 = 0, $174 = 0, $177 = 0, $178 = 0, $180 = 0, $181 = 0, $183 = 0, $184 = 0, $186 = 0, $187 = 0, $19 = 0, $193 = 0, $194 = 0, $2 = 0, $203 = 0, $212 = 0, $219 = 0, $22 = 0, $234 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $243 = 0, $244 = 0, $250 = 0, $255 = 0, $256 = 0, $259 = 0, $26 = 0, $261 = 0, $264 = 0, $269 = 0, $275 = 0, $279 = 0, $280 = 0, $287 = 0, $296 = 0, $299 = 0, $304 = 0, $311 = 0, $312 = 0, $313 = 0, $321 = 0, $39 = 0, $44 = 0, $46 = 0, $49 = 0, $5 = 0, $51 = 0, $54 = 0, $57 = 0, $58 = 0, $6 = 0, $60 = 0, $61 = 0, $63 = 0, $64 = 0, $66 = 0, $67 = 0, $72 = 0, $73 = 0, $8 = 0, $82 = 0, $9 = 0, $91 = 0, $98 = 0, $F16$0 = 0, $I18$0 = 0, $K19$057 = 0, $R$0 = 0, $R$1 = 0, $R7$0 = 0, $R7$1 = 0, $RP$0 = 0, $RP9$0 = 0, $T$0$lcssa = 0, $T$056 = 0, $p$0 = 0, $psize$0 = 0, $psize$1 = 0, $sp$0$i = 0, $sp$0$in$i = 0, sp = 0;
 sp = STACKTOP; //@line 8948
 if (!$mem) {
  STACKTOP = sp; //@line 8951
  return;
 }
 $1 = $mem + -8 | 0; //@line 8953
 $2 = HEAP32[3004] | 0; //@line 8954
 if ($1 >>> 0 < $2 >>> 0) _abort(); //@line 8957
 $5 = HEAP32[$mem + -4 >> 2] | 0; //@line 8961
 $6 = $5 & 3; //@line 8962
 if (($6 | 0) == 1) _abort(); //@line 8965
 $8 = $5 & -8; //@line 8968
 $9 = $mem + ($8 + -8) | 0; //@line 8970
 do if (!($5 & 1)) {
  $12 = HEAP32[$1 >> 2] | 0; //@line 8975
  if (!$6) {
   STACKTOP = sp; //@line 8978
   return;
  }
  $$sum2 = -8 - $12 | 0; //@line 8980
  $14 = $mem + $$sum2 | 0; //@line 8981
  $15 = $12 + $8 | 0; //@line 8982
  if ($14 >>> 0 < $2 >>> 0) _abort(); //@line 8985
  if (($14 | 0) == (HEAP32[3005] | 0)) {
   $104 = $mem + ($8 + -4) | 0; //@line 8992
   if ((HEAP32[$104 >> 2] & 3 | 0) != 3) {
    $p$0 = $14; //@line 8997
    $psize$0 = $15; //@line 8997
    break;
   }
   HEAP32[3002] = $15; //@line 9000
   HEAP32[$104 >> 2] = HEAP32[$104 >> 2] & -2; //@line 9003
   HEAP32[$mem + ($$sum2 + 4) >> 2] = $15 | 1; //@line 9007
   HEAP32[$9 >> 2] = $15; //@line 9008
   STACKTOP = sp; //@line 9009
   return;
  }
  $19 = $12 >>> 3; //@line 9011
  if ($12 >>> 0 < 256) {
   $22 = HEAP32[$mem + ($$sum2 + 8) >> 2] | 0; //@line 9016
   $24 = HEAP32[$mem + ($$sum2 + 12) >> 2] | 0; //@line 9019
   $26 = 12040 + ($19 << 1 << 2) | 0; //@line 9021
   if (($22 | 0) != ($26 | 0)) {
    if ($22 >>> 0 < $2 >>> 0) _abort(); //@line 9026
    if ((HEAP32[$22 + 12 >> 2] | 0) != ($14 | 0)) _abort(); //@line 9033
   }
   if (($24 | 0) == ($22 | 0)) {
    HEAP32[3e3] = HEAP32[3e3] & ~(1 << $19); //@line 9043
    $p$0 = $14; //@line 9044
    $psize$0 = $15; //@line 9044
    break;
   }
   if (($24 | 0) == ($26 | 0)) $$pre$phi70Z2D = $24 + 8 | 0; //@line 9050
 else {
    if ($24 >>> 0 < $2 >>> 0) _abort(); //@line 9054
    $39 = $24 + 8 | 0; //@line 9057
    if ((HEAP32[$39 >> 2] | 0) == ($14 | 0)) $$pre$phi70Z2D = $39; //@line 9061
 else _abort(); //@line 9063
   }
   HEAP32[$22 + 12 >> 2] = $24; //@line 9068
   HEAP32[$$pre$phi70Z2D >> 2] = $22; //@line 9069
   $p$0 = $14; //@line 9070
   $psize$0 = $15; //@line 9070
   break;
  }
  $44 = HEAP32[$mem + ($$sum2 + 24) >> 2] | 0; //@line 9075
  $46 = HEAP32[$mem + ($$sum2 + 12) >> 2] | 0; //@line 9078
  do if (($46 | 0) == ($14 | 0)) {
   $57 = $mem + ($$sum2 + 20) | 0; //@line 9083
   $58 = HEAP32[$57 >> 2] | 0; //@line 9084
   if (!$58) {
    $60 = $mem + ($$sum2 + 16) | 0; //@line 9088
    $61 = HEAP32[$60 >> 2] | 0; //@line 9089
    if (!$61) {
     $R$1 = 0; //@line 9092
     break;
    } else {
     $R$0 = $61; //@line 9095
     $RP$0 = $60; //@line 9095
    }
   } else {
    $R$0 = $58; //@line 9098
    $RP$0 = $57; //@line 9098
   }
   while (1) {
    $63 = $R$0 + 20 | 0; //@line 9101
    $64 = HEAP32[$63 >> 2] | 0; //@line 9102
    if ($64) {
     $R$0 = $64; //@line 9105
     $RP$0 = $63; //@line 9105
     continue;
    }
    $66 = $R$0 + 16 | 0; //@line 9108
    $67 = HEAP32[$66 >> 2] | 0; //@line 9109
    if (!$67) break; else {
     $R$0 = $67; //@line 9114
     $RP$0 = $66; //@line 9114
    }
   }
   if ($RP$0 >>> 0 < $2 >>> 0) _abort(); //@line 9119
 else {
    HEAP32[$RP$0 >> 2] = 0; //@line 9122
    $R$1 = $R$0; //@line 9123
    break;
   }
  } else {
   $49 = HEAP32[$mem + ($$sum2 + 8) >> 2] | 0; //@line 9129
   if ($49 >>> 0 < $2 >>> 0) _abort(); //@line 9132
   $51 = $49 + 12 | 0; //@line 9135
   if ((HEAP32[$51 >> 2] | 0) != ($14 | 0)) _abort(); //@line 9139
   $54 = $46 + 8 | 0; //@line 9142
   if ((HEAP32[$54 >> 2] | 0) == ($14 | 0)) {
    HEAP32[$51 >> 2] = $46; //@line 9146
    HEAP32[$54 >> 2] = $49; //@line 9147
    $R$1 = $46; //@line 9148
    break;
   } else _abort(); //@line 9151
  } while (0);
  if (!$44) {
   $p$0 = $14; //@line 9158
   $psize$0 = $15; //@line 9158
  } else {
   $72 = HEAP32[$mem + ($$sum2 + 28) >> 2] | 0; //@line 9162
   $73 = 12304 + ($72 << 2) | 0; //@line 9163
   if (($14 | 0) == (HEAP32[$73 >> 2] | 0)) {
    HEAP32[$73 >> 2] = $R$1; //@line 9167
    if (!$R$1) {
     HEAP32[3001] = HEAP32[3001] & ~(1 << $72); //@line 9174
     $p$0 = $14; //@line 9175
     $psize$0 = $15; //@line 9175
     break;
    }
   } else {
    if ($44 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9182
    $82 = $44 + 16 | 0; //@line 9185
    if ((HEAP32[$82 >> 2] | 0) == ($14 | 0)) HEAP32[$82 >> 2] = $R$1; //@line 9189
 else HEAP32[$44 + 20 >> 2] = $R$1; //@line 9192
    if (!$R$1) {
     $p$0 = $14; //@line 9196
     $psize$0 = $15; //@line 9196
     break;
    }
   }
   if ($R$1 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9203
   HEAP32[$R$1 + 24 >> 2] = $44; //@line 9207
   $91 = HEAP32[$mem + ($$sum2 + 16) >> 2] | 0; //@line 9210
   do if ($91) if ($91 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9217
 else {
    HEAP32[$R$1 + 16 >> 2] = $91; //@line 9221
    HEAP32[$91 + 24 >> 2] = $R$1; //@line 9223
    break;
   } while (0);
   $98 = HEAP32[$mem + ($$sum2 + 20) >> 2] | 0; //@line 9230
   if (!$98) {
    $p$0 = $14; //@line 9233
    $psize$0 = $15; //@line 9233
   } else if ($98 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9238
 else {
    HEAP32[$R$1 + 20 >> 2] = $98; //@line 9242
    HEAP32[$98 + 24 >> 2] = $R$1; //@line 9244
    $p$0 = $14; //@line 9245
    $psize$0 = $15; //@line 9245
    break;
   }
  }
 } else {
  $p$0 = $1; //@line 9251
  $psize$0 = $8; //@line 9251
 } while (0);
 if ($p$0 >>> 0 >= $9 >>> 0) _abort(); //@line 9256
 $113 = $mem + ($8 + -4) | 0; //@line 9260
 $114 = HEAP32[$113 >> 2] | 0; //@line 9261
 if (!($114 & 1)) _abort(); //@line 9265
 if (!($114 & 2)) {
  if (($9 | 0) == (HEAP32[3006] | 0)) {
   $122 = (HEAP32[3003] | 0) + $psize$0 | 0; //@line 9275
   HEAP32[3003] = $122; //@line 9276
   HEAP32[3006] = $p$0; //@line 9277
   HEAP32[$p$0 + 4 >> 2] = $122 | 1; //@line 9280
   if (($p$0 | 0) != (HEAP32[3005] | 0)) {
    STACKTOP = sp; //@line 9284
    return;
   }
   HEAP32[3005] = 0; //@line 9286
   HEAP32[3002] = 0; //@line 9287
   STACKTOP = sp; //@line 9288
   return;
  }
  if (($9 | 0) == (HEAP32[3005] | 0)) {
   $130 = (HEAP32[3002] | 0) + $psize$0 | 0; //@line 9294
   HEAP32[3002] = $130; //@line 9295
   HEAP32[3005] = $p$0; //@line 9296
   HEAP32[$p$0 + 4 >> 2] = $130 | 1; //@line 9299
   HEAP32[$p$0 + $130 >> 2] = $130; //@line 9301
   STACKTOP = sp; //@line 9302
   return;
  }
  $135 = ($114 & -8) + $psize$0 | 0; //@line 9305
  $136 = $114 >>> 3; //@line 9306
  do if ($114 >>> 0 < 256) {
   $139 = HEAP32[$mem + $8 >> 2] | 0; //@line 9311
   $141 = HEAP32[$mem + ($8 | 4) >> 2] | 0; //@line 9314
   $143 = 12040 + ($136 << 1 << 2) | 0; //@line 9316
   if (($139 | 0) != ($143 | 0)) {
    if ($139 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9322
    if ((HEAP32[$139 + 12 >> 2] | 0) != ($9 | 0)) _abort(); //@line 9329
   }
   if (($141 | 0) == ($139 | 0)) {
    HEAP32[3e3] = HEAP32[3e3] & ~(1 << $136); //@line 9339
    break;
   }
   if (($141 | 0) == ($143 | 0)) $$pre$phi68Z2D = $141 + 8 | 0; //@line 9345
 else {
    if ($141 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9350
    $158 = $141 + 8 | 0; //@line 9353
    if ((HEAP32[$158 >> 2] | 0) == ($9 | 0)) $$pre$phi68Z2D = $158; //@line 9357
 else _abort(); //@line 9359
   }
   HEAP32[$139 + 12 >> 2] = $141; //@line 9364
   HEAP32[$$pre$phi68Z2D >> 2] = $139; //@line 9365
  } else {
   $163 = HEAP32[$mem + ($8 + 16) >> 2] | 0; //@line 9369
   $165 = HEAP32[$mem + ($8 | 4) >> 2] | 0; //@line 9372
   do if (($165 | 0) == ($9 | 0)) {
    $177 = $mem + ($8 + 12) | 0; //@line 9377
    $178 = HEAP32[$177 >> 2] | 0; //@line 9378
    if (!$178) {
     $180 = $mem + ($8 + 8) | 0; //@line 9382
     $181 = HEAP32[$180 >> 2] | 0; //@line 9383
     if (!$181) {
      $R7$1 = 0; //@line 9386
      break;
     } else {
      $R7$0 = $181; //@line 9389
      $RP9$0 = $180; //@line 9389
     }
    } else {
     $R7$0 = $178; //@line 9392
     $RP9$0 = $177; //@line 9392
    }
    while (1) {
     $183 = $R7$0 + 20 | 0; //@line 9395
     $184 = HEAP32[$183 >> 2] | 0; //@line 9396
     if ($184) {
      $R7$0 = $184; //@line 9399
      $RP9$0 = $183; //@line 9399
      continue;
     }
     $186 = $R7$0 + 16 | 0; //@line 9402
     $187 = HEAP32[$186 >> 2] | 0; //@line 9403
     if (!$187) break; else {
      $R7$0 = $187; //@line 9408
      $RP9$0 = $186; //@line 9408
     }
    }
    if ($RP9$0 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9414
 else {
     HEAP32[$RP9$0 >> 2] = 0; //@line 9417
     $R7$1 = $R7$0; //@line 9418
     break;
    }
   } else {
    $168 = HEAP32[$mem + $8 >> 2] | 0; //@line 9423
    if ($168 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9427
    $171 = $168 + 12 | 0; //@line 9430
    if ((HEAP32[$171 >> 2] | 0) != ($9 | 0)) _abort(); //@line 9434
    $174 = $165 + 8 | 0; //@line 9437
    if ((HEAP32[$174 >> 2] | 0) == ($9 | 0)) {
     HEAP32[$171 >> 2] = $165; //@line 9441
     HEAP32[$174 >> 2] = $168; //@line 9442
     $R7$1 = $165; //@line 9443
     break;
    } else _abort(); //@line 9446
   } while (0);
   if ($163) {
    $193 = HEAP32[$mem + ($8 + 20) >> 2] | 0; //@line 9455
    $194 = 12304 + ($193 << 2) | 0; //@line 9456
    if (($9 | 0) == (HEAP32[$194 >> 2] | 0)) {
     HEAP32[$194 >> 2] = $R7$1; //@line 9460
     if (!$R7$1) {
      HEAP32[3001] = HEAP32[3001] & ~(1 << $193); //@line 9467
      break;
     }
    } else {
     if ($163 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9474
     $203 = $163 + 16 | 0; //@line 9477
     if ((HEAP32[$203 >> 2] | 0) == ($9 | 0)) HEAP32[$203 >> 2] = $R7$1; //@line 9481
 else HEAP32[$163 + 20 >> 2] = $R7$1; //@line 9484
     if (!$R7$1) break;
    }
    if ($R7$1 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9494
    HEAP32[$R7$1 + 24 >> 2] = $163; //@line 9498
    $212 = HEAP32[$mem + ($8 + 8) >> 2] | 0; //@line 9501
    do if ($212) if ($212 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9508
 else {
     HEAP32[$R7$1 + 16 >> 2] = $212; //@line 9512
     HEAP32[$212 + 24 >> 2] = $R7$1; //@line 9514
     break;
    } while (0);
    $219 = HEAP32[$mem + ($8 + 12) >> 2] | 0; //@line 9521
    if ($219) if ($219 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9527
 else {
     HEAP32[$R7$1 + 20 >> 2] = $219; //@line 9531
     HEAP32[$219 + 24 >> 2] = $R7$1; //@line 9533
     break;
    }
   }
  } while (0);
  HEAP32[$p$0 + 4 >> 2] = $135 | 1; //@line 9542
  HEAP32[$p$0 + $135 >> 2] = $135; //@line 9544
  if (($p$0 | 0) == (HEAP32[3005] | 0)) {
   HEAP32[3002] = $135; //@line 9548
   STACKTOP = sp; //@line 9549
   return;
  } else $psize$1 = $135; //@line 9551
 } else {
  HEAP32[$113 >> 2] = $114 & -2; //@line 9555
  HEAP32[$p$0 + 4 >> 2] = $psize$0 | 1; //@line 9558
  HEAP32[$p$0 + $psize$0 >> 2] = $psize$0; //@line 9560
  $psize$1 = $psize$0; //@line 9561
 }
 $234 = $psize$1 >>> 3; //@line 9563
 if ($psize$1 >>> 0 < 256) {
  $236 = $234 << 1; //@line 9566
  $237 = 12040 + ($236 << 2) | 0; //@line 9567
  $238 = HEAP32[3e3] | 0; //@line 9568
  $239 = 1 << $234; //@line 9569
  if (!($238 & $239)) {
   HEAP32[3e3] = $238 | $239; //@line 9574
   $$pre$phiZ2D = 12040 + ($236 + 2 << 2) | 0; //@line 9577
   $F16$0 = $237; //@line 9577
  } else {
   $243 = 12040 + ($236 + 2 << 2) | 0; //@line 9580
   $244 = HEAP32[$243 >> 2] | 0; //@line 9581
   if ($244 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9585
 else {
    $$pre$phiZ2D = $243; //@line 9588
    $F16$0 = $244; //@line 9588
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $p$0; //@line 9591
  HEAP32[$F16$0 + 12 >> 2] = $p$0; //@line 9593
  HEAP32[$p$0 + 8 >> 2] = $F16$0; //@line 9595
  HEAP32[$p$0 + 12 >> 2] = $237; //@line 9597
  STACKTOP = sp; //@line 9598
  return;
 }
 $250 = $psize$1 >>> 8; //@line 9600
 if (!$250) $I18$0 = 0; //@line 9603
 else if ($psize$1 >>> 0 > 16777215) $I18$0 = 31; //@line 9607
 else {
  $255 = ($250 + 1048320 | 0) >>> 16 & 8; //@line 9611
  $256 = $250 << $255; //@line 9612
  $259 = ($256 + 520192 | 0) >>> 16 & 4; //@line 9615
  $261 = $256 << $259; //@line 9617
  $264 = ($261 + 245760 | 0) >>> 16 & 2; //@line 9620
  $269 = 14 - ($259 | $255 | $264) + ($261 << $264 >>> 15) | 0; //@line 9625
  $I18$0 = $psize$1 >>> ($269 + 7 | 0) & 1 | $269 << 1; //@line 9631
 }
 $275 = 12304 + ($I18$0 << 2) | 0; //@line 9634
 HEAP32[$p$0 + 28 >> 2] = $I18$0; //@line 9637
 HEAP32[$p$0 + 20 >> 2] = 0; //@line 9639
 HEAP32[$p$0 + 16 >> 2] = 0; //@line 9641
 $279 = HEAP32[3001] | 0; //@line 9642
 $280 = 1 << $I18$0; //@line 9643
 L199 : do if (!($279 & $280)) {
  HEAP32[3001] = $279 | $280; //@line 9649
  HEAP32[$275 >> 2] = $p$0; //@line 9650
  HEAP32[$p$0 + 24 >> 2] = $275; //@line 9652
  HEAP32[$p$0 + 12 >> 2] = $p$0; //@line 9654
  HEAP32[$p$0 + 8 >> 2] = $p$0; //@line 9656
 } else {
  $287 = HEAP32[$275 >> 2] | 0; //@line 9658
  if (($I18$0 | 0) == 31) $296 = 0; //@line 9661
 else $296 = 25 - ($I18$0 >>> 1) | 0; //@line 9665
  L205 : do if ((HEAP32[$287 + 4 >> 2] & -8 | 0) == ($psize$1 | 0)) $T$0$lcssa = $287; //@line 9673
 else {
   $K19$057 = $psize$1 << $296; //@line 9676
   $T$056 = $287; //@line 9676
   while (1) {
    $304 = $T$056 + ($K19$057 >>> 31 << 2) + 16 | 0; //@line 9679
    $299 = HEAP32[$304 >> 2] | 0; //@line 9680
    if (!$299) break;
    if ((HEAP32[$299 + 4 >> 2] & -8 | 0) == ($psize$1 | 0)) {
     $T$0$lcssa = $299; //@line 9691
     break L205;
    } else {
     $K19$057 = $K19$057 << 1; //@line 9694
     $T$056 = $299; //@line 9694
    }
   }
   if ($304 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 9700
 else {
    HEAP32[$304 >> 2] = $p$0; //@line 9703
    HEAP32[$p$0 + 24 >> 2] = $T$056; //@line 9705
    HEAP32[$p$0 + 12 >> 2] = $p$0; //@line 9707
    HEAP32[$p$0 + 8 >> 2] = $p$0; //@line 9709
    break L199;
   }
  } while (0);
  $311 = $T$0$lcssa + 8 | 0; //@line 9714
  $312 = HEAP32[$311 >> 2] | 0; //@line 9715
  $313 = HEAP32[3004] | 0; //@line 9716
  if ($T$0$lcssa >>> 0 < $313 >>> 0) _abort(); //@line 9719
  if ($312 >>> 0 < $313 >>> 0) _abort(); //@line 9724
 else {
   HEAP32[$312 + 12 >> 2] = $p$0; //@line 9728
   HEAP32[$311 >> 2] = $p$0; //@line 9729
   HEAP32[$p$0 + 8 >> 2] = $312; //@line 9731
   HEAP32[$p$0 + 12 >> 2] = $T$0$lcssa; //@line 9733
   HEAP32[$p$0 + 24 >> 2] = 0; //@line 9735
   break;
  }
 } while (0);
 $321 = (HEAP32[3008] | 0) + -1 | 0; //@line 9741
 HEAP32[3008] = $321; //@line 9742
 if (!$321) $sp$0$in$i = 12456 | 0; //@line 9745
 else {
  STACKTOP = sp; //@line 9747
  return;
 }
 while (1) {
  $sp$0$i = HEAP32[$sp$0$in$i >> 2] | 0; //@line 9750
  if (!$sp$0$i) break; else $sp$0$in$i = $sp$0$i + 8 | 0; //@line 9756
 }
 HEAP32[3008] = -1; //@line 9759
 STACKTOP = sp; //@line 9760
 return;
}
function _dispose_chunk($p, $psize) {
 $p = $p | 0;
 $psize = $psize | 0;
 var $$0 = 0, $$02 = 0, $$1 = 0, $$pre$phi63Z2D = 0, $$pre$phi65Z2D = 0, $$pre$phiZ2D = 0, $$sum24 = 0, $$sum27 = 0, $0 = 0, $10 = 0, $100 = 0, $108 = 0, $11 = 0, $110 = 0, $111 = 0, $117 = 0, $125 = 0, $130 = 0, $131 = 0, $134 = 0, $136 = 0, $138 = 0, $15 = 0, $151 = 0, $156 = 0, $158 = 0, $161 = 0, $163 = 0, $166 = 0, $169 = 0, $170 = 0, $172 = 0, $173 = 0, $175 = 0, $176 = 0, $178 = 0, $179 = 0, $18 = 0, $184 = 0, $185 = 0, $194 = 0, $2 = 0, $20 = 0, $203 = 0, $210 = 0, $22 = 0, $225 = 0, $227 = 0, $228 = 0, $229 = 0, $230 = 0, $234 = 0, $235 = 0, $241 = 0, $246 = 0, $247 = 0, $250 = 0, $252 = 0, $255 = 0, $260 = 0, $266 = 0, $270 = 0, $271 = 0, $278 = 0, $287 = 0, $290 = 0, $295 = 0, $302 = 0, $303 = 0, $304 = 0, $35 = 0, $40 = 0, $42 = 0, $45 = 0, $47 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $60 = 0, $62 = 0, $63 = 0, $68 = 0, $69 = 0, $78 = 0, $87 = 0, $9 = 0, $94 = 0, $F16$0 = 0, $I19$0 = 0, $K20$049 = 0, $R$0 = 0, $R$1 = 0, $R7$0 = 0, $R7$1 = 0, $RP$0 = 0, $RP9$0 = 0, $T$0$lcssa = 0, $T$048 = 0, sp = 0;
 sp = STACKTOP; //@line 10283
 $0 = $p + $psize | 0; //@line 10284
 $2 = HEAP32[$p + 4 >> 2] | 0; //@line 10286
 do if (!($2 & 1)) {
  $5 = HEAP32[$p >> 2] | 0; //@line 10291
  if (!($2 & 3)) {
   STACKTOP = sp; //@line 10295
   return;
  }
  $9 = $p + (0 - $5) | 0; //@line 10298
  $10 = $5 + $psize | 0; //@line 10299
  $11 = HEAP32[3004] | 0; //@line 10300
  if ($9 >>> 0 < $11 >>> 0) _abort(); //@line 10303
  if (($9 | 0) == (HEAP32[3005] | 0)) {
   $100 = $p + ($psize + 4) | 0; //@line 10310
   if ((HEAP32[$100 >> 2] & 3 | 0) != 3) {
    $$0 = $9; //@line 10315
    $$02 = $10; //@line 10315
    break;
   }
   HEAP32[3002] = $10; //@line 10318
   HEAP32[$100 >> 2] = HEAP32[$100 >> 2] & -2; //@line 10321
   HEAP32[$p + (4 - $5) >> 2] = $10 | 1; //@line 10325
   HEAP32[$0 >> 2] = $10; //@line 10326
   STACKTOP = sp; //@line 10327
   return;
  }
  $15 = $5 >>> 3; //@line 10329
  if ($5 >>> 0 < 256) {
   $18 = HEAP32[$p + (8 - $5) >> 2] | 0; //@line 10334
   $20 = HEAP32[$p + (12 - $5) >> 2] | 0; //@line 10337
   $22 = 12040 + ($15 << 1 << 2) | 0; //@line 10339
   if (($18 | 0) != ($22 | 0)) {
    if ($18 >>> 0 < $11 >>> 0) _abort(); //@line 10344
    if ((HEAP32[$18 + 12 >> 2] | 0) != ($9 | 0)) _abort(); //@line 10351
   }
   if (($20 | 0) == ($18 | 0)) {
    HEAP32[3e3] = HEAP32[3e3] & ~(1 << $15); //@line 10361
    $$0 = $9; //@line 10362
    $$02 = $10; //@line 10362
    break;
   }
   if (($20 | 0) == ($22 | 0)) $$pre$phi65Z2D = $20 + 8 | 0; //@line 10368
 else {
    if ($20 >>> 0 < $11 >>> 0) _abort(); //@line 10372
    $35 = $20 + 8 | 0; //@line 10375
    if ((HEAP32[$35 >> 2] | 0) == ($9 | 0)) $$pre$phi65Z2D = $35; //@line 10379
 else _abort(); //@line 10381
   }
   HEAP32[$18 + 12 >> 2] = $20; //@line 10386
   HEAP32[$$pre$phi65Z2D >> 2] = $18; //@line 10387
   $$0 = $9; //@line 10388
   $$02 = $10; //@line 10388
   break;
  }
  $40 = HEAP32[$p + (24 - $5) >> 2] | 0; //@line 10393
  $42 = HEAP32[$p + (12 - $5) >> 2] | 0; //@line 10396
  do if (($42 | 0) == ($9 | 0)) {
   $$sum24 = 16 - $5 | 0; //@line 10400
   $53 = $p + ($$sum24 + 4) | 0; //@line 10402
   $54 = HEAP32[$53 >> 2] | 0; //@line 10403
   if (!$54) {
    $56 = $p + $$sum24 | 0; //@line 10406
    $57 = HEAP32[$56 >> 2] | 0; //@line 10407
    if (!$57) {
     $R$1 = 0; //@line 10410
     break;
    } else {
     $R$0 = $57; //@line 10413
     $RP$0 = $56; //@line 10413
    }
   } else {
    $R$0 = $54; //@line 10416
    $RP$0 = $53; //@line 10416
   }
   while (1) {
    $59 = $R$0 + 20 | 0; //@line 10419
    $60 = HEAP32[$59 >> 2] | 0; //@line 10420
    if ($60) {
     $R$0 = $60; //@line 10423
     $RP$0 = $59; //@line 10423
     continue;
    }
    $62 = $R$0 + 16 | 0; //@line 10426
    $63 = HEAP32[$62 >> 2] | 0; //@line 10427
    if (!$63) break; else {
     $R$0 = $63; //@line 10432
     $RP$0 = $62; //@line 10432
    }
   }
   if ($RP$0 >>> 0 < $11 >>> 0) _abort(); //@line 10437
 else {
    HEAP32[$RP$0 >> 2] = 0; //@line 10440
    $R$1 = $R$0; //@line 10441
    break;
   }
  } else {
   $45 = HEAP32[$p + (8 - $5) >> 2] | 0; //@line 10447
   if ($45 >>> 0 < $11 >>> 0) _abort(); //@line 10450
   $47 = $45 + 12 | 0; //@line 10453
   if ((HEAP32[$47 >> 2] | 0) != ($9 | 0)) _abort(); //@line 10457
   $50 = $42 + 8 | 0; //@line 10460
   if ((HEAP32[$50 >> 2] | 0) == ($9 | 0)) {
    HEAP32[$47 >> 2] = $42; //@line 10464
    HEAP32[$50 >> 2] = $45; //@line 10465
    $R$1 = $42; //@line 10466
    break;
   } else _abort(); //@line 10469
  } while (0);
  if (!$40) {
   $$0 = $9; //@line 10476
   $$02 = $10; //@line 10476
  } else {
   $68 = HEAP32[$p + (28 - $5) >> 2] | 0; //@line 10480
   $69 = 12304 + ($68 << 2) | 0; //@line 10481
   if (($9 | 0) == (HEAP32[$69 >> 2] | 0)) {
    HEAP32[$69 >> 2] = $R$1; //@line 10485
    if (!$R$1) {
     HEAP32[3001] = HEAP32[3001] & ~(1 << $68); //@line 10492
     $$0 = $9; //@line 10493
     $$02 = $10; //@line 10493
     break;
    }
   } else {
    if ($40 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10500
    $78 = $40 + 16 | 0; //@line 10503
    if ((HEAP32[$78 >> 2] | 0) == ($9 | 0)) HEAP32[$78 >> 2] = $R$1; //@line 10507
 else HEAP32[$40 + 20 >> 2] = $R$1; //@line 10510
    if (!$R$1) {
     $$0 = $9; //@line 10514
     $$02 = $10; //@line 10514
     break;
    }
   }
   if ($R$1 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10521
   HEAP32[$R$1 + 24 >> 2] = $40; //@line 10525
   $$sum27 = 16 - $5 | 0; //@line 10526
   $87 = HEAP32[$p + $$sum27 >> 2] | 0; //@line 10528
   do if ($87) if ($87 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10535
 else {
    HEAP32[$R$1 + 16 >> 2] = $87; //@line 10539
    HEAP32[$87 + 24 >> 2] = $R$1; //@line 10541
    break;
   } while (0);
   $94 = HEAP32[$p + ($$sum27 + 4) >> 2] | 0; //@line 10548
   if (!$94) {
    $$0 = $9; //@line 10551
    $$02 = $10; //@line 10551
   } else if ($94 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10556
 else {
    HEAP32[$R$1 + 20 >> 2] = $94; //@line 10560
    HEAP32[$94 + 24 >> 2] = $R$1; //@line 10562
    $$0 = $9; //@line 10563
    $$02 = $10; //@line 10563
    break;
   }
  }
 } else {
  $$0 = $p; //@line 10569
  $$02 = $psize; //@line 10569
 } while (0);
 $108 = HEAP32[3004] | 0; //@line 10572
 if ($0 >>> 0 < $108 >>> 0) _abort(); //@line 10575
 $110 = $p + ($psize + 4) | 0; //@line 10579
 $111 = HEAP32[$110 >> 2] | 0; //@line 10580
 if (!($111 & 2)) {
  if (($0 | 0) == (HEAP32[3006] | 0)) {
   $117 = (HEAP32[3003] | 0) + $$02 | 0; //@line 10588
   HEAP32[3003] = $117; //@line 10589
   HEAP32[3006] = $$0; //@line 10590
   HEAP32[$$0 + 4 >> 2] = $117 | 1; //@line 10593
   if (($$0 | 0) != (HEAP32[3005] | 0)) {
    STACKTOP = sp; //@line 10597
    return;
   }
   HEAP32[3005] = 0; //@line 10599
   HEAP32[3002] = 0; //@line 10600
   STACKTOP = sp; //@line 10601
   return;
  }
  if (($0 | 0) == (HEAP32[3005] | 0)) {
   $125 = (HEAP32[3002] | 0) + $$02 | 0; //@line 10607
   HEAP32[3002] = $125; //@line 10608
   HEAP32[3005] = $$0; //@line 10609
   HEAP32[$$0 + 4 >> 2] = $125 | 1; //@line 10612
   HEAP32[$$0 + $125 >> 2] = $125; //@line 10614
   STACKTOP = sp; //@line 10615
   return;
  }
  $130 = ($111 & -8) + $$02 | 0; //@line 10618
  $131 = $111 >>> 3; //@line 10619
  do if ($111 >>> 0 < 256) {
   $134 = HEAP32[$p + ($psize + 8) >> 2] | 0; //@line 10625
   $136 = HEAP32[$p + ($psize + 12) >> 2] | 0; //@line 10628
   $138 = 12040 + ($131 << 1 << 2) | 0; //@line 10630
   if (($134 | 0) != ($138 | 0)) {
    if ($134 >>> 0 < $108 >>> 0) _abort(); //@line 10635
    if ((HEAP32[$134 + 12 >> 2] | 0) != ($0 | 0)) _abort(); //@line 10642
   }
   if (($136 | 0) == ($134 | 0)) {
    HEAP32[3e3] = HEAP32[3e3] & ~(1 << $131); //@line 10652
    break;
   }
   if (($136 | 0) == ($138 | 0)) $$pre$phi63Z2D = $136 + 8 | 0; //@line 10658
 else {
    if ($136 >>> 0 < $108 >>> 0) _abort(); //@line 10662
    $151 = $136 + 8 | 0; //@line 10665
    if ((HEAP32[$151 >> 2] | 0) == ($0 | 0)) $$pre$phi63Z2D = $151; //@line 10669
 else _abort(); //@line 10671
   }
   HEAP32[$134 + 12 >> 2] = $136; //@line 10676
   HEAP32[$$pre$phi63Z2D >> 2] = $134; //@line 10677
  } else {
   $156 = HEAP32[$p + ($psize + 24) >> 2] | 0; //@line 10681
   $158 = HEAP32[$p + ($psize + 12) >> 2] | 0; //@line 10684
   do if (($158 | 0) == ($0 | 0)) {
    $169 = $p + ($psize + 20) | 0; //@line 10689
    $170 = HEAP32[$169 >> 2] | 0; //@line 10690
    if (!$170) {
     $172 = $p + ($psize + 16) | 0; //@line 10694
     $173 = HEAP32[$172 >> 2] | 0; //@line 10695
     if (!$173) {
      $R7$1 = 0; //@line 10698
      break;
     } else {
      $R7$0 = $173; //@line 10701
      $RP9$0 = $172; //@line 10701
     }
    } else {
     $R7$0 = $170; //@line 10704
     $RP9$0 = $169; //@line 10704
    }
    while (1) {
     $175 = $R7$0 + 20 | 0; //@line 10707
     $176 = HEAP32[$175 >> 2] | 0; //@line 10708
     if ($176) {
      $R7$0 = $176; //@line 10711
      $RP9$0 = $175; //@line 10711
      continue;
     }
     $178 = $R7$0 + 16 | 0; //@line 10714
     $179 = HEAP32[$178 >> 2] | 0; //@line 10715
     if (!$179) break; else {
      $R7$0 = $179; //@line 10720
      $RP9$0 = $178; //@line 10720
     }
    }
    if ($RP9$0 >>> 0 < $108 >>> 0) _abort(); //@line 10725
 else {
     HEAP32[$RP9$0 >> 2] = 0; //@line 10728
     $R7$1 = $R7$0; //@line 10729
     break;
    }
   } else {
    $161 = HEAP32[$p + ($psize + 8) >> 2] | 0; //@line 10735
    if ($161 >>> 0 < $108 >>> 0) _abort(); //@line 10738
    $163 = $161 + 12 | 0; //@line 10741
    if ((HEAP32[$163 >> 2] | 0) != ($0 | 0)) _abort(); //@line 10745
    $166 = $158 + 8 | 0; //@line 10748
    if ((HEAP32[$166 >> 2] | 0) == ($0 | 0)) {
     HEAP32[$163 >> 2] = $158; //@line 10752
     HEAP32[$166 >> 2] = $161; //@line 10753
     $R7$1 = $158; //@line 10754
     break;
    } else _abort(); //@line 10757
   } while (0);
   if ($156) {
    $184 = HEAP32[$p + ($psize + 28) >> 2] | 0; //@line 10766
    $185 = 12304 + ($184 << 2) | 0; //@line 10767
    if (($0 | 0) == (HEAP32[$185 >> 2] | 0)) {
     HEAP32[$185 >> 2] = $R7$1; //@line 10771
     if (!$R7$1) {
      HEAP32[3001] = HEAP32[3001] & ~(1 << $184); //@line 10778
      break;
     }
    } else {
     if ($156 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10785
     $194 = $156 + 16 | 0; //@line 10788
     if ((HEAP32[$194 >> 2] | 0) == ($0 | 0)) HEAP32[$194 >> 2] = $R7$1; //@line 10792
 else HEAP32[$156 + 20 >> 2] = $R7$1; //@line 10795
     if (!$R7$1) break;
    }
    if ($R7$1 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10805
    HEAP32[$R7$1 + 24 >> 2] = $156; //@line 10809
    $203 = HEAP32[$p + ($psize + 16) >> 2] | 0; //@line 10812
    do if ($203) if ($203 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10819
 else {
     HEAP32[$R7$1 + 16 >> 2] = $203; //@line 10823
     HEAP32[$203 + 24 >> 2] = $R7$1; //@line 10825
     break;
    } while (0);
    $210 = HEAP32[$p + ($psize + 20) >> 2] | 0; //@line 10832
    if ($210) if ($210 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10838
 else {
     HEAP32[$R7$1 + 20 >> 2] = $210; //@line 10842
     HEAP32[$210 + 24 >> 2] = $R7$1; //@line 10844
     break;
    }
   }
  } while (0);
  HEAP32[$$0 + 4 >> 2] = $130 | 1; //@line 10853
  HEAP32[$$0 + $130 >> 2] = $130; //@line 10855
  if (($$0 | 0) == (HEAP32[3005] | 0)) {
   HEAP32[3002] = $130; //@line 10859
   STACKTOP = sp; //@line 10860
   return;
  } else $$1 = $130; //@line 10862
 } else {
  HEAP32[$110 >> 2] = $111 & -2; //@line 10866
  HEAP32[$$0 + 4 >> 2] = $$02 | 1; //@line 10869
  HEAP32[$$0 + $$02 >> 2] = $$02; //@line 10871
  $$1 = $$02; //@line 10872
 }
 $225 = $$1 >>> 3; //@line 10874
 if ($$1 >>> 0 < 256) {
  $227 = $225 << 1; //@line 10877
  $228 = 12040 + ($227 << 2) | 0; //@line 10878
  $229 = HEAP32[3e3] | 0; //@line 10879
  $230 = 1 << $225; //@line 10880
  if (!($229 & $230)) {
   HEAP32[3e3] = $229 | $230; //@line 10885
   $$pre$phiZ2D = 12040 + ($227 + 2 << 2) | 0; //@line 10888
   $F16$0 = $228; //@line 10888
  } else {
   $234 = 12040 + ($227 + 2 << 2) | 0; //@line 10891
   $235 = HEAP32[$234 >> 2] | 0; //@line 10892
   if ($235 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10896
 else {
    $$pre$phiZ2D = $234; //@line 10899
    $F16$0 = $235; //@line 10899
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $$0; //@line 10902
  HEAP32[$F16$0 + 12 >> 2] = $$0; //@line 10904
  HEAP32[$$0 + 8 >> 2] = $F16$0; //@line 10906
  HEAP32[$$0 + 12 >> 2] = $228; //@line 10908
  STACKTOP = sp; //@line 10909
  return;
 }
 $241 = $$1 >>> 8; //@line 10911
 if (!$241) $I19$0 = 0; //@line 10914
 else if ($$1 >>> 0 > 16777215) $I19$0 = 31; //@line 10918
 else {
  $246 = ($241 + 1048320 | 0) >>> 16 & 8; //@line 10922
  $247 = $241 << $246; //@line 10923
  $250 = ($247 + 520192 | 0) >>> 16 & 4; //@line 10926
  $252 = $247 << $250; //@line 10928
  $255 = ($252 + 245760 | 0) >>> 16 & 2; //@line 10931
  $260 = 14 - ($250 | $246 | $255) + ($252 << $255 >>> 15) | 0; //@line 10936
  $I19$0 = $$1 >>> ($260 + 7 | 0) & 1 | $260 << 1; //@line 10942
 }
 $266 = 12304 + ($I19$0 << 2) | 0; //@line 10945
 HEAP32[$$0 + 28 >> 2] = $I19$0; //@line 10948
 HEAP32[$$0 + 20 >> 2] = 0; //@line 10950
 HEAP32[$$0 + 16 >> 2] = 0; //@line 10952
 $270 = HEAP32[3001] | 0; //@line 10953
 $271 = 1 << $I19$0; //@line 10954
 if (!($270 & $271)) {
  HEAP32[3001] = $270 | $271; //@line 10959
  HEAP32[$266 >> 2] = $$0; //@line 10960
  HEAP32[$$0 + 24 >> 2] = $266; //@line 10962
  HEAP32[$$0 + 12 >> 2] = $$0; //@line 10964
  HEAP32[$$0 + 8 >> 2] = $$0; //@line 10966
  STACKTOP = sp; //@line 10967
  return;
 }
 $278 = HEAP32[$266 >> 2] | 0; //@line 10969
 if (($I19$0 | 0) == 31) $287 = 0; //@line 10972
 else $287 = 25 - ($I19$0 >>> 1) | 0; //@line 10976
 L194 : do if ((HEAP32[$278 + 4 >> 2] & -8 | 0) == ($$1 | 0)) $T$0$lcssa = $278; //@line 10984
 else {
  $K20$049 = $$1 << $287; //@line 10987
  $T$048 = $278; //@line 10987
  while (1) {
   $295 = $T$048 + ($K20$049 >>> 31 << 2) + 16 | 0; //@line 10990
   $290 = HEAP32[$295 >> 2] | 0; //@line 10991
   if (!$290) break;
   if ((HEAP32[$290 + 4 >> 2] & -8 | 0) == ($$1 | 0)) {
    $T$0$lcssa = $290; //@line 11002
    break L194;
   } else {
    $K20$049 = $K20$049 << 1; //@line 11005
    $T$048 = $290; //@line 11005
   }
  }
  if ($295 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 11011
  HEAP32[$295 >> 2] = $$0; //@line 11014
  HEAP32[$$0 + 24 >> 2] = $T$048; //@line 11016
  HEAP32[$$0 + 12 >> 2] = $$0; //@line 11018
  HEAP32[$$0 + 8 >> 2] = $$0; //@line 11020
  STACKTOP = sp; //@line 11021
  return;
 } while (0);
 $302 = $T$0$lcssa + 8 | 0; //@line 11024
 $303 = HEAP32[$302 >> 2] | 0; //@line 11025
 $304 = HEAP32[3004] | 0; //@line 11026
 if ($T$0$lcssa >>> 0 < $304 >>> 0) _abort(); //@line 11029
 if ($303 >>> 0 < $304 >>> 0) _abort(); //@line 11034
 HEAP32[$303 + 12 >> 2] = $$0; //@line 11038
 HEAP32[$302 >> 2] = $$0; //@line 11039
 HEAP32[$$0 + 8 >> 2] = $303; //@line 11041
 HEAP32[$$0 + 12 >> 2] = $T$0$lcssa; //@line 11043
 HEAP32[$$0 + 24 >> 2] = 0; //@line 11045
 STACKTOP = sp; //@line 11046
 return;
}
function _exp2reg($fs, $e, $reg) {
 $fs = $fs | 0;
 $e = $e | 0;
 $reg = $reg | 0;
 var $$0$i$i = 0, $$0$i$i$us = 0, $$0$i$i21 = 0, $$0$i$i21$us = 0, $$0$i$i46 = 0, $$0$i$i61 = 0, $$014$i = 0, $$014$i12 = 0, $$02$i = 0, $$02$i$us = 0, $$02$i42 = 0, $$pre1$i63 = 0, $$pre93 = 0, $101 = 0, $102 = 0, $104 = 0, $105 = 0, $107 = 0, $11 = 0, $110 = 0, $112 = 0, $122 = 0, $124 = 0, $126 = 0, $128 = 0, $129 = 0, $130 = 0, $132 = 0, $137 = 0, $138 = 0, $14 = 0, $144 = 0, $153 = 0, $16 = 0, $163 = 0, $173 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $181 = 0, $186 = 0, $187 = 0, $193 = 0, $195 = 0, $2 = 0, $206 = 0, $215 = 0, $216 = 0, $218 = 0, $223 = 0, $224 = 0, $230 = 0, $238 = 0, $241 = 0, $242 = 0, $248 = 0, $25 = 0, $251 = 0, $252 = 0, $258 = 0, $26 = 0, $27 = 0, $30 = 0, $33 = 0, $39 = 0, $4 = 0, $43 = 0, $49 = 0, $52 = 0, $58 = 0, $6 = 0, $62 = 0, $69 = 0, $70 = 0, $73 = 0, $74 = 0, $76 = 0, $79 = 0, $8 = 0, $81 = 0, $9 = 0, $90 = 0, $92 = 0, $93 = 0, $95 = 0, $98 = 0, $fs$idx$val$idx$val$i = 0, $fs$idx$val$idx$val$i$i = 0, $fs$idx$val$idx$val$i$i31 = 0, $fs$idx$val$idx$val$i45$pre = 0, $fs$idx$val$idx$val$i5$us$pre = 0, $fs$idx2$val$idx$val$i = 0, $fs$idx2$val$idx$val$i10 = 0, $list$0$i = 0, $list$0$i$i = 0, $list$0$i$i33 = 0, $p_f$0 = 0, $p_t$0 = 0, $storemerge = 0, $storemerge$i = 0, $storemerge$i66 = 0, $storemerge95 = 0, $storemerge96 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 9928
 _discharge2reg($fs, $e, $reg); //@line 9929
 $2 = $e + 16 | 0; //@line 9932
 do if ((HEAP32[$e >> 2] | 0) == 10) {
  $4 = HEAP32[$e + 8 >> 2] | 0; //@line 9936
  if (($4 | 0) != -1) {
   $6 = HEAP32[$2 >> 2] | 0; //@line 9939
   if (($6 | 0) == -1) {
    HEAP32[$2 >> 2] = $4; //@line 9942
    break;
   }
   $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 9947
   $list$0$i = $6; //@line 9948
   while (1) {
    $8 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 9950
    $9 = HEAP32[$8 >> 2] | 0; //@line 9951
    $11 = ($9 >>> 14) + -131071 | 0; //@line 9953
    if (($11 | 0) == -1) break;
    $14 = $list$0$i + 1 + $11 | 0; //@line 9959
    if (($14 | 0) == -1) break; else $list$0$i = $14; //@line 9964
   }
   $16 = $4 + ~$list$0$i | 0; //@line 9968
   if (((($16 | 0) > -1 ? $16 : 0 - $16 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9976
 else {
    HEAP32[$8 >> 2] = ($16 << 14) + 2147467264 | $9 & 16383; //@line 9983
    break;
   }
  }
 } while (0);
 $25 = HEAP32[$2 >> 2] | 0; //@line 9989
 $26 = $e + 20 | 0; //@line 9990
 $27 = HEAP32[$26 >> 2] | 0; //@line 9991
 if (($25 | 0) == ($27 | 0)) {
  HEAP32[$2 >> 2] = -1; //@line 9994
  HEAP32[$26 >> 2] = -1; //@line 9995
  $258 = $e + 8 | 0; //@line 9996
  HEAP32[$258 >> 2] = $reg; //@line 9997
  HEAP32[$e >> 2] = 6; //@line 9998
  STACKTOP = sp; //@line 9999
  return;
 }
 L18 : do if (($25 | 0) == -1) label = 20; //@line 10004
 else {
  $fs$idx2$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10008
  $$014$i = $25; //@line 10009
  while (1) {
   $30 = $fs$idx2$val$idx$val$i + ($$014$i << 2) | 0; //@line 10011
   if (($$014$i | 0) > 0) {
    $33 = HEAP32[$fs$idx2$val$idx$val$i + ($$014$i + -1 << 2) >> 2] | 0; //@line 10016
    if ((HEAP8[8440 + ($33 & 63) >> 0] | 0) < 0) $39 = $33; //@line 10022
 else label = 16; //@line 10024
   } else label = 16; //@line 10027
   if ((label | 0) == 16) {
    label = 0; //@line 10030
    $39 = HEAP32[$30 >> 2] | 0; //@line 10032
   }
   if (($39 & 63 | 0) != 28) {
    label = 28; //@line 10037
    break L18;
   }
   $43 = ((HEAP32[$30 >> 2] | 0) >>> 14) + -131071 | 0; //@line 10042
   if (($43 | 0) == -1) {
    label = 20; //@line 10045
    break L18;
   }
   $$014$i = $$014$i + 1 + $43 | 0; //@line 10049
   if (($$014$i | 0) == -1) {
    label = 20; //@line 10052
    break;
   }
  }
 } while (0);
 L29 : do if ((label | 0) == 20) if (($27 | 0) == -1) {
  $p_f$0 = -1; //@line 10064
  $p_t$0 = -1; //@line 10064
 } else {
  $fs$idx2$val$idx$val$i10 = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10068
  $$014$i12 = $27; //@line 10069
  while (1) {
   $49 = $fs$idx2$val$idx$val$i10 + ($$014$i12 << 2) | 0; //@line 10071
   if (($$014$i12 | 0) > 0) {
    $52 = HEAP32[$fs$idx2$val$idx$val$i10 + ($$014$i12 + -1 << 2) >> 2] | 0; //@line 10076
    if ((HEAP8[8440 + ($52 & 63) >> 0] | 0) < 0) $58 = $52; //@line 10082
 else label = 24; //@line 10084
   } else label = 24; //@line 10087
   if ((label | 0) == 24) {
    label = 0; //@line 10090
    $58 = HEAP32[$49 >> 2] | 0; //@line 10092
   }
   if (($58 & 63 | 0) != 28) {
    label = 28; //@line 10097
    break L29;
   }
   $62 = ((HEAP32[$49 >> 2] | 0) >>> 14) + -131071 | 0; //@line 10102
   if (($62 | 0) == -1) {
    $p_f$0 = -1; //@line 10105
    $p_t$0 = -1; //@line 10105
    break L29;
   }
   $$014$i12 = $$014$i12 + 1 + $62 | 0; //@line 10109
   if (($$014$i12 | 0) == -1) {
    $p_f$0 = -1; //@line 10112
    $p_t$0 = -1; //@line 10112
    break;
   }
  }
 } while (0);
 do if ((label | 0) == 28) {
  $$pre93 = $fs + 28 | 0; //@line 10125
  do if ((HEAP32[$e >> 2] | 0) == 10) $101 = -1; //@line 10128
 else {
   $69 = HEAP32[$$pre93 >> 2] | 0; //@line 10130
   HEAP32[$$pre93 >> 2] = -1; //@line 10131
   $70 = _luaK_code($fs, 2147450903) | 0; //@line 10132
   if (($69 | 0) == -1) $101 = $70; //@line 10135
 else if (($70 | 0) == -1) $101 = $69; //@line 10139
 else {
    $fs$idx$val$idx$val$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10143
    $list$0$i$i = $70; //@line 10144
    while (1) {
     $73 = $fs$idx$val$idx$val$i$i + ($list$0$i$i << 2) | 0; //@line 10146
     $74 = HEAP32[$73 >> 2] | 0; //@line 10147
     $76 = ($74 >>> 14) + -131071 | 0; //@line 10149
     if (($76 | 0) == -1) break;
     $79 = $list$0$i$i + 1 + $76 | 0; //@line 10155
     if (($79 | 0) == -1) break; else $list$0$i$i = $79; //@line 10160
    }
    $81 = $69 + ~$list$0$i$i | 0; //@line 10164
    if (((($81 | 0) > -1 ? $81 : 0 - $81 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 10172
 else {
     HEAP32[$73 >> 2] = ($81 << 14) + 2147467264 | $74 & 16383; //@line 10179
     $101 = $70; //@line 10180
     break;
    }
   }
  } while (0);
  $90 = $fs + 20 | 0; //@line 10187
  $92 = $fs + 24 | 0; //@line 10189
  HEAP32[$92 >> 2] = HEAP32[$90 >> 2]; //@line 10190
  $93 = $reg << 6; //@line 10191
  $95 = _luaK_code($fs, $93 | 16387) | 0; //@line 10193
  HEAP32[$92 >> 2] = HEAP32[$90 >> 2]; //@line 10195
  $98 = _luaK_code($fs, $93 | 8388611) | 0; //@line 10197
  HEAP32[$92 >> 2] = HEAP32[$90 >> 2]; //@line 10199
  if (($101 | 0) == -1) {
   $p_f$0 = $95; //@line 10202
   $p_t$0 = $98; //@line 10202
  } else {
   $102 = HEAP32[$$pre93 >> 2] | 0; //@line 10204
   if (($102 | 0) == -1) {
    HEAP32[$$pre93 >> 2] = $101; //@line 10207
    $p_f$0 = $95; //@line 10208
    $p_t$0 = $98; //@line 10208
    break;
   }
   $fs$idx$val$idx$val$i$i31 = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10213
   $list$0$i$i33 = $102; //@line 10214
   while (1) {
    $104 = $fs$idx$val$idx$val$i$i31 + ($list$0$i$i33 << 2) | 0; //@line 10216
    $105 = HEAP32[$104 >> 2] | 0; //@line 10217
    $107 = ($105 >>> 14) + -131071 | 0; //@line 10219
    if (($107 | 0) == -1) break;
    $110 = $list$0$i$i33 + 1 + $107 | 0; //@line 10225
    if (($110 | 0) == -1) break; else $list$0$i$i33 = $110; //@line 10230
   }
   $112 = $101 + ~$list$0$i$i33 | 0; //@line 10234
   if (((($112 | 0) > -1 ? $112 : 0 - $112 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 10242
 else {
    HEAP32[$104 >> 2] = ($112 << 14) + 2147467264 | $105 & 16383; //@line 10249
    $p_f$0 = $95; //@line 10250
    $p_t$0 = $98; //@line 10250
    break;
   }
  }
 } while (0);
 $122 = HEAP32[$fs + 20 >> 2] | 0; //@line 10257
 HEAP32[$fs + 24 >> 2] = $122; //@line 10259
 $124 = HEAP32[$26 >> 2] | 0; //@line 10260
 L67 : do if (($124 | 0) != -1) {
  $126 = ($reg | 0) == 255; //@line 10264
  $128 = $reg << 6 & 16320; //@line 10266
  $fs$idx$val$idx$val$i45$pre = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10269
  $$02$i42 = $124; //@line 10270
  while (1) {
   $129 = $fs$idx$val$idx$val$i45$pre + ($$02$i42 << 2) | 0; //@line 10272
   $130 = HEAP32[$129 >> 2] | 0; //@line 10273
   $132 = ($130 >>> 14) + -131071 | 0; //@line 10275
   if (($132 | 0) == -1) $$0$i$i46 = -1; //@line 10278
 else $$0$i$i46 = $$02$i42 + 1 + $132 | 0; //@line 10282
   if (($$02$i42 | 0) > 0) {
    $137 = $fs$idx$val$idx$val$i45$pre + ($$02$i42 + -1 << 2) | 0; //@line 10287
    $138 = HEAP32[$137 >> 2] | 0; //@line 10288
    if ((HEAP8[8440 + ($138 & 63) >> 0] | 0) < 0) {
     $$0$i$i61 = $137; //@line 10294
     $144 = $138; //@line 10294
    } else label = 52; //@line 10296
   } else label = 52; //@line 10299
   if ((label | 0) == 52) {
    label = 0; //@line 10302
    $$0$i$i61 = $129; //@line 10303
    $144 = $130; //@line 10303
   }
   if (($144 & 63 | 0) == 28) {
    $$pre1$i63 = $144 >>> 23; //@line 10308
    if ($126 | ($$pre1$i63 | 0) == ($reg | 0)) $storemerge$i66 = $144 & 8372224 | $$pre1$i63 << 6 | 27; //@line 10316
 else $storemerge$i66 = $144 & -16321 | $128; //@line 10320
    HEAP32[$$0$i$i61 >> 2] = $storemerge$i66; //@line 10322
    $153 = $122 + ~$$02$i42 | 0; //@line 10324
    if (((($153 | 0) > -1 ? $153 : 0 - $153 | 0) | 0) > 131071) {
     label = 58; //@line 10330
     break;
    }
    $storemerge = HEAP32[$129 >> 2] & 16383 | ($153 << 14) + 2147467264; //@line 10338
   } else {
    $163 = $p_f$0 + ~$$02$i42 | 0; //@line 10341
    if (((($163 | 0) > -1 ? $163 : 0 - $163 | 0) | 0) > 131071) {
     label = 61; //@line 10347
     break;
    }
    $storemerge = $130 & 16383 | ($163 << 14) + 2147467264; //@line 10354
   }
   HEAP32[$129 >> 2] = $storemerge; //@line 10356
   if (($$0$i$i46 | 0) == -1) break L67; else $$02$i42 = $$0$i$i46; //@line 10361
  }
  if ((label | 0) == 58) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 10367
 else if ((label | 0) == 61) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 10373
 } while (0);
 $173 = HEAP32[$2 >> 2] | 0; //@line 10378
 if (($173 | 0) == -1) {
  HEAP32[$2 >> 2] = -1; //@line 10381
  HEAP32[$26 >> 2] = -1; //@line 10382
  $258 = $e + 8 | 0; //@line 10383
  HEAP32[$258 >> 2] = $reg; //@line 10384
  HEAP32[$e >> 2] = 6; //@line 10385
  STACKTOP = sp; //@line 10386
  return;
 }
 $176 = $reg << 6; //@line 10389
 $177 = $176 & 16320; //@line 10390
 $fs$idx$val$idx$val$i5$us$pre = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 10393
 if (($reg | 0) == 255) {
  $$02$i$us = $173; //@line 10395
  while (1) {
   $178 = $fs$idx$val$idx$val$i5$us$pre + ($$02$i$us << 2) | 0; //@line 10397
   $179 = HEAP32[$178 >> 2] | 0; //@line 10398
   $181 = ($179 >>> 14) + -131071 | 0; //@line 10400
   if (($181 | 0) == -1) $$0$i$i$us = -1; //@line 10403
 else $$0$i$i$us = $$02$i$us + 1 + $181 | 0; //@line 10407
   if (($$02$i$us | 0) > 0) {
    $186 = $fs$idx$val$idx$val$i5$us$pre + ($$02$i$us + -1 << 2) | 0; //@line 10412
    $187 = HEAP32[$186 >> 2] | 0; //@line 10413
    if ((HEAP8[8440 + ($187 & 63) >> 0] | 0) < 0) {
     $$0$i$i21$us = $186; //@line 10419
     $193 = $187; //@line 10419
    } else label = 70; //@line 10421
   } else label = 70; //@line 10424
   if ((label | 0) == 70) {
    label = 0; //@line 10427
    $$0$i$i21$us = $178; //@line 10428
    $193 = $179; //@line 10428
   }
   if (($193 & 63 | 0) == 28) {
    HEAP32[$$0$i$i21$us >> 2] = $193 & 8372224 | $193 >>> 23 << 6 | 27; //@line 10438
    $206 = $122 + ~$$02$i$us | 0; //@line 10440
    if (((($206 | 0) > -1 ? $206 : 0 - $206 | 0) | 0) > 131071) {
     label = 87; //@line 10446
     break;
    }
    $storemerge96 = HEAP32[$178 >> 2] & 16383 | ($206 << 14) + 2147467264; //@line 10454
   } else {
    $195 = $p_t$0 + ~$$02$i$us | 0; //@line 10457
    if (((($195 | 0) > -1 ? $195 : 0 - $195 | 0) | 0) > 131071) {
     label = 90; //@line 10463
     break;
    }
    $storemerge96 = $179 & 16383 | ($195 << 14) + 2147467264; //@line 10470
   }
   HEAP32[$178 >> 2] = $storemerge96; //@line 10472
   if (($$0$i$i$us | 0) == -1) {
    label = 93; //@line 10475
    break;
   } else $$02$i$us = $$0$i$i$us; //@line 10478
  }
  if ((label | 0) == 87) {
   $241 = $fs + 12 | 0; //@line 10482
   $242 = HEAP32[$241 >> 2] | 0; //@line 10483
   _luaX_syntaxerror($242, 2408); //@line 10484
  } else if ((label | 0) == 90) {
   $251 = $fs + 12 | 0; //@line 10488
   $252 = HEAP32[$251 >> 2] | 0; //@line 10489
   _luaX_syntaxerror($252, 2408); //@line 10490
  } else if ((label | 0) == 93) {
   HEAP32[$2 >> 2] = -1; //@line 10494
   HEAP32[$26 >> 2] = -1; //@line 10495
   $258 = $e + 8 | 0; //@line 10496
   HEAP32[$258 >> 2] = $reg; //@line 10497
   HEAP32[$e >> 2] = 6; //@line 10498
   STACKTOP = sp; //@line 10499
   return;
  }
 } else $$02$i = $173; //@line 10502
 while (1) {
  $215 = $fs$idx$val$idx$val$i5$us$pre + ($$02$i << 2) | 0; //@line 10505
  $216 = HEAP32[$215 >> 2] | 0; //@line 10506
  $218 = ($216 >>> 14) + -131071 | 0; //@line 10508
  if (($218 | 0) == -1) $$0$i$i = -1; //@line 10511
 else $$0$i$i = $$02$i + 1 + $218 | 0; //@line 10515
  if (($$02$i | 0) > 0) {
   $223 = $fs$idx$val$idx$val$i5$us$pre + ($$02$i + -1 << 2) | 0; //@line 10520
   $224 = HEAP32[$223 >> 2] | 0; //@line 10521
   if ((HEAP8[8440 + ($224 & 63) >> 0] | 0) < 0) {
    $$0$i$i21 = $223; //@line 10527
    $230 = $224; //@line 10527
   } else label = 81; //@line 10529
  } else label = 81; //@line 10532
  if ((label | 0) == 81) {
   label = 0; //@line 10535
   $$0$i$i21 = $215; //@line 10536
   $230 = $216; //@line 10536
  }
  if (($230 & 63 | 0) == 28) {
   if (($230 >>> 23 | 0) == ($reg | 0)) $storemerge$i = $230 & 8372224 | $176 | 27; //@line 10547
 else $storemerge$i = $230 & -16321 | $177; //@line 10551
   HEAP32[$$0$i$i21 >> 2] = $storemerge$i; //@line 10553
   $238 = $122 + ~$$02$i | 0; //@line 10555
   if (((($238 | 0) > -1 ? $238 : 0 - $238 | 0) | 0) > 131071) {
    label = 87; //@line 10561
    break;
   }
   $storemerge95 = HEAP32[$215 >> 2] & 16383 | ($238 << 14) + 2147467264; //@line 10569
  } else {
   $248 = $p_t$0 + ~$$02$i | 0; //@line 10572
   if (((($248 | 0) > -1 ? $248 : 0 - $248 | 0) | 0) > 131071) {
    label = 90; //@line 10578
    break;
   }
   $storemerge95 = $216 & 16383 | ($248 << 14) + 2147467264; //@line 10585
  }
  HEAP32[$215 >> 2] = $storemerge95; //@line 10587
  if (($$0$i$i | 0) == -1) {
   label = 93; //@line 10590
   break;
  } else $$02$i = $$0$i$i; //@line 10593
 }
 if ((label | 0) == 87) {
  $241 = $fs + 12 | 0; //@line 10597
  $242 = HEAP32[$241 >> 2] | 0; //@line 10598
  _luaX_syntaxerror($242, 2408); //@line 10599
 } else if ((label | 0) == 90) {
  $251 = $fs + 12 | 0; //@line 10603
  $252 = HEAP32[$251 >> 2] | 0; //@line 10604
  _luaX_syntaxerror($252, 2408); //@line 10605
 } else if ((label | 0) == 93) {
  HEAP32[$2 >> 2] = -1; //@line 10609
  HEAP32[$26 >> 2] = -1; //@line 10610
  $258 = $e + 8 | 0; //@line 10611
  HEAP32[$258 >> 2] = $reg; //@line 10612
  HEAP32[$e >> 2] = 6; //@line 10613
  STACKTOP = sp; //@line 10614
  return;
 }
}
function _luaD_precall($L, $func, $nresults) {
 $L = $L | 0;
 $func = $func | 0;
 $nresults = $nresults | 0;
 var $$$$i = 0, $$$$i$i = 0, $$$$i$i12 = 0, $$$$i4 = 0, $$$i = 0, $$$i$i = 0, $$$i$i11 = 0, $$$i3 = 0, $$0 = 0, $$0$i = 0, $$1$i = 0, $$25$i = 0, $$idx$val = 0, $$pn = 0, $$pre$phi$iZ2D = 0, $$pre3$i = 0, $$sum$i = 0, $$sum$i18 = 0, $0 = 0, $1 = 0, $10 = 0, $106 = 0, $108 = 0, $110 = 0, $111 = 0, $116 = 0, $118 = 0, $120 = 0, $125 = 0, $126 = 0, $130 = 0, $131 = 0, $135 = 0, $137 = 0, $138 = 0, $144 = 0, $146 = 0, $148 = 0, $150 = 0, $153 = 0, $155 = 0, $16 = 0, $162 = 0, $163 = 0, $169 = 0, $171 = 0, $176 = 0, $177 = 0, $181 = 0, $185 = 0, $188 = 0, $19 = 0, $193 = 0, $194 = 0, $198 = 0, $2 = 0, $204 = 0, $207 = 0, $210 = 0, $216 = 0, $220 = 0, $221 = 0, $23 = 0, $234 = 0, $24 = 0, $251 = 0, $254 = 0, $255 = 0, $259 = 0, $262 = 0, $267 = 0, $268 = 0, $276 = 0, $277 = 0, $28 = 0, $280 = 0, $283 = 0, $289 = 0, $290 = 0, $294 = 0, $295 = 0, $296 = 0, $3 = 0, $301 = 0, $302 = 0, $31 = 0, $34 = 0, $48 = 0, $5 = 0, $52 = 0, $55 = 0, $56 = 0, $58 = 0, $6 = 0, $66 = 0, $69 = 0, $7 = 0, $74 = 0, $76 = 0, $83 = 0, $84 = 0, $89 = 0, $90 = 0, $97 = 0, $base$0 = 0, $f$0 = 0, $f$0$in = 0, $func$tr = 0, $hook$0$i = 0, $i$03$i = 0, $i$11$i = 0, $n$0$lcssa = 0, $n$019 = 0, $p$01$i = 0, $res$04$i = 0, $res$1$lcssa$i = 0, $res$12$i = 0, $vararg_buffer5 = 0, label = 0, sp = 0, $p$01$i$looptemp = 0, $135$looptemp = 0;
 sp = STACKTOP; //@line 15772
 STACKTOP = STACKTOP + 16 | 0; //@line 15773
 $vararg_buffer5 = sp; //@line 15774
 $0 = $L + 28 | 0; //@line 15775
 $1 = $L + 8 | 0; //@line 15776
 $2 = $L + 24 | 0; //@line 15777
 $3 = $L + 32 | 0; //@line 15778
 $func$tr = $func; //@line 15779
 while (1) {
  $5 = $func$tr; //@line 15782
  $6 = HEAP32[$0 >> 2] | 0; //@line 15783
  $7 = $5 - $6 | 0; //@line 15784
  $10 = HEAP32[$func$tr + 8 >> 2] & 63; //@line 15787
  if (($10 | 0) == 38) {
   label = 4; //@line 15789
   break;
  } else if (($10 | 0) == 22) {
   label = 3; //@line 15792
   break;
  } else if (($10 | 0) == 6) {
   label = 31; //@line 15795
   break;
  }
  $251 = _luaT_gettmbyobj($L, $func$tr, 16) | 0; //@line 15798
  $254 = $5 - (HEAP32[$0 >> 2] | 0) | 0; //@line 15801
  $255 = $251 + 8 | 0; //@line 15802
  if ((HEAP32[$255 >> 2] & 15 | 0) != 6) {
   label = 62; //@line 15807
   break;
  }
  $259 = HEAP32[$1 >> 2] | 0; //@line 15810
  if ($259 >>> 0 > $func$tr >>> 0) {
   $p$01$i = $259; //@line 15813
   do {
    $p$01$i$looptemp = $p$01$i;
    $p$01$i = $p$01$i + -16 | 0; //@line 15815
    $262 = $p$01$i; //@line 15816
    $267 = HEAP32[$262 + 4 >> 2] | 0; //@line 15821
    $268 = $p$01$i$looptemp; //@line 15822
    HEAP32[$268 >> 2] = HEAP32[$262 >> 2]; //@line 15824
    HEAP32[$268 + 4 >> 2] = $267; //@line 15827
    HEAP32[$p$01$i$looptemp + 8 >> 2] = HEAP32[$p$01$i$looptemp + -8 >> 2]; //@line 15831
   } while ($p$01$i >>> 0 > $func$tr >>> 0);
   $277 = HEAP32[$1 >> 2] | 0; //@line 15840
  } else $277 = $259; //@line 15842
  $276 = $277 + 16 | 0; //@line 15844
  HEAP32[$1 >> 2] = $276; //@line 15845
  $280 = $276; //@line 15848
  if (((HEAP32[$2 >> 2] | 0) - $280 | 0) < 16) {
   $283 = HEAP32[$3 >> 2] | 0; //@line 15852
   if (($283 | 0) > 1e6) {
    label = 68; //@line 15855
    break;
   }
   $289 = ($280 - (HEAP32[$0 >> 2] | 0) >> 4) + 5 | 0; //@line 15862
   $290 = $283 << 1; //@line 15863
   $$$i$i11 = ($290 | 0) > 1e6 ? 1e6 : $290; //@line 15865
   $$$$i$i12 = ($$$i$i11 | 0) < ($289 | 0) ? $289 : $$$i$i11; //@line 15867
   if (($$$$i$i12 | 0) > 1e6) {
    label = 70; //@line 15870
    break;
   }
   _luaD_reallocstack($L, $$$$i$i12); //@line 15873
  }
  $294 = HEAP32[$0 >> 2] | 0; //@line 15875
  $295 = $294 + $254 | 0; //@line 15876
  $296 = $251; //@line 15877
  $301 = HEAP32[$296 + 4 >> 2] | 0; //@line 15882
  $302 = $295; //@line 15883
  HEAP32[$302 >> 2] = HEAP32[$296 >> 2]; //@line 15885
  HEAP32[$302 + 4 >> 2] = $301; //@line 15888
  HEAP32[$294 + ($254 + 8) >> 2] = HEAP32[$255 >> 2]; //@line 15892
  $func$tr = $295; //@line 15893
 }
 if ((label | 0) == 3) $f$0$in = $func$tr; //@line 15896
 else if ((label | 0) == 4) $f$0$in = (HEAP32[$func$tr >> 2] | 0) + 12 | 0; //@line 15901
 else if ((label | 0) == 31) {
  $106 = HEAP32[(HEAP32[$func$tr >> 2] | 0) + 12 >> 2] | 0; //@line 15906
  $108 = HEAP32[$1 >> 2] | 0; //@line 15908
  $110 = $108 - $5 >> 4; //@line 15910
  $111 = $110 + -1 | 0; //@line 15911
  $116 = $106 + 78 | 0; //@line 15916
  $118 = HEAPU8[$116 >> 0] | 0; //@line 15918
  do if (((HEAP32[$2 >> 2] | 0) - $108 >> 4 | 0) <= ($118 | 0)) {
   $120 = HEAP32[$3 >> 2] | 0; //@line 15922
   if (($120 | 0) > 1e6) _luaD_throw($L, 6); //@line 15925
   $125 = $118 + 5 + ($108 - $6 >> 4) | 0; //@line 15931
   $126 = $120 << 1; //@line 15932
   $$$i3 = ($126 | 0) > 1e6 ? 1e6 : $126; //@line 15934
   $$$$i4 = ($$$i3 | 0) < ($125 | 0) ? $125 : $$$i3; //@line 15936
   if (($$$$i4 | 0) > 1e6) {
    _luaD_reallocstack($L, 1000200); //@line 15939
    _luaG_runerror($L, 4264, $vararg_buffer5); //@line 15940
   } else {
    _luaD_reallocstack($L, $$$$i4); //@line 15943
    break;
   }
  } while (0);
  $130 = $106 + 76 | 0; //@line 15948
  $131 = HEAP8[$130 >> 0] | 0; //@line 15949
  if (($110 | 0) > ($131 & 255 | 0)) {
   $$idx$val = $131; //@line 15953
   $n$0$lcssa = $111; //@line 15953
  } else {
   $135 = HEAP32[$1 >> 2] | 0; //@line 15956
   $n$019 = $111; //@line 15956
   while (1) {
    $135$looptemp = $135;
    $135 = $135 + 16 | 0; //@line 15958
    HEAP32[$1 >> 2] = $135; //@line 15959
    HEAP32[$135$looptemp + 8 >> 2] = 0; //@line 15961
    $137 = $n$019 + 1 | 0; //@line 15962
    $138 = HEAP8[$130 >> 0] | 0; //@line 15963
    if (($137 | 0) >= ($138 & 255 | 0)) {
     $$idx$val = $138; //@line 15969
     $n$0$lcssa = $137; //@line 15969
     break;
    } else $n$019 = $137; //@line 15967
   }
  }
  if (!(HEAP8[$106 + 77 >> 0] | 0)) {
   $144 = HEAP32[$0 >> 2] | 0; //@line 15978
   $$pn = $144; //@line 15981
   $base$0 = $144 + ($7 + 16) | 0; //@line 15981
  } else {
   $146 = $$idx$val & 255; //@line 15984
   $148 = HEAP32[$1 >> 2] | 0; //@line 15986
   $150 = $148; //@line 15988
   $153 = HEAPU8[$116 >> 0] | 0; //@line 15991
   do if (((HEAP32[$2 >> 2] | 0) - $150 >> 4 | 0) > ($153 | 0)) $169 = $148; //@line 15995
 else {
    $155 = HEAP32[$3 >> 2] | 0; //@line 15997
    if (($155 | 0) > 1e6) _luaD_throw($L, 6); //@line 16000
    $162 = $153 + 5 + ($150 - (HEAP32[$0 >> 2] | 0) >> 4) | 0; //@line 16008
    $163 = $155 << 1; //@line 16009
    $$$i$i = ($163 | 0) > 1e6 ? 1e6 : $163; //@line 16011
    $$$$i$i = ($$$i$i | 0) < ($162 | 0) ? $162 : $$$i$i; //@line 16013
    if (($$$$i$i | 0) > 1e6) {
     _luaD_reallocstack($L, 1000200); //@line 16016
     _luaG_runerror($L, 4264, $vararg_buffer5); //@line 16017
    } else {
     _luaD_reallocstack($L, $$$$i$i); //@line 16020
     $169 = HEAP32[$1 >> 2] | 0; //@line 16022
     break;
    }
   } while (0);
   if ($$idx$val << 24 >> 24) {
    $$sum$i18 = 0 - $n$0$lcssa | 0; //@line 16029
    HEAP32[$1 >> 2] = $169 + 16; //@line 16032
    $171 = $169 + ($$sum$i18 << 4) | 0; //@line 16033
    $176 = HEAP32[$171 + 4 >> 2] | 0; //@line 16038
    $177 = $169; //@line 16039
    HEAP32[$177 >> 2] = HEAP32[$171 >> 2]; //@line 16041
    HEAP32[$177 + 4 >> 2] = $176; //@line 16044
    $181 = $169 + ($$sum$i18 << 4) + 8 | 0; //@line 16045
    HEAP32[$169 + 8 >> 2] = HEAP32[$181 >> 2]; //@line 16048
    HEAP32[$181 >> 2] = 0; //@line 16049
    if (($$idx$val & 255) > 1) {
     $185 = 1; //@line 16052
     do {
      $$pre3$i = HEAP32[$1 >> 2] | 0; //@line 16054
      $$sum$i = $185 - $n$0$lcssa | 0; //@line 16055
      HEAP32[$1 >> 2] = $$pre3$i + 16; //@line 16058
      $188 = $169 + ($$sum$i << 4) | 0; //@line 16059
      $193 = HEAP32[$188 + 4 >> 2] | 0; //@line 16064
      $194 = $$pre3$i; //@line 16065
      HEAP32[$194 >> 2] = HEAP32[$188 >> 2]; //@line 16067
      HEAP32[$194 + 4 >> 2] = $193; //@line 16070
      $198 = $169 + ($$sum$i << 4) + 8 | 0; //@line 16071
      HEAP32[$$pre3$i + 8 >> 2] = HEAP32[$198 >> 2]; //@line 16074
      HEAP32[$198 >> 2] = 0; //@line 16075
      $185 = $185 + 1 | 0; //@line 16076
     } while (($185 | 0) < ($146 | 0));
    }
   }
   $$pn = HEAP32[$0 >> 2] | 0; //@line 16087
   $base$0 = $169; //@line 16087
  }
  $204 = $L + 16 | 0; //@line 16090
  $207 = HEAP32[(HEAP32[$204 >> 2] | 0) + 12 >> 2] | 0; //@line 16093
  if (!$207) $210 = _luaE_extendCI($L) | 0; //@line 16097
 else $210 = $207; //@line 16099
  HEAP32[$204 >> 2] = $210; //@line 16101
  HEAP16[$210 + 16 >> 1] = $nresults; //@line 16104
  HEAP32[$210 >> 2] = $$pn + $7; //@line 16105
  HEAP32[$210 + 24 >> 2] = $base$0; //@line 16108
  $216 = $base$0 + (HEAPU8[$116 >> 0] << 4) | 0; //@line 16111
  HEAP32[$210 + 4 >> 2] = $216; //@line 16113
  $220 = $210 + 28 | 0; //@line 16116
  HEAP32[$220 >> 2] = HEAP32[$106 + 12 >> 2]; //@line 16117
  $221 = $210 + 18 | 0; //@line 16118
  HEAP8[$221 >> 0] = 1; //@line 16119
  HEAP32[$1 >> 2] = $216; //@line 16120
  if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 16127
  if (!(HEAP8[$L + 40 >> 0] & 1)) {
   $$0 = 0; //@line 16134
   STACKTOP = sp; //@line 16135
   return $$0 | 0; //@line 16135
  }
  HEAP32[$220 >> 2] = (HEAP32[$220 >> 2] | 0) + 4; //@line 16139
  $234 = HEAP32[$210 + 8 >> 2] | 0; //@line 16141
  if (!(HEAP8[$234 + 18 >> 0] & 1)) $hook$0$i = 0; //@line 16147
 else if ((HEAP32[(HEAP32[$234 + 28 >> 2] | 0) + -4 >> 2] & 63 | 0) == 30) {
   HEAP8[$221 >> 0] = HEAPU8[$221 >> 0] | 64; //@line 16160
   $hook$0$i = 4; //@line 16161
  } else $hook$0$i = 0; //@line 16163
  _luaD_hook($L, $hook$0$i, -1); //@line 16166
  HEAP32[$220 >> 2] = (HEAP32[$220 >> 2] | 0) + -4; //@line 16169
  $$0 = 0; //@line 16170
  STACKTOP = sp; //@line 16171
  return $$0 | 0; //@line 16171
 } else if ((label | 0) == 62) _luaG_typeerror($L, $func$tr, 4560); //@line 16174
 else if ((label | 0) == 68) _luaD_throw($L, 6); //@line 16178
 else if ((label | 0) == 70) {
  _luaD_reallocstack($L, 1000200); //@line 16182
  _luaG_runerror($L, 4264, $vararg_buffer5); //@line 16183
 }
 $f$0 = HEAP32[$f$0$in >> 2] | 0; //@line 16186
 $16 = HEAP32[$1 >> 2] | 0; //@line 16190
 do if (((HEAP32[$2 >> 2] | 0) - $16 | 0) < 336) {
  $19 = HEAP32[$3 >> 2] | 0; //@line 16195
  if (($19 | 0) > 1e6) _luaD_throw($L, 6); //@line 16198
  $23 = ($16 - $6 >> 4) + 25 | 0; //@line 16203
  $24 = $19 << 1; //@line 16204
  $$$i = ($24 | 0) > 1e6 ? 1e6 : $24; //@line 16206
  $$$$i = ($$$i | 0) < ($23 | 0) ? $23 : $$$i; //@line 16208
  if (($$$$i | 0) > 1e6) {
   _luaD_reallocstack($L, 1000200); //@line 16211
   _luaG_runerror($L, 4264, $vararg_buffer5); //@line 16212
  } else {
   _luaD_reallocstack($L, $$$$i); //@line 16215
   break;
  }
 } while (0);
 $28 = $L + 16 | 0; //@line 16220
 $31 = HEAP32[(HEAP32[$28 >> 2] | 0) + 12 >> 2] | 0; //@line 16223
 if (!$31) $34 = _luaE_extendCI($L) | 0; //@line 16227
 else $34 = $31; //@line 16229
 HEAP32[$28 >> 2] = $34; //@line 16231
 HEAP16[$34 + 16 >> 1] = $nresults; //@line 16234
 HEAP32[$34 >> 2] = (HEAP32[$0 >> 2] | 0) + $7; //@line 16237
 HEAP32[$34 + 4 >> 2] = (HEAP32[$1 >> 2] | 0) + 320; //@line 16241
 HEAP8[$34 + 18 >> 0] = 0; //@line 16243
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 16250
 $48 = $L + 40 | 0; //@line 16252
 if (HEAP8[$48 >> 0] & 1) _luaD_hook($L, 0, -1); //@line 16257
 $52 = FUNCTION_TABLE_ii[$f$0 & 255]($L) | 0; //@line 16259
 $55 = (HEAP32[$1 >> 2] | 0) + (0 - $52 << 4) | 0; //@line 16262
 $56 = HEAP32[$28 >> 2] | 0; //@line 16263
 $58 = HEAPU8[$48 >> 0] | 0; //@line 16265
 if (!($58 & 6)) {
  $$1$i = $55; //@line 16270
  $$pre$phi$iZ2D = $56 + 8 | 0; //@line 16270
 } else {
  if (!($58 & 2)) $$0$i = $55; //@line 16275
 else {
   $66 = $55 - (HEAP32[$0 >> 2] | 0) | 0; //@line 16280
   _luaD_hook($L, 1, -1); //@line 16281
   $$0$i = (HEAP32[$0 >> 2] | 0) + $66 | 0; //@line 16284
  }
  $69 = $56 + 8 | 0; //@line 16286
  HEAP32[$L + 20 >> 2] = HEAP32[(HEAP32[$69 >> 2] | 0) + 28 >> 2]; //@line 16291
  $$1$i = $$0$i; //@line 16292
  $$pre$phi$iZ2D = $69; //@line 16292
 }
 $74 = HEAP32[$56 >> 2] | 0; //@line 16294
 $76 = HEAP16[$56 + 16 >> 1] | 0; //@line 16296
 HEAP32[$28 >> 2] = HEAP32[$$pre$phi$iZ2D >> 2]; //@line 16298
 L94 : do if (!($76 << 16 >> 16)) $res$1$lcssa$i = $74; //@line 16302
 else {
  $$25$i = $$1$i; //@line 16305
  $i$03$i = $76 << 16 >> 16; //@line 16305
  $res$04$i = $74; //@line 16305
  while (1) {
   if ($$25$i >>> 0 >= (HEAP32[$1 >> 2] | 0) >>> 0) break;
   $83 = $res$04$i + 16 | 0; //@line 16312
   $84 = $$25$i; //@line 16313
   $89 = HEAP32[$84 + 4 >> 2] | 0; //@line 16318
   $90 = $res$04$i; //@line 16319
   HEAP32[$90 >> 2] = HEAP32[$84 >> 2]; //@line 16321
   HEAP32[$90 + 4 >> 2] = $89; //@line 16324
   HEAP32[$res$04$i + 8 >> 2] = HEAP32[$$25$i + 8 >> 2]; //@line 16328
   $97 = $i$03$i + -1 | 0; //@line 16329
   if (!$97) {
    $res$1$lcssa$i = $83; //@line 16332
    break L94;
   }
   $$25$i = $$25$i + 16 | 0; //@line 16336
   $i$03$i = $97; //@line 16336
   $res$04$i = $83; //@line 16336
  }
  if (($i$03$i | 0) > 0) {
   $i$11$i = $i$03$i; //@line 16340
   $res$12$i = $res$04$i; //@line 16340
   while (1) {
    $i$11$i = $i$11$i + -1 | 0; //@line 16342
    HEAP32[$res$12$i + 8 >> 2] = 0; //@line 16345
    if (($i$11$i | 0) <= 0) break; else $res$12$i = $res$12$i + 16 | 0; //@line 16348
   }
   $res$1$lcssa$i = $res$04$i + ($i$03$i << 4) | 0; //@line 16354
  } else $res$1$lcssa$i = $res$04$i; //@line 16356
 } while (0);
 HEAP32[$1 >> 2] = $res$1$lcssa$i; //@line 16360
 $$0 = 1; //@line 16361
 STACKTOP = sp; //@line 16362
 return $$0 | 0; //@line 16362
}
function _LoadFunction($S, $f) {
 $S = $S | 0;
 $f = $f | 0;
 var $$0$i$i = 0, $$0$i$i34 = 0, $$0$i17$i = 0, $$0$i5$i = 0, $0 = 0, $10 = 0, $104 = 0, $108 = 0, $110 = 0, $111 = 0, $113 = 0, $115 = 0, $116 = 0, $118 = 0, $128 = 0, $132 = 0, $134 = 0, $135 = 0, $139 = 0, $158 = 0, $163 = 0, $176 = 0, $180 = 0, $181 = 0, $182 = 0, $191 = 0, $195 = 0, $197 = 0, $198 = 0, $201 = 0, $203 = 0, $208 = 0, $212 = 0, $226 = 0, $233 = 0, $242 = 0, $245 = 0, $249 = 0, $253 = 0, $31 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $46 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $56 = 0, $59 = 0, $60 = 0, $65 = 0, $81 = 0, $85 = 0, $99 = 0, $i$0$i45 = 0, $i$1$i43 = 0, $i$126$i = 0, $i$16$i = 0, $i$2$i40 = 0, $i$225$i = 0, $i$3$i39 = 0, $x$i13$i = 0, $x$i8$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 18
 STACKTOP = STACKTOP + 16 | 0; //@line 19
 $x$i8$i = sp; //@line 20
 $x$i13$i = sp + 8 | 0; //@line 21
 $0 = $S + 4 | 0; //@line 22
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 27
 $4 = HEAP32[$x$i8$i >> 2] | 0; //@line 30
 if (($4 | 0) < 0) _error($S, 11728); //@line 33
 HEAP32[$f + 64 >> 2] = $4; //@line 37
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 42
 $10 = HEAP32[$x$i8$i >> 2] | 0; //@line 45
 if (($10 | 0) < 0) _error($S, 11728); //@line 48
 HEAP32[$f + 68 >> 2] = $10; //@line 52
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) _error($S, 11680); //@line 57
 HEAP8[$f + 76 >> 0] = HEAP8[$x$i8$i >> 0] | 0; //@line 62
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) _error($S, 11680); //@line 67
 HEAP8[$f + 77 >> 0] = HEAP8[$x$i8$i >> 0] | 0; //@line 72
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) _error($S, 11680); //@line 77
 HEAP8[$f + 78 >> 0] = HEAP8[$x$i8$i >> 0] | 0; //@line 82
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 87
 $31 = HEAP32[$x$i8$i >> 2] | 0; //@line 90
 if (($31 | 0) < 0) _error($S, 11728); //@line 93
 $35 = HEAP32[$S >> 2] | 0; //@line 98
 if (($31 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($35); //@line 100
 $36 = $31 << 2; //@line 103
 $37 = _luaM_realloc_($35, 0, 0, $36) | 0; //@line 104
 HEAP32[$f + 12 >> 2] = $37; //@line 106
 HEAP32[$f + 48 >> 2] = $31; //@line 108
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $37, $36) | 0) _error($S, 11680); //@line 113
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 120
 $46 = HEAP32[$x$i8$i >> 2] | 0; //@line 123
 if (($46 | 0) < 0) _error($S, 11728); //@line 126
 $50 = HEAP32[$S >> 2] | 0; //@line 131
 if (($46 + 1 | 0) >>> 0 > 268435455) _luaM_toobig($50); //@line 133
 $52 = _luaM_realloc_($50, 0, 0, $46 << 4) | 0; //@line 137
 $53 = $f + 8 | 0; //@line 138
 HEAP32[$53 >> 2] = $52; //@line 139
 HEAP32[$f + 44 >> 2] = $46; //@line 141
 $55 = ($46 | 0) > 0; //@line 142
 L43 : do if ($55) {
  $i$0$i45 = 0; //@line 145
  do {
   HEAP32[$52 + ($i$0$i45 << 4) + 8 >> 2] = 0; //@line 148
   $i$0$i45 = $i$0$i45 + 1 | 0; //@line 149
  } while (($i$0$i45 | 0) != ($46 | 0));
  if ($55) {
   $56 = $S + 8 | 0; //@line 158
   $60 = $52; //@line 159
   $i$1$i43 = 0; //@line 159
   while (1) {
    $59 = $60 + ($i$1$i43 << 4) | 0; //@line 161
    if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) {
     label = 34; //@line 166
     break;
    }
    $65 = HEAP8[$x$i8$i >> 0] | 0; //@line 170
    if (($65 | 0) == 4) {
     if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) {
      label = 44; //@line 176
      break;
     }
     $81 = HEAP32[$x$i8$i >> 2] | 0; //@line 179
     if (!$81) $$0$i$i34 = 0; //@line 182
 else {
      $85 = _luaZ_openspace(HEAP32[$S >> 2] | 0, HEAP32[$56 >> 2] | 0, $81) | 0; //@line 186
      if (_luaZ_read(HEAP32[$0 >> 2] | 0, $85, HEAP32[$x$i8$i >> 2] | 0) | 0) {
       label = 47; //@line 192
       break;
      }
      $$0$i$i34 = _luaS_newlstr(HEAP32[$S >> 2] | 0, $85, (HEAP32[$x$i8$i >> 2] | 0) + -1 | 0) | 0; //@line 199
     }
     HEAP32[$59 >> 2] = $$0$i$i34; //@line 201
     HEAP32[$60 + ($i$1$i43 << 4) + 8 >> 2] = HEAPU8[$$0$i$i34 + 4 >> 0] | 64; //@line 207
    } else if (($65 | 0) == 3) {
     if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 8) | 0) {
      label = 41; //@line 213
      break;
     }
     HEAPF64[$59 >> 3] = +HEAPF64[$x$i8$i >> 3]; //@line 217
     HEAP32[$60 + ($i$1$i43 << 4) + 8 >> 2] = 3; //@line 219
    } else if (!$65) HEAP32[$60 + ($i$1$i43 << 4) + 8 >> 2] = 0; //@line 222
 else if (($65 | 0) == 1) {
     if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) {
      label = 38; //@line 228
      break;
     }
     HEAP32[$59 >> 2] = HEAP8[$x$i8$i >> 0]; //@line 233
     HEAP32[$60 + ($i$1$i43 << 4) + 8 >> 2] = 1; //@line 235
    }
    $99 = $i$1$i43 + 1 | 0; //@line 237
    if (($99 | 0) >= ($46 | 0)) break L43;
    $60 = HEAP32[$53 >> 2] | 0; //@line 243
    $i$1$i43 = $99; //@line 243
   }
   if ((label | 0) == 34) _error($S, 11680); //@line 246
 else if ((label | 0) == 38) _error($S, 11680); //@line 250
 else if ((label | 0) == 41) _error($S, 11680); //@line 254
 else if ((label | 0) == 44) _error($S, 11680); //@line 258
 else if ((label | 0) == 47) _error($S, 11680); //@line 262
  }
 } while (0);
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 272
 $104 = HEAP32[$x$i8$i >> 2] | 0; //@line 275
 if (($104 | 0) < 0) _error($S, 11728); //@line 278
 $108 = HEAP32[$S >> 2] | 0; //@line 283
 if (($104 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($108); //@line 285
 $110 = _luaM_realloc_($108, 0, 0, $104 << 2) | 0; //@line 289
 $111 = $f + 16 | 0; //@line 290
 HEAP32[$111 >> 2] = $110; //@line 291
 HEAP32[$f + 56 >> 2] = $104; //@line 293
 $113 = ($104 | 0) > 0; //@line 294
 do if ($113) {
  $115 = $110; //@line 297
  $i$2$i40 = 0; //@line 297
  while (1) {
   HEAP32[$115 + ($i$2$i40 << 2) >> 2] = 0; //@line 300
   $116 = $i$2$i40 + 1 | 0; //@line 301
   if (($116 | 0) == ($104 | 0)) break;
   $115 = HEAP32[$111 >> 2] | 0; //@line 307
   $i$2$i40 = $116; //@line 307
  }
  if ($113) $i$3$i39 = 0; //@line 310
 else break;
  do {
   $118 = _luaF_newproto(HEAP32[$S >> 2] | 0) | 0; //@line 316
   HEAP32[(HEAP32[$111 >> 2] | 0) + ($i$3$i39 << 2) >> 2] = $118; //@line 319
   _LoadFunction($S, HEAP32[(HEAP32[$111 >> 2] | 0) + ($i$3$i39 << 2) >> 2] | 0); //@line 323
   $i$3$i39 = $i$3$i39 + 1 | 0; //@line 324
  } while (($i$3$i39 | 0) != ($104 | 0));
 } while (0);
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 338
 $128 = HEAP32[$x$i8$i >> 2] | 0; //@line 341
 if (($128 | 0) < 0) _error($S, 11728); //@line 344
 $132 = HEAP32[$S >> 2] | 0; //@line 349
 if (($128 + 1 | 0) >>> 0 > 536870911) _luaM_toobig($132); //@line 351
 $134 = _luaM_realloc_($132, 0, 0, $128 << 3) | 0; //@line 355
 $135 = $f + 28 | 0; //@line 356
 HEAP32[$135 >> 2] = $134; //@line 357
 HEAP32[$f + 40 >> 2] = $128; //@line 359
 L98 : do if (($128 | 0) > 0) {
  HEAP32[$134 >> 2] = 0; //@line 363
  if (($128 | 0) == 1) $i$16$i = 0; //@line 366
 else {
   $139 = 1; //@line 368
   do {
    HEAP32[(HEAP32[$135 >> 2] | 0) + ($139 << 3) >> 2] = 0; //@line 372
    $139 = $139 + 1 | 0; //@line 373
   } while (($139 | 0) != ($128 | 0));
   $i$16$i = 0; //@line 376
  }
  while (1) {
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) {
    label = 73; //@line 388
    break;
   }
   HEAP8[(HEAP32[$135 >> 2] | 0) + ($i$16$i << 3) + 4 >> 0] = HEAP8[$x$i8$i >> 0] | 0; //@line 394
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 1) | 0) {
    label = 75; //@line 399
    break;
   }
   HEAP8[(HEAP32[$135 >> 2] | 0) + ($i$16$i << 3) + 5 >> 0] = HEAP8[$x$i8$i >> 0] | 0; //@line 405
   $i$16$i = $i$16$i + 1 | 0; //@line 406
   if (($i$16$i | 0) >= ($128 | 0)) break L98;
  }
  if ((label | 0) == 73) _error($S, 11680); //@line 415
 else if ((label | 0) == 75) _error($S, 11680); //@line 419
 } while (0);
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 428
 $158 = HEAP32[$x$i8$i >> 2] | 0; //@line 431
 do if (!$158) $$0$i$i = 0; //@line 435
 else {
  $163 = _luaZ_openspace(HEAP32[$S >> 2] | 0, HEAP32[$S + 8 >> 2] | 0, $158) | 0; //@line 440
  if (!(_luaZ_read(HEAP32[$0 >> 2] | 0, $163, HEAP32[$x$i8$i >> 2] | 0) | 0)) {
   $$0$i$i = _luaS_newlstr(HEAP32[$S >> 2] | 0, $163, (HEAP32[$x$i8$i >> 2] | 0) + -1 | 0) | 0; //@line 450
   break;
  } else _error($S, 11680); //@line 453
 } while (0);
 HEAP32[$f + 36 >> 2] = $$0$i$i; //@line 459
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 464
 $176 = HEAP32[$x$i8$i >> 2] | 0; //@line 467
 if (($176 | 0) < 0) _error($S, 11728); //@line 470
 $180 = HEAP32[$S >> 2] | 0; //@line 475
 if (($176 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($180); //@line 477
 $181 = $176 << 2; //@line 480
 $182 = _luaM_realloc_($180, 0, 0, $181) | 0; //@line 481
 HEAP32[$f + 20 >> 2] = $182; //@line 483
 HEAP32[$f + 52 >> 2] = $176; //@line 485
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $182, $181) | 0) _error($S, 11680); //@line 490
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) _error($S, 11680); //@line 497
 $191 = HEAP32[$x$i8$i >> 2] | 0; //@line 500
 if (($191 | 0) < 0) _error($S, 11728); //@line 503
 $195 = HEAP32[$S >> 2] | 0; //@line 508
 if (($191 + 1 | 0) >>> 0 > 357913941) _luaM_toobig($195); //@line 510
 $197 = _luaM_realloc_($195, 0, 0, $191 * 12 | 0) | 0; //@line 514
 $198 = $f + 24 | 0; //@line 515
 HEAP32[$198 >> 2] = $197; //@line 516
 HEAP32[$f + 60 >> 2] = $191; //@line 518
 L141 : do if (($191 | 0) > 0) {
  HEAP32[$197 >> 2] = 0; //@line 522
  if (($191 | 0) != 1) {
   $203 = 1; //@line 525
   do {
    HEAP32[(HEAP32[$198 >> 2] | 0) + ($203 * 12 | 0) >> 2] = 0; //@line 529
    $203 = $203 + 1 | 0; //@line 530
   } while (($203 | 0) != ($191 | 0));
  }
  $201 = $S + 8 | 0; //@line 539
  $i$126$i = 0; //@line 540
  while (1) {
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) {
    label = 102; //@line 546
    break;
   }
   $208 = HEAP32[$x$i8$i >> 2] | 0; //@line 549
   if (!$208) $$0$i5$i = 0; //@line 552
 else {
    $212 = _luaZ_openspace(HEAP32[$S >> 2] | 0, HEAP32[$201 >> 2] | 0, $208) | 0; //@line 556
    if (_luaZ_read(HEAP32[$0 >> 2] | 0, $212, HEAP32[$x$i8$i >> 2] | 0) | 0) {
     label = 105; //@line 562
     break;
    }
    $$0$i5$i = _luaS_newlstr(HEAP32[$S >> 2] | 0, $212, (HEAP32[$x$i8$i >> 2] | 0) + -1 | 0) | 0; //@line 569
   }
   HEAP32[(HEAP32[$198 >> 2] | 0) + ($i$126$i * 12 | 0) >> 2] = $$0$i5$i; //@line 573
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) {
    label = 108; //@line 578
    break;
   }
   $226 = HEAP32[$x$i8$i >> 2] | 0; //@line 581
   if (($226 | 0) < 0) {
    label = 110; //@line 584
    break;
   }
   HEAP32[(HEAP32[$198 >> 2] | 0) + ($i$126$i * 12 | 0) + 4 >> 2] = $226; //@line 589
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) {
    label = 112; //@line 594
    break;
   }
   $233 = HEAP32[$x$i8$i >> 2] | 0; //@line 597
   if (($233 | 0) < 0) {
    label = 114; //@line 600
    break;
   }
   HEAP32[(HEAP32[$198 >> 2] | 0) + ($i$126$i * 12 | 0) + 8 >> 2] = $233; //@line 605
   $i$126$i = $i$126$i + 1 | 0; //@line 606
   if (($i$126$i | 0) >= ($191 | 0)) break L141;
  }
  if ((label | 0) == 102) _error($S, 11680); //@line 615
 else if ((label | 0) == 105) _error($S, 11680); //@line 619
 else if ((label | 0) == 108) _error($S, 11680); //@line 623
 else if ((label | 0) == 110) _error($S, 11728); //@line 627
 else if ((label | 0) == 112) _error($S, 11680); //@line 631
 else if ((label | 0) == 114) _error($S, 11728); //@line 635
 } while (0);
 if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i13$i, 4) | 0) _error($S, 11680); //@line 644
 $242 = HEAP32[$x$i13$i >> 2] | 0; //@line 647
 if (($242 | 0) < 0) _error($S, 11728); //@line 650
 if (($242 | 0) <= 0) {
  STACKTOP = sp; //@line 655
  return;
 }
 $245 = $S + 8 | 0; //@line 657
 $i$225$i = 0; //@line 658
 while (1) {
  if (_luaZ_read(HEAP32[$0 >> 2] | 0, $x$i8$i, 4) | 0) {
   label = 123; //@line 664
   break;
  }
  $249 = HEAP32[$x$i8$i >> 2] | 0; //@line 667
  if (!$249) $$0$i17$i = 0; //@line 670
 else {
   $253 = _luaZ_openspace(HEAP32[$S >> 2] | 0, HEAP32[$245 >> 2] | 0, $249) | 0; //@line 674
   if (_luaZ_read(HEAP32[$0 >> 2] | 0, $253, HEAP32[$x$i8$i >> 2] | 0) | 0) {
    label = 126; //@line 680
    break;
   }
   $$0$i17$i = _luaS_newlstr(HEAP32[$S >> 2] | 0, $253, (HEAP32[$x$i8$i >> 2] | 0) + -1 | 0) | 0; //@line 687
  }
  HEAP32[(HEAP32[$135 >> 2] | 0) + ($i$225$i << 3) >> 2] = $$0$i17$i; //@line 691
  $i$225$i = $i$225$i + 1 | 0; //@line 692
  if (($i$225$i | 0) >= ($242 | 0)) {
   label = 129; //@line 697
   break;
  }
 }
 if ((label | 0) == 123) _error($S, 11680); //@line 702
 else if ((label | 0) == 126) _error($S, 11680); //@line 706
 else if ((label | 0) == 129) {
  STACKTOP = sp; //@line 710
  return;
 }
}
function _str_format($L) {
 $L = $L | 0;
 var $$$$i = 0, $$$i = 0, $$0 = 0, $$p$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $103 = 0.0, $105 = 0, $106 = 0, $110 = 0, $113 = 0, $116 = 0, $117 = 0, $121 = 0, $124 = 0, $127 = 0, $129 = 0, $138 = 0, $139 = 0, $140 = 0, $143 = 0, $145 = 0, $149 = 0, $15 = 0, $152 = 0, $156 = 0, $159 = 0, $164 = 0, $169 = 0, $18 = 0, $19 = 0, $2 = 0, $22 = 0, $27 = 0, $3 = 0, $30 = 0, $32 = 0, $35 = 0, $38 = 0, $41 = 0, $44 = 0, $48 = 0, $5 = 0, $53 = 0, $55 = 0, $6 = 0, $63 = 0, $65 = 0, $7 = 0, $70 = 0, $73 = 0.0, $74 = 0, $76 = 0.0, $79 = 0, $8 = 0, $81 = 0, $82 = 0, $87 = 0.0, $88 = 0, $90 = 0.0, $93 = 0, $95 = 0, $96 = 0, $arg$0$ph11 = 0, $b = 0, $buff$i = 0, $form = 0, $l = 0, $l$i = 0, $nb$0 = 0, $p$0$lcssa$i = 0, $p$09$i = 0, $p$2$i = 0, $p$4$i = 0, $s$01$i = 0, $sfl = 0, $strfrmt$0$be = 0, $strfrmt$0$ph10 = 0, $strfrmt$08 = 0, $vararg_buffer23 = 0, label = 0, sp = 0, $arg$0$ph11$looptemp = 0;
 sp = STACKTOP; //@line 13714
 STACKTOP = STACKTOP + 1088 | 0; //@line 13715
 $vararg_buffer23 = sp; //@line 13716
 $l$i = sp + 12 | 0; //@line 13717
 $buff$i = sp + 1060 | 0; //@line 13718
 $sfl = sp + 1056 | 0; //@line 13719
 $b = sp + 16 | 0; //@line 13720
 $form = sp + 1070 | 0; //@line 13721
 $l = sp + 8 | 0; //@line 13722
 $0 = _lua_gettop($L) | 0; //@line 13723
 $1 = _luaL_checklstring($L, 1, $sfl) | 0; //@line 13724
 $2 = HEAP32[$sfl >> 2] | 0; //@line 13725
 $3 = $1 + $2 | 0; //@line 13726
 _luaL_buffinit($L, $b); //@line 13727
 L1 : do if (($2 | 0) > 0) {
  $5 = $b + 8 | 0; //@line 13731
  $6 = $b + 4 | 0; //@line 13732
  $7 = $form + 1 | 0; //@line 13733
  $arg$0$ph11 = 1; //@line 13734
  $strfrmt$0$ph10 = $1; //@line 13734
  L3 : while (1) {
   $strfrmt$08 = $strfrmt$0$ph10; //@line 13736
   while (1) {
    $8 = HEAP8[$strfrmt$08 >> 0] | 0; //@line 13738
    if ($8 << 24 >> 24 == 37) {
     $19 = $strfrmt$08 + 1 | 0; //@line 13741
     if ((HEAP8[$19 >> 0] | 0) != 37) break;
     $22 = HEAP32[$5 >> 2] | 0; //@line 13747
     if ($22 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) {
      $27 = $22; //@line 13751
      $30 = 37; //@line 13751
     } else {
      _luaL_prepbuffsize($b, 1) | 0; //@line 13753
      $27 = HEAP32[$5 >> 2] | 0; //@line 13756
      $30 = HEAP8[$19 >> 0] | 0; //@line 13756
     }
     HEAP32[$5 >> 2] = $27 + 1; //@line 13760
     HEAP8[(HEAP32[$b >> 2] | 0) + $27 >> 0] = $30; //@line 13763
     $strfrmt$0$be = $strfrmt$08 + 2 | 0; //@line 13764
    } else {
     $10 = HEAP32[$5 >> 2] | 0; //@line 13766
     if ($10 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) {
      $15 = $10; //@line 13770
      $18 = $8; //@line 13770
     } else {
      _luaL_prepbuffsize($b, 1) | 0; //@line 13772
      $15 = HEAP32[$5 >> 2] | 0; //@line 13775
      $18 = HEAP8[$strfrmt$08 >> 0] | 0; //@line 13775
     }
     HEAP32[$5 >> 2] = $15 + 1; //@line 13779
     HEAP8[(HEAP32[$b >> 2] | 0) + $15 >> 0] = $18; //@line 13782
     $strfrmt$0$be = $strfrmt$08 + 1 | 0; //@line 13783
    }
    if ($strfrmt$0$be >>> 0 < $3 >>> 0) $strfrmt$08 = $strfrmt$0$be; //@line 13787
 else break L1;
   }
   $32 = _luaL_prepbuffsize($b, 512) | 0; //@line 13792
   $arg$0$ph11$looptemp = $arg$0$ph11;
   $arg$0$ph11 = $arg$0$ph11 + 1 | 0; //@line 13793
   if (($arg$0$ph11$looptemp | 0) >= ($0 | 0)) _luaL_argerror($L, $arg$0$ph11, 10504) | 0; //@line 13796
   $35 = HEAP8[$19 >> 0] | 0; //@line 13798
   L22 : do if (!($35 << 24 >> 24)) {
    $169 = 0; //@line 13802
    $p$0$lcssa$i = $19; //@line 13802
   } else {
    $41 = $35; //@line 13804
    $p$09$i = $19; //@line 13804
    while (1) {
     $38 = $p$09$i + 1 | 0; //@line 13809
     if (!(_memchr(10656, $41 << 24 >> 24, 6) | 0)) {
      $169 = $41; //@line 13811
      $p$0$lcssa$i = $p$09$i; //@line 13811
      break L22;
     }
     $41 = HEAP8[$38 >> 0] | 0; //@line 13814
     if (!($41 << 24 >> 24)) {
      $169 = 0; //@line 13817
      $p$0$lcssa$i = $38; //@line 13817
      break;
     } else $p$09$i = $38; //@line 13820
    }
   } while (0);
   $44 = $19; //@line 13826
   if (($p$0$lcssa$i - $44 | 0) >>> 0 > 5) {
    _luaL_error($L, 10664, $vararg_buffer23) | 0; //@line 13830
    $48 = HEAP8[$p$0$lcssa$i >> 0] | 0; //@line 13832
   } else $48 = $169; //@line 13834
   $$p$0$i = (($48 & 255) + -48 | 0) >>> 0 < 10 ? $p$0$lcssa$i + 1 | 0 : $p$0$lcssa$i; //@line 13840
   $p$2$i = ((HEAPU8[$$p$0$i >> 0] | 0) + -48 | 0) >>> 0 < 10 ? $$p$0$i + 1 | 0 : $$p$0$i; //@line 13846
   $53 = HEAP8[$p$2$i >> 0] | 0; //@line 13847
   if ($53 << 24 >> 24 == 46) {
    $55 = $p$2$i + 1 | 0; //@line 13850
    $$$i = ((HEAPU8[$55 >> 0] | 0) + -48 | 0) >>> 0 < 10 ? $p$2$i + 2 | 0 : $55; //@line 13856
    $$$$i = ((HEAPU8[$$$i >> 0] | 0) + -48 | 0) >>> 0 < 10 ? $$$i + 1 | 0 : $$$i; //@line 13862
    $63 = HEAP8[$$$$i >> 0] | 0; //@line 13864
    $p$4$i = $$$$i; //@line 13864
   } else {
    $63 = $53; //@line 13866
    $p$4$i = $p$2$i; //@line 13866
   }
   if ((($63 & 255) + -48 | 0) >>> 0 < 10) _luaL_error($L, 10696, $vararg_buffer23) | 0; //@line 13872
   HEAP8[$form >> 0] = 37; //@line 13874
   $65 = $p$4$i - $44 | 0; //@line 13876
   _memcpy($7 | 0, $19 | 0, $65 + 1 | 0) | 0; //@line 13878
   HEAP8[$form + ($65 + 2) >> 0] = 0; //@line 13881
   $strfrmt$0$ph10 = $p$4$i + 1 | 0; //@line 13882
   $70 = HEAP8[$p$4$i >> 0] | 0; //@line 13884
   L36 : do switch ($70 | 0) {
   case 71:
   case 103:
   case 102:
   case 69:
   case 101:
    {
     HEAP8[$form + (_strlen($form | 0) | 0) >> 0] = 0; //@line 13890
     $103 = +_luaL_checknumber($L, $arg$0$ph11); //@line 13891
     HEAPF64[tempDoublePtr >> 3] = $103; //@line 13892
     HEAP32[$vararg_buffer23 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 13892
     HEAP32[$vararg_buffer23 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 13892
     $nb$0 = _sprintf($32, $form, $vararg_buffer23) | 0; //@line 13894
     break;
    }
   case 105:
   case 100:
    {
     $73 = +_luaL_checknumber($L, $arg$0$ph11); //@line 13898
     $74 = ~~$73; //@line 13899
     $76 = $73 - +($74 | 0); //@line 13901
     if (!($76 > -1.0 & $76 < 1.0)) _luaL_argerror($L, $arg$0$ph11, 10520) | 0; //@line 13906
     $79 = _strlen($form | 0) | 0; //@line 13908
     $81 = $form + ($79 + -1) | 0; //@line 13910
     $82 = HEAP8[$81 >> 0] | 0; //@line 13911
     HEAP8[$81 >> 0] = 108; //@line 13912
     HEAP8[$81 + 1 >> 0] = 0; //@line 13912
     HEAP8[$form + $79 >> 0] = $82; //@line 13915
     HEAP8[$form + ($79 + 1) >> 0] = 0; //@line 13917
     HEAP32[$vararg_buffer23 >> 2] = $74; //@line 13918
     $nb$0 = _sprintf($32, $form, $vararg_buffer23) | 0; //@line 13920
     break;
    }
   case 113:
    {
     $105 = _luaL_checklstring($L, $arg$0$ph11, $l$i) | 0; //@line 13924
     $106 = HEAP32[$5 >> 2] | 0; //@line 13925
     if ($106 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) $110 = $106; //@line 13929
 else {
      _luaL_prepbuffsize($b, 1) | 0; //@line 13931
      $110 = HEAP32[$5 >> 2] | 0; //@line 13933
     }
     HEAP32[$5 >> 2] = $110 + 1; //@line 13936
     HEAP8[(HEAP32[$b >> 2] | 0) + $110 >> 0] = 34; //@line 13939
     $113 = HEAP32[$l$i >> 2] | 0; //@line 13940
     HEAP32[$l$i >> 2] = $113 + -1; //@line 13942
     if ($113) {
      $s$01$i = $105; //@line 13945
      while (1) {
       $116 = HEAP8[$s$01$i >> 0] | 0; //@line 13947
       do if ($116 << 24 >> 24 == 10 | $116 << 24 >> 24 == 92 | $116 << 24 >> 24 == 34) {
        $117 = HEAP32[$5 >> 2] | 0; //@line 13950
        if ($117 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) $121 = $117; //@line 13954
 else {
         _luaL_prepbuffsize($b, 1) | 0; //@line 13956
         $121 = HEAP32[$5 >> 2] | 0; //@line 13958
        }
        HEAP32[$5 >> 2] = $121 + 1; //@line 13961
        HEAP8[(HEAP32[$b >> 2] | 0) + $121 >> 0] = 92; //@line 13964
        $124 = HEAP32[$5 >> 2] | 0; //@line 13965
        if ($124 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) $129 = $124; //@line 13969
 else {
         _luaL_prepbuffsize($b, 1) | 0; //@line 13971
         $129 = HEAP32[$5 >> 2] | 0; //@line 13973
        }
        $127 = HEAP8[$s$01$i >> 0] | 0; //@line 13975
        HEAP32[$5 >> 2] = $129 + 1; //@line 13977
        HEAP8[(HEAP32[$b >> 2] | 0) + $129 >> 0] = $127; //@line 13980
       } else if (!($116 << 24 >> 24)) {
        $139 = 0; //@line 13982
        label = 44; //@line 13983
       } else {
        if (_iscntrl($116 & 255) | 0) {
         $139 = HEAP8[$s$01$i >> 0] | 0; //@line 13990
         label = 44; //@line 13991
         break;
        }
        $140 = HEAP32[$5 >> 2] | 0; //@line 13994
        if ($140 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) $145 = $140; //@line 13998
 else {
         _luaL_prepbuffsize($b, 1) | 0; //@line 14000
         $145 = HEAP32[$5 >> 2] | 0; //@line 14002
        }
        $143 = HEAP8[$s$01$i >> 0] | 0; //@line 14004
        HEAP32[$5 >> 2] = $145 + 1; //@line 14006
        HEAP8[(HEAP32[$b >> 2] | 0) + $145 >> 0] = $143; //@line 14009
       } while (0);
       if ((label | 0) == 44) {
        label = 0; //@line 14013
        $138 = $139 & 255; //@line 14019
        if (((HEAPU8[$s$01$i + 1 >> 0] | 0) + -48 | 0) >>> 0 < 10) {
         HEAP32[$vararg_buffer23 >> 2] = $138; //@line 14021
         _sprintf($buff$i, 10648, $vararg_buffer23) | 0; //@line 14022
        } else {
         HEAP32[$vararg_buffer23 >> 2] = $138; //@line 14024
         _sprintf($buff$i, 10640, $vararg_buffer23) | 0; //@line 14025
        }
        _luaL_addstring($b, $buff$i); //@line 14027
       }
       $149 = HEAP32[$l$i >> 2] | 0; //@line 14030
       HEAP32[$l$i >> 2] = $149 + -1; //@line 14032
       if (!$149) break; else $s$01$i = $s$01$i + 1 | 0; //@line 14037
      }
     }
     $152 = HEAP32[$5 >> 2] | 0; //@line 14041
     if ($152 >>> 0 < (HEAP32[$6 >> 2] | 0) >>> 0) $156 = $152; //@line 14045
 else {
      _luaL_prepbuffsize($b, 1) | 0; //@line 14047
      $156 = HEAP32[$5 >> 2] | 0; //@line 14049
     }
     HEAP32[$5 >> 2] = $156 + 1; //@line 14052
     HEAP8[(HEAP32[$b >> 2] | 0) + $156 >> 0] = 34; //@line 14055
     $nb$0 = 0; //@line 14056
     break;
    }
   case 115:
    {
     $159 = _luaL_tolstring($L, $arg$0$ph11, $l) | 0; //@line 14060
     if (!(_strchr($form, 46) | 0)) if ((HEAP32[$l >> 2] | 0) >>> 0 > 99) {
      _luaL_addvalue($b); //@line 14067
      $nb$0 = 0; //@line 14068
      break L36;
     }
     HEAP32[$vararg_buffer23 >> 2] = $159; //@line 14072
     $164 = _sprintf($32, $form, $vararg_buffer23) | 0; //@line 14073
     _lua_settop($L, -2); //@line 14074
     $nb$0 = $164; //@line 14075
     break;
    }
   case 88:
   case 120:
   case 117:
   case 111:
    {
     $87 = +_luaL_checknumber($L, $arg$0$ph11); //@line 14079
     $88 = ~~$87 >>> 0; //@line 14080
     $90 = $87 - +($88 >>> 0); //@line 14082
     if (!($90 > -1.0 & $90 < 1.0)) _luaL_argerror($L, $arg$0$ph11, 10552) | 0; //@line 14087
     $93 = _strlen($form | 0) | 0; //@line 14089
     $95 = $form + ($93 + -1) | 0; //@line 14091
     $96 = HEAP8[$95 >> 0] | 0; //@line 14092
     HEAP8[$95 >> 0] = 108; //@line 14093
     HEAP8[$95 + 1 >> 0] = 0; //@line 14093
     HEAP8[$form + $93 >> 0] = $96; //@line 14096
     HEAP8[$form + ($93 + 1) >> 0] = 0; //@line 14098
     HEAP32[$vararg_buffer23 >> 2] = $88; //@line 14099
     $nb$0 = _sprintf($32, $form, $vararg_buffer23) | 0; //@line 14101
     break;
    }
   case 99:
    {
     HEAP32[$vararg_buffer23 >> 2] = _luaL_checkinteger($L, $arg$0$ph11) | 0; //@line 14106
     $nb$0 = _sprintf($32, $form, $vararg_buffer23) | 0; //@line 14108
     break;
    }
   default:
    break L3;
   } while (0);
   HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + $nb$0; //@line 14118
   if ($strfrmt$0$ph10 >>> 0 >= $3 >>> 0) break L1;
  }
  HEAP32[$vararg_buffer23 >> 2] = $70; //@line 14126
  $$0 = _luaL_error($L, 10600, $vararg_buffer23) | 0; //@line 14128
  STACKTOP = sp; //@line 14129
  return $$0 | 0; //@line 14129
 } while (0);
 _luaL_pushresult($b); //@line 14132
 $$0 = 1; //@line 14133
 STACKTOP = sp; //@line 14134
 return $$0 | 0; //@line 14134
}
function _lua_getinfo($L, $what, $ar) {
 $L = $L | 0;
 $what = $what | 0;
 $ar = $ar | 0;
 var $$0 = 0, $$03$i = 0, $104 = 0, $106 = 0, $114 = 0, $121 = 0, $122 = 0, $123 = 0, $128 = 0, $129 = 0, $14 = 0, $143 = 0, $144 = 0, $147 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $38 = 0, $4 = 0, $41 = 0, $43 = 0, $46 = 0, $48 = 0, $53 = 0, $60 = 0, $62 = 0, $7 = 0, $73 = 0, $86 = 0, $9 = 0, $90 = 0, $97 = 0, $99 = 0, $ci$0 = 0, $ci$idx1$i$i = 0, $func$0 = 0, $i$01$i = 0, $status$0$lcssa$i = 0, $status$04$i = 0, $status$1$i = 0, $storemerge$i = 0, $storemerge$ph$i = 0, $storemerge5$i = 0, $tm$0$i$i = 0, $v$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 14175
 STACKTOP = STACKTOP + 16 | 0; //@line 14176
 $v$i = sp; //@line 14177
 if ((HEAP8[$what >> 0] | 0) == 62) {
  $2 = $L + 8 | 0; //@line 14181
  $4 = (HEAP32[$2 >> 2] | 0) + -16 | 0; //@line 14183
  HEAP32[$2 >> 2] = $4; //@line 14185
  $$0 = $what + 1 | 0; //@line 14186
  $ci$0 = 0; //@line 14186
  $func$0 = $4; //@line 14186
 } else {
  $7 = HEAP32[$ar + 96 >> 2] | 0; //@line 14189
  $$0 = $what; //@line 14191
  $ci$0 = $7; //@line 14191
  $func$0 = HEAP32[$7 >> 2] | 0; //@line 14191
 }
 $9 = $func$0 + 8 | 0; //@line 14193
 if ((HEAP32[$9 >> 2] & 31 | 0) == 6) $17 = HEAP32[$func$0 >> 2] | 0; //@line 14199
 else $17 = 0; //@line 14201
 $14 = HEAP8[$$0 >> 0] | 0; //@line 14203
 L8 : do if (!($14 << 24 >> 24)) $status$0$lcssa$i = 1; //@line 14207
 else {
  $16 = ($17 | 0) == 0; //@line 14209
  $18 = $ar + 16 | 0; //@line 14210
  $19 = $ar + 24 | 0; //@line 14211
  $20 = $ar + 28 | 0; //@line 14212
  $21 = $ar + 12 | 0; //@line 14213
  $22 = $ar + 36 | 0; //@line 14214
  $23 = $17 + 4 | 0; //@line 14215
  $24 = $17 + 12 | 0; //@line 14216
  $25 = ($ci$0 | 0) == 0; //@line 14217
  $26 = $ar + 20 | 0; //@line 14218
  $27 = $ci$0 + 18 | 0; //@line 14219
  $ci$idx1$i$i = $ci$0 + 28 | 0; //@line 14220
  $28 = $ar + 32 | 0; //@line 14221
  $29 = $ar + 34 | 0; //@line 14222
  $30 = $ar + 33 | 0; //@line 14223
  $31 = $17 + 6 | 0; //@line 14224
  $32 = $ar + 35 | 0; //@line 14225
  $33 = $ar + 8 | 0; //@line 14226
  $34 = $ar + 4 | 0; //@line 14227
  $35 = $ci$0 + 8 | 0; //@line 14228
  $36 = $L + 12 | 0; //@line 14229
  $$03$i = $$0; //@line 14230
  $38 = $14; //@line 14230
  $status$04$i = 1; //@line 14230
  while (1) {
   L12 : do switch ($38 << 24 >> 24 | 0) {
   case 117:
    {
     if ($16) HEAP8[$28 >> 0] = 0; //@line 14237
 else {
      HEAP8[$28 >> 0] = HEAP8[$31 >> 0] | 0; //@line 14240
      if ((HEAP8[$23 >> 0] | 0) != 38) {
       HEAP8[$29 >> 0] = HEAP8[(HEAP32[$24 >> 2] | 0) + 77 >> 0] | 0; //@line 14247
       HEAP8[$30 >> 0] = HEAP8[(HEAP32[$24 >> 2] | 0) + 76 >> 0] | 0; //@line 14251
       $status$1$i = $status$04$i; //@line 14252
       break L12;
      }
     }
     HEAP8[$29 >> 0] = 1; //@line 14256
     HEAP8[$30 >> 0] = 0; //@line 14257
     $status$1$i = $status$04$i; //@line 14258
     break;
    }
   case 116:
    {
     if ($25) $86 = 0; //@line 14263
 else $86 = HEAPU8[$27 >> 0] & 64; //@line 14269
     HEAP8[$32 >> 0] = $86; //@line 14271
     $status$1$i = $status$04$i; //@line 14272
     break;
    }
   case 108:
    {
     if ($25) $73 = -1; //@line 14277
 else if (!(HEAP8[$27 >> 0] & 1)) $73 = -1; //@line 14283
 else {
      $60 = HEAP32[(HEAP32[HEAP32[$ci$0 >> 2] >> 2] | 0) + 12 >> 2] | 0; //@line 14288
      $62 = HEAP32[$60 + 20 >> 2] | 0; //@line 14290
      if (!$62) $73 = 0; //@line 14293
 else $73 = HEAP32[$62 + (((HEAP32[$ci$idx1$i$i >> 2] | 0) - (HEAP32[$60 + 12 >> 2] | 0) >> 2) + -1 << 2) >> 2] | 0; //@line 14305
     }
     HEAP32[$26 >> 2] = $73; //@line 14309
     $status$1$i = $status$04$i; //@line 14310
     break;
    }
   case 83:
    {
     if ($16) label = 11; //@line 14315
 else if ((HEAP8[$23 >> 0] | 0) == 38) label = 11; //@line 14320
 else {
      $41 = HEAP32[$24 >> 2] | 0; //@line 14322
      $43 = HEAP32[$41 + 36 >> 2] | 0; //@line 14324
      if (!$43) $46 = 4208; //@line 14327
 else $46 = $43 + 16 | 0; //@line 14330
      HEAP32[$18 >> 2] = $46; //@line 14332
      $48 = HEAP32[$41 + 64 >> 2] | 0; //@line 14334
      HEAP32[$19 >> 2] = $48; //@line 14335
      HEAP32[$20 >> 2] = HEAP32[$41 + 68 >> 2]; //@line 14338
      $53 = $46; //@line 14341
      $storemerge5$i = ($48 | 0) == 0 ? 4216 : 4224; //@line 14341
     }
     if ((label | 0) == 11) {
      label = 0; //@line 14345
      HEAP32[$18 >> 2] = 4192; //@line 14346
      HEAP32[$19 >> 2] = -1; //@line 14347
      HEAP32[$20 >> 2] = -1; //@line 14348
      $53 = 4192; //@line 14349
      $storemerge5$i = 4200; //@line 14349
     }
     HEAP32[$21 >> 2] = $storemerge5$i; //@line 14351
     _luaO_chunkid($22, $53, 60); //@line 14352
     $status$1$i = $status$04$i; //@line 14353
     break;
    }
   case 110:
    {
     L40 : do if ($25) label = 47; //@line 14359
 else if (!(HEAP8[$27 >> 0] & 64)) {
      $90 = HEAP32[$35 >> 2] | 0; //@line 14365
      if (!(HEAP8[$90 + 18 >> 0] & 1)) label = 47; //@line 14371
 else {
       $97 = HEAP32[(HEAP32[HEAP32[$90 >> 2] >> 2] | 0) + 12 >> 2] | 0; //@line 14378
       $99 = HEAP32[$97 + 12 >> 2] | 0; //@line 14380
       $104 = ((HEAP32[$90 + 28 >> 2] | 0) - $99 >> 2) + -1 | 0; //@line 14385
       $106 = HEAP32[$99 + ($104 << 2) >> 2] | 0; //@line 14387
       do switch ($106 & 63 | 0) {
       case 10:
       case 8:
        {
         $tm$0$i$i = 1; //@line 14392
         label = 46; //@line 14393
         break;
        }
       case 24:
        {
         $tm$0$i$i = 5; //@line 14397
         label = 46; //@line 14398
         break;
        }
       case 13:
        {
         $tm$0$i$i = 6; //@line 14402
         label = 46; //@line 14403
         break;
        }
       case 14:
        {
         $tm$0$i$i = 7; //@line 14407
         label = 46; //@line 14408
         break;
        }
       case 15:
        {
         $tm$0$i$i = 8; //@line 14412
         label = 46; //@line 14413
         break;
        }
       case 16:
        {
         $tm$0$i$i = 9; //@line 14417
         label = 46; //@line 14418
         break;
        }
       case 17:
        {
         $tm$0$i$i = 10; //@line 14422
         label = 46; //@line 14423
         break;
        }
       case 18:
        {
         $tm$0$i$i = 11; //@line 14427
         label = 46; //@line 14428
         break;
        }
       case 19:
        {
         $tm$0$i$i = 12; //@line 14432
         label = 46; //@line 14433
         break;
        }
       case 21:
        {
         $tm$0$i$i = 4; //@line 14437
         label = 46; //@line 14438
         break;
        }
       case 25:
        {
         $tm$0$i$i = 13; //@line 14442
         label = 46; //@line 14443
         break;
        }
       case 26:
        {
         $tm$0$i$i = 14; //@line 14447
         label = 46; //@line 14448
         break;
        }
       case 22:
        {
         $tm$0$i$i = 15; //@line 14452
         label = 46; //@line 14453
         break;
        }
       case 7:
       case 6:
       case 12:
        {
         $tm$0$i$i = 0; //@line 14457
         label = 46; //@line 14458
         break;
        }
       case 34:
        {
         $storemerge$i = 4160; //@line 14462
         $storemerge$ph$i = 4160; //@line 14462
         break;
        }
       case 30:
       case 29:
        {
         $114 = _getobjname($97, $104, $106 >>> 6 & 255, $34) | 0; //@line 14468
         HEAP32[$33 >> 2] = $114; //@line 14469
         if (!$114) break L40; else {
          $status$1$i = $status$04$i; //@line 14474
          break L12;
         }
         break;
        }
       default:
        {
         label = 47; //@line 14480
         break L40;
        }
       } while (0);
       if ((label | 0) == 46) {
        label = 0; //@line 14486
        $storemerge$i = (HEAP32[(HEAP32[$36 >> 2] | 0) + ($tm$0$i$i << 2) + 184 >> 2] | 0) + 16 | 0; //@line 14491
        $storemerge$ph$i = 4176; //@line 14491
       }
       HEAP32[$34 >> 2] = $storemerge$i; //@line 14493
       HEAP32[$33 >> 2] = $storemerge$ph$i; //@line 14494
       $status$1$i = $status$04$i; //@line 14495
       break L12;
      }
     } else label = 47; //@line 14499
 while (0);
     if ((label | 0) == 47) {
      label = 0; //@line 14504
      HEAP32[$33 >> 2] = 0; //@line 14505
     }
     HEAP32[$33 >> 2] = 4152; //@line 14507
     HEAP32[$34 >> 2] = 0; //@line 14508
     $status$1$i = $status$04$i; //@line 14509
     break;
    }
   case 102:
   case 76:
    {
     $status$1$i = $status$04$i; //@line 14513
     break;
    }
   default:
    $status$1$i = 0; //@line 14517
   } while (0);
   $$03$i = $$03$i + 1 | 0; //@line 14521
   $38 = HEAP8[$$03$i >> 0] | 0; //@line 14522
   if (!($38 << 24 >> 24)) {
    $status$0$lcssa$i = $status$1$i; //@line 14525
    break L8;
   } else $status$04$i = $status$1$i; //@line 14528
  }
 } while (0);
 if (_strchr($$0, 102) | 0) {
  $121 = $L + 8 | 0; //@line 14536
  $122 = HEAP32[$121 >> 2] | 0; //@line 14537
  $123 = $func$0; //@line 14538
  $128 = HEAP32[$123 + 4 >> 2] | 0; //@line 14543
  $129 = $122; //@line 14544
  HEAP32[$129 >> 2] = HEAP32[$123 >> 2]; //@line 14546
  HEAP32[$129 + 4 >> 2] = $128; //@line 14549
  HEAP32[$122 + 8 >> 2] = HEAP32[$9 >> 2]; //@line 14552
  HEAP32[$121 >> 2] = (HEAP32[$121 >> 2] | 0) + 16; //@line 14555
 }
 if (!(_strchr($$0, 76) | 0)) {
  STACKTOP = sp; //@line 14560
  return $status$0$lcssa$i | 0; //@line 14560
 }
 if ($17) if ((HEAP8[$17 + 4 >> 0] | 0) != 38) {
  $147 = $17 + 12 | 0; //@line 14568
  $150 = HEAP32[(HEAP32[$147 >> 2] | 0) + 20 >> 2] | 0; //@line 14571
  $151 = _luaH_new($L) | 0; //@line 14572
  $152 = $L + 8 | 0; //@line 14573
  $153 = HEAP32[$152 >> 2] | 0; //@line 14574
  HEAP32[$153 >> 2] = $151; //@line 14575
  HEAP32[$153 + 8 >> 2] = 69; //@line 14577
  HEAP32[$152 >> 2] = (HEAP32[$152 >> 2] | 0) + 16; //@line 14580
  HEAP32[$v$i >> 2] = 1; //@line 14581
  HEAP32[$v$i + 8 >> 2] = 1; //@line 14583
  if ((HEAP32[(HEAP32[$147 >> 2] | 0) + 52 >> 2] | 0) > 0) $i$01$i = 0; //@line 14589
 else {
   STACKTOP = sp; //@line 14591
   return $status$0$lcssa$i | 0; //@line 14591
  }
  do {
   _luaH_setint($L, $151, HEAP32[$150 + ($i$01$i << 2) >> 2] | 0, $v$i); //@line 14596
   $i$01$i = $i$01$i + 1 | 0; //@line 14597
  } while (($i$01$i | 0) < (HEAP32[(HEAP32[$147 >> 2] | 0) + 52 >> 2] | 0));
  STACKTOP = sp; //@line 14608
  return $status$0$lcssa$i | 0; //@line 14608
 }
 $143 = $L + 8 | 0; //@line 14611
 $144 = HEAP32[$143 >> 2] | 0; //@line 14612
 HEAP32[$144 + 8 >> 2] = 0; //@line 14614
 HEAP32[$143 >> 2] = $144 + 16; //@line 14616
 STACKTOP = sp; //@line 14617
 return $status$0$lcssa$i | 0; //@line 14617
}
function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 $rem = $rem | 0;
 var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $_0$0 = 0, $_0$1 = 0, $q_sroa_1_1198$looptemp = 0;
 $n_sroa_0_0_extract_trunc = $a$0; //@line 17206
 $n_sroa_1_4_extract_shift$0 = $a$1; //@line 17207
 $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0; //@line 17208
 $d_sroa_0_0_extract_trunc = $b$0; //@line 17209
 $d_sroa_1_4_extract_shift$0 = $b$1; //@line 17210
 $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0; //@line 17211
 if (!$n_sroa_1_4_extract_trunc) {
  $4 = ($rem | 0) != 0; //@line 17213
  if (!$d_sroa_1_4_extract_trunc) {
   if ($4) {
    HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0); //@line 17216
    HEAP32[$rem + 4 >> 2] = 0; //@line 17217
   }
   $_0$1 = 0; //@line 17219
   $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0; //@line 17220
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17221
  } else {
   if (!$4) {
    $_0$1 = 0; //@line 17224
    $_0$0 = 0; //@line 17225
    return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17226
   }
   HEAP32[$rem >> 2] = $a$0 | 0; //@line 17228
   HEAP32[$rem + 4 >> 2] = $a$1 & 0; //@line 17229
   $_0$1 = 0; //@line 17230
   $_0$0 = 0; //@line 17231
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17232
  }
 }
 $17 = ($d_sroa_1_4_extract_trunc | 0) == 0; //@line 17235
 do if (!$d_sroa_0_0_extract_trunc) {
  if ($17) {
   if ($rem) {
    HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0); //@line 17240
    HEAP32[$rem + 4 >> 2] = 0; //@line 17241
   }
   $_0$1 = 0; //@line 17243
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0; //@line 17244
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17245
  }
  if (!$n_sroa_0_0_extract_trunc) {
   if ($rem) {
    HEAP32[$rem >> 2] = 0; //@line 17249
    HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0); //@line 17250
   }
   $_0$1 = 0; //@line 17252
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0; //@line 17253
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17254
  }
  $37 = $d_sroa_1_4_extract_trunc - 1 | 0; //@line 17256
  if (!($37 & $d_sroa_1_4_extract_trunc)) {
   if ($rem) {
    HEAP32[$rem >> 2] = $a$0 | 0; //@line 17259
    HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0; //@line 17260
   }
   $_0$1 = 0; //@line 17262
   $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0); //@line 17263
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17264
  }
  $51 = (_llvm_ctlz_i32($d_sroa_1_4_extract_trunc | 0) | 0) - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0; //@line 17267
  if ($51 >>> 0 <= 30) {
   $57 = $51 + 1 | 0; //@line 17269
   $58 = 31 - $51 | 0; //@line 17270
   $sr_1_ph = $57; //@line 17271
   $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0); //@line 17272
   $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0); //@line 17273
   $q_sroa_0_1_ph = 0; //@line 17274
   $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58; //@line 17275
   break;
  }
  if (!$rem) {
   $_0$1 = 0; //@line 17279
   $_0$0 = 0; //@line 17280
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17281
  }
  HEAP32[$rem >> 2] = $a$0 | 0; //@line 17283
  HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0; //@line 17284
  $_0$1 = 0; //@line 17285
  $_0$0 = 0; //@line 17286
  return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17287
 } else {
  if (!$17) {
   $119 = (_llvm_ctlz_i32($d_sroa_1_4_extract_trunc | 0) | 0) - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0; //@line 17291
   if ($119 >>> 0 <= 31) {
    $125 = $119 + 1 | 0; //@line 17293
    $126 = 31 - $119 | 0; //@line 17294
    $130 = $119 - 31 >> 31; //@line 17295
    $sr_1_ph = $125; //@line 17296
    $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126; //@line 17297
    $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130; //@line 17298
    $q_sroa_0_1_ph = 0; //@line 17299
    $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126; //@line 17300
    break;
   }
   if (!$rem) {
    $_0$1 = 0; //@line 17304
    $_0$0 = 0; //@line 17305
    return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17306
   }
   HEAP32[$rem >> 2] = $a$0 | 0; //@line 17308
   HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0; //@line 17309
   $_0$1 = 0; //@line 17310
   $_0$0 = 0; //@line 17311
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17312
  }
  $66 = $d_sroa_0_0_extract_trunc - 1 | 0; //@line 17314
  if ($66 & $d_sroa_0_0_extract_trunc) {
   $88 = (_llvm_ctlz_i32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0; //@line 17317
   $89 = 64 - $88 | 0; //@line 17318
   $91 = 32 - $88 | 0; //@line 17319
   $92 = $91 >> 31; //@line 17320
   $95 = $88 - 32 | 0; //@line 17321
   $105 = $95 >> 31; //@line 17322
   $sr_1_ph = $88; //@line 17323
   $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105; //@line 17324
   $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0); //@line 17325
   $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92; //@line 17326
   $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31; //@line 17327
   break;
  }
  if ($rem) {
   HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc; //@line 17331
   HEAP32[$rem + 4 >> 2] = 0; //@line 17332
  }
  if (($d_sroa_0_0_extract_trunc | 0) == 1) {
   $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0; //@line 17335
   $_0$0 = $a$0 | 0 | 0; //@line 17336
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17337
  } else {
   $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0; //@line 17339
   $_0$1 = $n_sroa_1_4_extract_trunc >>> ($78 >>> 0) | 0; //@line 17340
   $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0; //@line 17341
   return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17342
  }
 } while (0);
 if (!$sr_1_ph) {
  $q_sroa_1_1_lcssa = $q_sroa_1_1_ph; //@line 17347
  $q_sroa_0_1_lcssa = $q_sroa_0_1_ph; //@line 17348
  $r_sroa_1_1_lcssa = $r_sroa_1_1_ph; //@line 17349
  $r_sroa_0_1_lcssa = $r_sroa_0_1_ph; //@line 17350
  $carry_0_lcssa$1 = 0; //@line 17351
  $carry_0_lcssa$0 = 0; //@line 17352
 } else {
  $d_sroa_0_0_insert_insert99$0 = $b$0 | 0 | 0; //@line 17354
  $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0; //@line 17355
  $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0, $d_sroa_0_0_insert_insert99$1, -1, -1) | 0; //@line 17356
  $137$1 = tempRet0; //@line 17357
  $q_sroa_1_1198 = $q_sroa_1_1_ph; //@line 17358
  $q_sroa_0_1199 = $q_sroa_0_1_ph; //@line 17359
  $r_sroa_1_1200 = $r_sroa_1_1_ph; //@line 17360
  $r_sroa_0_1201 = $r_sroa_0_1_ph; //@line 17361
  $sr_1202 = $sr_1_ph; //@line 17362
  $carry_0203 = 0; //@line 17363
  do {
   $q_sroa_1_1198$looptemp = $q_sroa_1_1198;
   $q_sroa_1_1198 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1; //@line 17365
   $q_sroa_0_1199 = $carry_0203 | $q_sroa_0_1199 << 1; //@line 17366
   $r_sroa_0_0_insert_insert42$0 = $r_sroa_0_1201 << 1 | $q_sroa_1_1198$looptemp >>> 31 | 0; //@line 17367
   $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0; //@line 17368
   _i64Subtract($137$0, $137$1, $r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1) | 0; //@line 17369
   $150$1 = tempRet0; //@line 17370
   $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1; //@line 17371
   $carry_0203 = $151$0 & 1; //@line 17372
   $r_sroa_0_1201 = _i64Subtract($r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1, $151$0 & $d_sroa_0_0_insert_insert99$0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1) | 0; //@line 17374
   $r_sroa_1_1200 = tempRet0; //@line 17375
   $sr_1202 = $sr_1202 - 1 | 0; //@line 17376
  } while (($sr_1202 | 0) != 0);
  $q_sroa_1_1_lcssa = $q_sroa_1_1198; //@line 17388
  $q_sroa_0_1_lcssa = $q_sroa_0_1199; //@line 17389
  $r_sroa_1_1_lcssa = $r_sroa_1_1200; //@line 17390
  $r_sroa_0_1_lcssa = $r_sroa_0_1201; //@line 17391
  $carry_0_lcssa$1 = 0; //@line 17392
  $carry_0_lcssa$0 = $carry_0203; //@line 17393
 }
 $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa; //@line 17395
 $q_sroa_0_0_insert_ext75$1 = 0; //@line 17396
 if ($rem) {
  HEAP32[$rem >> 2] = $r_sroa_0_1_lcssa; //@line 17399
  HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa; //@line 17400
 }
 $_0$1 = ($q_sroa_0_0_insert_ext75$0 | 0) >>> 31 | ($q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1) << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1; //@line 17402
 $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0; //@line 17403
 return (tempRet0 = $_0$1, $_0$0) | 0; //@line 17404
}
function _luaH_newkey($L, $t, $key) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $$0$i$i = 0, $$0$i$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $104 = 0, $108 = 0, $11 = 0, $113 = 0, $114 = 0, $13 = 0, $14 = 0, $19 = 0, $2 = 0.0, $20 = 0, $24 = 0, $32 = 0, $35 = 0, $4 = 0, $45 = 0, $5 = 0, $53 = 0.0, $55 = 0, $60 = 0, $65 = 0, $68 = 0.0, $70 = 0, $75 = 0, $78 = 0, $81 = 0, $83 = 0, $84 = 0, $85 = 0, $9 = 0, $94 = 0, $98 = 0, $a$03$i$i = 0, $a$1$i$i = 0, $ause$0$lcssa$i$i = 0, $ause$0$ph$i$i = 0, $ause$06$i$i = 0, $i$0$i$i = 0, $i$0$ph$i$i = 0, $i$01$i$i = 0, $i$07$i$i = 0, $i$1$lcssa$i$i = 0, $i$11$i$i = 0, $lc$0$lcssa$i$i = 0, $lc$02$i$i = 0, $lg$04$i$i = 0, $lim$0$ph$i$i = 0, $mp$0 = 0, $n$05$i$i = 0, $n$1$i$i = 0, $n$2$i$i = 0, $na$04$i$i = 0, $na$1$i$i = 0, $na$2$i$i = 0, $nums$i = 0, $othern$0 = 0, $totaluse$0$ph$i$i = 0, $ttlg$05$i$i = 0, $twotoi$02$i$i = 0, $u$sroa$0$i$i$i$i = 0, $vararg_buffer1 = 0, dest = 0, label = 0, sp = 0, stop = 0, $i$0$i$i$looptemp = 0;
 sp = STACKTOP; //@line 16933
 STACKTOP = STACKTOP + 144 | 0; //@line 16934
 $vararg_buffer1 = sp + 8 | 0; //@line 16935
 $u$sroa$0$i$i$i$i = sp; //@line 16936
 $nums$i = sp + 16 | 0; //@line 16937
 $0 = $key + 8 | 0; //@line 16938
 $1 = HEAP32[$0 >> 2] | 0; //@line 16939
 if (!$1) _luaG_runerror($L, 10824, $vararg_buffer1); //@line 16941
 else if (($1 | 0) == 3) label = 3; //@line 16944
 if ((label | 0) == 3) {
  $2 = +HEAPF64[$key >> 3]; //@line 16947
  if (!($2 == $2 & 0.0 == 0.0)) _luaG_runerror($L, 10848, $vararg_buffer1); //@line 16950
 }
 $4 = _mainposition($t, $key) | 0; //@line 16954
 $5 = $4 + 8 | 0; //@line 16955
 do if ((HEAP32[$5 >> 2] | 0) != 0 | ($4 | 0) == 10872) {
  $9 = $t + 20 | 0; //@line 16962
  $10 = $t + 16 | 0; //@line 16963
  $11 = HEAP32[$10 >> 2] | 0; //@line 16964
  $13 = HEAP32[$9 >> 2] | 0; //@line 16966
  while (1) {
   if ($13 >>> 0 <= $11 >>> 0) break;
   $14 = $13 + -32 | 0; //@line 16972
   HEAP32[$9 >> 2] = $14; //@line 16973
   if (!(HEAP32[$13 + -8 >> 2] | 0)) {
    label = 37; //@line 16978
    break;
   } else $13 = $14; //@line 16981
  }
  if ((label | 0) == 37) {
   $98 = _mainposition($t, $4 + 16 | 0) | 0; //@line 16986
   if (($98 | 0) == ($4 | 0)) {
    $104 = $4 + 28 | 0; //@line 16989
    HEAP32[$13 + -4 >> 2] = HEAP32[$104 >> 2]; //@line 16992
    HEAP32[$104 >> 2] = $14; //@line 16993
    $mp$0 = $14; //@line 16994
    break;
   } else $othern$0 = $98; //@line 16997
   do {
    $100 = $othern$0 + 28 | 0; //@line 17000
    $othern$0 = HEAP32[$100 >> 2] | 0; //@line 17001
   } while (($othern$0 | 0) != ($4 | 0));
   HEAP32[$100 >> 2] = $14; //@line 17009
   HEAP32[$14 + 0 >> 2] = HEAP32[$4 + 0 >> 2]; //@line 17010
   HEAP32[$14 + 4 >> 2] = HEAP32[$4 + 4 >> 2]; //@line 17010
   HEAP32[$14 + 8 >> 2] = HEAP32[$4 + 8 >> 2]; //@line 17010
   HEAP32[$14 + 12 >> 2] = HEAP32[$4 + 12 >> 2]; //@line 17010
   HEAP32[$14 + 16 >> 2] = HEAP32[$4 + 16 >> 2]; //@line 17010
   HEAP32[$14 + 20 >> 2] = HEAP32[$4 + 20 >> 2]; //@line 17010
   HEAP32[$14 + 24 >> 2] = HEAP32[$4 + 24 >> 2]; //@line 17010
   HEAP32[$14 + 28 >> 2] = HEAP32[$4 + 28 >> 2]; //@line 17010
   HEAP32[$4 + 28 >> 2] = 0; //@line 17012
   HEAP32[$5 >> 2] = 0; //@line 17013
   $mp$0 = $4; //@line 17014
   break;
  }
  dest = $nums$i + 0 | 0; //@line 17017
  stop = dest + 124 | 0; //@line 17017
  do {
   HEAP32[dest >> 2] = 0; //@line 17017
   dest = dest + 4 | 0; //@line 17017
  } while ((dest | 0) < (stop | 0));
  $19 = $t + 12 | 0; //@line 17019
  $20 = HEAP32[$t + 28 >> 2] | 0; //@line 17020
  $ause$06$i$i = 0; //@line 17021
  $i$07$i$i = 1; //@line 17021
  $lg$04$i$i = 0; //@line 17021
  $ttlg$05$i$i = 1; //@line 17021
  while (1) {
   if (($ttlg$05$i$i | 0) > ($20 | 0)) if (($i$07$i$i | 0) > ($20 | 0)) {
    $ause$0$lcssa$i$i = $ause$06$i$i; //@line 17027
    break;
   } else $lim$0$ph$i$i = $20; //@line 17030
 else $lim$0$ph$i$i = $ttlg$05$i$i; //@line 17033
   if (($i$07$i$i | 0) > ($lim$0$ph$i$i | 0)) {
    $i$1$lcssa$i$i = $i$07$i$i; //@line 17037
    $lc$0$lcssa$i$i = 0; //@line 17037
   } else {
    $24 = HEAP32[$19 >> 2] | 0; //@line 17039
    $i$11$i$i = $i$07$i$i; //@line 17040
    $lc$02$i$i = 0; //@line 17040
    while (1) {
     $lc$02$i$i = ((HEAP32[$24 + ($i$11$i$i + -1 << 4) + 8 >> 2] | 0) != 0 & 1) + $lc$02$i$i | 0; //@line 17047
     if (($i$11$i$i | 0) >= ($lim$0$ph$i$i | 0)) break; else $i$11$i$i = $i$11$i$i + 1 | 0; //@line 17051
    }
    $i$1$lcssa$i$i = $lim$0$ph$i$i + 1 | 0; //@line 17057
    $lc$0$lcssa$i$i = $lc$02$i$i; //@line 17057
   }
   $32 = $nums$i + ($lg$04$i$i << 2) | 0; //@line 17059
   HEAP32[$32 >> 2] = (HEAP32[$32 >> 2] | 0) + $lc$0$lcssa$i$i; //@line 17062
   $35 = $lc$0$lcssa$i$i + $ause$06$i$i | 0; //@line 17063
   $lg$04$i$i = $lg$04$i$i + 1 | 0; //@line 17064
   if (($lg$04$i$i | 0) >= 31) {
    $ause$0$lcssa$i$i = $35; //@line 17070
    break;
   } else {
    $ause$06$i$i = $35; //@line 17068
    $i$07$i$i = $i$1$lcssa$i$i; //@line 17068
    $ttlg$05$i$i = $ttlg$05$i$i << 1; //@line 17068
   }
  }
  $ause$0$ph$i$i = 0; //@line 17078
  $i$0$ph$i$i = 1 << (HEAPU8[$t + 7 >> 0] | 0); //@line 17078
  $totaluse$0$ph$i$i = 0; //@line 17078
  L32 : while (1) {
   $i$0$i$i = $i$0$ph$i$i; //@line 17080
   do {
    $i$0$i$i$looptemp = $i$0$i$i;
    $i$0$i$i = $i$0$i$i + -1 | 0; //@line 17082
    if (!$i$0$i$i$looptemp) break L32;
    $45 = HEAP32[$10 >> 2] | 0; //@line 17087
   } while ((HEAP32[$45 + ($i$0$i$i << 5) + 8 >> 2] | 0) == 0);
   if ((HEAP32[$45 + ($i$0$i$i << 5) + 24 >> 2] | 0) == 3) {
    $53 = +HEAPF64[$45 + ($i$0$i$i << 5) + 16 >> 3]; //@line 17102
    HEAPF64[$u$sroa$0$i$i$i$i >> 3] = $53 + 6755399441055744.0; //@line 17104
    $55 = HEAP32[$u$sroa$0$i$i$i$i >> 2] | 0; //@line 17105
    if (+($55 | 0) == $53) if (($55 + -1 | 0) >>> 0 < 1073741824) {
     $60 = $nums$i + ((_luaO_ceillog2($55) | 0) << 2) | 0; //@line 17113
     HEAP32[$60 >> 2] = (HEAP32[$60 >> 2] | 0) + 1; //@line 17116
     $$0$i$i$i = 1; //@line 17117
    } else $$0$i$i$i = 0; //@line 17119
 else $$0$i$i$i = 0; //@line 17122
   } else $$0$i$i$i = 0; //@line 17125
   $ause$0$ph$i$i = $$0$i$i$i + $ause$0$ph$i$i | 0; //@line 17129
   $i$0$ph$i$i = $i$0$i$i; //@line 17129
   $totaluse$0$ph$i$i = $totaluse$0$ph$i$i + 1 | 0; //@line 17129
  }
  $65 = $ause$0$ph$i$i + $ause$0$lcssa$i$i | 0; //@line 17131
  if ((HEAP32[$0 >> 2] | 0) == 3) {
   $68 = +HEAPF64[$key >> 3]; //@line 17135
   HEAPF64[$vararg_buffer1 >> 3] = $68 + 6755399441055744.0; //@line 17137
   $70 = HEAP32[$vararg_buffer1 >> 2] | 0; //@line 17138
   if (+($70 | 0) == $68) if (($70 + -1 | 0) >>> 0 < 1073741824) {
    $75 = $nums$i + ((_luaO_ceillog2($70) | 0) << 2) | 0; //@line 17146
    HEAP32[$75 >> 2] = (HEAP32[$75 >> 2] | 0) + 1; //@line 17149
    $$0$i$i = 1; //@line 17150
   } else $$0$i$i = 0; //@line 17152
 else $$0$i$i = 0; //@line 17155
  } else $$0$i$i = 0; //@line 17158
  $78 = $65 + $$0$i$i | 0; //@line 17160
  L49 : do if (($78 | 0) > 0) {
   $85 = 0; //@line 17164
   $a$03$i$i = 0; //@line 17164
   $i$01$i$i = 0; //@line 17164
   $n$05$i$i = 0; //@line 17164
   $na$04$i$i = 0; //@line 17164
   $twotoi$02$i$i = 1; //@line 17164
   while (1) {
    $81 = HEAP32[$nums$i + ($i$01$i$i << 2) >> 2] | 0; //@line 17167
    if (($81 | 0) > 0) {
     $83 = $81 + $a$03$i$i | 0; //@line 17170
     $84 = ($83 | 0) > ($85 | 0); //@line 17171
     $a$1$i$i = $83; //@line 17174
     $n$1$i$i = $84 ? $twotoi$02$i$i : $n$05$i$i; //@line 17174
     $na$1$i$i = $84 ? $83 : $na$04$i$i; //@line 17174
    } else {
     $a$1$i$i = $a$03$i$i; //@line 17176
     $n$1$i$i = $n$05$i$i; //@line 17176
     $na$1$i$i = $na$04$i$i; //@line 17176
    }
    if (($a$1$i$i | 0) == ($78 | 0)) {
     $n$2$i$i = $n$1$i$i; //@line 17180
     $na$2$i$i = $na$1$i$i; //@line 17180
     break L49;
    }
    $twotoi$02$i$i = $twotoi$02$i$i << 1; //@line 17184
    $85 = ($twotoi$02$i$i | 0) / 2 | 0; //@line 17185
    if (($85 | 0) >= ($78 | 0)) {
     $n$2$i$i = $n$1$i$i; //@line 17190
     $na$2$i$i = $na$1$i$i; //@line 17190
     break;
    } else {
     $a$03$i$i = $a$1$i$i; //@line 17188
     $i$01$i$i = $i$01$i$i + 1 | 0; //@line 17188
     $n$05$i$i = $n$1$i$i; //@line 17188
     $na$04$i$i = $na$1$i$i; //@line 17188
    }
   }
  } else {
   $n$2$i$i = 0; //@line 17195
   $na$2$i$i = 0; //@line 17195
  } while (0);
  _luaH_resize($L, $t, $n$2$i$i, $ause$0$lcssa$i$i + 1 + $totaluse$0$ph$i$i - $na$2$i$i | 0); //@line 17201
  $94 = _luaH_get($t, $key) | 0; //@line 17202
  if (($94 | 0) != 8048) {
   $$0 = $94; //@line 17205
   STACKTOP = sp; //@line 17206
   return $$0 | 0; //@line 17206
  }
  $$0 = _luaH_newkey($L, $t, $key) | 0; //@line 17209
  STACKTOP = sp; //@line 17210
  return $$0 | 0; //@line 17210
 } else $mp$0 = $4; //@line 17212
 while (0);
 $108 = $key; //@line 17216
 $113 = HEAP32[$108 + 4 >> 2] | 0; //@line 17221
 $114 = $mp$0 + 16 | 0; //@line 17222
 HEAP32[$114 >> 2] = HEAP32[$108 >> 2]; //@line 17224
 HEAP32[$114 + 4 >> 2] = $113; //@line 17227
 HEAP32[$mp$0 + 24 >> 2] = HEAP32[$0 >> 2]; //@line 17230
 if (HEAP32[$0 >> 2] & 64) if (HEAP8[(HEAP32[$key >> 2] | 0) + 5 >> 0] & 3) if (HEAP8[$t + 5 >> 0] & 4) _luaC_barrierback_($L, $t); //@line 17246
 $$0 = $mp$0; //@line 17250
 STACKTOP = sp; //@line 17251
 return $$0 | 0; //@line 17251
}
function _read_long_string($ls, $seminfo, $sep) {
 $ls = $ls | 0;
 $seminfo = $seminfo | 0;
 $sep = $sep | 0;
 var $$ph = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $103 = 0, $104 = 0, $107 = 0, $109 = 0, $111 = 0, $113 = 0, $115 = 0, $117 = 0, $118 = 0, $119 = 0, $122 = 0, $123 = 0, $128 = 0, $129 = 0, $13 = 0, $131 = 0, $137 = 0, $138 = 0, $139 = 0, $140 = 0, $15 = 0, $153 = 0, $154 = 0, $166 = 0, $18 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $39 = 0, $4 = 0, $40 = 0, $45 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $55 = 0, $56 = 0, $59 = 0, $6 = 0, $61 = 0, $63 = 0, $66 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $73 = 0, $74 = 0, $79 = 0, $80 = 0, $81 = 0, $82 = 0, $84 = 0, $85 = 0, $88 = 0, $90 = 0, $92 = 0, $94 = 0, $96 = 0, $99 = 0, $ts$0$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5388
 $0 = HEAP32[$ls >> 2] | 0; //@line 5389
 $1 = $ls + 60 | 0; //@line 5390
 $2 = HEAP32[$1 >> 2] | 0; //@line 5391
 $3 = $2 + 4 | 0; //@line 5392
 $4 = HEAP32[$3 >> 2] | 0; //@line 5393
 $6 = $2 + 8 | 0; //@line 5395
 $7 = HEAP32[$6 >> 2] | 0; //@line 5396
 do if (($4 + 1 | 0) >>> 0 > $7 >>> 0) {
  if ($7 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 5402
  $10 = $7 << 1; //@line 5405
  $13 = HEAP32[$ls + 52 >> 2] | 0; //@line 5408
  if (($10 | 0) == -2) _luaM_toobig($13); //@line 5410
 else {
   $15 = _luaM_realloc_($13, HEAP32[$2 >> 2] | 0, $7, $10) | 0; //@line 5414
   HEAP32[$2 >> 2] = $15; //@line 5415
   HEAP32[$6 >> 2] = $10; //@line 5416
   $18 = HEAP32[$3 >> 2] | 0; //@line 5418
   $20 = $15; //@line 5418
   break;
  }
 } else {
  $18 = $4; //@line 5423
  $20 = HEAP32[$2 >> 2] | 0; //@line 5423
 } while (0);
 HEAP32[$3 >> 2] = $18 + 1; //@line 5428
 HEAP8[$20 + $18 >> 0] = $0; //@line 5430
 $21 = $ls + 56 | 0; //@line 5431
 $22 = HEAP32[$21 >> 2] | 0; //@line 5432
 $23 = HEAP32[$22 >> 2] | 0; //@line 5433
 HEAP32[$22 >> 2] = $23 + -1; //@line 5435
 if (!$23) $32 = _luaZ_fill($22) | 0; //@line 5439
 else {
  $26 = $22 + 4 | 0; //@line 5441
  $27 = HEAP32[$26 >> 2] | 0; //@line 5442
  HEAP32[$26 >> 2] = $27 + 1; //@line 5444
  $32 = HEAPU8[$27 >> 0] | 0; //@line 5447
 }
 HEAP32[$ls >> 2] = $32; //@line 5449
 if (($32 | 0) == 13 | ($32 | 0) == 10) {
  _inclinenumber($ls); //@line 5451
  label = 13; //@line 5452
 } else $$ph = $32; //@line 5454
 L17 : while (1) {
  if ((label | 0) == 13) {
   label = 0; //@line 5458
   $$ph = HEAP32[$ls >> 2] | 0; //@line 5460
  }
  $33 = ($seminfo | 0) == 0; //@line 5462
  $34 = $ls + 52 | 0; //@line 5463
  L21 : do if ($33) {
   $166 = $$ph; //@line 5466
   while (1) {
    if (($166 | 0) == 93) {
     label = 22; //@line 5469
     break L21;
    } else if (($166 | 0) == -1) {
     label = 21; //@line 5472
     break L17;
    } else if (($166 | 0) == 13 | ($166 | 0) == 10) break L21;
    $35 = HEAP32[$21 >> 2] | 0; //@line 5477
    $36 = HEAP32[$35 >> 2] | 0; //@line 5478
    HEAP32[$35 >> 2] = $36 + -1; //@line 5480
    if (!$36) $45 = _luaZ_fill($35) | 0; //@line 5484
 else {
     $39 = $35 + 4 | 0; //@line 5486
     $40 = HEAP32[$39 >> 2] | 0; //@line 5487
     HEAP32[$39 >> 2] = $40 + 1; //@line 5489
     $45 = HEAPU8[$40 >> 0] | 0; //@line 5492
    }
    HEAP32[$ls >> 2] = $45; //@line 5494
    $166 = $45; //@line 5495
   }
  } else {
   $113 = $$ph; //@line 5498
   while (1) {
    if (($113 | 0) == 93) {
     label = 22; //@line 5501
     break L21;
    } else if (($113 | 0) == -1) {
     label = 21; //@line 5504
     break L17;
    } else if (($113 | 0) == 13 | ($113 | 0) == 10) break L21;
    $99 = HEAP32[$1 >> 2] | 0; //@line 5509
    $100 = $99 + 4 | 0; //@line 5510
    $101 = HEAP32[$100 >> 2] | 0; //@line 5511
    $103 = $99 + 8 | 0; //@line 5513
    $104 = HEAP32[$103 >> 2] | 0; //@line 5514
    if (($101 + 1 | 0) >>> 0 > $104 >>> 0) {
     if ($104 >>> 0 > 2147483645) {
      label = 46; //@line 5519
      break L17;
     }
     $107 = $104 << 1; //@line 5522
     $109 = HEAP32[$34 >> 2] | 0; //@line 5524
     if (($107 | 0) == -2) {
      label = 48; //@line 5526
      break L17;
     }
     $111 = _luaM_realloc_($109, HEAP32[$99 >> 2] | 0, $104, $107) | 0; //@line 5530
     HEAP32[$99 >> 2] = $111; //@line 5531
     HEAP32[$103 >> 2] = $107; //@line 5532
     $115 = HEAP32[$100 >> 2] | 0; //@line 5534
     $117 = $111; //@line 5534
    } else {
     $115 = $101; //@line 5537
     $117 = HEAP32[$99 >> 2] | 0; //@line 5537
    }
    HEAP32[$100 >> 2] = $115 + 1; //@line 5541
    HEAP8[$117 + $115 >> 0] = $113; //@line 5543
    $118 = HEAP32[$21 >> 2] | 0; //@line 5544
    $119 = HEAP32[$118 >> 2] | 0; //@line 5545
    HEAP32[$118 >> 2] = $119 + -1; //@line 5547
    if (!$119) $128 = _luaZ_fill($118) | 0; //@line 5551
 else {
     $122 = $118 + 4 | 0; //@line 5553
     $123 = HEAP32[$122 >> 2] | 0; //@line 5554
     HEAP32[$122 >> 2] = $123 + 1; //@line 5556
     $128 = HEAPU8[$123 >> 0] | 0; //@line 5559
    }
    HEAP32[$ls >> 2] = $128; //@line 5561
    $113 = $128; //@line 5562
   }
  } while (0);
  if ((label | 0) == 22) {
   label = 0; //@line 5567
   if ((_skip_sep($ls) | 0) == ($sep | 0)) {
    label = 23; //@line 5571
    break;
   } else {
    label = 13; //@line 5574
    continue;
   }
  }
  $80 = HEAP32[$1 >> 2] | 0; //@line 5578
  $81 = $80 + 4 | 0; //@line 5579
  $82 = HEAP32[$81 >> 2] | 0; //@line 5580
  $84 = $80 + 8 | 0; //@line 5582
  $85 = HEAP32[$84 >> 2] | 0; //@line 5583
  if (($82 + 1 | 0) >>> 0 > $85 >>> 0) {
   if ($85 >>> 0 > 2147483645) {
    label = 37; //@line 5588
    break;
   }
   $88 = $85 << 1; //@line 5591
   $90 = HEAP32[$34 >> 2] | 0; //@line 5593
   if (($88 | 0) == -2) {
    label = 39; //@line 5595
    break;
   }
   $92 = _luaM_realloc_($90, HEAP32[$80 >> 2] | 0, $85, $88) | 0; //@line 5599
   HEAP32[$80 >> 2] = $92; //@line 5600
   HEAP32[$84 >> 2] = $88; //@line 5601
   $94 = HEAP32[$81 >> 2] | 0; //@line 5603
   $96 = $92; //@line 5603
  } else {
   $94 = $82; //@line 5606
   $96 = HEAP32[$80 >> 2] | 0; //@line 5606
  }
  HEAP32[$81 >> 2] = $94 + 1; //@line 5609
  HEAP8[$96 + $94 >> 0] = 10; //@line 5611
  _inclinenumber($ls); //@line 5612
  if (!$33) {
   label = 13; //@line 5614
   continue;
  }
  HEAP32[(HEAP32[$1 >> 2] | 0) + 4 >> 2] = 0; //@line 5619
  label = 13; //@line 5620
 }
 if ((label | 0) == 21) _lexerror($ls, ($seminfo | 0) != 0 ? 6032 : 6056, 286); //@line 5625
 else if ((label | 0) == 23) {
  $50 = HEAP32[$ls >> 2] | 0; //@line 5629
  $51 = HEAP32[$1 >> 2] | 0; //@line 5630
  $52 = $51 + 4 | 0; //@line 5631
  $53 = HEAP32[$52 >> 2] | 0; //@line 5632
  $55 = $51 + 8 | 0; //@line 5634
  $56 = HEAP32[$55 >> 2] | 0; //@line 5635
  do if (($53 + 1 | 0) >>> 0 > $56 >>> 0) {
   if ($56 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 5641
   $59 = $56 << 1; //@line 5644
   $61 = HEAP32[$34 >> 2] | 0; //@line 5646
   if (($59 | 0) == -2) _luaM_toobig($61); //@line 5648
 else {
    $63 = _luaM_realloc_($61, HEAP32[$51 >> 2] | 0, $56, $59) | 0; //@line 5652
    HEAP32[$51 >> 2] = $63; //@line 5653
    HEAP32[$55 >> 2] = $59; //@line 5654
    $66 = HEAP32[$52 >> 2] | 0; //@line 5656
    $68 = $63; //@line 5656
    break;
   }
  } else {
   $66 = $53; //@line 5661
   $68 = HEAP32[$51 >> 2] | 0; //@line 5661
  } while (0);
  HEAP32[$52 >> 2] = $66 + 1; //@line 5666
  HEAP8[$68 + $66 >> 0] = $50; //@line 5668
  $69 = HEAP32[$21 >> 2] | 0; //@line 5669
  $70 = HEAP32[$69 >> 2] | 0; //@line 5670
  HEAP32[$69 >> 2] = $70 + -1; //@line 5672
  if (!$70) $79 = _luaZ_fill($69) | 0; //@line 5676
 else {
   $73 = $69 + 4 | 0; //@line 5678
   $74 = HEAP32[$73 >> 2] | 0; //@line 5679
   HEAP32[$73 >> 2] = $74 + 1; //@line 5681
   $79 = HEAPU8[$74 >> 0] | 0; //@line 5684
  }
  HEAP32[$ls >> 2] = $79; //@line 5686
  if ($33) {
   STACKTOP = sp; //@line 5688
   return;
  }
  $129 = HEAP32[$1 >> 2] | 0; //@line 5690
  $131 = $sep + 2 | 0; //@line 5692
  $137 = HEAP32[$34 >> 2] | 0; //@line 5698
  $138 = _luaS_newlstr($137, (HEAP32[$129 >> 2] | 0) + $131 | 0, (HEAP32[$129 + 4 >> 2] | 0) - ($131 << 1) | 0) | 0; //@line 5699
  $139 = $137 + 8 | 0; //@line 5700
  $140 = HEAP32[$139 >> 2] | 0; //@line 5701
  HEAP32[$139 >> 2] = $140 + 16; //@line 5703
  HEAP32[$140 >> 2] = $138; //@line 5704
  HEAP32[$140 + 8 >> 2] = HEAPU8[$138 + 4 >> 0] | 0 | 64; //@line 5710
  $153 = _luaH_set($137, HEAP32[(HEAP32[$ls + 48 >> 2] | 0) + 4 >> 2] | 0, (HEAP32[$139 >> 2] | 0) + -16 | 0) | 0; //@line 5717
  $154 = $153 + 8 | 0; //@line 5718
  if (!(HEAP32[$154 >> 2] | 0)) {
   HEAP32[$153 >> 2] = 1; //@line 5722
   HEAP32[$154 >> 2] = 1; //@line 5723
   if ((HEAP32[(HEAP32[$137 + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) {
    _luaC_step($137); //@line 5730
    $ts$0$i = $138; //@line 5731
   } else $ts$0$i = $138; //@line 5733
  } else $ts$0$i = HEAP32[$153 + 16 >> 2] | 0; //@line 5738
  HEAP32[$139 >> 2] = (HEAP32[$139 >> 2] | 0) + -16; //@line 5742
  HEAP32[$seminfo >> 2] = $ts$0$i; //@line 5743
  STACKTOP = sp; //@line 5744
  return;
 } else if ((label | 0) == 37) _lexerror($ls, 5888, 0); //@line 5747
 else if ((label | 0) == 39) _luaM_toobig($90); //@line 5751
 else if ((label | 0) == 46) _lexerror($ls, 5888, 0); //@line 5755
 else if ((label | 0) == 48) _luaM_toobig($109); //@line 5759
}
function _body($ls, $e, $ismethod, $line) {
 $ls = $ls | 0;
 $e = $e | 0;
 $ismethod = $ismethod | 0;
 $line = $line | 0;
 var $$idx$val$idx$val$pre$i$i = 0, $$idx1$val$idx$val$idx$val$pre$i$i = 0, $$idx2$i$i = 0, $$pre3$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $104 = 0, $105 = 0, $106 = 0, $110 = 0, $113 = 0, $116 = 0, $125 = 0, $130 = 0, $138 = 0, $14 = 0, $153 = 0, $157 = 0, $16 = 0, $17 = 0, $3 = 0, $30 = 0, $33 = 0, $39 = 0, $4 = 0, $40 = 0, $45 = 0, $50 = 0, $52 = 0, $53 = 0, $56 = 0, $69 = 0, $7 = 0, $8 = 0, $80 = 0, $85 = 0, $88 = 0, $99 = 0, $bl = 0, $ls$idx = 0, $ls$idx$val = 0, $ls$idx$val$i = 0, $ls$idx$val$i8 = 0, $ls$idx1 = 0, $ls$idx1$val = 0, $ls$idx2$val = 0, $ls$idx3$val$idx$val = 0, $new_fs = 0, $nparams$0$i = 0, $nparams$2$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11296
 STACKTOP = STACKTOP + 64 | 0; //@line 11297
 $new_fs = sp + 12 | 0; //@line 11298
 $bl = sp; //@line 11299
 $ls$idx = $ls + 48 | 0; //@line 11300
 $ls$idx$val = HEAP32[$ls$idx >> 2] | 0; //@line 11301
 $ls$idx1 = $ls + 52 | 0; //@line 11302
 $ls$idx1$val = HEAP32[$ls$idx1 >> 2] | 0; //@line 11303
 $0 = HEAP32[$ls$idx$val >> 2] | 0; //@line 11304
 $1 = $ls$idx$val + 36 | 0; //@line 11305
 $3 = $0 + 56 | 0; //@line 11307
 $4 = HEAP32[$3 >> 2] | 0; //@line 11308
 $$pre3$i = $0 + 16 | 0; //@line 11310
 if ((HEAP32[$1 >> 2] | 0) >= ($4 | 0)) {
  $7 = _luaM_growaux_($ls$idx1$val, HEAP32[$$pre3$i >> 2] | 0, $3, 4, 262143, 9368) | 0; //@line 11313
  HEAP32[$$pre3$i >> 2] = $7; //@line 11314
  $8 = HEAP32[$3 >> 2] | 0; //@line 11315
  if (($4 | 0) < ($8 | 0)) {
   $10 = $4 + 1 | 0; //@line 11318
   HEAP32[$7 + ($4 << 2) >> 2] = 0; //@line 11320
   if (($10 | 0) < ($8 | 0)) {
    $14 = $10; //@line 11323
    do {
     HEAP32[(HEAP32[$$pre3$i >> 2] | 0) + ($14 << 2) >> 2] = 0; //@line 11328
     $14 = $14 + 1 | 0; //@line 11326
    } while (($14 | 0) != ($8 | 0));
   }
  }
 }
 $16 = _luaF_newproto($ls$idx1$val) | 0; //@line 11339
 $17 = HEAP32[$1 >> 2] | 0; //@line 11340
 HEAP32[$1 >> 2] = $17 + 1; //@line 11342
 HEAP32[(HEAP32[$$pre3$i >> 2] | 0) + ($17 << 2) >> 2] = $16; //@line 11345
 if (HEAP8[$16 + 5 >> 0] & 3) if (HEAP8[$0 + 5 >> 0] & 4) _luaC_barrier_($ls$idx1$val, $0, $16); //@line 11356
 HEAP32[$new_fs >> 2] = $16; //@line 11359
 HEAP32[$16 + 64 >> 2] = $line; //@line 11361
 $30 = HEAP32[$ls$idx1 >> 2] | 0; //@line 11362
 HEAP32[$new_fs + 8 >> 2] = HEAP32[$ls$idx >> 2]; //@line 11365
 $33 = $new_fs + 12 | 0; //@line 11366
 HEAP32[$33 >> 2] = $ls; //@line 11367
 HEAP32[$ls$idx >> 2] = $new_fs; //@line 11368
 HEAP32[$new_fs + 20 >> 2] = 0; //@line 11370
 HEAP32[$new_fs + 24 >> 2] = 0; //@line 11372
 HEAP32[$new_fs + 28 >> 2] = -1; //@line 11374
 HEAP32[$new_fs + 32 >> 2] = 0; //@line 11376
 HEAP32[$new_fs + 36 >> 2] = 0; //@line 11378
 $39 = $new_fs + 44 | 0; //@line 11379
 $40 = $ls + 64 | 0; //@line 11380
 HEAP32[$39 + 0 >> 2] = 0; //@line 11381
 HEAP8[$39 + 4 >> 0] = 0; //@line 11381
 HEAP32[$new_fs + 40 >> 2] = HEAP32[(HEAP32[$40 >> 2] | 0) + 4 >> 2]; //@line 11386
 $45 = $new_fs + 16 | 0; //@line 11387
 HEAP32[$45 >> 2] = 0; //@line 11388
 HEAP32[$16 + 36 >> 2] = HEAP32[$ls + 68 >> 2]; //@line 11392
 HEAP8[$16 + 78 >> 0] = 2; //@line 11394
 $50 = _luaH_new($30) | 0; //@line 11395
 HEAP32[$new_fs + 4 >> 2] = $50; //@line 11397
 $52 = $30 + 8 | 0; //@line 11398
 $53 = HEAP32[$52 >> 2] | 0; //@line 11399
 HEAP32[$53 >> 2] = $50; //@line 11400
 HEAP32[$53 + 8 >> 2] = 69; //@line 11402
 $56 = (HEAP32[$52 >> 2] | 0) + 16 | 0; //@line 11404
 HEAP32[$52 >> 2] = $56; //@line 11405
 if (((HEAP32[$30 + 24 >> 2] | 0) - $56 | 0) < 16) _luaD_growstack($30, 0); //@line 11413
 HEAP8[$bl + 10 >> 0] = 0; //@line 11416
 HEAP8[$bl + 8 >> 0] = HEAP8[$new_fs + 46 >> 0] | 0; //@line 11420
 $69 = HEAP32[(HEAP32[$33 >> 2] | 0) + 64 >> 2] | 0; //@line 11423
 HEAP16[$bl + 4 >> 1] = HEAP32[$69 + 28 >> 2]; //@line 11428
 HEAP16[$bl + 6 >> 1] = HEAP32[$69 + 16 >> 2]; //@line 11433
 HEAP8[$bl + 9 >> 0] = 0; //@line 11435
 HEAP32[$bl >> 2] = HEAP32[$45 >> 2]; //@line 11437
 HEAP32[$45 >> 2] = $bl; //@line 11438
 $80 = $ls + 16 | 0; //@line 11439
 if ((HEAP32[$80 >> 2] | 0) != 40) _error_expected($ls, 40); //@line 11443
 _luaX_next($ls); //@line 11446
 if ($ismethod) {
  _new_localvar($ls, _luaX_newstring($ls, 9312, 4) | 0); //@line 11450
  $ls$idx2$val = HEAP32[$ls$idx >> 2] | 0; //@line 11451
  $85 = $ls$idx2$val + 46 | 0; //@line 11452
  $88 = (HEAPU8[$85 >> 0] | 0) + 1 | 0; //@line 11455
  HEAP8[$85 >> 0] = $88; //@line 11457
  HEAP32[(HEAP32[(HEAP32[$ls$idx2$val >> 2] | 0) + 24 >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[(HEAP32[$ls$idx2$val + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0) + (($88 & 255) + -1 + (HEAP32[$ls$idx2$val + 40 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$ls$idx2$val + 20 >> 2]; //@line 11477
 }
 $99 = HEAP32[$ls$idx >> 2] | 0; //@line 11479
 $100 = HEAP32[$99 >> 2] | 0; //@line 11480
 $101 = $100 + 77 | 0; //@line 11481
 HEAP8[$101 >> 0] = 0; //@line 11482
 $102 = HEAP32[$80 >> 2] | 0; //@line 11483
 L20 : do if (($102 | 0) == 41) $nparams$2$i = 0; //@line 11487
 else {
  $104 = $ls + 24 | 0; //@line 11489
  $157 = $102; //@line 11490
  $nparams$0$i = 0; //@line 11490
  while (1) {
   if (($157 | 0) == 280) {
    label = 18; //@line 11493
    break;
   } else if (($157 | 0) != 288) {
    label = 19; //@line 11496
    break;
   }
   $105 = HEAP32[$104 >> 2] | 0; //@line 11499
   _luaX_next($ls); //@line 11500
   _new_localvar($ls, $105); //@line 11501
   $106 = $nparams$0$i + 1 | 0; //@line 11502
   if (HEAP8[$101 >> 0] | 0) {
    $nparams$2$i = $106; //@line 11506
    break L20;
   }
   if ((HEAP32[$80 >> 2] | 0) != 44) {
    $nparams$2$i = $106; //@line 11512
    break L20;
   }
   _luaX_next($ls); //@line 11515
   $157 = HEAP32[$80 >> 2] | 0; //@line 11517
   $nparams$0$i = $106; //@line 11517
  }
  if ((label | 0) == 18) {
   _luaX_next($ls); //@line 11520
   HEAP8[$101 >> 0] = 1; //@line 11521
   $nparams$2$i = $nparams$0$i; //@line 11522
   break;
  } else if ((label | 0) == 19) _luaX_syntaxerror($ls, 9320); //@line 11526
 } while (0);
 $ls$idx$val$i = HEAP32[$ls$idx >> 2] | 0; //@line 11531
 $110 = $ls$idx$val$i + 46 | 0; //@line 11532
 $113 = (HEAPU8[$110 >> 0] | 0) + $nparams$2$i | 0; //@line 11535
 HEAP8[$110 >> 0] = $113; //@line 11537
 if ($nparams$2$i) {
  $116 = $ls$idx$val$i + 20 | 0; //@line 11540
  $$idx2$i$i = $ls$idx$val$i + 40 | 0; //@line 11542
  $$idx$val$idx$val$pre$i$i = HEAP32[(HEAP32[$ls$idx$val$i >> 2] | 0) + 24 >> 2] | 0; //@line 11546
  $$idx1$val$idx$val$idx$val$pre$i$i = HEAP32[HEAP32[(HEAP32[$ls$idx$val$i + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0; //@line 11549
  HEAP32[$$idx$val$idx$val$pre$i$i + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i$i + (($113 & 255) - $nparams$2$i + (HEAP32[$$idx2$i$i >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$116 >> 2]; //@line 11559
  $125 = $nparams$2$i + -1 | 0; //@line 11560
  if ($125) {
   $130 = $125; //@line 11563
   do {
    HEAP32[$$idx$val$idx$val$pre$i$i + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i$i + ((HEAPU8[$110 >> 0] | 0) - $130 + (HEAP32[$$idx2$i$i >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$116 >> 2]; //@line 11575
    $130 = $130 + -1 | 0; //@line 11576
   } while (($130 | 0) != 0);
  }
 }
 $138 = $99 + 46 | 0; //@line 11586
 HEAP8[$100 + 76 >> 0] = HEAP8[$138 >> 0] | 0; //@line 11589
 _luaK_reserveregs($99, HEAPU8[$138 >> 0] | 0); //@line 11592
 if ((HEAP32[$80 >> 2] | 0) != 41) _error_expected($ls, 41); //@line 11596
 _luaX_next($ls); //@line 11599
 L39 : while (1) {
  $ls$idx$val$i8 = HEAP32[$80 >> 2] | 0; //@line 11601
  switch ($ls$idx$val$i8 | 0) {
  case 277:
  case 286:
  case 262:
  case 261:
  case 260:
   {
    label = 30; //@line 11604
    break L39;
    break;
   }
  default:
   {}
  }
  _statement($ls); //@line 11612
  if (($ls$idx$val$i8 | 0) == 274) {
   label = 30; //@line 11614
   break;
  }
 }
 if ((label | 0) == 30) {
  HEAP32[(HEAP32[$new_fs >> 2] | 0) + 68 >> 2] = HEAP32[$ls + 4 >> 2]; //@line 11623
  _check_match($ls, 262, 265, $line); //@line 11624
  $ls$idx3$val$idx$val = HEAP32[(HEAP32[$ls$idx >> 2] | 0) + 8 >> 2] | 0; //@line 11627
  $153 = _luaK_codeABx($ls$idx3$val$idx$val, 37, 0, (HEAP32[$ls$idx3$val$idx$val + 36 >> 2] | 0) + -1 | 0) | 0; //@line 11631
  HEAP32[$e + 16 >> 2] = -1; //@line 11633
  HEAP32[$e + 20 >> 2] = -1; //@line 11635
  HEAP32[$e >> 2] = 11; //@line 11636
  HEAP32[$e + 8 >> 2] = $153; //@line 11638
  _luaK_exp2nextreg($ls$idx3$val$idx$val, $e); //@line 11639
  _close_func($ls); //@line 11640
  STACKTOP = sp; //@line 11641
  return;
 }
}
function _try_realloc_chunk($p, $nb) {
 $p = $p | 0;
 $nb = $nb | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $103 = 0, $105 = 0, $108 = 0, $111 = 0, $112 = 0, $114 = 0, $115 = 0, $117 = 0, $118 = 0, $120 = 0, $121 = 0, $126 = 0, $127 = 0, $136 = 0, $145 = 0, $152 = 0, $163 = 0, $173 = 0, $2 = 0, $22 = 0, $3 = 0, $35 = 0, $37 = 0, $4 = 0, $47 = 0, $49 = 0, $58 = 0, $6 = 0, $64 = 0, $70 = 0, $72 = 0, $73 = 0, $76 = 0, $78 = 0, $80 = 0, $9 = 0, $93 = 0, $98 = 0, $R$0 = 0, $R$1 = 0, $RP$0 = 0, $newp$0 = 0, $storemerge = 0, $storemerge21 = 0, sp = 0;
 sp = STACKTOP; //@line 9833
 $0 = $p + 4 | 0; //@line 9834
 $1 = HEAP32[$0 >> 2] | 0; //@line 9835
 $2 = $1 & -8; //@line 9836
 $3 = $p + $2 | 0; //@line 9837
 $4 = HEAP32[3004] | 0; //@line 9838
 if ($p >>> 0 < $4 >>> 0) _abort(); //@line 9841
 $6 = $1 & 3; //@line 9844
 if (!(($6 | 0) != 1 & $p >>> 0 < $3 >>> 0)) _abort(); //@line 9849
 $9 = $p + ($2 | 4) | 0; //@line 9853
 $10 = HEAP32[$9 >> 2] | 0; //@line 9854
 if (!($10 & 1)) _abort(); //@line 9858
 if (!$6) {
  if ($nb >>> 0 < 256) {
   $newp$0 = 0; //@line 9865
   STACKTOP = sp; //@line 9866
   return $newp$0 | 0; //@line 9866
  }
  if ($2 >>> 0 >= ($nb + 4 | 0) >>> 0) if (($2 - $nb | 0) >>> 0 <= HEAP32[3120] << 1 >>> 0) {
   $newp$0 = $p; //@line 9876
   STACKTOP = sp; //@line 9877
   return $newp$0 | 0; //@line 9877
  }
  $newp$0 = 0; //@line 9880
  STACKTOP = sp; //@line 9881
  return $newp$0 | 0; //@line 9881
 }
 if ($2 >>> 0 >= $nb >>> 0) {
  $22 = $2 - $nb | 0; //@line 9885
  if ($22 >>> 0 <= 15) {
   $newp$0 = $p; //@line 9888
   STACKTOP = sp; //@line 9889
   return $newp$0 | 0; //@line 9889
  }
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2; //@line 9895
  HEAP32[$p + ($nb + 4) >> 2] = $22 | 3; //@line 9899
  HEAP32[$9 >> 2] = HEAP32[$9 >> 2] | 1; //@line 9902
  _dispose_chunk($p + $nb | 0, $22); //@line 9903
  $newp$0 = $p; //@line 9904
  STACKTOP = sp; //@line 9905
  return $newp$0 | 0; //@line 9905
 }
 if (($3 | 0) == (HEAP32[3006] | 0)) {
  $35 = (HEAP32[3003] | 0) + $2 | 0; //@line 9911
  if ($35 >>> 0 <= $nb >>> 0) {
   $newp$0 = 0; //@line 9914
   STACKTOP = sp; //@line 9915
   return $newp$0 | 0; //@line 9915
  }
  $37 = $35 - $nb | 0; //@line 9917
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2; //@line 9922
  HEAP32[$p + ($nb + 4) >> 2] = $37 | 1; //@line 9926
  HEAP32[3006] = $p + $nb; //@line 9927
  HEAP32[3003] = $37; //@line 9928
  $newp$0 = $p; //@line 9929
  STACKTOP = sp; //@line 9930
  return $newp$0 | 0; //@line 9930
 }
 if (($3 | 0) == (HEAP32[3005] | 0)) {
  $47 = (HEAP32[3002] | 0) + $2 | 0; //@line 9936
  if ($47 >>> 0 < $nb >>> 0) {
   $newp$0 = 0; //@line 9939
   STACKTOP = sp; //@line 9940
   return $newp$0 | 0; //@line 9940
  }
  $49 = $47 - $nb | 0; //@line 9942
  if ($49 >>> 0 > 15) {
   HEAP32[$0 >> 2] = $1 & 1 | $nb | 2; //@line 9950
   HEAP32[$p + ($nb + 4) >> 2] = $49 | 1; //@line 9954
   HEAP32[$p + $47 >> 2] = $49; //@line 9955
   $58 = $p + ($47 + 4) | 0; //@line 9957
   HEAP32[$58 >> 2] = HEAP32[$58 >> 2] & -2; //@line 9960
   $storemerge = $p + $nb | 0; //@line 9961
   $storemerge21 = $49; //@line 9961
  } else {
   HEAP32[$0 >> 2] = $1 & 1 | $47 | 2; //@line 9966
   $64 = $p + ($47 + 4) | 0; //@line 9968
   HEAP32[$64 >> 2] = HEAP32[$64 >> 2] | 1; //@line 9971
   $storemerge = 0; //@line 9972
   $storemerge21 = 0; //@line 9972
  }
  HEAP32[3002] = $storemerge21; //@line 9974
  HEAP32[3005] = $storemerge; //@line 9975
  $newp$0 = $p; //@line 9976
  STACKTOP = sp; //@line 9977
  return $newp$0 | 0; //@line 9977
 }
 if ($10 & 2) {
  $newp$0 = 0; //@line 9982
  STACKTOP = sp; //@line 9983
  return $newp$0 | 0; //@line 9983
 }
 $70 = ($10 & -8) + $2 | 0; //@line 9986
 if ($70 >>> 0 < $nb >>> 0) {
  $newp$0 = 0; //@line 9989
  STACKTOP = sp; //@line 9990
  return $newp$0 | 0; //@line 9990
 }
 $72 = $70 - $nb | 0; //@line 9992
 $73 = $10 >>> 3; //@line 9993
 do if ($10 >>> 0 < 256) {
  $76 = HEAP32[$p + ($2 + 8) >> 2] | 0; //@line 9999
  $78 = HEAP32[$p + ($2 + 12) >> 2] | 0; //@line 10002
  $80 = 12040 + ($73 << 1 << 2) | 0; //@line 10004
  if (($76 | 0) != ($80 | 0)) {
   if ($76 >>> 0 < $4 >>> 0) _abort(); //@line 10009
   if ((HEAP32[$76 + 12 >> 2] | 0) != ($3 | 0)) _abort(); //@line 10016
  }
  if (($78 | 0) == ($76 | 0)) {
   HEAP32[3e3] = HEAP32[3e3] & ~(1 << $73); //@line 10026
   break;
  }
  if (($78 | 0) == ($80 | 0)) $$pre$phiZ2D = $78 + 8 | 0; //@line 10032
 else {
   if ($78 >>> 0 < $4 >>> 0) _abort(); //@line 10036
   $93 = $78 + 8 | 0; //@line 10039
   if ((HEAP32[$93 >> 2] | 0) == ($3 | 0)) $$pre$phiZ2D = $93; //@line 10043
 else _abort(); //@line 10045
  }
  HEAP32[$76 + 12 >> 2] = $78; //@line 10050
  HEAP32[$$pre$phiZ2D >> 2] = $76; //@line 10051
 } else {
  $98 = HEAP32[$p + ($2 + 24) >> 2] | 0; //@line 10055
  $100 = HEAP32[$p + ($2 + 12) >> 2] | 0; //@line 10058
  do if (($100 | 0) == ($3 | 0)) {
   $111 = $p + ($2 + 20) | 0; //@line 10063
   $112 = HEAP32[$111 >> 2] | 0; //@line 10064
   if (!$112) {
    $114 = $p + ($2 + 16) | 0; //@line 10068
    $115 = HEAP32[$114 >> 2] | 0; //@line 10069
    if (!$115) {
     $R$1 = 0; //@line 10072
     break;
    } else {
     $R$0 = $115; //@line 10075
     $RP$0 = $114; //@line 10075
    }
   } else {
    $R$0 = $112; //@line 10078
    $RP$0 = $111; //@line 10078
   }
   while (1) {
    $117 = $R$0 + 20 | 0; //@line 10081
    $118 = HEAP32[$117 >> 2] | 0; //@line 10082
    if ($118) {
     $R$0 = $118; //@line 10085
     $RP$0 = $117; //@line 10085
     continue;
    }
    $120 = $R$0 + 16 | 0; //@line 10088
    $121 = HEAP32[$120 >> 2] | 0; //@line 10089
    if (!$121) break; else {
     $R$0 = $121; //@line 10094
     $RP$0 = $120; //@line 10094
    }
   }
   if ($RP$0 >>> 0 < $4 >>> 0) _abort(); //@line 10099
 else {
    HEAP32[$RP$0 >> 2] = 0; //@line 10102
    $R$1 = $R$0; //@line 10103
    break;
   }
  } else {
   $103 = HEAP32[$p + ($2 + 8) >> 2] | 0; //@line 10109
   if ($103 >>> 0 < $4 >>> 0) _abort(); //@line 10112
   $105 = $103 + 12 | 0; //@line 10115
   if ((HEAP32[$105 >> 2] | 0) != ($3 | 0)) _abort(); //@line 10119
   $108 = $100 + 8 | 0; //@line 10122
   if ((HEAP32[$108 >> 2] | 0) == ($3 | 0)) {
    HEAP32[$105 >> 2] = $100; //@line 10126
    HEAP32[$108 >> 2] = $103; //@line 10127
    $R$1 = $100; //@line 10128
    break;
   } else _abort(); //@line 10131
  } while (0);
  if ($98) {
   $126 = HEAP32[$p + ($2 + 28) >> 2] | 0; //@line 10140
   $127 = 12304 + ($126 << 2) | 0; //@line 10141
   if (($3 | 0) == (HEAP32[$127 >> 2] | 0)) {
    HEAP32[$127 >> 2] = $R$1; //@line 10145
    if (!$R$1) {
     HEAP32[3001] = HEAP32[3001] & ~(1 << $126); //@line 10152
     break;
    }
   } else {
    if ($98 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10159
    $136 = $98 + 16 | 0; //@line 10162
    if ((HEAP32[$136 >> 2] | 0) == ($3 | 0)) HEAP32[$136 >> 2] = $R$1; //@line 10166
 else HEAP32[$98 + 20 >> 2] = $R$1; //@line 10169
    if (!$R$1) break;
   }
   if ($R$1 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10179
   HEAP32[$R$1 + 24 >> 2] = $98; //@line 10183
   $145 = HEAP32[$p + ($2 + 16) >> 2] | 0; //@line 10186
   do if ($145) if ($145 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10193
 else {
    HEAP32[$R$1 + 16 >> 2] = $145; //@line 10197
    HEAP32[$145 + 24 >> 2] = $R$1; //@line 10199
    break;
   } while (0);
   $152 = HEAP32[$p + ($2 + 20) >> 2] | 0; //@line 10206
   if ($152) if ($152 >>> 0 < (HEAP32[3004] | 0) >>> 0) _abort(); //@line 10212
 else {
    HEAP32[$R$1 + 20 >> 2] = $152; //@line 10216
    HEAP32[$152 + 24 >> 2] = $R$1; //@line 10218
    break;
   }
  }
 } while (0);
 if ($72 >>> 0 < 16) {
  HEAP32[$0 >> 2] = $70 | HEAP32[$0 >> 2] & 1 | 2; //@line 10231
  $163 = $p + ($70 | 4) | 0; //@line 10233
  HEAP32[$163 >> 2] = HEAP32[$163 >> 2] | 1; //@line 10236
  $newp$0 = $p; //@line 10237
  STACKTOP = sp; //@line 10238
  return $newp$0 | 0; //@line 10238
 } else {
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & 1 | $nb | 2; //@line 10245
  HEAP32[$p + ($nb + 4) >> 2] = $72 | 3; //@line 10249
  $173 = $p + ($70 | 4) | 0; //@line 10251
  HEAP32[$173 >> 2] = HEAP32[$173 >> 2] | 1; //@line 10254
  _dispose_chunk($p + $nb | 0, $72); //@line 10255
  $newp$0 = $p; //@line 10256
  STACKTOP = sp; //@line 10257
  return $newp$0 | 0; //@line 10257
 }
 return 0; //@line 10259
}
function _luaK_posfix($fs, $op, $e1, $e2, $line) {
 $fs = $fs | 0;
 $op = $op | 0;
 $e1 = $e1 | 0;
 $e2 = $e2 | 0;
 $line = $line | 0;
 var $$pre = 0, $$pre23 = 0, $0 = 0, $102 = 0, $109 = 0, $114 = 0, $115 = 0, $12 = 0, $122 = 0, $126 = 0, $127 = 0, $128 = 0, $132 = 0, $139 = 0, $14 = 0, $144 = 0, $145 = 0, $152 = 0, $155 = 0, $2 = 0, $23 = 0, $25 = 0, $27 = 0, $29 = 0, $30 = 0, $32 = 0, $35 = 0, $37 = 0, $4 = 0, $46 = 0, $48 = 0, $50 = 0, $57 = 0, $6 = 0, $64 = 0, $65 = 0, $67 = 0, $68 = 0, $7 = 0, $70 = 0, $75 = 0, $76 = 0, $83 = 0, $87 = 0, $88 = 0, $9 = 0, $90 = 0, $96 = 0, $97 = 0, $98 = 0, $fs$idx$val$idx$val$i = 0, $fs$idx$val$idx$val$i4 = 0, $list$0$i = 0, $list$0$i6 = 0, sp = 0;
 sp = STACKTOP; //@line 12283
 switch ($op | 0) {
 case 14:
  {
   _luaK_dischargevars($fs, $e2); //@line 12286
   $23 = $e2 + 16 | 0; //@line 12287
   $25 = HEAP32[$e1 + 16 >> 2] | 0; //@line 12289
   do if (($25 | 0) != -1) {
    $27 = HEAP32[$23 >> 2] | 0; //@line 12293
    if (($27 | 0) == -1) {
     HEAP32[$23 >> 2] = $25; //@line 12296
     break;
    }
    $fs$idx$val$idx$val$i4 = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 12301
    $list$0$i6 = $27; //@line 12302
    while (1) {
     $29 = $fs$idx$val$idx$val$i4 + ($list$0$i6 << 2) | 0; //@line 12304
     $30 = HEAP32[$29 >> 2] | 0; //@line 12305
     $32 = ($30 >>> 14) + -131071 | 0; //@line 12307
     if (($32 | 0) == -1) break;
     $35 = $list$0$i6 + 1 + $32 | 0; //@line 12313
     if (($35 | 0) == -1) break; else $list$0$i6 = $35; //@line 12318
    }
    $37 = $25 + ~$list$0$i6 | 0; //@line 12322
    if (((($37 | 0) > -1 ? $37 : 0 - $37 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 12330
 else {
     HEAP32[$29 >> 2] = ($37 << 14) + 2147467264 | $30 & 16383; //@line 12337
     break;
    }
   } while (0);
   HEAP32[$e1 + 0 >> 2] = HEAP32[$e2 + 0 >> 2]; //@line 12342
   HEAP32[$e1 + 4 >> 2] = HEAP32[$e2 + 4 >> 2]; //@line 12342
   HEAP32[$e1 + 8 >> 2] = HEAP32[$e2 + 8 >> 2]; //@line 12342
   HEAP32[$e1 + 12 >> 2] = HEAP32[$e2 + 12 >> 2]; //@line 12342
   HEAP32[$e1 + 16 >> 2] = HEAP32[$e2 + 16 >> 2]; //@line 12342
   HEAP32[$e1 + 20 >> 2] = HEAP32[$e2 + 20 >> 2]; //@line 12342
   STACKTOP = sp; //@line 12343
   return;
  }
 case 13:
  {
   _luaK_dischargevars($fs, $e2); //@line 12347
   $0 = $e2 + 20 | 0; //@line 12348
   $2 = HEAP32[$e1 + 20 >> 2] | 0; //@line 12350
   do if (($2 | 0) != -1) {
    $4 = HEAP32[$0 >> 2] | 0; //@line 12354
    if (($4 | 0) == -1) {
     HEAP32[$0 >> 2] = $2; //@line 12357
     break;
    }
    $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 12362
    $list$0$i = $4; //@line 12363
    while (1) {
     $6 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 12365
     $7 = HEAP32[$6 >> 2] | 0; //@line 12366
     $9 = ($7 >>> 14) + -131071 | 0; //@line 12368
     if (($9 | 0) == -1) break;
     $12 = $list$0$i + 1 + $9 | 0; //@line 12374
     if (($12 | 0) == -1) break; else $list$0$i = $12; //@line 12379
    }
    $14 = $2 + ~$list$0$i | 0; //@line 12383
    if (((($14 | 0) > -1 ? $14 : 0 - $14 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 12391
 else {
     HEAP32[$6 >> 2] = ($14 << 14) + 2147467264 | $7 & 16383; //@line 12398
     break;
    }
   } while (0);
   HEAP32[$e1 + 0 >> 2] = HEAP32[$e2 + 0 >> 2]; //@line 12403
   HEAP32[$e1 + 4 >> 2] = HEAP32[$e2 + 4 >> 2]; //@line 12403
   HEAP32[$e1 + 8 >> 2] = HEAP32[$e2 + 8 >> 2]; //@line 12403
   HEAP32[$e1 + 12 >> 2] = HEAP32[$e2 + 12 >> 2]; //@line 12403
   HEAP32[$e1 + 16 >> 2] = HEAP32[$e2 + 16 >> 2]; //@line 12403
   HEAP32[$e1 + 20 >> 2] = HEAP32[$e2 + 20 >> 2]; //@line 12403
   STACKTOP = sp; //@line 12404
   return;
  }
 case 9:
 case 8:
 case 7:
  {
   $96 = $op + 17 | 0; //@line 12408
   $97 = _luaK_exp2RK($fs, $e1) | 0; //@line 12409
   $98 = _luaK_exp2RK($fs, $e2) | 0; //@line 12410
   if ((HEAP32[$e2 >> 2] | 0) == 6) {
    $102 = HEAP32[$e2 + 8 >> 2] | 0; //@line 12415
    if (!($102 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($102 | 0)) {
     $109 = $fs + 48 | 0; //@line 12424
     HEAP8[$109 >> 0] = (HEAP8[$109 >> 0] | 0) + -1 << 24 >> 24; //@line 12427
    }
   }
   $114 = $e1 + 8 | 0; //@line 12433
   if ((HEAP32[$e1 >> 2] | 0) == 6) {
    $115 = HEAP32[$114 >> 2] | 0; //@line 12435
    if (!($115 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($115 | 0)) {
     $122 = $fs + 48 | 0; //@line 12444
     HEAP8[$122 >> 0] = (HEAP8[$122 >> 0] | 0) + -1 << 24 >> 24; //@line 12447
    }
   }
   HEAP32[$114 >> 2] = _condjump($fs, $96, 1, $97, $98) | 0; //@line 12452
   HEAP32[$e1 >> 2] = 10; //@line 12453
   STACKTOP = sp; //@line 12454
   return;
  }
 case 5:
 case 4:
 case 3:
 case 2:
 case 1:
 case 0:
  {
   _codearith($fs, $op + 13 | 0, $e1, $e2, $line); //@line 12459
   STACKTOP = sp; //@line 12460
   return;
  }
 case 6:
  {
   $46 = $e2 + 16 | 0; //@line 12464
   $48 = $e2 + 20 | 0; //@line 12466
   $50 = (HEAP32[$46 >> 2] | 0) == (HEAP32[$48 >> 2] | 0); //@line 12468
   _luaK_dischargevars($fs, $e2); //@line 12469
   do if (!$50) {
    if ((HEAP32[$e2 >> 2] | 0) == 6) {
     $57 = HEAP32[$e2 + 8 >> 2] | 0; //@line 12479
     if ((HEAP32[$46 >> 2] | 0) == (HEAP32[$48 >> 2] | 0)) break;
     if (($57 | 0) >= (HEAPU8[$fs + 46 >> 0] | 0 | 0)) {
      _exp2reg($fs, $e2, $57); //@line 12488
      break;
     }
    }
    _luaK_exp2nextreg($fs, $e2); //@line 12492
   } while (0);
   if ((HEAP32[$e2 >> 2] | 0) == 11) {
    $64 = $e2 + 8 | 0; //@line 12498
    $65 = HEAP32[$64 >> 2] | 0; //@line 12499
    $67 = (HEAP32[$fs >> 2] | 0) + 12 | 0; //@line 12501
    $68 = HEAP32[$67 >> 2] | 0; //@line 12502
    $70 = HEAP32[$68 + ($65 << 2) >> 2] | 0; //@line 12504
    if (($70 & 63 | 0) == 22) {
     $75 = $e1 + 8 | 0; //@line 12510
     if ((HEAP32[$e1 >> 2] | 0) == 6) {
      $76 = HEAP32[$75 >> 2] | 0; //@line 12512
      if (!($76 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) > ($76 | 0)) {
       $87 = $68; //@line 12521
       $88 = $65; //@line 12521
       $90 = $70; //@line 12521
      } else {
       $83 = $fs + 48 | 0; //@line 12523
       HEAP8[$83 >> 0] = (HEAP8[$83 >> 0] | 0) + -1 << 24 >> 24; //@line 12526
       $$pre = HEAP32[$64 >> 2] | 0; //@line 12527
       $$pre23 = HEAP32[$67 >> 2] | 0; //@line 12528
       $87 = $$pre23; //@line 12531
       $88 = $$pre; //@line 12531
       $90 = HEAP32[$$pre23 + ($$pre << 2) >> 2] | 0; //@line 12531
      } else {
       $87 = $68; //@line 12534
       $88 = $65; //@line 12534
       $90 = $70; //@line 12534
      }
     } else {
      $87 = $68; //@line 12537
      $88 = $65; //@line 12537
      $90 = $70; //@line 12537
     }
     HEAP32[$87 + ($88 << 2) >> 2] = HEAP32[$75 >> 2] << 23 | $90 & 8388607; //@line 12544
     HEAP32[$e1 >> 2] = 11; //@line 12545
     HEAP32[$75 >> 2] = HEAP32[$64 >> 2]; //@line 12547
     STACKTOP = sp; //@line 12548
     return;
    }
   }
   _luaK_exp2nextreg($fs, $e2); //@line 12551
   _codearith($fs, 22, $e1, $e2, $line); //@line 12552
   STACKTOP = sp; //@line 12553
   return;
  }
 case 12:
 case 11:
 case 10:
  {
   $126 = $op + 14 | 0; //@line 12557
   $127 = _luaK_exp2RK($fs, $e1) | 0; //@line 12558
   $128 = _luaK_exp2RK($fs, $e2) | 0; //@line 12559
   if ((HEAP32[$e2 >> 2] | 0) == 6) {
    $132 = HEAP32[$e2 + 8 >> 2] | 0; //@line 12564
    if (!($132 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($132 | 0)) {
     $139 = $fs + 48 | 0; //@line 12573
     HEAP8[$139 >> 0] = (HEAP8[$139 >> 0] | 0) + -1 << 24 >> 24; //@line 12576
    }
   }
   $144 = $e1 + 8 | 0; //@line 12582
   if ((HEAP32[$e1 >> 2] | 0) == 6) {
    $145 = HEAP32[$144 >> 2] | 0; //@line 12584
    if (!($145 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($145 | 0)) {
     $152 = $fs + 48 | 0; //@line 12593
     HEAP8[$152 >> 0] = (HEAP8[$152 >> 0] | 0) + -1 << 24 >> 24; //@line 12596
    }
   }
   $155 = ($126 | 0) == 24; //@line 12600
   HEAP32[$144 >> 2] = _condjump($fs, $126, $155 & 1 ^ 1, $155 ? $127 : $128, $155 ? $128 : $127) | 0; //@line 12606
   HEAP32[$e1 >> 2] = 10; //@line 12607
   STACKTOP = sp; //@line 12608
   return;
  }
 default:
  {
   STACKTOP = sp; //@line 12612
   return;
  }
 }
}
function _luaV_concat($L, $total) {
 $L = $L | 0;
 $total = $total | 0;
 var $$0 = 0, $$pre$phi32Z2D = 0, $$pre$phiZ2D = 0, $$sum = 0, $0 = 0, $1 = 0, $104 = 0, $107 = 0, $108 = 0, $11 = 0, $112 = 0, $12 = 0, $121 = 0, $126 = 0, $127 = 0, $13 = 0, $133 = 0, $134 = 0, $135 = 0, $141 = 0, $148 = 0, $151 = 0, $152 = 0, $156 = 0, $159 = 0, $161 = 0, $167 = 0, $169 = 0, $19 = 0, $2 = 0, $24 = 0, $28 = 0, $3 = 0, $33 = 0, $34 = 0, $36 = 0, $4 = 0, $41 = 0, $42 = 0, $49 = 0, $5 = 0, $51 = 0, $56 = 0, $57 = 0, $6 = 0, $63 = 0, $65 = 0, $7 = 0, $70 = 0, $71 = 0, $85 = 0, $87 = 0, $88 = 0, $89 = 0, $94 = 0, $95 = 0, $i$0$lcssa = 0, $i$011 = 0, $i$1 = 0, $n$0 = 0, $s$i = 0, $tl$0$lcssa = 0, $tl$012 = 0, $tl$1 = 0, $tm$01$i = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 2264
 STACKTOP = STACKTOP + 48 | 0; //@line 2265
 $vararg_buffer7 = sp; //@line 2266
 $s$i = sp + 8 | 0; //@line 2267
 $0 = $L + 8 | 0; //@line 2268
 $1 = $L + 12 | 0; //@line 2269
 $2 = $L + 28 | 0; //@line 2270
 $3 = $L + 16 | 0; //@line 2271
 $$0 = $total; //@line 2273
 $5 = HEAP32[$0 >> 2] | 0; //@line 2273
 L1 : while (1) {
  $4 = $5 + -32 | 0; //@line 2275
  $6 = $5 + -24 | 0; //@line 2276
  $7 = HEAP32[$6 >> 2] | 0; //@line 2277
  $11 = $5 + -16 | 0; //@line 2282
  do if (($7 & 15 | 0) == 4 | ($7 | 0) == 3) {
   $12 = $5 + -8 | 0; //@line 2285
   $13 = HEAP32[$12 >> 2] | 0; //@line 2286
   if (($13 & 15 | 0) == 4) {
    $$pre$phiZ2D = $11; //@line 2290
    $107 = $7; //@line 2290
   } else {
    if (($13 | 0) != 3) {
     label = 7; //@line 2294
     break;
    }
    HEAPF64[tempDoublePtr >> 3] = +HEAPF64[$11 >> 3]; //@line 2298
    HEAP32[$vararg_buffer7 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 2298
    HEAP32[$vararg_buffer7 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 2298
    $19 = _luaS_newlstr($L, $s$i, _sprintf($s$i, 11792, $vararg_buffer7) | 0) | 0; //@line 2300
    HEAP32[$11 >> 2] = $19; //@line 2301
    HEAP32[$12 >> 2] = HEAPU8[$19 + 4 >> 0] | 0 | 64; //@line 2306
    $$pre$phiZ2D = $11; //@line 2308
    $107 = HEAP32[$6 >> 2] | 0; //@line 2308
   }
   $104 = HEAP32[(HEAP32[$$pre$phiZ2D >> 2] | 0) + 12 >> 2] | 0; //@line 2312
   $108 = ($107 & 15 | 0) == 4; //@line 2315
   if (!$104) {
    if ($108) {
     $n$0 = 2; //@line 2318
     break;
    }
    if (($107 | 0) != 3) {
     $n$0 = 2; //@line 2323
     break;
    }
    HEAPF64[tempDoublePtr >> 3] = +HEAPF64[$4 >> 3]; //@line 2327
    HEAP32[$vararg_buffer7 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 2327
    HEAP32[$vararg_buffer7 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 2327
    $112 = _luaS_newlstr($L, $s$i, _sprintf($s$i, 11792, $vararg_buffer7) | 0) | 0; //@line 2329
    HEAP32[$4 >> 2] = $112; //@line 2330
    HEAP32[$6 >> 2] = HEAPU8[$112 + 4 >> 0] | 0 | 64; //@line 2335
    $n$0 = 2; //@line 2336
    break;
   }
   if ($108) if (!(HEAP32[(HEAP32[$4 >> 2] | 0) + 12 >> 2] | 0)) {
    $121 = $11; //@line 2345
    $126 = HEAP32[$121 + 4 >> 2] | 0; //@line 2350
    $127 = $4; //@line 2351
    HEAP32[$127 >> 2] = HEAP32[$121 >> 2]; //@line 2353
    HEAP32[$127 + 4 >> 2] = $126; //@line 2356
    HEAP32[$6 >> 2] = HEAP32[$12 >> 2]; //@line 2358
    $n$0 = 2; //@line 2359
    break;
   }
   L19 : do if (($$0 | 0) > 1) {
    $i$011 = 1; //@line 2366
    $tl$012 = $104; //@line 2366
    while (1) {
     $$sum = ~$i$011; //@line 2368
     $133 = $5 + ($$sum << 4) | 0; //@line 2369
     $134 = $5 + ($$sum << 4) + 8 | 0; //@line 2370
     $135 = HEAP32[$134 >> 2] | 0; //@line 2371
     if (($135 & 15 | 0) == 4) $$pre$phi32Z2D = $133; //@line 2375
 else {
      if (($135 | 0) != 3) {
       $i$0$lcssa = $i$011; //@line 2379
       $tl$0$lcssa = $tl$012; //@line 2379
       break L19;
      }
      HEAPF64[tempDoublePtr >> 3] = +HEAPF64[$133 >> 3]; //@line 2383
      HEAP32[$vararg_buffer7 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 2383
      HEAP32[$vararg_buffer7 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 2383
      $141 = _luaS_newlstr($L, $s$i, _sprintf($s$i, 11792, $vararg_buffer7) | 0) | 0; //@line 2385
      HEAP32[$133 >> 2] = $141; //@line 2386
      HEAP32[$134 >> 2] = HEAPU8[$141 + 4 >> 0] | 0 | 64; //@line 2391
      $$pre$phi32Z2D = $133; //@line 2392
     }
     $148 = HEAP32[(HEAP32[$$pre$phi32Z2D >> 2] | 0) + 12 >> 2] | 0; //@line 2396
     if ($148 >>> 0 >= (-3 - $tl$012 | 0) >>> 0) {
      label = 24; //@line 2400
      break L1;
     }
     $151 = $148 + $tl$012 | 0; //@line 2403
     $152 = $i$011 + 1 | 0; //@line 2404
     if (($152 | 0) < ($$0 | 0)) {
      $i$011 = $152; //@line 2407
      $tl$012 = $151; //@line 2407
     } else {
      $i$0$lcssa = $152; //@line 2409
      $tl$0$lcssa = $151; //@line 2409
      break;
     }
    }
   } else {
    $i$0$lcssa = 1; //@line 2414
    $tl$0$lcssa = $104; //@line 2414
   } while (0);
   $156 = _luaZ_openspace($L, (HEAP32[$1 >> 2] | 0) + 144 | 0, $tl$0$lcssa) | 0; //@line 2419
   $i$1 = $i$0$lcssa; //@line 2420
   $tl$1 = 0; //@line 2420
   do {
    $159 = HEAP32[$5 + (0 - $i$1 << 4) >> 2] | 0; //@line 2424
    $161 = HEAP32[$159 + 12 >> 2] | 0; //@line 2426
    _memcpy($156 + $tl$1 | 0, $159 + 16 | 0, $161 | 0) | 0; //@line 2429
    $tl$1 = $161 + $tl$1 | 0; //@line 2430
    $i$1 = $i$1 + -1 | 0; //@line 2431
   } while (($i$1 | 0) > 0);
   $167 = 0 - $i$0$lcssa | 0; //@line 2439
   $169 = _luaS_newlstr($L, $156, $tl$1) | 0; //@line 2441
   HEAP32[$5 + ($167 << 4) >> 2] = $169; //@line 2442
   HEAP32[$5 + ($167 << 4) + 8 >> 2] = HEAPU8[$169 + 4 >> 0] | 0 | 64; //@line 2448
   $n$0 = $i$0$lcssa; //@line 2449
  } else label = 7; //@line 2451
 while (0);
  if ((label | 0) == 7) {
   label = 0; //@line 2455
   $24 = _luaT_gettmbyobj($L, $4, 15) | 0; //@line 2456
   if (!(HEAP32[$24 + 8 >> 2] | 0)) {
    $28 = _luaT_gettmbyobj($L, $11, 15) | 0; //@line 2461
    if (!(HEAP32[$28 + 8 >> 2] | 0)) {
     label = 10; //@line 2466
     break;
    } else $tm$01$i = $28; //@line 2469
   } else $tm$01$i = $24; //@line 2472
   $33 = $4 - (HEAP32[$2 >> 2] | 0) | 0; //@line 2477
   $34 = HEAP32[$0 >> 2] | 0; //@line 2478
   HEAP32[$0 >> 2] = $34 + 16; //@line 2480
   $36 = $tm$01$i; //@line 2481
   $41 = HEAP32[$36 + 4 >> 2] | 0; //@line 2486
   $42 = $34; //@line 2487
   HEAP32[$42 >> 2] = HEAP32[$36 >> 2]; //@line 2489
   HEAP32[$42 + 4 >> 2] = $41; //@line 2492
   HEAP32[$34 + 8 >> 2] = HEAP32[$tm$01$i + 8 >> 2]; //@line 2496
   $49 = HEAP32[$0 >> 2] | 0; //@line 2497
   HEAP32[$0 >> 2] = $49 + 16; //@line 2499
   $51 = $4; //@line 2500
   $56 = HEAP32[$51 + 4 >> 2] | 0; //@line 2505
   $57 = $49; //@line 2506
   HEAP32[$57 >> 2] = HEAP32[$51 >> 2]; //@line 2508
   HEAP32[$57 + 4 >> 2] = $56; //@line 2511
   HEAP32[$49 + 8 >> 2] = HEAP32[$6 >> 2]; //@line 2514
   $63 = HEAP32[$0 >> 2] | 0; //@line 2515
   HEAP32[$0 >> 2] = $63 + 16; //@line 2517
   $65 = $11; //@line 2518
   $70 = HEAP32[$65 + 4 >> 2] | 0; //@line 2523
   $71 = $63; //@line 2524
   HEAP32[$71 >> 2] = HEAP32[$65 >> 2]; //@line 2526
   HEAP32[$71 + 4 >> 2] = $70; //@line 2529
   HEAP32[$63 + 8 >> 2] = HEAP32[$5 + -8 >> 2]; //@line 2533
   _luaD_call($L, (HEAP32[$0 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$3 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 2541
   $85 = HEAP32[$2 >> 2] | 0; //@line 2542
   $87 = HEAP32[$0 >> 2] | 0; //@line 2544
   $88 = $87 + -16 | 0; //@line 2545
   HEAP32[$0 >> 2] = $88; //@line 2546
   $89 = $88; //@line 2547
   $94 = HEAP32[$89 + 4 >> 2] | 0; //@line 2552
   $95 = $85 + $33 | 0; //@line 2553
   HEAP32[$95 >> 2] = HEAP32[$89 >> 2]; //@line 2555
   HEAP32[$95 + 4 >> 2] = $94; //@line 2558
   HEAP32[$85 + ($33 + 8) >> 2] = HEAP32[$87 + -8 >> 2]; //@line 2563
   $n$0 = 2; //@line 2564
  }
  $$0 = $$0 + 1 - $n$0 | 0; //@line 2567
  $5 = (HEAP32[$0 >> 2] | 0) + (1 - $n$0 << 4) | 0; //@line 2570
  HEAP32[$0 >> 2] = $5; //@line 2571
  if (($$0 | 0) <= 1) {
   label = 30; //@line 2576
   break;
  }
 }
 if ((label | 0) == 10) _luaG_concaterror($L, $4, $11); //@line 2581
 else if ((label | 0) == 24) _luaG_runerror($L, 11856, $vararg_buffer7); //@line 2585
 else if ((label | 0) == 30) {
  STACKTOP = sp; //@line 2589
  return;
 }
}
function _str_gsub($L) {
 $L = $L | 0;
 var $$$i$i = 0, $0 = 0, $1 = 0, $105 = 0, $109 = 0, $111 = 0, $13 = 0, $14 = 0, $15 = 0, $18 = 0, $2 = 0, $20 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $28 = 0, $30 = 0, $31 = 0, $32 = 0, $43 = 0, $48 = 0, $5 = 0, $54 = 0, $55 = 0, $56 = 0, $61 = 0, $62 = 0, $63 = 0, $65 = 0, $69 = 0, $7 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $77 = 0, $79 = 0, $80 = 0, $83 = 0, $85 = 0, $b = 0, $i$01$i$i = 0, $i$01$i2$i = 0, $i$1$i$i = 0, $l$i$i = 0, $lp = 0, $ms = 0, $n$0 = 0, $n$17 = 0, $n$18 = 0, $n$2 = 0, $p$0 = 0, $src$0 = 0, $src$1 = 0, $src$2 = 0, $srcl = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 14157
 STACKTOP = STACKTOP + 1344 | 0; //@line 14158
 $vararg_buffer3 = sp; //@line 14159
 $l$i$i = sp + 1336 | 0; //@line 14160
 $srcl = sp + 1332 | 0; //@line 14161
 $lp = sp + 1328 | 0; //@line 14162
 $ms = sp + 1048 | 0; //@line 14163
 $b = sp + 8 | 0; //@line 14164
 $0 = _luaL_checklstring($L, 1, $srcl) | 0; //@line 14165
 $1 = _luaL_checklstring($L, 2, $lp) | 0; //@line 14166
 $2 = _lua_type($L, 3) | 0; //@line 14167
 $5 = _luaL_optinteger($L, 4, (HEAP32[$srcl >> 2] | 0) + 1 | 0) | 0; //@line 14170
 $7 = (HEAP8[$1 >> 0] | 0) == 94; //@line 14172
 if (!(($2 + -3 | 0) >>> 0 < 2 | ($2 | 0) == 6 | ($2 | 0) == 5)) _luaL_argerror($L, 3, 10384) | 0; //@line 14180
 _luaL_buffinit($L, $b); //@line 14182
 if ($7) {
  $13 = (HEAP32[$lp >> 2] | 0) + -1 | 0; //@line 14186
  HEAP32[$lp >> 2] = $13; //@line 14187
  $20 = $13; //@line 14188
  $p$0 = $1 + 1 | 0; //@line 14188
 } else {
  $20 = HEAP32[$lp >> 2] | 0; //@line 14191
  $p$0 = $1; //@line 14191
 }
 $14 = $ms + 16 | 0; //@line 14193
 HEAP32[$14 >> 2] = $L; //@line 14194
 HEAP32[$ms >> 2] = 200; //@line 14195
 $15 = $ms + 4 | 0; //@line 14196
 HEAP32[$15 >> 2] = $0; //@line 14197
 $18 = $ms + 8 | 0; //@line 14200
 HEAP32[$18 >> 2] = $0 + (HEAP32[$srcl >> 2] | 0); //@line 14201
 HEAP32[$ms + 12 >> 2] = $p$0 + $20; //@line 14204
 $22 = $ms + 20 | 0; //@line 14205
 $23 = $b + 8 | 0; //@line 14206
 $24 = $b + 4 | 0; //@line 14207
 $25 = $ms + 28 | 0; //@line 14208
 $26 = $ms + 24 | 0; //@line 14209
 $n$0 = 0; //@line 14210
 $src$0 = $0; //@line 14210
 while (1) {
  if ($n$0 >>> 0 >= $5 >>> 0) {
   $n$2 = $n$0; //@line 14214
   $src$2 = $src$0; //@line 14214
   label = 48; //@line 14215
   break;
  }
  HEAP32[$22 >> 2] = 0; //@line 14218
  $28 = _match($ms, $src$0, $p$0) | 0; //@line 14219
  if (!$28) {
   $n$17 = $n$0; //@line 14222
   label = 43; //@line 14223
  } else {
   $30 = $n$0 + 1 | 0; //@line 14225
   $31 = HEAP32[$14 >> 2] | 0; //@line 14226
   if (($2 | 0) == 5) {
    do if ((HEAP32[$22 >> 2] | 0) > 0) {
     $43 = HEAP32[$25 >> 2] | 0; //@line 14232
     if (($43 | 0) == -1) {
      _luaL_error($31, 10104, $vararg_buffer3) | 0; //@line 14235
      $54 = HEAP32[$14 >> 2] | 0; //@line 14238
      $55 = HEAP32[$26 >> 2] | 0; //@line 14238
     } else {
      $48 = HEAP32[$26 >> 2] | 0; //@line 14241
      if (($43 | 0) == -2) {
       _lua_pushinteger($31, $48 + 1 - (HEAP32[$15 >> 2] | 0) | 0); //@line 14248
       break;
      } else {
       $54 = $31; //@line 14251
       $55 = $48; //@line 14251
      }
     }
     _lua_pushlstring($54, $55, $43) | 0; //@line 14254
    } else _lua_pushlstring($31, $src$0, $28 - $src$0 | 0) | 0; //@line 14259
 while (0);
    _lua_gettable($31, 3); //@line 14262
    label = 37; //@line 14263
   } else if (($2 | 0) == 6) {
    _lua_pushvalue($31, 3); //@line 14265
    $32 = HEAP32[$22 >> 2] | 0; //@line 14266
    $$$i$i = ($32 | 0) != 0 | ($src$0 | 0) == 0 ? $32 : 1; //@line 14270
    _luaL_checkstack(HEAP32[$14 >> 2] | 0, $$$i$i, 10056); //@line 14272
    if (($$$i$i | 0) > 0) {
     $i$01$i$i = 0; //@line 14275
     do {
      _push_onecapture($ms, $i$01$i$i, $src$0, $28); //@line 14277
      $i$01$i$i = $i$01$i$i + 1 | 0; //@line 14278
     } while (($i$01$i$i | 0) != ($$$i$i | 0));
    }
    _lua_callk($31, $$$i$i, 1, 0, 0); //@line 14287
    label = 37; //@line 14288
   } else {
    $56 = _lua_tolstring($31, 3, $l$i$i) | 0; //@line 14290
    if (HEAP32[$l$i$i >> 2] | 0) {
     $61 = $28 - $src$0 | 0; //@line 14296
     $i$01$i2$i = 0; //@line 14297
     do {
      $62 = $56 + $i$01$i2$i | 0; //@line 14299
      $63 = HEAP8[$62 >> 0] | 0; //@line 14300
      do if ($63 << 24 >> 24 == 37) {
       $73 = $i$01$i2$i + 1 | 0; //@line 14304
       $74 = $56 + $73 | 0; //@line 14305
       $75 = HEAP8[$74 >> 0] | 0; //@line 14306
       $77 = $75 << 24 >> 24; //@line 14310
       if ((($75 & 255) + -48 | 0) >>> 0 < 10) if ($75 << 24 >> 24 == 48) {
        _luaL_addlstring($b, $src$0, $61); //@line 14314
        $i$1$i$i = $73; //@line 14315
        break;
       } else {
        _push_onecapture($ms, $77 + -49 | 0, $src$0, $28); //@line 14319
        _luaL_addvalue($b); //@line 14320
        $i$1$i$i = $73; //@line 14321
        break;
       }
       if ($75 << 24 >> 24 != 37) {
        $79 = HEAP32[$14 >> 2] | 0; //@line 14327
        HEAP32[$vararg_buffer3 >> 2] = 37; //@line 14328
        _luaL_error($79, 10456, $vararg_buffer3) | 0; //@line 14329
       }
       $80 = HEAP32[$23 >> 2] | 0; //@line 14331
       if ($80 >>> 0 < (HEAP32[$24 >> 2] | 0) >>> 0) $85 = $80; //@line 14335
 else {
        _luaL_prepbuffsize($b, 1) | 0; //@line 14337
        $85 = HEAP32[$23 >> 2] | 0; //@line 14339
       }
       $83 = HEAP8[$74 >> 0] | 0; //@line 14341
       HEAP32[$23 >> 2] = $85 + 1; //@line 14343
       HEAP8[(HEAP32[$b >> 2] | 0) + $85 >> 0] = $83; //@line 14346
       $i$1$i$i = $73; //@line 14347
      } else {
       $65 = HEAP32[$23 >> 2] | 0; //@line 14349
       if ($65 >>> 0 < (HEAP32[$24 >> 2] | 0) >>> 0) {
        $69 = $65; //@line 14353
        $72 = $63; //@line 14353
       } else {
        _luaL_prepbuffsize($b, 1) | 0; //@line 14355
        $69 = HEAP32[$23 >> 2] | 0; //@line 14358
        $72 = HEAP8[$62 >> 0] | 0; //@line 14358
       }
       HEAP32[$23 >> 2] = $69 + 1; //@line 14361
       HEAP8[(HEAP32[$b >> 2] | 0) + $69 >> 0] = $72; //@line 14364
       $i$1$i$i = $i$01$i2$i; //@line 14365
      } while (0);
      $i$01$i2$i = $i$1$i$i + 1 | 0; //@line 14368
     } while ($i$01$i2$i >>> 0 < (HEAP32[$l$i$i >> 2] | 0) >>> 0);
    }
   }
   if ((label | 0) == 37) {
    label = 0; //@line 14380
    if (!(_lua_toboolean($31, -1) | 0)) {
     _lua_settop($31, -2); //@line 14384
     _lua_pushlstring($31, $src$0, $28 - $src$0 | 0) | 0; //@line 14388
    } else if (!(_lua_isstring($31, -1) | 0)) {
     HEAP32[$vararg_buffer3 >> 2] = _lua_typename($31, _lua_type($31, -1) | 0) | 0; //@line 14395
     _luaL_error($31, 10416, $vararg_buffer3) | 0; //@line 14396
    }
    _luaL_addvalue($b); //@line 14399
   }
   if ($28 >>> 0 > $src$0 >>> 0) {
    $n$18 = $30; //@line 14403
    $src$1 = $28; //@line 14403
   } else {
    $n$17 = $30; //@line 14405
    label = 43; //@line 14406
   }
  }
  if ((label | 0) == 43) {
   label = 0; //@line 14410
   if ($src$0 >>> 0 >= (HEAP32[$18 >> 2] | 0) >>> 0) {
    $n$2 = $n$17; //@line 14414
    $src$2 = $src$0; //@line 14414
    label = 48; //@line 14415
    break;
   }
   $105 = HEAP32[$23 >> 2] | 0; //@line 14418
   if ($105 >>> 0 < (HEAP32[$24 >> 2] | 0) >>> 0) $111 = $105; //@line 14422
 else {
    _luaL_prepbuffsize($b, 1) | 0; //@line 14424
    $111 = HEAP32[$23 >> 2] | 0; //@line 14426
   }
   $109 = HEAP8[$src$0 >> 0] | 0; //@line 14429
   HEAP32[$23 >> 2] = $111 + 1; //@line 14431
   HEAP8[(HEAP32[$b >> 2] | 0) + $111 >> 0] = $109; //@line 14434
   $n$18 = $n$17; //@line 14435
   $src$1 = $src$0 + 1 | 0; //@line 14435
  }
  if ($7) {
   $n$2 = $n$18; //@line 14438
   $src$2 = $src$1; //@line 14438
   label = 48; //@line 14439
   break;
  } else {
   $n$0 = $n$18; //@line 14442
   $src$0 = $src$1; //@line 14442
  }
 }
 if ((label | 0) == 48) {
  _luaL_addlstring($b, $src$2, (HEAP32[$18 >> 2] | 0) - $src$2 | 0); //@line 14450
  _luaL_pushresult($b); //@line 14451
  _lua_pushinteger($L, $n$2); //@line 14452
  STACKTOP = sp; //@line 14453
  return 2; //@line 14453
 }
 return 0; //@line 14455
}
function _luaK_prefix($fs, $op, $e, $line) {
 $fs = $fs | 0;
 $op = $op | 0;
 $e = $e | 0;
 $line = $line | 0;
 var $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i9$i = 0, $$03$i$i = 0, $$03$i6$i = 0, $$pre$phi18$iZ2D = 0, $101 = 0, $107 = 0, $108 = 0, $11 = 0, $110 = 0, $111 = 0, $117 = 0, $125 = 0, $138 = 0, $22 = 0, $29 = 0, $30 = 0, $32 = 0, $33 = 0, $39 = 0, $45 = 0, $46 = 0, $48 = 0, $50 = 0, $59 = 0, $60 = 0, $64 = 0, $65 = 0, $72 = 0, $79 = 0, $80 = 0, $81 = 0, $82 = 0, $84 = 0, $86 = 0, $87 = 0, $93 = 0, $e2 = 0, $fs$idx$val$idx$val$i = 0, $fs$idx1$val$idx$val$pre$i$i = 0, $fs$idx1$val$idx$val$pre$i4$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11696
 STACKTOP = STACKTOP + 32 | 0; //@line 11697
 $e2 = sp; //@line 11698
 HEAP32[$e2 + 20 >> 2] = -1; //@line 11700
 HEAP32[$e2 + 16 >> 2] = -1; //@line 11702
 HEAP32[$e2 >> 2] = 5; //@line 11703
 HEAPF64[$e2 + 8 >> 3] = 0.0; //@line 11705
 if (($op | 0) == 1) {
  _luaK_dischargevars($fs, $e); //@line 11707
  switch (HEAP32[$e >> 2] | 0) {
  case 6:
   {
    label = 25; //@line 11711
    break;
   }
  case 3:
  case 1:
   {
    HEAP32[$e >> 2] = 2; //@line 11715
    break;
   }
  case 2:
  case 5:
  case 4:
   {
    HEAP32[$e >> 2] = 3; //@line 11719
    break;
   }
  case 10:
   {
    $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11725
    $29 = HEAP32[$e + 8 >> 2] | 0; //@line 11727
    $30 = $fs$idx$val$idx$val$i + ($29 << 2) | 0; //@line 11728
    if (($29 | 0) > 0) {
     $32 = $fs$idx$val$idx$val$i + ($29 + -1 << 2) | 0; //@line 11732
     $33 = HEAP32[$32 >> 2] | 0; //@line 11733
     if ((HEAP8[8440 + ($33 & 63) >> 0] | 0) < 0) {
      $$0$i$i$i = $32; //@line 11739
      $39 = $33; //@line 11739
     } else label = 17; //@line 11741
    } else label = 17; //@line 11744
    if ((label | 0) == 17) {
     $$0$i$i$i = $30; //@line 11748
     $39 = HEAP32[$30 >> 2] | 0; //@line 11748
    }
    HEAP32[$$0$i$i$i >> 2] = (($39 & 16320 | 0) == 0 & 1) << 6 | $39 & -16321; //@line 11756
    break;
   }
  case 11:
   {
    $45 = $fs + 48 | 0; //@line 11760
    $46 = HEAP8[$45 >> 0] | 0; //@line 11761
    $48 = ($46 & 255) + 1 | 0; //@line 11763
    $50 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 11765
    do if ($48 >>> 0 > (HEAPU8[$50 >> 0] | 0) >>> 0) if ($48 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 11775
 else {
     HEAP8[$50 >> 0] = $48; //@line 11779
     $59 = HEAP8[$45 >> 0] | 0; //@line 11781
     break;
    } else $59 = $46; //@line 11785
 while (0);
    $60 = ($59 & 255) + 1 | 0; //@line 11789
    HEAP8[$45 >> 0] = $60; //@line 11791
    _discharge2reg($fs, $e, ($60 & 255) + -1 | 0); //@line 11794
    if ((HEAP32[$e >> 2] | 0) == 6) label = 25; //@line 11798
 else {
     $$pre$phi18$iZ2D = $e + 8 | 0; //@line 11801
     label = 28; //@line 11802
    }
    break;
   }
  default:
   {}
  }
  if ((label | 0) == 25) {
   $64 = $e + 8 | 0; //@line 11810
   $65 = HEAP32[$64 >> 2] | 0; //@line 11811
   if (!($65 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0) > ($65 | 0)) {
    $$pre$phi18$iZ2D = $64; //@line 11820
    label = 28; //@line 11821
   } else {
    $72 = $fs + 48 | 0; //@line 11823
    HEAP8[$72 >> 0] = (HEAP8[$72 >> 0] | 0) + -1 << 24 >> 24; //@line 11826
    $$pre$phi18$iZ2D = $64; //@line 11827
    label = 28; //@line 11828
   } else {
    $$pre$phi18$iZ2D = $64; //@line 11831
    label = 28; //@line 11832
   }
  }
  if ((label | 0) == 28) {
   HEAP32[$$pre$phi18$iZ2D >> 2] = _luaK_code($fs, HEAP32[$$pre$phi18$iZ2D >> 2] << 23 | 20) | 0; //@line 11840
   HEAP32[$e >> 2] = 11; //@line 11841
  }
  $79 = $e + 20 | 0; //@line 11843
  $80 = HEAP32[$79 >> 2] | 0; //@line 11844
  $81 = $e + 16 | 0; //@line 11845
  $82 = HEAP32[$81 >> 2] | 0; //@line 11846
  HEAP32[$79 >> 2] = $82; //@line 11847
  HEAP32[$81 >> 2] = $80; //@line 11848
  if (($82 | 0) == -1) $107 = $80; //@line 11851
 else {
   $fs$idx1$val$idx$val$pre$i4$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11855
   $$03$i6$i = $82; //@line 11856
   do {
    $84 = $fs$idx1$val$idx$val$pre$i4$i + ($$03$i6$i << 2) | 0; //@line 11858
    if (($$03$i6$i | 0) > 0) {
     $86 = $fs$idx1$val$idx$val$pre$i4$i + ($$03$i6$i + -1 << 2) | 0; //@line 11862
     $87 = HEAP32[$86 >> 2] | 0; //@line 11863
     if ((HEAP8[8440 + ($87 & 63) >> 0] | 0) < 0) {
      $$0$i$i$i9$i = $86; //@line 11869
      $93 = $87; //@line 11869
     } else label = 33; //@line 11871
    } else label = 33; //@line 11874
    if ((label | 0) == 33) {
     label = 0; //@line 11877
     $$0$i$i$i9$i = $84; //@line 11879
     $93 = HEAP32[$84 >> 2] | 0; //@line 11879
    }
    if (($93 & 63 | 0) == 28) HEAP32[$$0$i$i$i9$i >> 2] = $93 & 8372224 | $93 >>> 23 << 6 | 27; //@line 11889
    $101 = ((HEAP32[$84 >> 2] | 0) >>> 14) + -131071 | 0; //@line 11893
    if (($101 | 0) == -1) break;
    $$03$i6$i = $$03$i6$i + 1 + $101 | 0; //@line 11899
   } while (($$03$i6$i | 0) != -1);
   $107 = HEAP32[$81 >> 2] | 0; //@line 11908
  }
  if (($107 | 0) == -1) {
   STACKTOP = sp; //@line 11912
   return;
  }
  $fs$idx1$val$idx$val$pre$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11916
  $$03$i$i = $107; //@line 11917
  while (1) {
   $108 = $fs$idx1$val$idx$val$pre$i$i + ($$03$i$i << 2) | 0; //@line 11919
   if (($$03$i$i | 0) > 0) {
    $110 = $fs$idx1$val$idx$val$pre$i$i + ($$03$i$i + -1 << 2) | 0; //@line 11923
    $111 = HEAP32[$110 >> 2] | 0; //@line 11924
    if ((HEAP8[8440 + ($111 & 63) >> 0] | 0) < 0) {
     $$0$i$i$i$i = $110; //@line 11930
     $117 = $111; //@line 11930
    } else label = 43; //@line 11932
   } else label = 43; //@line 11935
   if ((label | 0) == 43) {
    label = 0; //@line 11938
    $$0$i$i$i$i = $108; //@line 11940
    $117 = HEAP32[$108 >> 2] | 0; //@line 11940
   }
   if (($117 & 63 | 0) == 28) HEAP32[$$0$i$i$i$i >> 2] = $117 & 8372224 | $117 >>> 23 << 6 | 27; //@line 11950
   $125 = ((HEAP32[$108 >> 2] | 0) >>> 14) + -131071 | 0; //@line 11954
   if (($125 | 0) == -1) {
    label = 54; //@line 11957
    break;
   }
   $$03$i$i = $$03$i$i + 1 + $125 | 0; //@line 11961
   if (($$03$i$i | 0) == -1) {
    label = 54; //@line 11964
    break;
   }
  }
  if ((label | 0) == 54) {
   STACKTOP = sp; //@line 11971
   return;
  }
 } else if (!$op) {
  if ((HEAP32[$e >> 2] | 0) == 5) if ((HEAP32[$e + 16 >> 2] | 0) == -1) if ((HEAP32[$e + 20 >> 2] | 0) == -1) {
   $11 = $e + 8 | 0; //@line 11985
   HEAPF64[$11 >> 3] = -+HEAPF64[$11 >> 3]; //@line 11988
   STACKTOP = sp; //@line 11989
   return;
  }
  _luaK_dischargevars($fs, $e); //@line 11993
  if ((HEAP32[$e >> 2] | 0) == 6) {
   $22 = HEAP32[$e + 8 >> 2] | 0; //@line 12003
   if ((HEAP32[$e + 16 >> 2] | 0) != (HEAP32[$e + 20 >> 2] | 0)) if (($22 | 0) < (HEAPU8[$fs + 46 >> 0] | 0)) label = 10; //@line 12010
 else _exp2reg($fs, $e, $22); //@line 12012
  } else label = 10; //@line 12016
  if ((label | 0) == 10) _luaK_exp2nextreg($fs, $e); //@line 12019
  _codearith($fs, 19, $e, $e2, $line); //@line 12021
  STACKTOP = sp; //@line 12022
  return;
 } else if (($op | 0) == 2) {
  _luaK_dischargevars($fs, $e); //@line 12024
  if ((HEAP32[$e >> 2] | 0) == 6) {
   $138 = HEAP32[$e + 8 >> 2] | 0; //@line 12034
   if ((HEAP32[$e + 16 >> 2] | 0) != (HEAP32[$e + 20 >> 2] | 0)) if (($138 | 0) < (HEAPU8[$fs + 46 >> 0] | 0)) label = 52; //@line 12041
 else _exp2reg($fs, $e, $138); //@line 12043
  } else label = 52; //@line 12047
  if ((label | 0) == 52) _luaK_exp2nextreg($fs, $e); //@line 12050
  _codearith($fs, 21, $e, $e2, $line); //@line 12052
  STACKTOP = sp; //@line 12053
  return;
 } else {
  STACKTOP = sp; //@line 12055
  return;
 }
}
function _getobjname($p, $lastpc, $reg, $name) {
 $p = $p | 0;
 $lastpc = $lastpc | 0;
 $reg = $reg | 0;
 $name = $name | 0;
 var $$0 = 0, $$0$i = 0, $0 = 0, $10 = 0, $106 = 0, $2 = 0, $23 = 0, $36 = 0, $37 = 0, $42 = 0, $43 = 0, $44 = 0, $49 = 0, $5 = 0, $54 = 0, $56 = 0, $64 = 0, $69 = 0, $7 = 0, $71 = 0, $74 = 0, $8 = 0, $83 = 0, $85 = 0, $92 = 0, $95 = 0, $97 = 0, $jmptarget$07$i = 0, $jmptarget$1$i = 0, $lastpc$tr = 0, $pc$09$i = 0, $reg$tr = 0, $setreg$08$i = 0, $setreg$1$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 14770
 $0 = $p + 12 | 0; //@line 14771
 $lastpc$tr = $lastpc; //@line 14772
 $reg$tr = $reg; //@line 14772
 L1 : while (1) {
  $2 = _luaF_getlocalname($p, $reg$tr + 1 | 0, $lastpc$tr) | 0; //@line 14775
  HEAP32[$name >> 2] = $2; //@line 14776
  if ($2) {
   $$0 = 4080; //@line 14779
   label = 47; //@line 14780
   break;
  }
  if (($lastpc$tr | 0) <= 0) {
   $$0 = 0; //@line 14785
   label = 47; //@line 14786
   break;
  }
  $5 = HEAP32[$0 >> 2] | 0; //@line 14789
  $jmptarget$07$i = 0; //@line 14790
  $pc$09$i = 0; //@line 14790
  $setreg$08$i = -1; //@line 14790
  while (1) {
   $7 = HEAP32[$5 + ($pc$09$i << 2) >> 2] | 0; //@line 14793
   $8 = $7 & 63; //@line 14794
   $10 = $7 >>> 6 & 255; //@line 14796
   switch ($8 | 0) {
   case 34:
    {
     if (($10 + 2 | 0) > ($reg$tr | 0)) {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14802
      $setreg$1$i = $setreg$08$i; //@line 14802
     } else {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14806
      $setreg$1$i = ($pc$09$i | 0) < ($jmptarget$07$i | 0) ? -1 : $pc$09$i; //@line 14806
     }
     break;
    }
   case 4:
    {
     if (($10 | 0) > ($reg$tr | 0)) {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14813
      $setreg$1$i = $setreg$08$i; //@line 14813
     } else if (($10 + ($7 >>> 23) | 0) < ($reg$tr | 0)) {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14819
      $setreg$1$i = $setreg$08$i; //@line 14819
     } else {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14823
      $setreg$1$i = ($pc$09$i | 0) < ($jmptarget$07$i | 0) ? -1 : $pc$09$i; //@line 14823
     }
     break;
    }
   case 30:
   case 29:
    {
     if (($10 | 0) > ($reg$tr | 0)) {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14831
      $setreg$1$i = $setreg$08$i; //@line 14831
     } else {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14835
      $setreg$1$i = ($pc$09$i | 0) < ($jmptarget$07$i | 0) ? -1 : $pc$09$i; //@line 14835
     }
     break;
    }
   case 23:
    {
     $23 = $pc$09$i + -131070 + ($7 >>> 14) | 0; //@line 14842
     $jmptarget$1$i = ($23 | 0) <= ($lastpc$tr | 0) & ($pc$09$i | 0) < ($23 | 0) & ($23 | 0) > ($jmptarget$07$i | 0) ? $23 : $jmptarget$07$i; //@line 14849
     $setreg$1$i = $setreg$08$i; //@line 14849
     break;
    }
   case 27:
    {
     if (($10 | 0) == ($reg$tr | 0)) {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14857
      $setreg$1$i = ($pc$09$i | 0) < ($jmptarget$07$i | 0) ? -1 : $pc$09$i; //@line 14857
     } else {
      $jmptarget$1$i = $jmptarget$07$i; //@line 14859
      $setreg$1$i = $setreg$08$i; //@line 14859
     }
     break;
    }
   default:
    if ((HEAP8[8440 + $8 >> 0] & 64) != 0 & ($10 | 0) == ($reg$tr | 0)) {
     $jmptarget$1$i = $jmptarget$07$i; //@line 14873
     $setreg$1$i = ($pc$09$i | 0) < ($jmptarget$07$i | 0) ? -1 : $pc$09$i; //@line 14873
    } else {
     $jmptarget$1$i = $jmptarget$07$i; //@line 14875
     $setreg$1$i = $setreg$08$i; //@line 14875
    }
   }
   $pc$09$i = $pc$09$i + 1 | 0; //@line 14879
   if (($pc$09$i | 0) == ($lastpc$tr | 0)) break; else {
    $jmptarget$07$i = $jmptarget$1$i; //@line 14884
    $setreg$08$i = $setreg$1$i; //@line 14884
   }
  }
  if (($setreg$1$i | 0) == -1) {
   $$0 = 0; //@line 14889
   label = 47; //@line 14890
   break;
  }
  $36 = HEAP32[$5 + ($setreg$1$i << 2) >> 2] | 0; //@line 14894
  $37 = $36 & 63; //@line 14895
  switch ($37 | 0) {
  case 0:
   break;
  case 1:
   {
    label = 37; //@line 14901
    break L1;
    break;
   }
  case 2:
   {
    label = 38; //@line 14906
    break L1;
    break;
   }
  case 12:
   {
    label = 41; //@line 14911
    break L1;
    break;
   }
  case 7:
  case 6:
   {
    label = 22; //@line 14916
    break L1;
    break;
   }
  case 5:
   {
    label = 34; //@line 14921
    break L1;
    break;
   }
  default:
   {
    $$0 = 0; //@line 14926
    label = 47; //@line 14927
    break L1;
   }
  }
  $reg$tr = $36 >>> 23; //@line 14931
  if ($reg$tr >>> 0 >= ($36 >>> 6 & 255) >>> 0) {
   $$0 = 0; //@line 14938
   label = 47; //@line 14939
   break;
  } else $lastpc$tr = $setreg$1$i; //@line 14936
 }
 if ((label | 0) == 22) {
  $42 = $36 >>> 14; //@line 14944
  $43 = $42 & 511; //@line 14945
  $44 = $36 >>> 23; //@line 14946
  if (($37 | 0) == 7) $69 = _luaF_getlocalname($p, $44 + 1 | 0, $setreg$1$i) | 0; //@line 14951
 else {
   $49 = HEAP32[(HEAP32[$p + 28 >> 2] | 0) + ($44 << 3) >> 2] | 0; //@line 14956
   if (!$49) $69 = 4144; //@line 14959
 else $69 = $49 + 16 | 0; //@line 14962
  }
  if (!($42 & 256)) {
   $64 = _getobjname($p, $setreg$1$i, $43, $name) | 0; //@line 14968
   if (!$64) label = 31; //@line 14971
 else if ((HEAP8[$64 >> 0] | 0) != 99) label = 31; //@line 14976
  } else {
   $54 = $42 & 255; //@line 14980
   $56 = HEAP32[$p + 8 >> 2] | 0; //@line 14982
   if ((HEAP32[$56 + ($54 << 4) + 8 >> 2] & 15 | 0) == 4) HEAP32[$name >> 2] = (HEAP32[$56 + ($54 << 4) >> 2] | 0) + 16; //@line 14991
 else label = 31; //@line 14993
  }
  if ((label | 0) == 31) HEAP32[$name >> 2] = 4144; //@line 14997
  if (!$69) {
   $$0 = 4104; //@line 15001
   STACKTOP = sp; //@line 15002
   return $$0 | 0; //@line 15002
  }
  $71 = (_strcmp($69, 4088) | 0) == 0; //@line 15005
  $$0 = $71 ? 4096 : 4104; //@line 15007
  STACKTOP = sp; //@line 15008
  return $$0 | 0; //@line 15008
 } else if ((label | 0) == 34) {
  $74 = HEAP32[(HEAP32[$p + 28 >> 2] | 0) + ($36 >>> 23 << 3) >> 2] | 0; //@line 15015
  if (!$74) $$0$i = 4144; //@line 15018
 else $$0$i = $74 + 16 | 0; //@line 15021
  HEAP32[$name >> 2] = $$0$i; //@line 15023
  $$0 = 4112; //@line 15024
  STACKTOP = sp; //@line 15025
  return $$0 | 0; //@line 15025
 } else if ((label | 0) == 37) $85 = $36 >>> 14; //@line 15029
 else if ((label | 0) == 38) $85 = (HEAP32[$5 + ($setreg$1$i + 1 << 2) >> 2] | 0) >>> 6; //@line 15036
 else if ((label | 0) == 41) {
  $92 = $36 >>> 14; //@line 15039
  if (!($92 & 256)) {
   $106 = _getobjname($p, $setreg$1$i, $92 & 511, $name) | 0; //@line 15044
   if ($106) if ((HEAP8[$106 >> 0] | 0) == 99) {
    $$0 = 4136; //@line 15050
    STACKTOP = sp; //@line 15051
    return $$0 | 0; //@line 15051
   }
  } else {
   $95 = $92 & 255; //@line 15055
   $97 = HEAP32[$p + 8 >> 2] | 0; //@line 15057
   if ((HEAP32[$97 + ($95 << 4) + 8 >> 2] & 15 | 0) == 4) {
    HEAP32[$name >> 2] = (HEAP32[$97 + ($95 << 4) >> 2] | 0) + 16; //@line 15066
    $$0 = 4136; //@line 15067
    STACKTOP = sp; //@line 15068
    return $$0 | 0; //@line 15068
   }
  }
  HEAP32[$name >> 2] = 4144; //@line 15071
  $$0 = 4136; //@line 15072
  STACKTOP = sp; //@line 15073
  return $$0 | 0; //@line 15073
 } else if ((label | 0) == 47) {
  STACKTOP = sp; //@line 15076
  return $$0 | 0; //@line 15076
 }
 $83 = HEAP32[$p + 8 >> 2] | 0; //@line 15079
 if ((HEAP32[$83 + ($85 << 4) + 8 >> 2] & 15 | 0) != 4) {
  $$0 = 0; //@line 15085
  STACKTOP = sp; //@line 15086
  return $$0 | 0; //@line 15086
 }
 HEAP32[$name >> 2] = (HEAP32[$83 + ($85 << 4) >> 2] | 0) + 16; //@line 15091
 $$0 = 4120; //@line 15092
 STACKTOP = sp; //@line 15093
 return $$0 | 0; //@line 15093
}
function _luaV_lessequal($L, $l, $r) {
 $L = $L | 0;
 $l = $l | 0;
 $r = $r | 0;
 var $$0 = 0, $$0$i = 0, $0 = 0, $1 = 0, $105 = 0, $107 = 0, $108 = 0, $109 = 0, $114 = 0, $115 = 0, $122 = 0, $124 = 0, $129 = 0, $130 = 0, $131 = 0, $135 = 0, $137 = 0, $141 = 0, $142 = 0, $144 = 0, $149 = 0, $150 = 0, $157 = 0, $159 = 0, $16 = 0, $164 = 0, $165 = 0, $17 = 0, $172 = 0, $174 = 0, $179 = 0, $18 = 0, $180 = 0, $19 = 0, $194 = 0, $196 = 0, $197 = 0, $198 = 0, $20 = 0, $203 = 0, $204 = 0, $211 = 0, $213 = 0, $218 = 0, $26 = 0, $28 = 0, $31 = 0, $36 = 0, $40 = 0, $41 = 0, $42 = 0, $46 = 0, $48 = 0, $52 = 0, $53 = 0, $55 = 0, $60 = 0, $61 = 0, $68 = 0, $70 = 0, $75 = 0, $76 = 0, $82 = 0, $84 = 0, $89 = 0, $90 = 0, $l$01$i = 0, $ll$02$i = 0, $lr$04$i = 0, $r$03$i = 0, $tm$01$i$i = 0, $tm$01$i$i4 = 0, sp = 0;
 sp = STACKTOP; //@line 1499
 $0 = $l + 8 | 0; //@line 1500
 $1 = HEAP32[$0 >> 2] | 0; //@line 1501
 if (($1 | 0) == 3) {
  if ((HEAP32[$r + 8 >> 2] | 0) == 3) {
   $$0 = +HEAPF64[$l >> 3] <= +HEAPF64[$r >> 3] & 1; //@line 1512
   STACKTOP = sp; //@line 1513
   return $$0 | 0; //@line 1513
  }
 } else if (($1 & 15 | 0) == 4) if ((HEAP32[$r + 8 >> 2] & 15 | 0) == 4) {
  $16 = HEAP32[$l >> 2] | 0; //@line 1524
  $17 = HEAP32[$r >> 2] | 0; //@line 1525
  $18 = $16 + 16 | 0; //@line 1526
  $19 = $17 + 16 | 0; //@line 1527
  $20 = _strcoll($18, $19) | 0; //@line 1528
  L5 : do if (!$20) {
   $l$01$i = $18; //@line 1536
   $ll$02$i = HEAP32[$16 + 12 >> 2] | 0; //@line 1536
   $lr$04$i = HEAP32[$17 + 12 >> 2] | 0; //@line 1536
   $r$03$i = $19; //@line 1536
   while (1) {
    $26 = _strlen($l$01$i | 0) | 0; //@line 1538
    $28 = ($26 | 0) == ($ll$02$i | 0); //@line 1540
    if (($26 | 0) == ($lr$04$i | 0)) break;
    if ($28) {
     $$0$i = -1; //@line 1545
     break L5;
    }
    $31 = $26 + 1 | 0; //@line 1548
    $l$01$i = $l$01$i + $31 | 0; //@line 1549
    $r$03$i = $r$03$i + $31 | 0; //@line 1551
    $36 = _strcoll($l$01$i, $r$03$i) | 0; //@line 1553
    if ($36) {
     $$0$i = $36; //@line 1558
     break L5;
    } else {
     $ll$02$i = $ll$02$i - $31 | 0; //@line 1556
     $lr$04$i = $lr$04$i - $31 | 0; //@line 1556
    }
   }
   $$0$i = $28 & 1 ^ 1; //@line 1564
  } else $$0$i = $20; //@line 1566
 while (0);
  $$0 = ($$0$i | 0) < 1 & 1; //@line 1571
  STACKTOP = sp; //@line 1572
  return $$0 | 0; //@line 1572
 }
 $40 = $L + 8 | 0; //@line 1576
 $41 = HEAP32[$40 >> 2] | 0; //@line 1577
 $42 = _luaT_gettmbyobj($L, $l, 14) | 0; //@line 1578
 if (!(HEAP32[$42 + 8 >> 2] | 0)) {
  $46 = _luaT_gettmbyobj($L, $r, 14) | 0; //@line 1583
  if (!(HEAP32[$46 + 8 >> 2] | 0)) {
   $130 = HEAP32[$40 >> 2] | 0; //@line 1588
   $131 = _luaT_gettmbyobj($L, $r, 13) | 0; //@line 1589
   if (!(HEAP32[$131 + 8 >> 2] | 0)) {
    $135 = _luaT_gettmbyobj($L, $l, 13) | 0; //@line 1594
    if (!(HEAP32[$135 + 8 >> 2] | 0)) _luaG_ordererror($L, $l, $r); //@line 1599
 else $tm$01$i$i4 = $135; //@line 1602
   } else $tm$01$i$i4 = $131; //@line 1605
   $137 = $L + 28 | 0; //@line 1607
   $141 = $130 - (HEAP32[$137 >> 2] | 0) | 0; //@line 1611
   $142 = HEAP32[$40 >> 2] | 0; //@line 1612
   HEAP32[$40 >> 2] = $142 + 16; //@line 1614
   $144 = $tm$01$i$i4; //@line 1615
   $149 = HEAP32[$144 + 4 >> 2] | 0; //@line 1620
   $150 = $142; //@line 1621
   HEAP32[$150 >> 2] = HEAP32[$144 >> 2]; //@line 1623
   HEAP32[$150 + 4 >> 2] = $149; //@line 1626
   HEAP32[$142 + 8 >> 2] = HEAP32[$tm$01$i$i4 + 8 >> 2]; //@line 1630
   $157 = HEAP32[$40 >> 2] | 0; //@line 1631
   HEAP32[$40 >> 2] = $157 + 16; //@line 1633
   $159 = $r; //@line 1634
   $164 = HEAP32[$159 + 4 >> 2] | 0; //@line 1639
   $165 = $157; //@line 1640
   HEAP32[$165 >> 2] = HEAP32[$159 >> 2]; //@line 1642
   HEAP32[$165 + 4 >> 2] = $164; //@line 1645
   HEAP32[$157 + 8 >> 2] = HEAP32[$r + 8 >> 2]; //@line 1649
   $172 = HEAP32[$40 >> 2] | 0; //@line 1650
   HEAP32[$40 >> 2] = $172 + 16; //@line 1652
   $174 = $l; //@line 1653
   $179 = HEAP32[$174 + 4 >> 2] | 0; //@line 1658
   $180 = $172; //@line 1659
   HEAP32[$180 >> 2] = HEAP32[$174 >> 2]; //@line 1661
   HEAP32[$180 + 4 >> 2] = $179; //@line 1664
   HEAP32[$172 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 1667
   _luaD_call($L, (HEAP32[$40 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 1676
   $194 = HEAP32[$137 >> 2] | 0; //@line 1677
   $196 = HEAP32[$40 >> 2] | 0; //@line 1679
   $197 = $196 + -16 | 0; //@line 1680
   HEAP32[$40 >> 2] = $197; //@line 1681
   $198 = $197; //@line 1682
   $203 = HEAP32[$198 + 4 >> 2] | 0; //@line 1687
   $204 = $194 + $141 | 0; //@line 1688
   HEAP32[$204 >> 2] = HEAP32[$198 >> 2]; //@line 1690
   HEAP32[$204 + 4 >> 2] = $203; //@line 1693
   HEAP32[$194 + ($141 + 8) >> 2] = HEAP32[$196 + -8 >> 2]; //@line 1698
   $211 = HEAP32[$40 >> 2] | 0; //@line 1699
   $213 = HEAP32[$211 + 8 >> 2] | 0; //@line 1701
   if (!$213) $218 = 0; //@line 1704
 else if (($213 | 0) == 1) $218 = (HEAP32[$211 >> 2] | 0) != 0; //@line 1710
 else $218 = 1; //@line 1712
   $$0 = $218 & 1 ^ 1; //@line 1717
   STACKTOP = sp; //@line 1718
   return $$0 | 0; //@line 1718
  } else $tm$01$i$i = $46; //@line 1720
 } else $tm$01$i$i = $42; //@line 1723
 $48 = $L + 28 | 0; //@line 1725
 $52 = $41 - (HEAP32[$48 >> 2] | 0) | 0; //@line 1729
 $53 = HEAP32[$40 >> 2] | 0; //@line 1730
 HEAP32[$40 >> 2] = $53 + 16; //@line 1732
 $55 = $tm$01$i$i; //@line 1733
 $60 = HEAP32[$55 + 4 >> 2] | 0; //@line 1738
 $61 = $53; //@line 1739
 HEAP32[$61 >> 2] = HEAP32[$55 >> 2]; //@line 1741
 HEAP32[$61 + 4 >> 2] = $60; //@line 1744
 HEAP32[$53 + 8 >> 2] = HEAP32[$tm$01$i$i + 8 >> 2]; //@line 1748
 $68 = HEAP32[$40 >> 2] | 0; //@line 1749
 HEAP32[$40 >> 2] = $68 + 16; //@line 1751
 $70 = $l; //@line 1752
 $75 = HEAP32[$70 + 4 >> 2] | 0; //@line 1757
 $76 = $68; //@line 1758
 HEAP32[$76 >> 2] = HEAP32[$70 >> 2]; //@line 1760
 HEAP32[$76 + 4 >> 2] = $75; //@line 1763
 HEAP32[$68 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 1766
 $82 = HEAP32[$40 >> 2] | 0; //@line 1767
 HEAP32[$40 >> 2] = $82 + 16; //@line 1769
 $84 = $r; //@line 1770
 $89 = HEAP32[$84 + 4 >> 2] | 0; //@line 1775
 $90 = $82; //@line 1776
 HEAP32[$90 >> 2] = HEAP32[$84 >> 2]; //@line 1778
 HEAP32[$90 + 4 >> 2] = $89; //@line 1781
 HEAP32[$82 + 8 >> 2] = HEAP32[$r + 8 >> 2]; //@line 1785
 _luaD_call($L, (HEAP32[$40 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 1794
 $105 = HEAP32[$48 >> 2] | 0; //@line 1795
 $107 = HEAP32[$40 >> 2] | 0; //@line 1797
 $108 = $107 + -16 | 0; //@line 1798
 HEAP32[$40 >> 2] = $108; //@line 1799
 $109 = $108; //@line 1800
 $114 = HEAP32[$109 + 4 >> 2] | 0; //@line 1805
 $115 = $105 + $52 | 0; //@line 1806
 HEAP32[$115 >> 2] = HEAP32[$109 >> 2]; //@line 1808
 HEAP32[$115 + 4 >> 2] = $114; //@line 1811
 HEAP32[$105 + ($52 + 8) >> 2] = HEAP32[$107 + -8 >> 2]; //@line 1816
 $122 = HEAP32[$40 >> 2] | 0; //@line 1817
 $124 = HEAP32[$122 + 8 >> 2] | 0; //@line 1819
 if (!$124) $129 = 0; //@line 1822
 else if (($124 | 0) == 1) $129 = (HEAP32[$122 >> 2] | 0) != 0; //@line 1828
 else $129 = 1; //@line 1830
 $$0 = $129 & 1; //@line 1834
 STACKTOP = sp; //@line 1835
 return $$0 | 0; //@line 1835
}
function _subexpr($ls, $v, $limit) {
 $ls = $ls | 0;
 $v = $v | 0;
 $limit = $limit | 0;
 var $$0$i2$ph = 0, $0 = 0, $10 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $19 = 0, $2 = 0, $29 = 0, $4 = 0, $46 = 0, $53 = 0, $58 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $ls$idx = 0, $ls$idx$val = 0, $ls$idx1 = 0, $op$0$lcssa = 0, $op$0$ph$ph = 0, $op$04 = 0, $v2 = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, label = 0, sp = 0, $op$04$looptemp = 0;
 sp = STACKTOP; //@line 10734
 STACKTOP = STACKTOP + 48 | 0; //@line 10735
 $vararg_buffer1 = sp + 24 | 0; //@line 10736
 $v2 = sp; //@line 10737
 $ls$idx = $ls + 48 | 0; //@line 10738
 $ls$idx$val = HEAP32[$ls$idx >> 2] | 0; //@line 10739
 $ls$idx1 = $ls + 52 | 0; //@line 10740
 $0 = (HEAP32[$ls$idx1 >> 2] | 0) + 38 | 0; //@line 10742
 $2 = (HEAP16[$0 >> 1] | 0) + 1 << 16 >> 16; //@line 10744
 HEAP16[$0 >> 1] = $2; //@line 10745
 if (($2 & 65535) > 200) {
  $4 = $ls$idx$val + 12 | 0; //@line 10748
  $7 = HEAP32[(HEAP32[$4 >> 2] | 0) + 52 >> 2] | 0; //@line 10751
  $10 = HEAP32[(HEAP32[$ls$idx$val >> 2] | 0) + 64 >> 2] | 0; //@line 10754
  if (!$10) {
   $13 = 9408; //@line 10757
   HEAP32[$vararg_buffer1 >> 2] = 9216; //@line 10758
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 10759
   HEAP32[$vararg_ptr4 >> 2] = 200; //@line 10760
   $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 10761
   HEAP32[$vararg_ptr5 >> 2] = $13; //@line 10762
   $14 = _luaO_pushfstring($7, 9448, $vararg_buffer1) | 0; //@line 10763
   $15 = HEAP32[$4 >> 2] | 0; //@line 10764
   _luaX_syntaxerror($15, $14); //@line 10765
  }
  HEAP32[$vararg_buffer1 >> 2] = $10; //@line 10768
  $13 = _luaO_pushfstring($7, 9424, $vararg_buffer1) | 0; //@line 10770
  HEAP32[$vararg_buffer1 >> 2] = 9216; //@line 10771
  $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 10772
  HEAP32[$vararg_ptr4 >> 2] = 200; //@line 10773
  $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 10774
  HEAP32[$vararg_ptr5 >> 2] = $13; //@line 10775
  $14 = _luaO_pushfstring($7, 9448, $vararg_buffer1) | 0; //@line 10776
  $15 = HEAP32[$4 >> 2] | 0; //@line 10777
  _luaX_syntaxerror($15, $14); //@line 10778
 }
 $16 = $ls + 16 | 0; //@line 10781
 L8 : do switch (HEAP32[$16 >> 2] | 0) {
 case 45:
  {
   $$0$i2$ph = 0; //@line 10786
   label = 8; //@line 10787
   break;
  }
 case 271:
  {
   $$0$i2$ph = 1; //@line 10791
   label = 8; //@line 10792
   break;
  }
 case 35:
  {
   $$0$i2$ph = 2; //@line 10796
   label = 8; //@line 10797
   break;
  }
 case 289:
  {
   $29 = _luaK_stringK($ls$idx$val, HEAP32[$ls + 24 >> 2] | 0) | 0; //@line 10803
   HEAP32[$v + 16 >> 2] = -1; //@line 10805
   HEAP32[$v + 20 >> 2] = -1; //@line 10807
   HEAP32[$v >> 2] = 4; //@line 10808
   HEAP32[$v + 8 >> 2] = $29; //@line 10810
   label = 20; //@line 10811
   break;
  }
 case 265:
  {
   _luaX_next($ls); //@line 10815
   _body($ls, $v, 0, HEAP32[$ls + 4 >> 2] | 0); //@line 10818
   break;
  }
 case 123:
  {
   _constructor($ls, $v); //@line 10822
   break;
  }
 case 280:
  {
   if (!(HEAP8[(HEAP32[$ls$idx$val >> 2] | 0) + 77 >> 0] | 0)) _luaX_syntaxerror($ls, 9264); //@line 10831
 else {
    $46 = _luaK_codeABC($ls$idx$val, 38, 0, 1, 0) | 0; //@line 10834
    HEAP32[$v + 16 >> 2] = -1; //@line 10836
    HEAP32[$v + 20 >> 2] = -1; //@line 10838
    HEAP32[$v >> 2] = 13; //@line 10839
    HEAP32[$v + 8 >> 2] = $46; //@line 10841
    label = 20; //@line 10842
    break L8;
   }
   break;
  }
 case 276:
  {
   HEAP32[$v + 16 >> 2] = -1; //@line 10849
   HEAP32[$v + 20 >> 2] = -1; //@line 10851
   HEAP32[$v >> 2] = 2; //@line 10852
   HEAP32[$v + 8 >> 2] = 0; //@line 10854
   label = 20; //@line 10855
   break;
  }
 case 263:
  {
   HEAP32[$v + 16 >> 2] = -1; //@line 10860
   HEAP32[$v + 20 >> 2] = -1; //@line 10862
   HEAP32[$v >> 2] = 3; //@line 10863
   HEAP32[$v + 8 >> 2] = 0; //@line 10865
   label = 20; //@line 10866
   break;
  }
 case 287:
  {
   HEAP32[$v + 16 >> 2] = -1; //@line 10871
   HEAP32[$v + 20 >> 2] = -1; //@line 10873
   HEAP32[$v >> 2] = 5; //@line 10874
   HEAP32[$v + 8 >> 2] = 0; //@line 10876
   HEAPF64[$v + 8 >> 3] = +HEAPF64[$ls + 24 >> 3]; //@line 10880
   label = 20; //@line 10881
   break;
  }
 case 270:
  {
   HEAP32[$v + 16 >> 2] = -1; //@line 10886
   HEAP32[$v + 20 >> 2] = -1; //@line 10888
   HEAP32[$v >> 2] = 1; //@line 10889
   HEAP32[$v + 8 >> 2] = 0; //@line 10891
   label = 20; //@line 10892
   break;
  }
 default:
  _suffixedexp($ls, $v); //@line 10896
 } while (0);
 if ((label | 0) == 8) {
  $19 = HEAP32[$ls + 4 >> 2] | 0; //@line 10902
  _luaX_next($ls); //@line 10903
  _subexpr($ls, $v, 8) | 0; //@line 10904
  _luaK_prefix(HEAP32[$ls$idx >> 2] | 0, $$0$i2$ph, $v, $19); //@line 10906
 } else if ((label | 0) == 20) _luaX_next($ls); //@line 10909
 do switch (HEAP32[$16 >> 2] | 0) {
 case 43:
  {
   $op$0$ph$ph = 0; //@line 10915
   break;
  }
 case 62:
  {
   $op$0$ph$ph = 11; //@line 10919
   break;
  }
 case 282:
  {
   $op$0$ph$ph = 12; //@line 10923
   break;
  }
 case 60:
  {
   $op$0$ph$ph = 8; //@line 10927
   break;
  }
 case 283:
  {
   $op$0$ph$ph = 9; //@line 10931
   break;
  }
 case 257:
  {
   $op$0$ph$ph = 13; //@line 10935
   break;
  }
 case 272:
  {
   $op$0$ph$ph = 14; //@line 10939
   break;
  }
 case 284:
  {
   $op$0$ph$ph = 10; //@line 10943
   break;
  }
 case 281:
  {
   $op$0$ph$ph = 7; //@line 10947
   break;
  }
 case 45:
  {
   $op$0$ph$ph = 1; //@line 10951
   break;
  }
 case 42:
  {
   $op$0$ph$ph = 2; //@line 10955
   break;
  }
 case 47:
  {
   $op$0$ph$ph = 3; //@line 10959
   break;
  }
 case 37:
  {
   $op$0$ph$ph = 4; //@line 10963
   break;
  }
 case 94:
  {
   $op$0$ph$ph = 5; //@line 10967
   break;
  }
 case 279:
  {
   $op$0$ph$ph = 6; //@line 10971
   break;
  }
 default:
  {
   $op$0$lcssa = 15; //@line 10975
   $66 = HEAP32[$ls$idx1 >> 2] | 0; //@line 10976
   $67 = $66 + 38 | 0; //@line 10977
   $68 = HEAP16[$67 >> 1] | 0; //@line 10978
   $69 = $68 + -1 << 16 >> 16; //@line 10979
   HEAP16[$67 >> 1] = $69; //@line 10980
   STACKTOP = sp; //@line 10981
   return $op$0$lcssa | 0; //@line 10981
  }
 } while (0);
 $53 = $ls + 4 | 0; //@line 10985
 $op$04 = $op$0$ph$ph; //@line 10986
 while (1) {
  if ((HEAPU8[9232 + ($op$04 << 1) >> 0] | 0) <= ($limit | 0)) {
   $op$0$lcssa = $op$04; //@line 10993
   label = 39; //@line 10994
   break;
  }
  $58 = HEAP32[$53 >> 2] | 0; //@line 10997
  _luaX_next($ls); //@line 10998
  _luaK_infix(HEAP32[$ls$idx >> 2] | 0, $op$04, $v); //@line 11000
  $op$04$looptemp = $op$04;
  $op$04 = _subexpr($ls, $v2, HEAPU8[9233 + ($op$04 << 1) >> 0] | 0) | 0; //@line 11004
  _luaK_posfix(HEAP32[$ls$idx >> 2] | 0, $op$04$looptemp, $v, $v2, $58); //@line 11006
  if (($op$04 | 0) == 15) {
   $op$0$lcssa = 15; //@line 11009
   label = 39; //@line 11010
   break;
  }
 }
 if ((label | 0) == 39) {
  $66 = HEAP32[$ls$idx1 >> 2] | 0; //@line 11017
  $67 = $66 + 38 | 0; //@line 11018
  $68 = HEAP16[$67 >> 1] | 0; //@line 11019
  $69 = $68 + -1 << 16 >> 16; //@line 11020
  HEAP16[$67 >> 1] = $69; //@line 11021
  STACKTOP = sp; //@line 11022
  return $op$0$lcssa | 0; //@line 11022
 }
 return 0; //@line 11024
}
function _constructor($ls, $t) {
 $ls = $ls | 0;
 $t = $t | 0;
 var $0 = 0, $1 = 0, $104 = 0, $16 = 0, $29 = 0, $3 = 0, $32 = 0, $33 = 0, $35 = 0, $38 = 0, $4 = 0, $41 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $50 = 0, $51 = 0, $53 = 0, $56 = 0, $59 = 0, $6 = 0, $62 = 0, $63 = 0, $64 = 0, $68 = 0, $7 = 0, $71 = 0, $73 = 0, $8 = 0, $84 = 0, $90 = 0, $94 = 0, $cc = 0, $vararg_buffer9 = 0, $vararg_ptr12 = 0, $vararg_ptr13 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11035
 STACKTOP = STACKTOP + 64 | 0; //@line 11036
 $vararg_buffer9 = sp + 40 | 0; //@line 11037
 $cc = sp; //@line 11038
 $0 = $ls + 48 | 0; //@line 11039
 $1 = HEAP32[$0 >> 2] | 0; //@line 11040
 $3 = HEAP32[$ls + 4 >> 2] | 0; //@line 11042
 $4 = _luaK_codeABC($1, 11, 0, 0, 0) | 0; //@line 11043
 $5 = $cc + 36 | 0; //@line 11044
 HEAP32[$5 >> 2] = 0; //@line 11045
 $6 = $cc + 28 | 0; //@line 11046
 HEAP32[$6 >> 2] = 0; //@line 11047
 $7 = $cc + 32 | 0; //@line 11048
 HEAP32[$7 >> 2] = 0; //@line 11049
 $8 = $cc + 24 | 0; //@line 11050
 HEAP32[$8 >> 2] = $t; //@line 11051
 HEAP32[$t + 16 >> 2] = -1; //@line 11053
 HEAP32[$t + 20 >> 2] = -1; //@line 11055
 HEAP32[$t >> 2] = 11; //@line 11056
 HEAP32[$t + 8 >> 2] = $4; //@line 11058
 HEAP32[$cc + 16 >> 2] = -1; //@line 11060
 HEAP32[$cc + 20 >> 2] = -1; //@line 11062
 HEAP32[$cc >> 2] = 0; //@line 11063
 HEAP32[$cc + 8 >> 2] = 0; //@line 11065
 _luaK_exp2nextreg(HEAP32[$0 >> 2] | 0, $t); //@line 11067
 $16 = $ls + 16 | 0; //@line 11068
 if ((HEAP32[$16 >> 2] | 0) != 123) _error_expected($ls, 123); //@line 11072
 _luaX_next($ls); //@line 11075
 L4 : do if ((HEAP32[$16 >> 2] | 0) != 125) {
  L5 : while (1) {
   if (HEAP32[$cc >> 2] | 0) {
    _luaK_exp2nextreg($1, $cc); //@line 11084
    HEAP32[$cc >> 2] = 0; //@line 11085
    if ((HEAP32[$5 >> 2] | 0) == 50) {
     _luaK_setlist($1, HEAP32[(HEAP32[$8 >> 2] | 0) + 8 >> 2] | 0, HEAP32[$7 >> 2] | 0, 50); //@line 11093
     HEAP32[$5 >> 2] = 0; //@line 11094
    }
   }
   $29 = HEAP32[$16 >> 2] | 0; //@line 11097
   do if (($29 | 0) == 91) _recfield($ls, $cc); //@line 11100
 else if (($29 | 0) == 288) {
    if ((_luaX_lookahead($ls) | 0) == 61) {
     _recfield($ls, $cc); //@line 11105
     break;
    }
    _subexpr($ls, $cc, 0) | 0; //@line 11108
    $32 = HEAP32[$0 >> 2] | 0; //@line 11109
    $33 = HEAP32[$7 >> 2] | 0; //@line 11110
    if (($33 | 0) > 2147483645) {
     label = 10; //@line 11113
     break L5;
    }
    HEAP32[$7 >> 2] = $33 + 1; //@line 11117
    HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + 1; //@line 11120
   } else {
    _subexpr($ls, $cc, 0) | 0; //@line 11122
    $50 = HEAP32[$0 >> 2] | 0; //@line 11123
    $51 = HEAP32[$7 >> 2] | 0; //@line 11124
    if (($51 | 0) > 2147483645) {
     label = 17; //@line 11127
     break L5;
    }
    HEAP32[$7 >> 2] = $51 + 1; //@line 11131
    HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + 1; //@line 11134
   } while (0);
   $68 = HEAP32[$16 >> 2] | 0; //@line 11137
   if (($68 | 0) == 44) _luaX_next($ls); //@line 11139
 else if (($68 | 0) == 59) _luaX_next($ls); //@line 11141
 else break L4;
   if ((HEAP32[$16 >> 2] | 0) == 125) break L4;
  }
  if ((label | 0) == 10) {
   $35 = $32 + 12 | 0; //@line 11152
   $38 = HEAP32[(HEAP32[$35 >> 2] | 0) + 52 >> 2] | 0; //@line 11155
   $41 = HEAP32[(HEAP32[$32 >> 2] | 0) + 64 >> 2] | 0; //@line 11158
   if (!$41) {
    $44 = 9408; //@line 11161
    HEAP32[$vararg_buffer9 >> 2] = 9384; //@line 11162
    $vararg_ptr4 = $vararg_buffer9 + 4 | 0; //@line 11163
    HEAP32[$vararg_ptr4 >> 2] = 2147483645; //@line 11164
    $vararg_ptr5 = $vararg_buffer9 + 8 | 0; //@line 11165
    HEAP32[$vararg_ptr5 >> 2] = $44; //@line 11166
    $45 = _luaO_pushfstring($38, 9448, $vararg_buffer9) | 0; //@line 11167
    $46 = HEAP32[$35 >> 2] | 0; //@line 11168
    _luaX_syntaxerror($46, $45); //@line 11169
   }
   HEAP32[$vararg_buffer9 >> 2] = $41; //@line 11172
   $44 = _luaO_pushfstring($38, 9424, $vararg_buffer9) | 0; //@line 11174
   HEAP32[$vararg_buffer9 >> 2] = 9384; //@line 11175
   $vararg_ptr4 = $vararg_buffer9 + 4 | 0; //@line 11176
   HEAP32[$vararg_ptr4 >> 2] = 2147483645; //@line 11177
   $vararg_ptr5 = $vararg_buffer9 + 8 | 0; //@line 11178
   HEAP32[$vararg_ptr5 >> 2] = $44; //@line 11179
   $45 = _luaO_pushfstring($38, 9448, $vararg_buffer9) | 0; //@line 11180
   $46 = HEAP32[$35 >> 2] | 0; //@line 11181
   _luaX_syntaxerror($46, $45); //@line 11182
  } else if ((label | 0) == 17) {
   $53 = $50 + 12 | 0; //@line 11186
   $56 = HEAP32[(HEAP32[$53 >> 2] | 0) + 52 >> 2] | 0; //@line 11189
   $59 = HEAP32[(HEAP32[$50 >> 2] | 0) + 64 >> 2] | 0; //@line 11192
   if (!$59) {
    $62 = 9408; //@line 11195
    HEAP32[$vararg_buffer9 >> 2] = 9384; //@line 11196
    $vararg_ptr12 = $vararg_buffer9 + 4 | 0; //@line 11197
    HEAP32[$vararg_ptr12 >> 2] = 2147483645; //@line 11198
    $vararg_ptr13 = $vararg_buffer9 + 8 | 0; //@line 11199
    HEAP32[$vararg_ptr13 >> 2] = $62; //@line 11200
    $63 = _luaO_pushfstring($56, 9448, $vararg_buffer9) | 0; //@line 11201
    $64 = HEAP32[$53 >> 2] | 0; //@line 11202
    _luaX_syntaxerror($64, $63); //@line 11203
   }
   HEAP32[$vararg_buffer9 >> 2] = $59; //@line 11206
   $62 = _luaO_pushfstring($56, 9424, $vararg_buffer9) | 0; //@line 11208
   HEAP32[$vararg_buffer9 >> 2] = 9384; //@line 11209
   $vararg_ptr12 = $vararg_buffer9 + 4 | 0; //@line 11210
   HEAP32[$vararg_ptr12 >> 2] = 2147483645; //@line 11211
   $vararg_ptr13 = $vararg_buffer9 + 8 | 0; //@line 11212
   HEAP32[$vararg_ptr13 >> 2] = $62; //@line 11213
   $63 = _luaO_pushfstring($56, 9448, $vararg_buffer9) | 0; //@line 11214
   $64 = HEAP32[$53 >> 2] | 0; //@line 11215
   _luaX_syntaxerror($64, $63); //@line 11216
  }
 } while (0);
 _check_match($ls, 125, 123, $3); //@line 11221
 $71 = HEAP32[$5 >> 2] | 0; //@line 11222
 do if ($71) {
  $73 = HEAP32[$cc >> 2] | 0; //@line 11226
  if (($73 | 0) == 13 | ($73 | 0) == 12) {
   _luaK_setreturns($1, $cc, -1); //@line 11228
   _luaK_setlist($1, HEAP32[(HEAP32[$8 >> 2] | 0) + 8 >> 2] | 0, HEAP32[$7 >> 2] | 0, -1); //@line 11233
   HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1; //@line 11236
   break;
  } else if (!$73) $84 = $71; //@line 11239
 else {
   _luaK_exp2nextreg($1, $cc); //@line 11241
   $84 = HEAP32[$5 >> 2] | 0; //@line 11243
  }
  _luaK_setlist($1, HEAP32[(HEAP32[$8 >> 2] | 0) + 8 >> 2] | 0, HEAP32[$7 >> 2] | 0, $84); //@line 11249
 } while (0);
 $90 = HEAP32[(HEAP32[(HEAP32[$1 >> 2] | 0) + 12 >> 2] | 0) + ($4 << 2) >> 2] & 8388607; //@line 11257
 $94 = (_luaO_int2fb(HEAP32[$7 >> 2] | 0) | 0) << 23 | $90; //@line 11261
 HEAP32[(HEAP32[(HEAP32[$1 >> 2] | 0) + 12 >> 2] | 0) + ($4 << 2) >> 2] = $94; //@line 11266
 $104 = (_luaO_int2fb(HEAP32[$6 >> 2] | 0) | 0) << 14 & 8372224 | $94 & -8372225; //@line 11272
 HEAP32[(HEAP32[(HEAP32[$1 >> 2] | 0) + 12 >> 2] | 0) + ($4 << 2) >> 2] = $104; //@line 11277
 STACKTOP = sp; //@line 11278
 return;
}
function _luaO_str2d($s, $len, $result) {
 $s = $s | 0;
 $len = $len | 0;
 $result = $result | 0;
 var $$0 = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i$i5$i = 0, $$0$i1$i = 0, $$0$lcssa$i7$i = 0.0, $$01$i$i = 0.0, $$01$i3$i = 0.0, $$lcssa = 0, $100 = 0, $102 = 0, $115 = 0, $118 = 0, $12 = 0, $120 = 0.0, $122 = 0, $131 = 0, $14 = 0, $142 = 0, $143 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $23 = 0, $28 = 0, $31 = 0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $52 = 0, $55 = 0, $60 = 0, $63 = 0, $67 = 0.0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $80 = 0, $81 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $90 = 0, $91 = 0, $endptr = 0, $exp1$09$i = 0, $r$0$i = 0.0, $r$1$i = 0.0, $storemerge = 0.0, label = 0, sp = 0;
 sp = STACKTOP; //@line 7156
 STACKTOP = STACKTOP + 16 | 0; //@line 7157
 $endptr = sp; //@line 7158
 if (_strpbrk($s, 8320) | 0) {
  $$0 = 0; //@line 7162
  STACKTOP = sp; //@line 7163
  return $$0 | 0; //@line 7163
 }
 do if (!(_strpbrk($s, 8328) | 0)) {
  $120 = +_strtod($s, $endptr); //@line 7169
  $122 = HEAP32[$endptr >> 2] | 0; //@line 7171
  $storemerge = $120; //@line 7171
 } else {
  HEAP32[$endptr >> 2] = $s; //@line 7173
  $5 = $s; //@line 7174
  while (1) {
   $4 = HEAP8[$5 >> 0] | 0; //@line 7176
   $12 = $5 + 1 | 0; //@line 7183
   if (!(HEAP8[($4 & 255) + 2697 >> 0] & 8)) break; else $5 = $12; //@line 7187
  }
  if ($4 << 24 >> 24 == 43) {
   $$0$i$i = 0; //@line 7191
   $14 = $12; //@line 7191
  } else if ($4 << 24 >> 24 == 45) {
   $$0$i$i = 1; //@line 7193
   $14 = $12; //@line 7193
  } else {
   $$0$i$i = 0; //@line 7195
   $14 = $5; //@line 7195
  }
  if ((HEAP8[$14 >> 0] | 0) == 48) {
   $17 = HEAP8[$14 + 1 >> 0] | 0; //@line 7201
   if ($17 << 24 >> 24 == 88 | $17 << 24 >> 24 == 120) {
    $18 = $14 + 2 | 0; //@line 7203
    $19 = HEAP8[$18 >> 0] | 0; //@line 7204
    $20 = $19 & 255; //@line 7205
    $23 = HEAP8[$20 + 2697 >> 0] | 0; //@line 7208
    if (!($23 & 16)) {
     $$0$lcssa$i7$i = 0.0; //@line 7212
     $48 = $19; //@line 7212
     $50 = $18; //@line 7212
     $81 = 0; //@line 7212
    } else {
     $$01$i3$i = 0.0; //@line 7214
     $28 = $23; //@line 7214
     $31 = $20; //@line 7214
     $37 = 0; //@line 7214
     $39 = $18; //@line 7214
     while (1) {
      if (!($28 & 2)) $$0$i$i5$i = ($31 | 32) + -87 | 0; //@line 7222
 else $$0$i$i5$i = $31 + -48 | 0; //@line 7225
      $35 = $$01$i3$i * 16.0 + +($$0$i$i5$i | 0); //@line 7228
      $36 = $37 + 1 | 0; //@line 7229
      $38 = $39 + 1 | 0; //@line 7230
      $40 = HEAP8[$38 >> 0] | 0; //@line 7231
      $31 = $40 & 255; //@line 7232
      $28 = HEAP8[$31 + 2697 >> 0] | 0; //@line 7235
      if (!($28 & 16)) {
       $$0$lcssa$i7$i = $35; //@line 7239
       $48 = $40; //@line 7239
       $50 = $38; //@line 7239
       $81 = $36; //@line 7239
       break;
      } else {
       $$01$i3$i = $35; //@line 7242
       $37 = $36; //@line 7242
       $39 = $38; //@line 7242
      }
     }
    }
    if ($48 << 24 >> 24 == 46) {
     $49 = $50 + 1 | 0; //@line 7248
     $52 = HEAPU8[$49 >> 0] | 0; //@line 7250
     $55 = HEAP8[$52 + 2697 >> 0] | 0; //@line 7253
     if (!($55 & 16)) {
      $80 = 0; //@line 7257
      $84 = $49; //@line 7257
      $r$0$i = $$0$lcssa$i7$i; //@line 7257
     } else {
      $$01$i$i = $$0$lcssa$i7$i; //@line 7259
      $60 = $55; //@line 7259
      $63 = $52; //@line 7259
      $69 = 0; //@line 7259
      $71 = $49; //@line 7259
      while (1) {
       if (!($60 & 2)) $$0$i$i$i = ($63 | 32) + -87 | 0; //@line 7267
 else $$0$i$i$i = $63 + -48 | 0; //@line 7270
       $67 = $$01$i$i * 16.0 + +($$0$i$i$i | 0); //@line 7273
       $68 = $69 + 1 | 0; //@line 7274
       $70 = $71 + 1 | 0; //@line 7275
       $63 = HEAPU8[$70 >> 0] | 0; //@line 7277
       $60 = HEAP8[$63 + 2697 >> 0] | 0; //@line 7280
       if (!($60 & 16)) {
        $80 = $68; //@line 7284
        $84 = $70; //@line 7284
        $r$0$i = $67; //@line 7284
        break;
       } else {
        $$01$i$i = $67; //@line 7287
        $69 = $68; //@line 7287
        $71 = $70; //@line 7287
       }
      }
     }
    } else {
     $80 = 0; //@line 7292
     $84 = $50; //@line 7292
     $r$0$i = $$0$lcssa$i7$i; //@line 7292
    }
    if ($80 | $81) {
     $83 = Math_imul($80, -4) | 0; //@line 7297
     HEAP32[$endptr >> 2] = $84; //@line 7298
     $85 = HEAP8[$84 >> 0] | 0; //@line 7299
     if ($85 << 24 >> 24 == 80 | $85 << 24 >> 24 == 112) {
      $86 = $84 + 1 | 0; //@line 7301
      $87 = HEAP8[$86 >> 0] | 0; //@line 7302
      if ($87 << 24 >> 24 == 43) {
       $$0$i1$i = 0; //@line 7305
       $91 = $84 + 2 | 0; //@line 7305
      } else if ($87 << 24 >> 24 == 45) {
       $$0$i1$i = 1; //@line 7308
       $91 = $84 + 2 | 0; //@line 7308
      } else {
       $$0$i1$i = 0; //@line 7310
       $91 = $86; //@line 7310
      }
      $90 = HEAP8[$91 >> 0] | 0; //@line 7312
      if (!(HEAP8[($90 & 255) + 2697 >> 0] & 2)) {
       $118 = $83; //@line 7320
       $143 = $84; //@line 7320
      } else {
       $100 = $91; //@line 7322
       $102 = $90; //@line 7322
       $exp1$09$i = 0; //@line 7322
       do {
        $100 = $100 + 1 | 0; //@line 7325
        $exp1$09$i = ($102 << 24 >> 24) + -48 + ($exp1$09$i * 10 | 0) | 0; //@line 7328
        $102 = HEAP8[$100 >> 0] | 0; //@line 7329
       } while ((HEAP8[($102 & 255) + 2697 >> 0] & 2) != 0);
       $115 = $100; //@line 7346
       $142 = (($$0$i1$i | 0) == 0 ? $exp1$09$i : 0 - $exp1$09$i | 0) + $83 | 0; //@line 7346
       label = 29; //@line 7347
      }
     } else {
      $115 = $84; //@line 7350
      $142 = $83; //@line 7350
      label = 29; //@line 7351
     }
     if ((label | 0) == 29) {
      HEAP32[$endptr >> 2] = $115; //@line 7354
      $118 = $142; //@line 7355
      $143 = $115; //@line 7355
     }
     if (!$$0$i$i) $r$1$i = $r$0$i; //@line 7359
 else $r$1$i = -$r$0$i; //@line 7362
     $122 = $143; //@line 7365
     $storemerge = +_ldexp($r$1$i, $118); //@line 7365
     break;
    }
   }
  }
  HEAPF64[$result >> 3] = 0.0; //@line 7370
  $$0 = 0; //@line 7371
  STACKTOP = sp; //@line 7372
  return $$0 | 0; //@line 7372
 } while (0);
 HEAPF64[$result >> 3] = $storemerge; //@line 7375
 if (($122 | 0) == ($s | 0)) {
  $$0 = 0; //@line 7378
  STACKTOP = sp; //@line 7379
  return $$0 | 0; //@line 7379
 }
 if (!(HEAP8[(HEAPU8[$122 >> 0] | 0) + 2697 >> 0] & 8)) $$lcssa = $122; //@line 7389
 else {
  $131 = $122; //@line 7391
  do $131 = $131 + 1 | 0; //@line 7393
 while ((HEAP8[(HEAPU8[$131 >> 0] | 0) + 2697 >> 0] & 8) != 0);
  HEAP32[$endptr >> 2] = $131; //@line 7407
  $$lcssa = $131; //@line 7408
 }
 $$0 = ($$lcssa | 0) == ($s + $len | 0) & 1; //@line 7413
 STACKTOP = sp; //@line 7414
 return $$0 | 0; //@line 7414
}
function _leaveblock($fs) {
 $fs = $fs | 0;
 var $0 = 0, $1 = 0, $100 = 0, $105 = 0, $111 = 0, $112 = 0, $113 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $121 = 0, $122 = 0, $128 = 0, $139 = 0, $141 = 0, $148 = 0, $149 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $16 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $33 = 0, $35 = 0, $36 = 0, $46 = 0, $49 = 0, $55 = 0, $56 = 0, $59 = 0, $72 = 0, $73 = 0, $75 = 0, $79 = 0, $81 = 0, $85 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $97 = 0, $fs$idx$val$idx$i = 0, $fs$idx2$i = 0, $i$0$ph1$i$i = 0, $i$01$i = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, sp = 0;
 sp = STACKTOP; //@line 8607
 STACKTOP = STACKTOP + 16 | 0; //@line 8608
 $vararg_buffer = sp; //@line 8609
 $0 = $fs + 16 | 0; //@line 8610
 $1 = HEAP32[$0 >> 2] | 0; //@line 8611
 $2 = $fs + 12 | 0; //@line 8612
 $3 = HEAP32[$2 >> 2] | 0; //@line 8613
 if (HEAP32[$1 >> 2] | 0) if (HEAP8[$1 + 9 >> 0] | 0) {
  $9 = _luaK_jump($fs) | 0; //@line 8621
  _luaK_patchclose($fs, $9, HEAPU8[$1 + 8 >> 0] | 0); //@line 8625
  _luaK_patchtohere($fs, $9); //@line 8626
 }
 L5 : do if (HEAP8[$1 + 10 >> 0] | 0) {
  $16 = $3 + 52 | 0; //@line 8634
  $18 = _luaS_new(HEAP32[$16 >> 2] | 0, 9160) | 0; //@line 8636
  $19 = $3 + 64 | 0; //@line 8637
  $20 = HEAP32[$19 >> 2] | 0; //@line 8638
  $21 = $20 + 24 | 0; //@line 8639
  $22 = $3 + 48 | 0; //@line 8640
  $25 = HEAP32[(HEAP32[$22 >> 2] | 0) + 20 >> 2] | 0; //@line 8643
  $26 = $20 + 28 | 0; //@line 8644
  $27 = HEAP32[$26 >> 2] | 0; //@line 8645
  $28 = $20 + 32 | 0; //@line 8646
  if (($27 | 0) < (HEAP32[$28 >> 2] | 0)) $35 = HEAP32[$21 >> 2] | 0; //@line 8651
 else {
   $33 = _luaM_growaux_(HEAP32[$16 >> 2] | 0, HEAP32[$21 >> 2] | 0, $28, 16, 32767, 9168) | 0; //@line 8655
   HEAP32[$21 >> 2] = $33; //@line 8656
   $35 = $33; //@line 8657
  }
  HEAP32[$35 + ($27 << 4) >> 2] = $18; //@line 8660
  $36 = HEAP32[$21 >> 2] | 0; //@line 8661
  HEAP32[$36 + ($27 << 4) + 8 >> 2] = 0; //@line 8663
  HEAP8[$36 + ($27 << 4) + 12 >> 0] = HEAP8[(HEAP32[$22 >> 2] | 0) + 46 >> 0] | 0; //@line 8668
  HEAP32[(HEAP32[$21 >> 2] | 0) + ($27 << 4) + 4 >> 2] = $25; //@line 8671
  HEAP32[$26 >> 2] = (HEAP32[$26 >> 2] | 0) + 1; //@line 8674
  $46 = HEAP32[$19 >> 2] | 0; //@line 8675
  $49 = (HEAP32[$46 + 24 >> 2] | 0) + ($27 << 4) | 0; //@line 8678
  $55 = HEAP16[(HEAP32[(HEAP32[$22 >> 2] | 0) + 16 >> 2] | 0) + 6 >> 1] | 0; //@line 8684
  $56 = $46 + 16 | 0; //@line 8685
  if (($55 | 0) < (HEAP32[$56 >> 2] | 0)) {
   $59 = $46 + 12 | 0; //@line 8689
   $i$0$ph1$i$i = $55; //@line 8690
   do {
    while (1) {
     if (!(_luaS_eqstr(HEAP32[(HEAP32[$59 >> 2] | 0) + ($i$0$ph1$i$i << 4) >> 2] | 0, HEAP32[$49 >> 2] | 0) | 0)) break;
     _closegoto($3, $i$0$ph1$i$i, $49); //@line 8702
     if (($i$0$ph1$i$i | 0) >= (HEAP32[$56 >> 2] | 0)) break L5;
    }
    $i$0$ph1$i$i = $i$0$ph1$i$i + 1 | 0; //@line 8709
   } while (($i$0$ph1$i$i | 0) < (HEAP32[$56 >> 2] | 0));
  }
 } while (0);
 HEAP32[$0 >> 2] = HEAP32[$1 >> 2]; //@line 8722
 $72 = $1 + 8 | 0; //@line 8723
 $73 = HEAP8[$72 >> 0] | 0; //@line 8724
 $75 = $fs + 46 | 0; //@line 8726
 $79 = (HEAP32[$2 >> 2] | 0) + 64 | 0; //@line 8730
 $81 = (HEAP32[$79 >> 2] | 0) + 4 | 0; //@line 8732
 HEAP32[$81 >> 2] = ($73 & 255) - (HEAPU8[$75 >> 0] | 0) + (HEAP32[$81 >> 2] | 0); //@line 8736
 $85 = HEAP8[$75 >> 0] | 0; //@line 8737
 if (($85 & 255) > ($73 & 255)) {
  $87 = $fs + 20 | 0; //@line 8740
  $fs$idx2$i = $fs + 40 | 0; //@line 8741
  $fs$idx$val$idx$i = (HEAP32[$fs >> 2] | 0) + 24 | 0; //@line 8743
  $90 = $85; //@line 8744
  while (1) {
   $88 = HEAP32[$87 >> 2] | 0; //@line 8746
   $89 = $90 + -1 << 24 >> 24; //@line 8747
   HEAP8[$75 >> 0] = $89; //@line 8748
   HEAP32[(HEAP32[$fs$idx$val$idx$i >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[$79 >> 2] >> 2] | 0) + ((HEAP32[$fs$idx2$i >> 2] | 0) + ($89 & 255) << 1) >> 1] | 0) * 12 | 0) + 8 >> 2] = $88; //@line 8759
   $97 = HEAP8[$75 >> 0] | 0; //@line 8760
   if (($97 & 255) > ($73 & 255)) $90 = $97; //@line 8763
 else {
    $100 = $97; //@line 8765
    break;
   }
  }
 } else $100 = $85; //@line 8770
 HEAP8[$fs + 48 >> 0] = $100; //@line 8773
 $105 = HEAP32[$3 + 64 >> 2] | 0; //@line 8778
 HEAP32[$105 + 28 >> 2] = HEAP16[$1 + 4 >> 1]; //@line 8780
 $111 = HEAP16[$1 + 6 >> 1] | 0; //@line 8785
 if (!(HEAP32[$1 >> 2] | 0)) {
  if (($111 | 0) >= (HEAP32[$105 + 16 >> 2] | 0)) {
   STACKTOP = sp; //@line 8791
   return;
  }
  $139 = HEAP32[$105 + 12 >> 2] | 0; //@line 8794
  $141 = HEAP32[$139 + ($111 << 4) >> 2] | 0; //@line 8796
  if ((HEAP8[$141 + 4 >> 0] | 0) != 4) {
   $153 = 9056; //@line 8801
   $148 = $3 + 52 | 0; //@line 8802
   $149 = HEAP32[$148 >> 2] | 0; //@line 8803
   $150 = $141 + 16 | 0; //@line 8804
   $151 = $139 + ($111 << 4) + 8 | 0; //@line 8805
   $152 = HEAP32[$151 >> 2] | 0; //@line 8806
   HEAP32[$vararg_buffer >> 2] = $150; //@line 8807
   $vararg_ptr1 = $vararg_buffer + 4 | 0; //@line 8808
   HEAP32[$vararg_ptr1 >> 2] = $152; //@line 8809
   $154 = _luaO_pushfstring($149, $153, $vararg_buffer) | 0; //@line 8810
   _semerror($3, $154); //@line 8811
  }
  $153 = (HEAP8[$141 + 6 >> 0] | 0) != 0 ? 9016 : 9056; //@line 8818
  $148 = $3 + 52 | 0; //@line 8819
  $149 = HEAP32[$148 >> 2] | 0; //@line 8820
  $150 = $141 + 16 | 0; //@line 8821
  $151 = $139 + ($111 << 4) + 8 | 0; //@line 8822
  $152 = HEAP32[$151 >> 2] | 0; //@line 8823
  HEAP32[$vararg_buffer >> 2] = $150; //@line 8824
  $vararg_ptr1 = $vararg_buffer + 4 | 0; //@line 8825
  HEAP32[$vararg_ptr1 >> 2] = $152; //@line 8826
  $154 = _luaO_pushfstring($149, $153, $vararg_buffer) | 0; //@line 8827
  _semerror($3, $154); //@line 8828
 }
 $112 = HEAP32[$79 >> 2] | 0; //@line 8831
 $113 = $112 + 16 | 0; //@line 8832
 if (($111 | 0) >= (HEAP32[$113 >> 2] | 0)) {
  STACKTOP = sp; //@line 8836
  return;
 }
 $116 = $112 + 12 | 0; //@line 8838
 $117 = $1 + 9 | 0; //@line 8839
 $i$01$i = $111; //@line 8840
 do {
  $118 = HEAP32[$116 >> 2] | 0; //@line 8842
  $119 = $118 + ($i$01$i << 4) + 12 | 0; //@line 8843
  $121 = HEAP8[$72 >> 0] | 0; //@line 8845
  $122 = $121 & 255; //@line 8846
  if ((HEAPU8[$119 >> 0] | 0) > ($121 & 255)) {
   if (!(HEAP8[$117 >> 0] | 0)) $128 = $121; //@line 8852
 else {
    _luaK_patchclose($fs, HEAP32[$118 + ($i$01$i << 4) + 4 >> 2] | 0, $122); //@line 8856
    $128 = HEAP8[$72 >> 0] | 0; //@line 8858
   }
   HEAP8[$119 >> 0] = $128; //@line 8860
  }
  $i$01$i = ((_findlabel(HEAP32[$2 >> 2] | 0, $i$01$i) | 0) == 0 & 1) + $i$01$i | 0; //@line 8866
 } while (($i$01$i | 0) < (HEAP32[$113 >> 2] | 0));
 STACKTOP = sp; //@line 8875
 return;
}
function _assignment($ls, $lh, $nvars) {
 $ls = $ls | 0;
 $lh = $lh | 0;
 $nvars = $nvars | 0;
 var $$$i = 0, $$02$i = 0, $$pre = 0, $$pre$phi4Z2D = 0, $0 = 0, $10 = 0, $12 = 0, $13 = 0, $17 = 0, $18 = 0, $20 = 0, $21 = 0, $23 = 0, $29 = 0, $3 = 0, $4 = 0, $41 = 0, $49 = 0, $5 = 0, $52 = 0, $55 = 0, $58 = 0, $59 = 0, $60 = 0, $64 = 0, $66 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $80 = 0, $83 = 0, $9 = 0, $90 = 0, $94 = 0, $conflict$01$i = 0, $conflict$1$i = 0, $conflict$2$i = 0, $e = 0, $ls$idx1$val = 0, $n$0$i$lcssa = 0, $n$0$i2 = 0, $nv = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 10484
 STACKTOP = STACKTOP + 80 | 0; //@line 10485
 $vararg_buffer1 = sp + 56 | 0; //@line 10486
 $e = sp + 32 | 0; //@line 10487
 $nv = sp; //@line 10488
 $0 = $lh + 8 | 0; //@line 10489
 if (((HEAP32[$0 >> 2] | 0) + -7 | 0) >>> 0 >= 3) _luaX_syntaxerror($ls, 9200); //@line 10494
 $3 = $ls + 16 | 0; //@line 10497
 $4 = HEAP32[$3 >> 2] | 0; //@line 10498
 do if (($4 | 0) == 61) {
  _luaX_next($ls); //@line 10501
  _subexpr($ls, $e, 0) | 0; //@line 10502
  $64 = $ls + 48 | 0; //@line 10505
  if ((HEAP32[$3 >> 2] | 0) == 44) {
   $n$0$i2 = 1; //@line 10507
   while (1) {
    _luaX_next($ls); //@line 10509
    _luaK_exp2nextreg(HEAP32[$64 >> 2] | 0, $e); //@line 10511
    _subexpr($ls, $e, 0) | 0; //@line 10512
    $66 = $n$0$i2 + 1 | 0; //@line 10513
    if ((HEAP32[$3 >> 2] | 0) == 44) $n$0$i2 = $66; //@line 10517
 else {
     $n$0$i$lcssa = $66; //@line 10519
     break;
    }
   }
  } else $n$0$i$lcssa = 1; //@line 10524
  $70 = HEAP32[$64 >> 2] | 0; //@line 10527
  if (($n$0$i$lcssa | 0) == ($nvars | 0)) {
   _luaK_setoneret($70, $e); //@line 10529
   _luaK_storevar(HEAP32[$64 >> 2] | 0, $0, $e); //@line 10531
   STACKTOP = sp; //@line 10532
   return;
  }
  $71 = $nvars - $n$0$i$lcssa | 0; //@line 10534
  $72 = HEAP32[$e >> 2] | 0; //@line 10535
  if (($72 | 0) == 13 | ($72 | 0) == 12) {
   $73 = $71 + 1 | 0; //@line 10537
   $$$i = ($73 | 0) < 0 ? 0 : $73; //@line 10539
   _luaK_setreturns($70, $e, $$$i); //@line 10540
   if (($$$i | 0) > 1) _luaK_reserveregs($70, $$$i + -1 | 0); //@line 10544
  } else if (!$72) label = 30; //@line 10547
 else {
   _luaK_exp2nextreg($70, $e); //@line 10549
   label = 30; //@line 10550
  }
  if ((label | 0) == 30) if (($71 | 0) > 0) {
   $80 = HEAPU8[$70 + 48 >> 0] | 0; //@line 10557
   _luaK_reserveregs($70, $71); //@line 10558
   _luaK_nil($70, $80, $71); //@line 10559
  }
  if (($n$0$i$lcssa | 0) > ($nvars | 0)) {
   $83 = (HEAP32[$64 >> 2] | 0) + 48 | 0; //@line 10565
   HEAP8[$83 >> 0] = $71 + (HEAPU8[$83 >> 0] | 0); //@line 10570
   $$pre$phi4Z2D = $e; //@line 10571
  } else $$pre$phi4Z2D = $e; //@line 10573
 } else if (($4 | 0) == 44) {
  _luaX_next($ls); //@line 10576
  HEAP32[$nv >> 2] = $lh; //@line 10577
  $5 = $nv + 8 | 0; //@line 10578
  _suffixedexp($ls, $5); //@line 10579
  $$pre = $ls + 48 | 0; //@line 10582
  if ((HEAP32[$5 >> 2] | 0) != 9) {
   $ls$idx1$val = HEAP32[$$pre >> 2] | 0; //@line 10584
   $9 = HEAP8[$ls$idx1$val + 48 >> 0] | 0; //@line 10586
   $10 = $9 & 255; //@line 10587
   if ($lh) {
    $12 = $nv + 16 | 0; //@line 10590
    $13 = $9 & 255; //@line 10591
    $$02$i = $lh; //@line 10592
    $conflict$01$i = 0; //@line 10592
    while (1) {
     if ((HEAP32[$$02$i + 8 >> 2] | 0) == 9) {
      $17 = $$02$i + 16 | 0; //@line 10598
      $18 = $17 + 3 | 0; //@line 10599
      $20 = HEAPU8[$18 >> 0] | 0; //@line 10601
      $21 = HEAP32[$5 >> 2] | 0; //@line 10602
      if (($20 | 0) == ($21 | 0)) {
       $23 = $17 + 2 | 0; //@line 10605
       if ((HEAPU8[$23 >> 0] | 0) == (HEAP32[$12 >> 2] | 0)) {
        HEAP8[$18 >> 0] = 7; //@line 10611
        HEAP8[$23 >> 0] = $9; //@line 10612
        $29 = HEAP32[$5 >> 2] | 0; //@line 10614
        $conflict$1$i = 1; //@line 10614
       } else {
        $29 = $20; //@line 10616
        $conflict$1$i = $conflict$01$i; //@line 10616
       }
      } else {
       $29 = $21; //@line 10619
       $conflict$1$i = $conflict$01$i; //@line 10619
      }
      if (($29 | 0) == 7) if ((HEAP16[$17 >> 1] | 0) == (HEAP32[$12 >> 2] | 0)) {
       HEAP16[$17 >> 1] = $13; //@line 10628
       $conflict$2$i = 1; //@line 10629
      } else $conflict$2$i = $conflict$1$i; //@line 10631
 else $conflict$2$i = $conflict$1$i; //@line 10634
     } else $conflict$2$i = $conflict$01$i; //@line 10637
     $$02$i = HEAP32[$$02$i >> 2] | 0; //@line 10639
     if (!$$02$i) break; else $conflict$01$i = $conflict$2$i; //@line 10644
    }
    if ($conflict$2$i) {
     _luaK_codeABC($ls$idx1$val, (HEAP32[$5 >> 2] | 0) == 7 ? 0 : 5, $10, HEAP32[$12 >> 2] | 0, 0) | 0; //@line 10653
     _luaK_reserveregs($ls$idx1$val, 1); //@line 10654
    }
   }
  }
  $41 = HEAP32[$$pre >> 2] | 0; //@line 10658
  if (((HEAPU16[(HEAP32[$ls + 52 >> 2] | 0) + 38 >> 1] | 0) + $nvars | 0) <= 200) {
   _assignment($ls, $nv, $nvars + 1 | 0); //@line 10668
   $$pre$phi4Z2D = $e; //@line 10669
   break;
  }
  $49 = $41 + 12 | 0; //@line 10672
  $52 = HEAP32[(HEAP32[$49 >> 2] | 0) + 52 >> 2] | 0; //@line 10675
  $55 = HEAP32[(HEAP32[$41 >> 2] | 0) + 64 >> 2] | 0; //@line 10678
  if (!$55) {
   $58 = 9408; //@line 10681
   HEAP32[$vararg_buffer1 >> 2] = 9216; //@line 10682
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 10683
   HEAP32[$vararg_ptr4 >> 2] = 200; //@line 10684
   $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 10685
   HEAP32[$vararg_ptr5 >> 2] = $58; //@line 10686
   $59 = _luaO_pushfstring($52, 9448, $vararg_buffer1) | 0; //@line 10687
   $60 = HEAP32[$49 >> 2] | 0; //@line 10688
   _luaX_syntaxerror($60, $59); //@line 10689
  }
  HEAP32[$vararg_buffer1 >> 2] = $55; //@line 10692
  $58 = _luaO_pushfstring($52, 9424, $vararg_buffer1) | 0; //@line 10694
  HEAP32[$vararg_buffer1 >> 2] = 9216; //@line 10695
  $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 10696
  HEAP32[$vararg_ptr4 >> 2] = 200; //@line 10697
  $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 10698
  HEAP32[$vararg_ptr5 >> 2] = $58; //@line 10699
  $59 = _luaO_pushfstring($52, 9448, $vararg_buffer1) | 0; //@line 10700
  $60 = HEAP32[$49 >> 2] | 0; //@line 10701
  _luaX_syntaxerror($60, $59); //@line 10702
 } else _error_expected($ls, 61); //@line 10705
 while (0);
 $90 = HEAP32[$ls + 48 >> 2] | 0; //@line 10710
 $94 = (HEAPU8[$90 + 48 >> 0] | 0) + -1 | 0; //@line 10714
 HEAP32[$e + 16 >> 2] = -1; //@line 10716
 HEAP32[$e + 20 >> 2] = -1; //@line 10718
 HEAP32[$$pre$phi4Z2D >> 2] = 6; //@line 10719
 HEAP32[$e + 8 >> 2] = $94; //@line 10721
 _luaK_storevar($90, $0, $e); //@line 10722
 STACKTOP = sp; //@line 10723
 return;
}
function _luaO_pushvfstring($L, $fmt, $argp) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $argp = $argp | 0;
 var $$ = 0, $$0$lcssa = 0, $$08 = 0, $$lcssa4 = 0, $0 = 0, $10 = 0, $100 = 0, $12 = 0, $16 = 0, $17 = 0, $2 = 0, $25 = 0, $26 = 0, $28 = 0, $29 = 0, $31 = 0, $37 = 0, $39 = 0, $4 = 0, $41 = 0, $47 = 0, $49 = 0, $5 = 0, $52 = 0, $54 = 0.0, $56 = 0, $57 = 0, $58 = 0, $60 = 0, $66 = 0, $68 = 0, $74 = 0, $75 = 0, $79 = 0, $8 = 0, $82 = 0, $84 = 0, $86 = 0, $87 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $arglist_current = 0, $arglist_current11 = 0, $arglist_current2 = 0, $arglist_current5 = 0, $arglist_current8 = 0, $buff = 0, $buff2 = 0, $n$0$lcssa = 0, $n$07 = 0, $vararg_buffer13 = 0, sp = 0;
 sp = STACKTOP; //@line 7427
 STACKTOP = STACKTOP + 48 | 0; //@line 7428
 $vararg_buffer13 = sp; //@line 7429
 $buff = sp + 32 | 0; //@line 7430
 $buff2 = sp + 8 | 0; //@line 7431
 $0 = _strchr($fmt, 37) | 0; //@line 7432
 $2 = $L + 24 | 0; //@line 7434
 $4 = $L + 8 | 0; //@line 7436
 $5 = HEAP32[$4 >> 2] | 0; //@line 7437
 $8 = (HEAP32[$2 >> 2] | 0) - $5 | 0; //@line 7440
 L1 : do if (!$0) {
  $$0$lcssa = $fmt; //@line 7443
  $$lcssa4 = $8; //@line 7443
  $99 = $5; //@line 7443
  $n$0$lcssa = 0; //@line 7443
 } else {
  $$08 = $fmt; //@line 7445
  $10 = $8; //@line 7445
  $100 = $5; //@line 7445
  $12 = $0; //@line 7445
  $n$07 = 0; //@line 7445
  L3 : while (1) {
   if (($10 | 0) < 48) {
    _luaD_growstack($L, 2); //@line 7449
    $16 = HEAP32[$4 >> 2] | 0; //@line 7451
   } else $16 = $100; //@line 7453
   HEAP32[$4 >> 2] = $16 + 16; //@line 7459
   $17 = _luaS_newlstr($L, $$08, $12 - $$08 | 0) | 0; //@line 7460
   HEAP32[$16 >> 2] = $17; //@line 7461
   HEAP32[$16 + 8 >> 2] = HEAPU8[$17 + 4 >> 0] | 64; //@line 7467
   $25 = HEAP8[$12 + 1 >> 0] | 0; //@line 7470
   switch ($25 | 0) {
   case 102:
    {
     $52 = HEAP32[$4 >> 2] | 0; //@line 7473
     HEAP32[$4 >> 2] = $52 + 16; //@line 7475
     $arglist_current8 = HEAP32[$argp >> 2] | 0; //@line 7476
     HEAP32[tempDoublePtr >> 2] = HEAP32[$arglist_current8 >> 2]; //@line 7477
     HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[$arglist_current8 + 4 >> 2]; //@line 7477
     $54 = +HEAPF64[tempDoublePtr >> 3]; //@line 7477
     HEAP32[$argp >> 2] = $arglist_current8 + 8; //@line 7479
     HEAPF64[$52 >> 3] = $54; //@line 7480
     HEAP32[$52 + 8 >> 2] = 3; //@line 7482
     break;
    }
   case 37:
    {
     $66 = HEAP32[$4 >> 2] | 0; //@line 7486
     HEAP32[$4 >> 2] = $66 + 16; //@line 7488
     $68 = _luaS_newlstr($L, 8352, 1) | 0; //@line 7489
     HEAP32[$66 >> 2] = $68; //@line 7490
     HEAP32[$66 + 8 >> 2] = HEAPU8[$68 + 4 >> 0] | 64; //@line 7496
     break;
    }
   case 115:
    {
     $arglist_current = HEAP32[$argp >> 2] | 0; //@line 7500
     $26 = HEAP32[$arglist_current >> 2] | 0; //@line 7501
     HEAP32[$argp >> 2] = $arglist_current + 4; //@line 7503
     $$ = ($26 | 0) == 0 ? 8336 : $26; //@line 7505
     $28 = _strlen($$ | 0) | 0; //@line 7506
     $29 = HEAP32[$4 >> 2] | 0; //@line 7507
     HEAP32[$4 >> 2] = $29 + 16; //@line 7509
     $31 = _luaS_newlstr($L, $$, $28) | 0; //@line 7510
     HEAP32[$29 >> 2] = $31; //@line 7511
     HEAP32[$29 + 8 >> 2] = HEAPU8[$31 + 4 >> 0] | 64; //@line 7517
     break;
    }
   case 99:
    {
     $arglist_current2 = HEAP32[$argp >> 2] | 0; //@line 7521
     $37 = HEAP32[$arglist_current2 >> 2] | 0; //@line 7522
     HEAP32[$argp >> 2] = $arglist_current2 + 4; //@line 7524
     HEAP8[$buff >> 0] = $37; //@line 7526
     $39 = HEAP32[$4 >> 2] | 0; //@line 7527
     HEAP32[$4 >> 2] = $39 + 16; //@line 7529
     $41 = _luaS_newlstr($L, $buff, 1) | 0; //@line 7530
     HEAP32[$39 >> 2] = $41; //@line 7531
     HEAP32[$39 + 8 >> 2] = HEAPU8[$41 + 4 >> 0] | 64; //@line 7537
     break;
    }
   case 112:
    {
     $arglist_current11 = HEAP32[$argp >> 2] | 0; //@line 7541
     $56 = HEAP32[$arglist_current11 >> 2] | 0; //@line 7542
     HEAP32[$argp >> 2] = $arglist_current11 + 4; //@line 7544
     HEAP32[$vararg_buffer13 >> 2] = $56; //@line 7545
     $57 = _sprintf($buff2, 8344, $vararg_buffer13) | 0; //@line 7546
     $58 = HEAP32[$4 >> 2] | 0; //@line 7547
     HEAP32[$4 >> 2] = $58 + 16; //@line 7549
     $60 = _luaS_newlstr($L, $buff2, $57) | 0; //@line 7550
     HEAP32[$58 >> 2] = $60; //@line 7551
     HEAP32[$58 + 8 >> 2] = HEAPU8[$60 + 4 >> 0] | 64; //@line 7557
     break;
    }
   case 100:
    {
     $47 = HEAP32[$4 >> 2] | 0; //@line 7561
     HEAP32[$4 >> 2] = $47 + 16; //@line 7563
     $arglist_current5 = HEAP32[$argp >> 2] | 0; //@line 7564
     $49 = HEAP32[$arglist_current5 >> 2] | 0; //@line 7565
     HEAP32[$argp >> 2] = $arglist_current5 + 4; //@line 7567
     HEAPF64[$47 >> 3] = +($49 | 0); //@line 7569
     HEAP32[$47 + 8 >> 2] = 3; //@line 7571
     break;
    }
   default:
    break L3;
   }
   $74 = $n$07 + 2 | 0; //@line 7578
   $75 = $12 + 2 | 0; //@line 7579
   $12 = _strchr($75, 37) | 0; //@line 7580
   $79 = HEAP32[$4 >> 2] | 0; //@line 7583
   $82 = (HEAP32[$2 >> 2] | 0) - $79 | 0; //@line 7586
   if (!$12) {
    $$0$lcssa = $75; //@line 7588
    $$lcssa4 = $82; //@line 7588
    $99 = $79; //@line 7588
    $n$0$lcssa = $74; //@line 7588
    break L1;
   } else {
    $$08 = $75; //@line 7591
    $10 = $82; //@line 7591
    $100 = $79; //@line 7591
    $n$07 = $74; //@line 7591
   }
  }
  HEAP32[$vararg_buffer13 >> 2] = $25; //@line 7594
  _luaG_runerror($L, 8360, $vararg_buffer13); //@line 7595
 } while (0);
 if (($$lcssa4 | 0) < 32) {
  _luaD_growstack($L, 1); //@line 7601
  $86 = HEAP32[$4 >> 2] | 0; //@line 7603
 } else $86 = $99; //@line 7605
 $84 = _strlen($$0$lcssa | 0) | 0; //@line 7607
 HEAP32[$4 >> 2] = $86 + 16; //@line 7609
 $87 = _luaS_newlstr($L, $$0$lcssa, $84) | 0; //@line 7610
 HEAP32[$86 >> 2] = $87; //@line 7611
 HEAP32[$86 + 8 >> 2] = HEAPU8[$87 + 4 >> 0] | 64; //@line 7617
 if (($n$0$lcssa | 0) <= 0) {
  $95 = HEAP32[$4 >> 2] | 0; //@line 7620
  $96 = $95 + -16 | 0; //@line 7621
  $97 = HEAP32[$96 >> 2] | 0; //@line 7622
  $98 = $97 + 16 | 0; //@line 7623
  STACKTOP = sp; //@line 7624
  return $98 | 0; //@line 7624
 }
 _luaV_concat($L, $n$0$lcssa | 1); //@line 7627
 $95 = HEAP32[$4 >> 2] | 0; //@line 7628
 $96 = $95 + -16 | 0; //@line 7629
 $97 = HEAP32[$96 >> 2] | 0; //@line 7630
 $98 = $97 + 16 | 0; //@line 7631
 STACKTOP = sp; //@line 7632
 return $98 | 0; //@line 7632
}
function _luaH_getn($t) {
 $t = $t | 0;
 var $$0 = 0, $$0$i$i = 0, $$0$i12$i = 0, $$0$i6$i = 0, $$01$i = 0, $$115$i = 0, $0 = 0, $1 = 0, $101 = 0, $102 = 0, $107 = 0.0, $11 = 0, $111 = 0, $113 = 0, $131 = 0, $135 = 0, $15 = 0, $18 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $27 = 0, $30 = 0.0, $34 = 0, $36 = 0, $5 = 0, $54 = 0, $61 = 0, $62 = 0, $64 = 0, $65 = 0, $70 = 0.0, $74 = 0, $76 = 0, $94 = 0, $i$0$ = 0, $i$0$i = 0, $i$0$i$phi = 0, $i$09 = 0, $i$1$i = 0, $i$1$i$i$i = 0, $i$1$i$i3$i = 0, $i$1$i$i9$i = 0, $i$2$$i = 0, $i$216$i = 0, $j$08 = 0, $n$0$i$i = 0, $n$0$i11$i = 0, $n$0$i5$i = 0, $u$sroa$0$i$i8$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 17721
 STACKTOP = STACKTOP + 16 | 0; //@line 17722
 $u$sroa$0$i$i8$i = sp; //@line 17723
 $0 = $t + 28 | 0; //@line 17724
 $1 = HEAP32[$0 >> 2] | 0; //@line 17725
 if ($1) {
  $5 = HEAP32[$t + 12 >> 2] | 0; //@line 17730
  if (!(HEAP32[$5 + ($1 + -1 << 4) + 8 >> 2] | 0)) {
   if ($1 >>> 0 > 1) {
    $i$09 = 0; //@line 17737
    $j$08 = $1; //@line 17737
   } else {
    $$0 = 0; //@line 17739
    STACKTOP = sp; //@line 17740
    return $$0 | 0; //@line 17740
   }
   while (1) {
    $11 = ($i$09 + $j$08 | 0) >>> 1; //@line 17744
    $15 = (HEAP32[$5 + ($11 + -1 << 4) + 8 >> 2] | 0) == 0; //@line 17748
    $j$08 = $15 ? $11 : $j$08; //@line 17749
    $i$0$ = $15 ? $i$09 : $11; //@line 17750
    if (($j$08 - $i$0$ | 0) >>> 0 <= 1) {
     $$0 = $i$0$; //@line 17756
     break;
    } else $i$09 = $i$0$; //@line 17754
   }
   STACKTOP = sp; //@line 17760
   return $$0 | 0; //@line 17760
  }
 }
 $18 = $t + 16 | 0; //@line 17763
 if ((HEAP32[$18 >> 2] | 0) == 10872) {
  $$0 = $1; //@line 17767
  STACKTOP = sp; //@line 17768
  return $$0 | 0; //@line 17768
 }
 $22 = $t + 12 | 0; //@line 17771
 $23 = $t + 7 | 0; //@line 17772
 $24 = $u$sroa$0$i$i8$i + 4 | 0; //@line 17773
 $$01$i = $1 + 1 | 0; //@line 17774
 $27 = $1; //@line 17774
 $i$0$i = $1; //@line 17774
 while (1) {
  $25 = $$01$i + -1 | 0; //@line 17776
  L15 : do if ($25 >>> 0 < $27 >>> 0) $$0$i$i = (HEAP32[$22 >> 2] | 0) + ($25 << 4) | 0; //@line 17782
 else {
   $30 = +($$01$i | 0); //@line 17784
   HEAPF64[$u$sroa$0$i$i8$i >> 3] = $30 + 1.0; //@line 17786
   $34 = (HEAP32[$24 >> 2] | 0) + (HEAP32[$u$sroa$0$i$i8$i >> 2] | 0) | 0; //@line 17789
   if (($34 | 0) < 0) {
    $36 = 0 - $34 | 0; //@line 17792
    $i$1$i$i$i = ($34 | 0) == ($36 | 0) ? 0 : $36; //@line 17795
   } else $i$1$i$i$i = $34; //@line 17797
   $n$0$i$i = (HEAP32[$18 >> 2] | 0) + ((($i$1$i$i$i | 0) % ((1 << (HEAPU8[$23 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17807
   while (1) {
    if ((HEAP32[$n$0$i$i + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0$i$i + 16 >> 3] == $30) break;
    $54 = HEAP32[$n$0$i$i + 28 >> 2] | 0; //@line 17821
    if (!$54) {
     $$0$i$i = 8048; //@line 17824
     break L15;
    } else $n$0$i$i = $54; //@line 17827
   }
   $$0$i$i = $n$0$i$i; //@line 17830
  } while (0);
  if (!(HEAP32[$$0$i$i + 8 >> 2] | 0)) break;
  $62 = $$01$i << 1; //@line 17839
  if ($62 >>> 0 > 2147483645) {
   label = 21; //@line 17842
   break;
  }
  $i$0$i$phi = $$01$i; //@line 17846
  $$01$i = $62; //@line 17846
  $27 = HEAP32[$0 >> 2] | 0; //@line 17846
  $i$0$i = $i$0$i$phi; //@line 17846
 }
 if ((label | 0) == 21) {
  $64 = $u$sroa$0$i$i8$i + 4 | 0; //@line 17849
  $i$1$i = 1; //@line 17850
  while (1) {
   $65 = $i$1$i + -1 | 0; //@line 17852
   L34 : do if ($65 >>> 0 < (HEAP32[$0 >> 2] | 0) >>> 0) $$0$i12$i = (HEAP32[$22 >> 2] | 0) + ($65 << 4) | 0; //@line 17859
 else {
    $70 = +($i$1$i | 0); //@line 17861
    HEAPF64[$u$sroa$0$i$i8$i >> 3] = $70 + 1.0; //@line 17863
    $74 = (HEAP32[$64 >> 2] | 0) + (HEAP32[$u$sroa$0$i$i8$i >> 2] | 0) | 0; //@line 17866
    if (($74 | 0) < 0) {
     $76 = 0 - $74 | 0; //@line 17869
     $i$1$i$i9$i = ($74 | 0) == ($76 | 0) ? 0 : $76; //@line 17872
    } else $i$1$i$i9$i = $74; //@line 17874
    $n$0$i11$i = (HEAP32[$18 >> 2] | 0) + ((($i$1$i$i9$i | 0) % ((1 << (HEAPU8[$23 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17884
    while (1) {
     if ((HEAP32[$n$0$i11$i + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0$i11$i + 16 >> 3] == $70) break;
     $94 = HEAP32[$n$0$i11$i + 28 >> 2] | 0; //@line 17898
     if (!$94) {
      $$0$i12$i = 8048; //@line 17901
      break L34;
     } else $n$0$i11$i = $94; //@line 17904
    }
    $$0$i12$i = $n$0$i11$i; //@line 17907
   } while (0);
   if (!(HEAP32[$$0$i12$i + 8 >> 2] | 0)) {
    $$0 = $65; //@line 17914
    break;
   }
   $i$1$i = $i$1$i + 1 | 0; //@line 17918
  }
  STACKTOP = sp; //@line 17920
  return $$0 | 0; //@line 17920
 }
 if (($$01$i - $i$0$i | 0) >>> 0 <= 1) {
  $$0 = $i$0$i; //@line 17925
  STACKTOP = sp; //@line 17926
  return $$0 | 0; //@line 17926
 }
 $61 = $u$sroa$0$i$i8$i + 4 | 0; //@line 17928
 $$115$i = $$01$i; //@line 17929
 $i$216$i = $i$0$i; //@line 17929
 while (1) {
  $101 = ($$115$i + $i$216$i | 0) >>> 1; //@line 17932
  $102 = $101 + -1 | 0; //@line 17933
  L55 : do if ($102 >>> 0 < (HEAP32[$0 >> 2] | 0) >>> 0) $$0$i6$i = (HEAP32[$22 >> 2] | 0) + ($102 << 4) | 0; //@line 17940
 else {
   $107 = +($101 | 0); //@line 17942
   HEAPF64[$u$sroa$0$i$i8$i >> 3] = $107 + 1.0; //@line 17944
   $111 = (HEAP32[$61 >> 2] | 0) + (HEAP32[$u$sroa$0$i$i8$i >> 2] | 0) | 0; //@line 17947
   if (($111 | 0) < 0) {
    $113 = 0 - $111 | 0; //@line 17950
    $i$1$i$i3$i = ($111 | 0) == ($113 | 0) ? 0 : $113; //@line 17953
   } else $i$1$i$i3$i = $111; //@line 17955
   $n$0$i5$i = (HEAP32[$18 >> 2] | 0) + ((($i$1$i$i3$i | 0) % ((1 << (HEAPU8[$23 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17965
   while (1) {
    if ((HEAP32[$n$0$i5$i + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0$i5$i + 16 >> 3] == $107) break;
    $131 = HEAP32[$n$0$i5$i + 28 >> 2] | 0; //@line 17979
    if (!$131) {
     $$0$i6$i = 8048; //@line 17982
     break L55;
    } else $n$0$i5$i = $131; //@line 17985
   }
   $$0$i6$i = $n$0$i5$i; //@line 17988
  } while (0);
  $135 = (HEAP32[$$0$i6$i + 8 >> 2] | 0) == 0; //@line 17993
  $$115$i = $135 ? $101 : $$115$i; //@line 17994
  $i$2$$i = $135 ? $i$216$i : $101; //@line 17995
  if (($$115$i - $i$2$$i | 0) >>> 0 <= 1) {
   $$0 = $i$2$$i; //@line 18001
   break;
  } else $i$216$i = $i$2$$i; //@line 17999
 }
 STACKTOP = sp; //@line 18005
 return $$0 | 0; //@line 18005
}
function _lua_resume($L, $from, $nargs) {
 $L = $L | 0;
 $from = $from | 0;
 $nargs = $nargs | 0;
 var $$$i$i = 0, $$lim$0$i$i$i = 0, $0 = 0, $1 = 0, $105 = 0, $112 = 0, $117 = 0, $118 = 0, $125 = 0, $128 = 0, $129 = 0, $13 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $25 = 0, $29 = 0, $31 = 0, $32 = 0, $35 = 0, $41 = 0, $47 = 0, $49 = 0, $54 = 0, $55 = 0, $62 = 0, $67 = 0, $7 = 0, $74 = 0, $76 = 0, $79 = 0, $8 = 0, $9 = 0, $92 = 0, $96 = 0, $99 = 0, $ci$0$i$i = 0, $ci$01$i$i = 0, $ci$02$i$i = 0, $ci$03$i$i$i = 0, $lim$0$lcssa$i$i$i = 0, $lim$02$i$i$i = 0, $status$010 = 0, $status$1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16553
 $0 = $L + 36 | 0; //@line 16554
 $1 = HEAP16[$0 >> 1] | 0; //@line 16555
 if (!$from) $8 = 1; //@line 16558
 else $8 = (HEAPU16[$from + 38 >> 1] | 0) + 1 & 65535; //@line 16565
 $7 = $L + 38 | 0; //@line 16567
 HEAP16[$7 >> 1] = $8; //@line 16568
 HEAP16[$0 >> 1] = 0; //@line 16569
 $9 = $L + 8 | 0; //@line 16570
 $13 = _luaD_rawrunprotected($L, 21, (HEAP32[$9 >> 2] | 0) + (0 - $nargs << 4) | 0) | 0; //@line 16574
 if (($13 | 0) == -1) {
  $status$1 = 2; //@line 16577
  HEAP16[$0 >> 1] = $1; //@line 16578
  $128 = HEAP16[$7 >> 1] | 0; //@line 16579
  $129 = $128 + -1 << 16 >> 16; //@line 16580
  HEAP16[$7 >> 1] = $129; //@line 16581
  STACKTOP = sp; //@line 16582
  return $status$1 | 0; //@line 16582
 }
 if ($13 >>> 0 <= 1) {
  $status$1 = $13; //@line 16586
  HEAP16[$0 >> 1] = $1; //@line 16587
  $128 = HEAP16[$7 >> 1] | 0; //@line 16588
  $129 = $128 + -1 << 16 >> 16; //@line 16589
  HEAP16[$7 >> 1] = $129; //@line 16590
  STACKTOP = sp; //@line 16591
  return $status$1 | 0; //@line 16591
 }
 $16 = $L + 16 | 0; //@line 16593
 $17 = $L + 28 | 0; //@line 16594
 $18 = $L + 41 | 0; //@line 16595
 $19 = $L + 68 | 0; //@line 16596
 $20 = $L + 32 | 0; //@line 16597
 $21 = $L + 12 | 0; //@line 16598
 $status$010 = $13; //@line 16599
 L10 : while (1) {
  $ci$01$i$i = HEAP32[$16 >> 2] | 0; //@line 16601
  if (!$ci$01$i$i) break; else $ci$02$i$i = $ci$01$i$i; //@line 16606
  while (1) {
   $25 = $ci$02$i$i + 18 | 0; //@line 16609
   if (HEAP8[$25 >> 0] & 16) break;
   $ci$0$i$i = HEAP32[$ci$02$i$i + 8 >> 2] | 0; //@line 16617
   if (!$ci$0$i$i) break L10; else $ci$02$i$i = $ci$0$i$i; //@line 16622
  }
  $29 = HEAP32[$17 >> 2] | 0; //@line 16625
  $31 = HEAP32[$ci$02$i$i + 20 >> 2] | 0; //@line 16627
  $32 = $29 + $31 | 0; //@line 16628
  _luaF_close($L, $32); //@line 16629
  if (($status$010 | 0) == 4) {
   $35 = HEAP32[(HEAP32[$21 >> 2] | 0) + 180 >> 2] | 0; //@line 16633
   HEAP32[$32 >> 2] = $35; //@line 16634
   HEAP32[$29 + ($31 + 8) >> 2] = HEAPU8[$35 + 4 >> 0] | 0 | 64; //@line 16641
  } else if (($status$010 | 0) == 6) {
   $41 = _luaS_newlstr($L, 4464, 23) | 0; //@line 16643
   HEAP32[$32 >> 2] = $41; //@line 16644
   HEAP32[$29 + ($31 + 8) >> 2] = HEAPU8[$41 + 4 >> 0] | 0 | 64; //@line 16651
  } else {
   $47 = HEAP32[$9 >> 2] | 0; //@line 16653
   $49 = $47 + -16 | 0; //@line 16655
   $54 = HEAP32[$49 + 4 >> 2] | 0; //@line 16660
   $55 = $32; //@line 16661
   HEAP32[$55 >> 2] = HEAP32[$49 >> 2]; //@line 16663
   HEAP32[$55 + 4 >> 2] = $54; //@line 16666
   HEAP32[$29 + ($31 + 8) >> 2] = HEAP32[$47 + -8 >> 2]; //@line 16671
  }
  $62 = $29 + ($31 + 16) | 0; //@line 16674
  HEAP32[$9 >> 2] = $62; //@line 16675
  HEAP32[$16 >> 2] = $ci$02$i$i; //@line 16676
  HEAP8[$18 >> 0] = HEAP8[$ci$02$i$i + 36 >> 0] | 0; //@line 16679
  HEAP16[$0 >> 1] = 0; //@line 16680
  if (!$ci$02$i$i) $lim$0$lcssa$i$i$i = $62; //@line 16683
 else {
   $ci$03$i$i$i = $ci$02$i$i; //@line 16685
   $lim$02$i$i$i = $62; //@line 16685
   while (1) {
    $67 = HEAP32[$ci$03$i$i$i + 4 >> 2] | 0; //@line 16688
    $$lim$0$i$i$i = $lim$02$i$i$i >>> 0 < $67 >>> 0 ? $67 : $lim$02$i$i$i; //@line 16690
    $ci$03$i$i$i = HEAP32[$ci$03$i$i$i + 8 >> 2] | 0; //@line 16692
    if (!$ci$03$i$i$i) {
     $lim$0$lcssa$i$i$i = $$lim$0$i$i$i; //@line 16695
     break;
    } else $lim$02$i$i$i = $$lim$0$i$i$i; //@line 16698
   }
  }
  $74 = $lim$0$lcssa$i$i$i - (HEAP32[$17 >> 2] | 0) | 0; //@line 16705
  $76 = ($74 >> 4) + 1 | 0; //@line 16707
  $79 = (($76 | 0) / 8 | 0) + 10 + $76 | 0; //@line 16710
  $$$i$i = ($79 | 0) > 1e6 ? 1e6 : $79; //@line 16712
  if (($74 | 0) <= 15999984) if (($$$i$i | 0) < (HEAP32[$20 >> 2] | 0)) _luaD_reallocstack($L, $$$i$i); //@line 16718
  HEAP32[$19 >> 2] = HEAP32[$ci$02$i$i + 32 >> 2]; //@line 16723
  HEAP8[$25 >> 0] = HEAPU8[$25 >> 0] | 0 | 32; //@line 16728
  HEAP8[$ci$02$i$i + 37 >> 0] = $status$010; //@line 16731
  $92 = _luaD_rawrunprotected($L, 22, 0) | 0; //@line 16732
  if ($92 >>> 0 > 1) $status$010 = $92; //@line 16735
 else {
   $status$1 = $92; //@line 16737
   label = 24; //@line 16738
   break;
  }
 }
 if ((label | 0) == 24) {
  HEAP16[$0 >> 1] = $1; //@line 16743
  $128 = HEAP16[$7 >> 1] | 0; //@line 16744
  $129 = $128 + -1 << 16 >> 16; //@line 16745
  HEAP16[$7 >> 1] = $129; //@line 16746
  STACKTOP = sp; //@line 16747
  return $status$1 | 0; //@line 16747
 }
 HEAP8[$L + 6 >> 0] = $status$010; //@line 16751
 $96 = HEAP32[$9 >> 2] | 0; //@line 16752
 if (($status$010 | 0) == 4) {
  $99 = HEAP32[(HEAP32[$21 >> 2] | 0) + 180 >> 2] | 0; //@line 16756
  HEAP32[$96 >> 2] = $99; //@line 16757
  HEAP32[$96 + 8 >> 2] = HEAPU8[$99 + 4 >> 0] | 0 | 64; //@line 16763
 } else if (($status$010 | 0) == 6) {
  $105 = _luaS_newlstr($L, 4464, 23) | 0; //@line 16765
  HEAP32[$96 >> 2] = $105; //@line 16766
  HEAP32[$96 + 8 >> 2] = HEAPU8[$105 + 4 >> 0] | 0 | 64; //@line 16772
 } else {
  $112 = $96 + -16 | 0; //@line 16775
  $117 = HEAP32[$112 + 4 >> 2] | 0; //@line 16780
  $118 = $96; //@line 16781
  HEAP32[$118 >> 2] = HEAP32[$112 >> 2]; //@line 16783
  HEAP32[$118 + 4 >> 2] = $117; //@line 16786
  HEAP32[$96 + 8 >> 2] = HEAP32[$96 + -8 >> 2]; //@line 16790
 }
 $125 = $96 + 16 | 0; //@line 16792
 HEAP32[$9 >> 2] = $125; //@line 16793
 HEAP32[(HEAP32[$16 >> 2] | 0) + 4 >> 2] = $125; //@line 16796
 $status$1 = $status$010; //@line 16797
 HEAP16[$0 >> 1] = $1; //@line 16798
 $128 = HEAP16[$7 >> 1] | 0; //@line 16799
 $129 = $128 + -1 << 16 >> 16; //@line 16800
 HEAP16[$7 >> 1] = $129; //@line 16801
 STACKTOP = sp; //@line 16802
 return $status$1 | 0; //@line 16802
}
function _str_find_aux($L, $find) {
 $L = $L | 0;
 $find = $find | 0;
 var $$$i = 0, $$0$i = 0, $$0$i512 = 0, $$014$i = 0, $$023$i = 0, $$1 = 0, $$lcssa17 = 0, $0 = 0, $1 = 0, $12 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $23 = 0, $26 = 0, $29 = 0, $3 = 0, $33 = 0, $34 = 0, $35 = 0, $40 = 0, $42 = 0, $48 = 0, $52 = 0, $54 = 0, $57 = 0, $58 = 0, $62 = 0, $64 = 0, $66 = 0, $67 = 0, $69 = 0, $72 = 0, $77 = 0, $82 = 0, $i$01$i = 0, $i$01$i6 = 0, $init$0 = 0, $lp = 0, $ls = 0, $ms = 0, $p$0 = 0, $s1$0 = 0, $s1$0$lcssa = 0, $upto$0$i = 0, label = 0, sp = 0, $$023$i$looptemp = 0;
 sp = STACKTOP; //@line 14731
 STACKTOP = STACKTOP + 288 | 0; //@line 14732
 $ls = sp + 284 | 0; //@line 14733
 $lp = sp + 280 | 0; //@line 14734
 $ms = sp; //@line 14735
 $0 = _luaL_checklstring($L, 1, $ls) | 0; //@line 14736
 $1 = _luaL_checklstring($L, 2, $lp) | 0; //@line 14737
 $2 = _luaL_optinteger($L, 3, 1) | 0; //@line 14738
 $3 = HEAP32[$ls >> 2] | 0; //@line 14739
 if (($2 | 0) > -1) {
  $$0$i = $2; //@line 14742
  label = 4; //@line 14743
 } else if ($3 >>> 0 < (0 - $2 | 0) >>> 0) $init$0 = 1; //@line 14748
 else {
  $$0$i = $2 + 1 + $3 | 0; //@line 14752
  label = 4; //@line 14753
 }
 if ((label | 0) == 4) if (!$$0$i) $init$0 = 1; //@line 14759
 else if ($$0$i >>> 0 > ($3 + 1 | 0) >>> 0) {
  _lua_pushnil($L); //@line 14764
  $$1 = 1; //@line 14765
  STACKTOP = sp; //@line 14766
  return $$1 | 0; //@line 14766
 } else $init$0 = $$0$i; //@line 14768
 $12 = ($find | 0) != 0; //@line 14772
 L10 : do if ($12) {
  $14 = (_lua_toboolean($L, 4) | 0) == 0; //@line 14776
  $15 = HEAP32[$lp >> 2] | 0; //@line 14777
  if ($14) {
   $upto$0$i = 0; //@line 14779
   do {
    $16 = $1 + $upto$0$i | 0; //@line 14781
    if (_strpbrk($16, 10368) | 0) {
     label = 20; //@line 14785
     break L10;
    }
    $upto$0$i = $upto$0$i + 1 + (_strlen($16 | 0) | 0) | 0; //@line 14790
   } while ($upto$0$i >>> 0 <= $15 >>> 0);
  }
  $23 = $0 + ($init$0 + -1) | 0; //@line 14800
  $26 = (HEAP32[$ls >> 2] | 0) - $init$0 + 1 | 0; //@line 14803
  L17 : do if (!$15) if (!$23) break L10; else $$0$i512 = $23; //@line 14811
 else {
   if ($15 >>> 0 > $26 >>> 0) break L10;
   $29 = $15 + -1 | 0; //@line 14818
   if (($29 | 0) == ($26 | 0)) break L10;
   $33 = HEAP8[$1 >> 0] | 0; //@line 14825
   $34 = $1 + 1 | 0; //@line 14826
   $$014$i = $26 - $29 | 0; //@line 14827
   $$023$i = $23; //@line 14827
   while (1) {
    $35 = _memchr($$023$i, $33, $$014$i) | 0; //@line 14829
    if (!$35) break L10;
    $$023$i$looptemp = $$023$i;
    $$023$i = $35 + 1 | 0; //@line 14834
    if (!(_memcmp($$023$i, $34, $29) | 0)) {
     $$0$i512 = $35; //@line 14838
     break L17;
    }
    $40 = $$023$i; //@line 14841
    $42 = $$023$i$looptemp + $$014$i | 0; //@line 14843
    if (($42 | 0) == ($40 | 0)) break L10; else $$014$i = $42 - $40 | 0; //@line 14849
   }
  } while (0);
  $48 = $$0$i512 - $0 | 0; //@line 14856
  _lua_pushinteger($L, $48 + 1 | 0); //@line 14858
  _lua_pushinteger($L, $48 + (HEAP32[$lp >> 2] | 0) | 0); //@line 14861
  $$1 = 2; //@line 14862
  STACKTOP = sp; //@line 14863
  return $$1 | 0; //@line 14863
 } else label = 20; //@line 14865
 while (0);
 L28 : do if ((label | 0) == 20) {
  $52 = $0 + ($init$0 + -1) | 0; //@line 14871
  $54 = (HEAP8[$1 >> 0] | 0) == 94; //@line 14873
  if ($54) {
   $57 = (HEAP32[$lp >> 2] | 0) + -1 | 0; //@line 14877
   HEAP32[$lp >> 2] = $57; //@line 14878
   $64 = $57; //@line 14879
   $p$0 = $1 + 1 | 0; //@line 14879
  } else {
   $64 = HEAP32[$lp >> 2] | 0; //@line 14882
   $p$0 = $1; //@line 14882
  }
  $58 = $ms + 16 | 0; //@line 14884
  HEAP32[$58 >> 2] = $L; //@line 14885
  HEAP32[$ms >> 2] = 200; //@line 14886
  HEAP32[$ms + 4 >> 2] = $0; //@line 14888
  $62 = $ms + 8 | 0; //@line 14891
  HEAP32[$62 >> 2] = $0 + (HEAP32[$ls >> 2] | 0); //@line 14892
  HEAP32[$ms + 12 >> 2] = $p$0 + $64; //@line 14895
  $66 = $ms + 20 | 0; //@line 14896
  L34 : do if ($54) {
   HEAP32[$66 >> 2] = 0; //@line 14899
   $67 = _match($ms, $52, $p$0) | 0; //@line 14900
   if (!$67) break L28; else {
    $$lcssa17 = $67; //@line 14905
    $s1$0$lcssa = $52; //@line 14905
   }
  } else {
   $s1$0 = $52; //@line 14908
   while (1) {
    HEAP32[$66 >> 2] = 0; //@line 14910
    $69 = _match($ms, $s1$0, $p$0) | 0; //@line 14911
    if ($69) {
     $$lcssa17 = $69; //@line 14914
     $s1$0$lcssa = $s1$0; //@line 14914
     break L34;
    }
    if ($s1$0 >>> 0 >= (HEAP32[$62 >> 2] | 0) >>> 0) break L28;
    $s1$0 = $s1$0 + 1 | 0; //@line 14923
   }
  } while (0);
  if ($12) {
   $72 = $0; //@line 14929
   _lua_pushinteger($L, 1 - $72 + $s1$0$lcssa | 0); //@line 14932
   _lua_pushinteger($L, $$lcssa17 - $72 | 0); //@line 14935
   $77 = HEAP32[$66 >> 2] | 0; //@line 14936
   _luaL_checkstack(HEAP32[$58 >> 2] | 0, $77, 10056); //@line 14938
   if (($77 | 0) > 0) {
    $i$01$i6 = 0; //@line 14941
    do {
     _push_onecapture($ms, $i$01$i6, 0, 0); //@line 14943
     $i$01$i6 = $i$01$i6 + 1 | 0; //@line 14944
    } while (($i$01$i6 | 0) != ($77 | 0));
   }
   $$1 = $77 + 2 | 0; //@line 14954
   STACKTOP = sp; //@line 14955
   return $$1 | 0; //@line 14955
  } else {
   $82 = HEAP32[$66 >> 2] | 0; //@line 14957
   $$$i = ($82 | 0) != 0 | ($s1$0$lcssa | 0) == 0 ? $82 : 1; //@line 14961
   _luaL_checkstack(HEAP32[$58 >> 2] | 0, $$$i, 10056); //@line 14963
   if (($$$i | 0) > 0) $i$01$i = 0; //@line 14966
 else {
    $$1 = $82; //@line 14968
    STACKTOP = sp; //@line 14969
    return $$1 | 0; //@line 14969
   }
   do {
    _push_onecapture($ms, $i$01$i, $s1$0$lcssa, $$lcssa17); //@line 14972
    $i$01$i = $i$01$i + 1 | 0; //@line 14973
   } while (($i$01$i | 0) != ($$$i | 0));
   $$1 = $$$i; //@line 14976
   STACKTOP = sp; //@line 14982
   return $$1 | 0; //@line 14982
  }
 } while (0);
 _lua_pushnil($L); //@line 14986
 $$1 = 1; //@line 14987
 STACKTOP = sp; //@line 14988
 return $$1 | 0; //@line 14988
}
function _traverseephemeron($g, $h) {
 $g = $g | 0;
 $h = $h | 0;
 var $10 = 0, $11 = 0, $17 = 0, $24 = 0, $26 = 0, $27 = 0, $28 = 0, $30 = 0, $31 = 0, $33 = 0, $4 = 0, $43 = 0, $5 = 0, $50 = 0, $57 = 0, $6 = 0, $63 = 0, $7 = 0, $71 = 0, $75 = 0, $78 = 0, $8 = 0, $81 = 0, $hasclears$01 = 0, $hasclears$1 = 0, $i$012 = 0, $marked$0$lcssa = 0, $marked$011 = 0, $marked$1 = 0, $marked$2$lcssa20 = 0, $marked$2$lcssa2123 = 0, $marked$27 = 0, $marked$3 = 0, $n$05 = 0, $prop$03 = 0, $prop$1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 1643
 $4 = $h + 16 | 0; //@line 1648
 $5 = HEAP32[$4 >> 2] | 0; //@line 1649
 $6 = $5 + (1 << (HEAPU8[$h + 7 >> 0] | 0) << 5) | 0; //@line 1650
 $7 = $h + 28 | 0; //@line 1651
 $8 = HEAP32[$7 >> 2] | 0; //@line 1652
 if (($8 | 0) > 0) {
  $10 = $h + 12 | 0; //@line 1655
  $81 = $8; //@line 1656
  $i$012 = 0; //@line 1656
  $marked$011 = 0; //@line 1656
  while (1) {
   $11 = HEAP32[$10 >> 2] | 0; //@line 1658
   if (!(HEAP32[$11 + ($i$012 << 4) + 8 >> 2] & 64)) {
    $24 = $81; //@line 1664
    $marked$1 = $marked$011; //@line 1664
   } else {
    $17 = HEAP32[$11 + ($i$012 << 4) >> 2] | 0; //@line 1667
    if (!(HEAP8[$17 + 5 >> 0] & 3)) {
     $24 = $81; //@line 1673
     $marked$1 = $marked$011; //@line 1673
    } else {
     _reallymarkobject($g, $17); //@line 1675
     $24 = HEAP32[$7 >> 2] | 0; //@line 1677
     $marked$1 = 1; //@line 1677
    }
   }
   $i$012 = $i$012 + 1 | 0; //@line 1680
   if (($i$012 | 0) >= ($24 | 0)) break; else {
    $81 = $24; //@line 1683
    $marked$011 = $marked$1; //@line 1683
   }
  }
  $26 = HEAP32[$4 >> 2] | 0; //@line 1689
  $marked$0$lcssa = $marked$1; //@line 1689
 } else {
  $26 = $5; //@line 1691
  $marked$0$lcssa = 0; //@line 1691
 }
 if ($26 >>> 0 < $6 >>> 0) {
  $hasclears$01 = 0; //@line 1695
  $marked$27 = $marked$0$lcssa; //@line 1695
  $n$05 = $26; //@line 1695
  $prop$03 = 0; //@line 1695
  while (1) {
   $27 = $n$05 + 8 | 0; //@line 1697
   $28 = HEAP32[$27 >> 2] | 0; //@line 1698
   $30 = $n$05 + 24 | 0; //@line 1700
   $31 = HEAP32[$30 >> 2] | 0; //@line 1701
   $33 = ($31 & 64 | 0) == 0; //@line 1703
   L14 : do if (!$28) if ($33) {
    $hasclears$1 = $hasclears$01; //@line 1707
    $marked$3 = $marked$27; //@line 1707
    $prop$1 = $prop$03; //@line 1707
   } else if (!(HEAP8[(HEAP32[$n$05 + 16 >> 2] | 0) + 5 >> 0] & 3)) {
    $hasclears$1 = $hasclears$01; //@line 1716
    $marked$3 = $marked$27; //@line 1716
    $prop$1 = $prop$03; //@line 1716
   } else {
    HEAP32[$30 >> 2] = 11; //@line 1718
    $hasclears$1 = $hasclears$01; //@line 1719
    $marked$3 = $marked$27; //@line 1719
    $prop$1 = $prop$03; //@line 1719
   } else {
    do if ($33) {
     $50 = $28; //@line 1725
     label = 18; //@line 1726
    } else {
     $43 = HEAP32[$n$05 + 16 >> 2] | 0; //@line 1731
     if (($31 & 15 | 0) == 4) {
      if (!$43) {
       $50 = $28; //@line 1735
       label = 18; //@line 1736
       break;
      }
      if (!(HEAP8[$43 + 5 >> 0] & 3)) {
       $50 = $28; //@line 1744
       label = 18; //@line 1745
       break;
      }
      _reallymarkobject($g, $43); //@line 1748
      $50 = HEAP32[$27 >> 2] | 0; //@line 1750
      label = 18; //@line 1751
      break;
     }
     $57 = ($28 & 64 | 0) == 0; //@line 1759
     if (!(HEAP8[$43 + 5 >> 0] & 3)) if ($57) {
      $hasclears$1 = $hasclears$01; //@line 1762
      $marked$3 = $marked$27; //@line 1762
      $prop$1 = $prop$03; //@line 1762
      break L14;
     } else break;
     if ($57) {
      $hasclears$1 = 1; //@line 1769
      $marked$3 = $marked$27; //@line 1769
      $prop$1 = $prop$03; //@line 1769
      break L14;
     }
     $hasclears$1 = 1; //@line 1778
     $marked$3 = $marked$27; //@line 1778
     $prop$1 = (HEAP8[(HEAP32[$n$05 >> 2] | 0) + 5 >> 0] & 3) == 0 ? $prop$03 : 1; //@line 1778
     break L14;
    } while (0);
    if ((label | 0) == 18) {
     label = 0; //@line 1783
     if (!($50 & 64)) {
      $hasclears$1 = $hasclears$01; //@line 1787
      $marked$3 = $marked$27; //@line 1787
      $prop$1 = $prop$03; //@line 1787
      break;
     }
    }
    $63 = HEAP32[$n$05 >> 2] | 0; //@line 1791
    if (!(HEAP8[$63 + 5 >> 0] & 3)) {
     $hasclears$1 = $hasclears$01; //@line 1797
     $marked$3 = $marked$27; //@line 1797
     $prop$1 = $prop$03; //@line 1797
    } else {
     _reallymarkobject($g, $63); //@line 1799
     $hasclears$1 = $hasclears$01; //@line 1800
     $marked$3 = 1; //@line 1800
     $prop$1 = $prop$03; //@line 1800
    }
   } while (0);
   $n$05 = $n$05 + 32 | 0; //@line 1804
   if ($n$05 >>> 0 >= $6 >>> 0) break; else {
    $hasclears$01 = $hasclears$1; //@line 1807
    $marked$27 = $marked$3; //@line 1807
    $prop$03 = $prop$1; //@line 1807
   }
  }
  if ($prop$1) {
   $71 = $g + 96 | 0; //@line 1814
   HEAP32[$h + 24 >> 2] = HEAP32[$71 >> 2]; //@line 1817
   HEAP32[$71 >> 2] = $h; //@line 1818
   $marked$2$lcssa20 = $marked$3; //@line 1819
   STACKTOP = sp; //@line 1820
   return $marked$2$lcssa20 | 0; //@line 1820
  }
  if (!$hasclears$1) $marked$2$lcssa2123 = $marked$3; //@line 1824
 else {
   $75 = $g + 100 | 0; //@line 1826
   HEAP32[$h + 24 >> 2] = HEAP32[$75 >> 2]; //@line 1829
   HEAP32[$75 >> 2] = $h; //@line 1830
   $marked$2$lcssa20 = $marked$3; //@line 1831
   STACKTOP = sp; //@line 1832
   return $marked$2$lcssa20 | 0; //@line 1832
  }
 } else $marked$2$lcssa2123 = $marked$0$lcssa; //@line 1835
 $78 = $g + 88 | 0; //@line 1837
 HEAP32[$h + 24 >> 2] = HEAP32[$78 >> 2]; //@line 1840
 HEAP32[$78 >> 2] = $h; //@line 1841
 $marked$2$lcssa20 = $marked$2$lcssa2123; //@line 1842
 STACKTOP = sp; //@line 1843
 return $marked$2$lcssa20 | 0; //@line 1843
}
function _luaK_goiftrue($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $$0$i$i = 0, $0 = 0, $1 = 0, $101 = 0, $103 = 0, $12 = 0, $19 = 0, $2 = 0, $25 = 0, $28 = 0, $3 = 0, $33 = 0, $34 = 0, $36 = 0, $38 = 0, $47 = 0, $48 = 0, $5 = 0, $53 = 0, $6 = 0, $60 = 0, $65 = 0, $67 = 0, $69 = 0, $70 = 0, $72 = 0, $75 = 0, $77 = 0, $86 = 0, $87 = 0, $91 = 0, $93 = 0, $95 = 0, $96 = 0, $98 = 0, $fs$idx$val$idx$val = 0, $fs$idx$val$idx$val$i = 0, $fs$idx$val$idx$val$i$i = 0, $list$0$i = 0, $list$0$i$i = 0, $pc$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11180
 _luaK_dischargevars($fs, $e); //@line 11181
 $0 = HEAP32[$e >> 2] | 0; //@line 11182
 do if (($0 | 0) == 10) {
  $fs$idx$val$idx$val = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11187
  $1 = $e + 8 | 0; //@line 11188
  $2 = HEAP32[$1 >> 2] | 0; //@line 11189
  $3 = $fs$idx$val$idx$val + ($2 << 2) | 0; //@line 11190
  if (($2 | 0) > 0) {
   $5 = $fs$idx$val$idx$val + ($2 + -1 << 2) | 0; //@line 11194
   $6 = HEAP32[$5 >> 2] | 0; //@line 11195
   if ((HEAP8[8440 + ($6 & 63) >> 0] | 0) < 0) {
    $$0$i$i = $5; //@line 11201
    $12 = $6; //@line 11201
   } else label = 4; //@line 11203
  } else label = 4; //@line 11206
  if ((label | 0) == 4) {
   $$0$i$i = $3; //@line 11210
   $12 = HEAP32[$3 >> 2] | 0; //@line 11210
  }
  HEAP32[$$0$i$i >> 2] = (($12 & 16320 | 0) == 0 & 1) << 6 | $12 & -16321; //@line 11218
  $pc$0 = HEAP32[$1 >> 2] | 0; //@line 11220
  label = 18; //@line 11221
 } else if (!(($0 | 0) == 2 | ($0 | 0) == 5 | ($0 | 0) == 4)) {
  $19 = $e + 8 | 0; //@line 11223
  if (($0 | 0) == 11) {
   $25 = HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$19 >> 2] << 2) >> 2] | 0; //@line 11230
   if (($25 & 63 | 0) == 20) {
    $28 = $fs + 20 | 0; //@line 11234
    HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + -1; //@line 11237
    $pc$0 = _condjump($fs, 27, $25 >>> 23, 0, 1) | 0; //@line 11240
    label = 18; //@line 11241
    break;
   } else label = 9; //@line 11244
  } else if (($0 | 0) == 6) label = 14; //@line 11247
 else label = 9; //@line 11249
  if ((label | 0) == 9) {
   $33 = $fs + 48 | 0; //@line 11252
   $34 = HEAP8[$33 >> 0] | 0; //@line 11253
   $36 = ($34 & 255) + 1 | 0; //@line 11255
   $38 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 11257
   do if ($36 >>> 0 > (HEAPU8[$38 >> 0] | 0) >>> 0) if ($36 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 11267
 else {
    HEAP8[$38 >> 0] = $36; //@line 11271
    $47 = HEAP8[$33 >> 0] | 0; //@line 11273
    break;
   } else $47 = $34; //@line 11277
 while (0);
   $48 = ($47 & 255) + 1 | 0; //@line 11281
   HEAP8[$33 >> 0] = $48; //@line 11283
   _discharge2reg($fs, $e, ($48 & 255) + -1 | 0); //@line 11286
   if ((HEAP32[$e >> 2] | 0) == 6) label = 14; //@line 11290
  }
  if ((label | 0) == 14) {
   $53 = HEAP32[$19 >> 2] | 0; //@line 11294
   if (!($53 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0) <= ($53 | 0)) {
    $60 = $fs + 48 | 0; //@line 11303
    HEAP8[$60 >> 0] = (HEAP8[$60 >> 0] | 0) + -1 << 24 >> 24; //@line 11306
   }
  }
  $pc$0 = _condjump($fs, 28, 255, HEAP32[$19 >> 2] | 0, 0) | 0; //@line 11312
  label = 18; //@line 11313
 } while (0);
 do if ((label | 0) == 18) {
  $65 = $e + 20 | 0; //@line 11318
  if (($pc$0 | 0) != -1) {
   $67 = HEAP32[$65 >> 2] | 0; //@line 11321
   if (($67 | 0) == -1) {
    HEAP32[$65 >> 2] = $pc$0; //@line 11324
    break;
   }
   $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11329
   $list$0$i = $67; //@line 11330
   while (1) {
    $69 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 11332
    $70 = HEAP32[$69 >> 2] | 0; //@line 11333
    $72 = ($70 >>> 14) + -131071 | 0; //@line 11335
    if (($72 | 0) == -1) break;
    $75 = $list$0$i + 1 + $72 | 0; //@line 11341
    if (($75 | 0) == -1) break; else $list$0$i = $75; //@line 11346
   }
   $77 = $pc$0 + ~$list$0$i | 0; //@line 11350
   if (((($77 | 0) > -1 ? $77 : 0 - $77 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 11358
 else {
    HEAP32[$69 >> 2] = ($77 << 14) + 2147467264 | $70 & 16383; //@line 11365
    break;
   }
  }
 } while (0);
 $86 = $e + 16 | 0; //@line 11371
 $87 = HEAP32[$86 >> 2] | 0; //@line 11372
 HEAP32[$fs + 24 >> 2] = HEAP32[$fs + 20 >> 2]; //@line 11376
 $91 = $fs + 28 | 0; //@line 11377
 if (($87 | 0) == -1) {
  HEAP32[$86 >> 2] = -1; //@line 11380
  STACKTOP = sp; //@line 11381
  return;
 }
 $93 = HEAP32[$91 >> 2] | 0; //@line 11383
 if (($93 | 0) == -1) {
  HEAP32[$91 >> 2] = $87; //@line 11386
  HEAP32[$86 >> 2] = -1; //@line 11387
  STACKTOP = sp; //@line 11388
  return;
 }
 $fs$idx$val$idx$val$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11392
 $list$0$i$i = $93; //@line 11393
 while (1) {
  $95 = $fs$idx$val$idx$val$i$i + ($list$0$i$i << 2) | 0; //@line 11395
  $96 = HEAP32[$95 >> 2] | 0; //@line 11396
  $98 = ($96 >>> 14) + -131071 | 0; //@line 11398
  if (($98 | 0) == -1) break;
  $101 = $list$0$i$i + 1 + $98 | 0; //@line 11404
  if (($101 | 0) == -1) break; else $list$0$i$i = $101; //@line 11409
 }
 $103 = $87 + ~$list$0$i$i | 0; //@line 11413
 if (((($103 | 0) > -1 ? $103 : 0 - $103 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 11421
 HEAP32[$95 >> 2] = ($103 << 14) + 2147467264 | $96 & 16383; //@line 11428
 HEAP32[$86 >> 2] = -1; //@line 11429
 STACKTOP = sp; //@line 11430
 return;
}
function _forbody($ls, $base, $line, $nvars, $isnum) {
 $ls = $ls | 0;
 $base = $base | 0;
 $line = $line | 0;
 $nvars = $nvars | 0;
 $isnum = $isnum | 0;
 var $$idx$val$idx$val$pre$i = 0, $$idx$val$idx$val$pre$i8 = 0, $$idx1$i = 0, $$idx1$val$idx$val$idx$val$pre$i = 0, $$idx1$val$idx$val$idx$val$pre$i12 = 0, $$idx2$i = 0, $$idx2$i4 = 0, $0 = 0, $1 = 0, $101 = 0, $104 = 0, $108 = 0, $2 = 0, $32 = 0, $35 = 0, $43 = 0, $5 = 0, $53 = 0, $55 = 0, $58 = 0, $61 = 0, $7 = 0, $70 = 0, $75 = 0, $83 = 0, $91 = 0, $bl = 0, $bl$i = 0, $endfor$0 = 0, $ls$idx$val = 0, $ls$idx$val$i$i = 0, sp = 0;
 sp = STACKTOP; //@line 12184
 STACKTOP = STACKTOP + 32 | 0; //@line 12185
 $bl$i = sp + 12 | 0; //@line 12186
 $bl = sp; //@line 12187
 $0 = $ls + 48 | 0; //@line 12188
 $1 = HEAP32[$0 >> 2] | 0; //@line 12189
 $2 = $1 + 46 | 0; //@line 12190
 $5 = (HEAPU8[$2 >> 0] | 0) + 3 | 0; //@line 12193
 HEAP8[$2 >> 0] = $5; //@line 12195
 $7 = $1 + 20 | 0; //@line 12196
 $$idx1$i = $1 + 12 | 0; //@line 12197
 $$idx2$i = $1 + 40 | 0; //@line 12198
 $$idx$val$idx$val$pre$i = HEAP32[(HEAP32[$1 >> 2] | 0) + 24 >> 2] | 0; //@line 12202
 $$idx1$val$idx$val$idx$val$pre$i = HEAP32[HEAP32[(HEAP32[$$idx1$i >> 2] | 0) + 64 >> 2] >> 2] | 0; //@line 12205
 HEAP32[$$idx$val$idx$val$pre$i + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i + (($5 & 255) + -3 + (HEAP32[$$idx2$i >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$7 >> 2]; //@line 12215
 HEAP32[$$idx$val$idx$val$pre$i + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i + ((HEAPU8[$2 >> 0] | 0) + -2 + (HEAP32[$$idx2$i >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$7 >> 2]; //@line 12226
 HEAP32[$$idx$val$idx$val$pre$i + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i + ((HEAPU8[$2 >> 0] | 0) + -1 + (HEAP32[$$idx2$i >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$7 >> 2]; //@line 12237
 $32 = $ls + 16 | 0; //@line 12238
 if ((HEAP32[$32 >> 2] | 0) != 259) _error_expected($ls, 259); //@line 12242
 _luaX_next($ls); //@line 12245
 $35 = ($isnum | 0) != 0; //@line 12246
 if ($35) $104 = _luaK_codeABx($1, 33, $base, 131070) | 0; //@line 12249
 else $104 = _luaK_jump($1) | 0; //@line 12252
 HEAP8[$bl + 10 >> 0] = 0; //@line 12255
 HEAP8[$bl + 8 >> 0] = HEAP8[$2 >> 0] | 0; //@line 12258
 $43 = HEAP32[(HEAP32[$$idx1$i >> 2] | 0) + 64 >> 2] | 0; //@line 12261
 HEAP16[$bl + 4 >> 1] = HEAP32[$43 + 28 >> 2]; //@line 12266
 HEAP16[$bl + 6 >> 1] = HEAP32[$43 + 16 >> 2]; //@line 12271
 HEAP8[$bl + 9 >> 0] = 0; //@line 12273
 $53 = $1 + 16 | 0; //@line 12274
 HEAP32[$bl >> 2] = HEAP32[$53 >> 2]; //@line 12276
 HEAP32[$53 >> 2] = $bl; //@line 12277
 $ls$idx$val = HEAP32[$0 >> 2] | 0; //@line 12278
 $55 = $ls$idx$val + 46 | 0; //@line 12279
 $58 = (HEAPU8[$55 >> 0] | 0) + $nvars | 0; //@line 12282
 HEAP8[$55 >> 0] = $58; //@line 12284
 if ($nvars) {
  $61 = $ls$idx$val + 20 | 0; //@line 12287
  $$idx2$i4 = $ls$idx$val + 40 | 0; //@line 12289
  $$idx$val$idx$val$pre$i8 = HEAP32[(HEAP32[$ls$idx$val >> 2] | 0) + 24 >> 2] | 0; //@line 12293
  $$idx1$val$idx$val$idx$val$pre$i12 = HEAP32[HEAP32[(HEAP32[$ls$idx$val + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0; //@line 12296
  HEAP32[$$idx$val$idx$val$pre$i8 + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i12 + (($58 & 255) - $nvars + (HEAP32[$$idx2$i4 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$61 >> 2]; //@line 12306
  $70 = $nvars + -1 | 0; //@line 12307
  if ($70) {
   $75 = $70; //@line 12310
   do {
    HEAP32[$$idx$val$idx$val$pre$i8 + ((HEAP16[$$idx1$val$idx$val$idx$val$pre$i12 + ((HEAPU8[$55 >> 0] | 0) - $75 + (HEAP32[$$idx2$i4 >> 2] | 0) << 1) >> 1] | 0) * 12 | 0) + 4 >> 2] = HEAP32[$61 >> 2]; //@line 12322
    $75 = $75 + -1 | 0; //@line 12323
   } while (($75 | 0) != 0);
  }
 }
 _luaK_reserveregs($1, $nvars); //@line 12333
 $83 = HEAP32[$0 >> 2] | 0; //@line 12334
 HEAP8[$bl$i + 10 >> 0] = 0; //@line 12336
 HEAP8[$bl$i + 8 >> 0] = HEAP8[$83 + 46 >> 0] | 0; //@line 12340
 $91 = HEAP32[(HEAP32[$83 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 12344
 HEAP16[$bl$i + 4 >> 1] = HEAP32[$91 + 28 >> 2]; //@line 12349
 HEAP16[$bl$i + 6 >> 1] = HEAP32[$91 + 16 >> 2]; //@line 12354
 HEAP8[$bl$i + 9 >> 0] = 0; //@line 12356
 $101 = $83 + 16 | 0; //@line 12357
 HEAP32[$bl$i >> 2] = HEAP32[$101 >> 2]; //@line 12359
 HEAP32[$101 >> 2] = $bl$i; //@line 12360
 L13 : do {
  $ls$idx$val$i$i = HEAP32[$32 >> 2] | 0; //@line 12362
  switch ($ls$idx$val$i$i | 0) {
  case 277:
  case 286:
  case 262:
  case 261:
  case 260:
   {
    break L13;
    break;
   }
  default:
   {}
  }
  _statement($ls); //@line 12372
 } while (($ls$idx$val$i$i | 0) != 274);
 _leaveblock($83); //@line 12377
 _leaveblock($1); //@line 12378
 _luaK_patchtohere($1, $104); //@line 12379
 if ($35) {
  $endfor$0 = _luaK_codeABx($1, 32, $base, 131070) | 0; //@line 12382
  $108 = $104 + 1 | 0; //@line 12383
  _luaK_patchlist($1, $endfor$0, $108); //@line 12384
  _luaK_fixline($1, $line); //@line 12385
  STACKTOP = sp; //@line 12386
  return;
 } else {
  _luaK_codeABC($1, 34, $base, 0, $nvars) | 0; //@line 12388
  _luaK_fixline($1, $line); //@line 12389
  $endfor$0 = _luaK_codeABx($1, 35, $base + 2 | 0, 131070) | 0; //@line 12392
  $108 = $104 + 1 | 0; //@line 12393
  _luaK_patchlist($1, $endfor$0, $108); //@line 12394
  _luaK_fixline($1, $line); //@line 12395
  STACKTOP = sp; //@line 12396
  return;
 }
}
function _luaL_gsub($L, $s, $p, $r) {
 $L = $L | 0;
 $s = $s | 0;
 $p = $p | 0;
 $r = $r | 0;
 var $$$i$i = 0, $$$i$i11 = 0, $$$i$i4 = 0, $$0$lcssa = 0, $$015 = 0, $$pre = 0, $$pre16 = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $13 = 0, $15 = 0, $2 = 0, $22 = 0, $23 = 0, $29 = 0, $3 = 0, $30 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $38 = 0, $4 = 0, $45 = 0, $5 = 0, $51 = 0, $52 = 0, $54 = 0, $55 = 0, $58 = 0, $60 = 0, $61 = 0, $63 = 0, $70 = 0, $71 = 0, $77 = 0, $78 = 0, $8 = 0, $80 = 0, $81 = 0, $85 = 0, $b = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP; //@line 7360
 STACKTOP = STACKTOP + 1056 | 0; //@line 7361
 $vararg_buffer3 = sp; //@line 7362
 $b = sp + 8 | 0; //@line 7363
 $0 = _strlen($p | 0) | 0; //@line 7364
 $1 = $b + 12 | 0; //@line 7365
 HEAP32[$1 >> 2] = $L; //@line 7366
 $2 = $b + 16 | 0; //@line 7367
 HEAP32[$b >> 2] = $2; //@line 7368
 $3 = $b + 8 | 0; //@line 7369
 HEAP32[$3 >> 2] = 0; //@line 7370
 $4 = $b + 4 | 0; //@line 7371
 HEAP32[$4 >> 2] = 1024; //@line 7372
 $5 = _strstr($s, $p) | 0; //@line 7373
 if (!$5) {
  $$0$lcssa = $s; //@line 7376
  $60 = 1024; //@line 7376
  $61 = 0; //@line 7376
  $70 = $L; //@line 7376
 } else {
  $$015 = $s; //@line 7378
  $12 = 1024; //@line 7378
  $13 = 0; //@line 7378
  $22 = $L; //@line 7378
  $8 = $5; //@line 7378
  while (1) {
   $10 = $8 - $$015 | 0; //@line 7382
   if (($12 - $13 | 0) >>> 0 < $10 >>> 0) {
    $15 = $12 << 1; //@line 7386
    $$$i$i = ($15 - $13 | 0) >>> 0 < $10 >>> 0 ? $13 + $10 | 0 : $15; //@line 7390
    if ($$$i$i >>> 0 < $13 >>> 0 | ($$$i$i - $13 | 0) >>> 0 < $10 >>> 0) _luaL_error($22, 360, $vararg_buffer3) | 0; //@line 7396
    $23 = _lua_newuserdata($22, $$$i$i) | 0; //@line 7398
    _memcpy($23 | 0, HEAP32[$b >> 2] | 0, HEAP32[$3 >> 2] | 0) | 0; //@line 7401
    if ((HEAP32[$b >> 2] | 0) != ($2 | 0)) _lua_remove($22, -2); //@line 7405
    HEAP32[$b >> 2] = $23; //@line 7407
    HEAP32[$4 >> 2] = $$$i$i; //@line 7408
    $29 = $23; //@line 7410
    $30 = HEAP32[$3 >> 2] | 0; //@line 7410
   } else {
    $29 = HEAP32[$b >> 2] | 0; //@line 7413
    $30 = $13; //@line 7413
   }
   _memcpy($29 + $30 | 0, $$015 | 0, $10 | 0) | 0; //@line 7416
   $32 = (HEAP32[$3 >> 2] | 0) + $10 | 0; //@line 7418
   HEAP32[$3 >> 2] = $32; //@line 7419
   $33 = _strlen($r | 0) | 0; //@line 7420
   $34 = HEAP32[$1 >> 2] | 0; //@line 7421
   $35 = HEAP32[$4 >> 2] | 0; //@line 7422
   if (($35 - $32 | 0) >>> 0 < $33 >>> 0) {
    $38 = $35 << 1; //@line 7426
    $$$i$i4 = ($38 - $32 | 0) >>> 0 < $33 >>> 0 ? $32 + $33 | 0 : $38; //@line 7430
    if ($$$i$i4 >>> 0 < $32 >>> 0 | ($$$i$i4 - $32 | 0) >>> 0 < $33 >>> 0) _luaL_error($34, 360, $vararg_buffer3) | 0; //@line 7436
    $45 = _lua_newuserdata($34, $$$i$i4) | 0; //@line 7438
    _memcpy($45 | 0, HEAP32[$b >> 2] | 0, HEAP32[$3 >> 2] | 0) | 0; //@line 7441
    if ((HEAP32[$b >> 2] | 0) != ($2 | 0)) _lua_remove($34, -2); //@line 7445
    HEAP32[$b >> 2] = $45; //@line 7447
    HEAP32[$4 >> 2] = $$$i$i4; //@line 7448
    $51 = $45; //@line 7450
    $52 = HEAP32[$3 >> 2] | 0; //@line 7450
   } else {
    $51 = HEAP32[$b >> 2] | 0; //@line 7453
    $52 = $32; //@line 7453
   }
   _memcpy($51 + $52 | 0, $r | 0, $33 | 0) | 0; //@line 7456
   $54 = (HEAP32[$3 >> 2] | 0) + $33 | 0; //@line 7458
   HEAP32[$3 >> 2] = $54; //@line 7459
   $55 = $8 + $0 | 0; //@line 7460
   $8 = _strstr($55, $p) | 0; //@line 7461
   $$pre = HEAP32[$1 >> 2] | 0; //@line 7463
   $$pre16 = HEAP32[$4 >> 2] | 0; //@line 7464
   if (!$8) {
    $$0$lcssa = $55; //@line 7466
    $60 = $$pre16; //@line 7466
    $61 = $54; //@line 7466
    $70 = $$pre; //@line 7466
    break;
   } else {
    $$015 = $55; //@line 7469
    $12 = $$pre16; //@line 7469
    $13 = $54; //@line 7469
    $22 = $$pre; //@line 7469
   }
  }
 }
 $58 = _strlen($$0$lcssa | 0) | 0; //@line 7473
 if (($60 - $61 | 0) >>> 0 < $58 >>> 0) {
  $63 = $60 << 1; //@line 7477
  $$$i$i11 = ($63 - $61 | 0) >>> 0 < $58 >>> 0 ? $61 + $58 | 0 : $63; //@line 7481
  if ($$$i$i11 >>> 0 < $61 >>> 0 | ($$$i$i11 - $61 | 0) >>> 0 < $58 >>> 0) _luaL_error($70, 360, $vararg_buffer3) | 0; //@line 7487
  $71 = _lua_newuserdata($70, $$$i$i11) | 0; //@line 7489
  _memcpy($71 | 0, HEAP32[$b >> 2] | 0, HEAP32[$3 >> 2] | 0) | 0; //@line 7492
  if ((HEAP32[$b >> 2] | 0) != ($2 | 0)) _lua_remove($70, -2); //@line 7496
  HEAP32[$b >> 2] = $71; //@line 7498
  HEAP32[$4 >> 2] = $$$i$i11; //@line 7499
  $77 = $71; //@line 7501
  $78 = HEAP32[$3 >> 2] | 0; //@line 7501
 } else {
  $77 = HEAP32[$b >> 2] | 0; //@line 7504
  $78 = $61; //@line 7504
 }
 _memcpy($77 + $78 | 0, $$0$lcssa | 0, $58 | 0) | 0; //@line 7507
 $80 = (HEAP32[$3 >> 2] | 0) + $58 | 0; //@line 7509
 HEAP32[$3 >> 2] = $80; //@line 7510
 $81 = HEAP32[$1 >> 2] | 0; //@line 7511
 _lua_pushlstring($81, HEAP32[$b >> 2] | 0, $80) | 0; //@line 7513
 if ((HEAP32[$b >> 2] | 0) == ($2 | 0)) {
  $85 = _lua_tolstring($L, -1, 0) | 0; //@line 7517
  STACKTOP = sp; //@line 7518
  return $85 | 0; //@line 7518
 }
 _lua_remove($81, -2); //@line 7520
 $85 = _lua_tolstring($L, -1, 0) | 0; //@line 7521
 STACKTOP = sp; //@line 7522
 return $85 | 0; //@line 7522
}
function _luaV_equalobj_($L, $t1, $t2) {
 $L = $L | 0;
 $t1 = $t1 | 0;
 $t2 = $t2 | 0;
 var $$0 = 0, $0 = 0, $107 = 0, $109 = 0, $110 = 0, $111 = 0, $116 = 0, $117 = 0, $124 = 0, $126 = 0, $131 = 0, $26 = 0, $27 = 0, $35 = 0, $36 = 0, $49 = 0, $50 = 0, $51 = 0, $55 = 0, $57 = 0, $62 = 0, $63 = 0, $70 = 0, $72 = 0, $77 = 0, $78 = 0, $84 = 0, $86 = 0, $91 = 0, $92 = 0, $tm$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1848
 $0 = $t1 + 8 | 0; //@line 1849
 L1 : do switch (HEAP32[$0 >> 2] & 63 | 0) {
 case 2:
  {
   $$0 = (HEAP32[$t1 >> 2] | 0) == (HEAP32[$t2 >> 2] | 0) & 1; //@line 1859
   STACKTOP = sp; //@line 1860
   return $$0 | 0; //@line 1860
  }
 case 7:
  {
   $26 = HEAP32[$t1 >> 2] | 0; //@line 1864
   $27 = HEAP32[$t2 >> 2] | 0; //@line 1865
   if (($26 | 0) == ($27 | 0)) {
    $$0 = 1; //@line 1868
    STACKTOP = sp; //@line 1869
    return $$0 | 0; //@line 1869
   }
   if (!$L) {
    $$0 = 0; //@line 1873
    STACKTOP = sp; //@line 1874
    return $$0 | 0; //@line 1874
   } else {
    $tm$0 = _get_equalTM($L, HEAP32[$26 + 8 >> 2] | 0, HEAP32[$27 + 8 >> 2] | 0) | 0; //@line 1881
    break L1;
   }
   break;
  }
 case 22:
  {
   $$0 = (HEAP32[$t1 >> 2] | 0) == (HEAP32[$t2 >> 2] | 0) & 1; //@line 1891
   STACKTOP = sp; //@line 1892
   return $$0 | 0; //@line 1892
  }
 case 5:
  {
   $35 = HEAP32[$t1 >> 2] | 0; //@line 1896
   $36 = HEAP32[$t2 >> 2] | 0; //@line 1897
   if (($35 | 0) == ($36 | 0)) {
    $$0 = 1; //@line 1900
    STACKTOP = sp; //@line 1901
    return $$0 | 0; //@line 1901
   }
   if (!$L) {
    $$0 = 0; //@line 1905
    STACKTOP = sp; //@line 1906
    return $$0 | 0; //@line 1906
   } else {
    $tm$0 = _get_equalTM($L, HEAP32[$35 + 8 >> 2] | 0, HEAP32[$36 + 8 >> 2] | 0) | 0; //@line 1913
    break L1;
   }
   break;
  }
 case 20:
  {
   $$0 = _luaS_eqlngstr(HEAP32[$t1 >> 2] | 0, HEAP32[$t2 >> 2] | 0) | 0; //@line 1922
   STACKTOP = sp; //@line 1923
   return $$0 | 0; //@line 1923
  }
 case 4:
  {
   $$0 = (HEAP32[$t1 >> 2] | 0) == (HEAP32[$t2 >> 2] | 0) & 1; //@line 1931
   STACKTOP = sp; //@line 1932
   return $$0 | 0; //@line 1932
  }
 case 3:
  {
   $$0 = +HEAPF64[$t1 >> 3] == +HEAPF64[$t2 >> 3] & 1; //@line 1940
   STACKTOP = sp; //@line 1941
   return $$0 | 0; //@line 1941
  }
 case 1:
  {
   $$0 = (HEAP32[$t1 >> 2] | 0) == (HEAP32[$t2 >> 2] | 0) & 1; //@line 1949
   STACKTOP = sp; //@line 1950
   return $$0 | 0; //@line 1950
  }
 case 0:
  {
   $$0 = 1; //@line 1954
   STACKTOP = sp; //@line 1955
   return $$0 | 0; //@line 1955
  }
 default:
  {
   $$0 = (HEAP32[$t1 >> 2] | 0) == (HEAP32[$t2 >> 2] | 0) & 1; //@line 1963
   STACKTOP = sp; //@line 1964
   return $$0 | 0; //@line 1964
  }
 } while (0);
 if (!$tm$0) {
  $$0 = 0; //@line 1970
  STACKTOP = sp; //@line 1971
  return $$0 | 0; //@line 1971
 }
 $49 = $L + 8 | 0; //@line 1973
 $50 = HEAP32[$49 >> 2] | 0; //@line 1974
 $51 = $L + 28 | 0; //@line 1975
 $55 = $50 - (HEAP32[$51 >> 2] | 0) | 0; //@line 1979
 HEAP32[$49 >> 2] = $50 + 16; //@line 1981
 $57 = $tm$0; //@line 1982
 $62 = HEAP32[$57 + 4 >> 2] | 0; //@line 1987
 $63 = $50; //@line 1988
 HEAP32[$63 >> 2] = HEAP32[$57 >> 2]; //@line 1990
 HEAP32[$63 + 4 >> 2] = $62; //@line 1993
 HEAP32[$50 + 8 >> 2] = HEAP32[$tm$0 + 8 >> 2]; //@line 1997
 $70 = HEAP32[$49 >> 2] | 0; //@line 1998
 HEAP32[$49 >> 2] = $70 + 16; //@line 2000
 $72 = $t1; //@line 2001
 $77 = HEAP32[$72 + 4 >> 2] | 0; //@line 2006
 $78 = $70; //@line 2007
 HEAP32[$78 >> 2] = HEAP32[$72 >> 2]; //@line 2009
 HEAP32[$78 + 4 >> 2] = $77; //@line 2012
 HEAP32[$70 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 2015
 $84 = HEAP32[$49 >> 2] | 0; //@line 2016
 HEAP32[$49 >> 2] = $84 + 16; //@line 2018
 $86 = $t2; //@line 2019
 $91 = HEAP32[$86 + 4 >> 2] | 0; //@line 2024
 $92 = $84; //@line 2025
 HEAP32[$92 >> 2] = HEAP32[$86 >> 2]; //@line 2027
 HEAP32[$92 + 4 >> 2] = $91; //@line 2030
 HEAP32[$84 + 8 >> 2] = HEAP32[$t2 + 8 >> 2]; //@line 2034
 _luaD_call($L, (HEAP32[$49 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 2043
 $107 = HEAP32[$51 >> 2] | 0; //@line 2044
 $109 = HEAP32[$49 >> 2] | 0; //@line 2046
 $110 = $109 + -16 | 0; //@line 2047
 HEAP32[$49 >> 2] = $110; //@line 2048
 $111 = $110; //@line 2049
 $116 = HEAP32[$111 + 4 >> 2] | 0; //@line 2054
 $117 = $107 + $55 | 0; //@line 2055
 HEAP32[$117 >> 2] = HEAP32[$111 >> 2]; //@line 2057
 HEAP32[$117 + 4 >> 2] = $116; //@line 2060
 HEAP32[$107 + ($55 + 8) >> 2] = HEAP32[$109 + -8 >> 2]; //@line 2065
 $124 = HEAP32[$49 >> 2] | 0; //@line 2066
 $126 = HEAP32[$124 + 8 >> 2] | 0; //@line 2068
 if (!$126) $131 = 0; //@line 2071
 else if (($126 | 0) == 1) $131 = (HEAP32[$124 >> 2] | 0) != 0; //@line 2077
 else $131 = 1; //@line 2079
 $$0 = $131 & 1; //@line 2083
 STACKTOP = sp; //@line 2084
 return $$0 | 0; //@line 2084
}
function _luaK_code($fs, $i) {
 $fs = $fs | 0;
 $i = $i | 0;
 var $$0$i$i$i = 0, $$0$i$i5$i = 0, $$02$i$i = 0, $$pre$phi7Z2D = 0, $$pre$phiZ2D = 0, $$pre4 = 0, $0 = 0, $1 = 0, $14 = 0, $15 = 0, $2 = 0, $21 = 0, $27 = 0, $3 = 0, $37 = 0, $4 = 0, $47 = 0, $50 = 0, $55 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $68 = 0, $7 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $9 = 0, $fs$idx$val$idx$val$i$pre$i = 0, $storemerge$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 9141
 $0 = HEAP32[$fs >> 2] | 0; //@line 9142
 $1 = $fs + 28 | 0; //@line 9143
 $2 = HEAP32[$1 >> 2] | 0; //@line 9144
 $3 = $fs + 20 | 0; //@line 9145
 $4 = HEAP32[$3 >> 2] | 0; //@line 9146
 do if (($2 | 0) == -1) $50 = $4; //@line 9150
 else {
  $fs$idx$val$idx$val$i$pre$i = HEAP32[$0 + 12 >> 2] | 0; //@line 9153
  $$02$i$i = $2; //@line 9154
  while (1) {
   $6 = $fs$idx$val$idx$val$i$pre$i + ($$02$i$i << 2) | 0; //@line 9156
   $7 = HEAP32[$6 >> 2] | 0; //@line 9157
   $9 = ($7 >>> 14) + -131071 | 0; //@line 9159
   if (($9 | 0) == -1) $$0$i$i$i = -1; //@line 9162
 else $$0$i$i$i = $$02$i$i + 1 + $9 | 0; //@line 9166
   if (($$02$i$i | 0) > 0) {
    $14 = $fs$idx$val$idx$val$i$pre$i + ($$02$i$i + -1 << 2) | 0; //@line 9171
    $15 = HEAP32[$14 >> 2] | 0; //@line 9172
    if ((HEAP8[8440 + ($15 & 63) >> 0] | 0) < 0) {
     $$0$i$i5$i = $14; //@line 9178
     $21 = $15; //@line 9178
    } else label = 7; //@line 9180
   } else label = 7; //@line 9183
   if ((label | 0) == 7) {
    label = 0; //@line 9186
    $$0$i$i5$i = $6; //@line 9187
    $21 = $7; //@line 9187
   }
   if (($21 & 63 | 0) == 28) {
    HEAP32[$$0$i$i5$i >> 2] = $21 & 8372224 | $21 >>> 23 << 6 | 27; //@line 9197
    $27 = $4 + ~$$02$i$i | 0; //@line 9199
    if (((($27 | 0) > -1 ? $27 : 0 - $27 | 0) | 0) > 131071) {
     label = 10; //@line 9205
     break;
    }
    $storemerge$i = HEAP32[$6 >> 2] & 16383 | ($27 << 14) + 2147467264; //@line 9213
   } else {
    $37 = $4 + ~$$02$i$i | 0; //@line 9216
    if (((($37 | 0) > -1 ? $37 : 0 - $37 | 0) | 0) > 131071) {
     label = 13; //@line 9222
     break;
    }
    $storemerge$i = ($37 << 14) + 2147467264 | $7 & 16383; //@line 9229
   }
   HEAP32[$6 >> 2] = $storemerge$i; //@line 9231
   if (($$0$i$i$i | 0) == -1) {
    label = 16; //@line 9234
    break;
   } else $$02$i$i = $$0$i$i$i; //@line 9237
  }
  if ((label | 0) == 10) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9243
 else if ((label | 0) == 13) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9249
 else if ((label | 0) == 16) {
   $50 = HEAP32[$3 >> 2] | 0; //@line 9254
   break;
  }
 } while (0);
 HEAP32[$1 >> 2] = -1; //@line 9259
 $47 = $0 + 48 | 0; //@line 9260
 if (($50 | 0) < (HEAP32[$47 >> 2] | 0)) {
  $$pre$phiZ2D = $0 + 12 | 0; //@line 9265
  $60 = $50; //@line 9265
 } else {
  $55 = $0 + 12 | 0; //@line 9271
  HEAP32[$55 >> 2] = _luaM_growaux_(HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0, HEAP32[$55 >> 2] | 0, $47, 4, 2147483645, 2400) | 0; //@line 9274
  $$pre$phiZ2D = $55; //@line 9276
  $60 = HEAP32[$3 >> 2] | 0; //@line 9276
 }
 HEAP32[(HEAP32[$$pre$phiZ2D >> 2] | 0) + ($60 << 2) >> 2] = $i; //@line 9280
 $61 = HEAP32[$3 >> 2] | 0; //@line 9281
 $62 = $0 + 52 | 0; //@line 9282
 $$pre4 = $fs + 12 | 0; //@line 9285
 if (($61 | 0) < (HEAP32[$62 >> 2] | 0)) {
  $$pre$phi7Z2D = $0 + 20 | 0; //@line 9288
  $76 = $61; //@line 9288
  $71 = HEAP32[$$pre4 >> 2] | 0; //@line 9289
  $72 = $71 + 8 | 0; //@line 9290
  $73 = HEAP32[$72 >> 2] | 0; //@line 9291
  $74 = HEAP32[$$pre$phi7Z2D >> 2] | 0; //@line 9292
  $75 = $74 + ($76 << 2) | 0; //@line 9293
  HEAP32[$75 >> 2] = $73; //@line 9294
  $77 = HEAP32[$3 >> 2] | 0; //@line 9295
  $78 = $77 + 1 | 0; //@line 9296
  HEAP32[$3 >> 2] = $78; //@line 9297
  STACKTOP = sp; //@line 9298
  return $77 | 0; //@line 9298
 } else {
  $68 = $0 + 20 | 0; //@line 9303
  HEAP32[$68 >> 2] = _luaM_growaux_(HEAP32[(HEAP32[$$pre4 >> 2] | 0) + 52 >> 2] | 0, HEAP32[$68 >> 2] | 0, $62, 4, 2147483645, 2400) | 0; //@line 9306
  $$pre$phi7Z2D = $68; //@line 9308
  $76 = HEAP32[$3 >> 2] | 0; //@line 9308
  $71 = HEAP32[$$pre4 >> 2] | 0; //@line 9309
  $72 = $71 + 8 | 0; //@line 9310
  $73 = HEAP32[$72 >> 2] | 0; //@line 9311
  $74 = HEAP32[$$pre$phi7Z2D >> 2] | 0; //@line 9312
  $75 = $74 + ($76 << 2) | 0; //@line 9313
  HEAP32[$75 >> 2] = $73; //@line 9314
  $77 = HEAP32[$3 >> 2] | 0; //@line 9315
  $78 = $77 + 1 | 0; //@line 9316
  HEAP32[$3 >> 2] = $78; //@line 9317
  STACKTOP = sp; //@line 9318
  return $77 | 0; //@line 9318
 }
 return 0; //@line 9320
}
function _luaK_goiffalse($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $0 = 0, $12 = 0, $17 = 0, $18 = 0, $20 = 0, $22 = 0, $3 = 0, $31 = 0, $32 = 0, $37 = 0, $44 = 0, $49 = 0, $51 = 0, $53 = 0, $54 = 0, $56 = 0, $59 = 0, $61 = 0, $70 = 0, $71 = 0, $75 = 0, $77 = 0, $79 = 0, $80 = 0, $82 = 0, $85 = 0, $87 = 0, $9 = 0, $fs$idx$val$idx$val$i = 0, $fs$idx$val$idx$val$i$i = 0, $list$0$i = 0, $list$0$i$i = 0, $pc$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11441
 _luaK_dischargevars($fs, $e); //@line 11442
 $0 = HEAP32[$e >> 2] | 0; //@line 11443
 do if (($0 | 0) == 10) {
  $pc$0 = HEAP32[$e + 8 >> 2] | 0; //@line 11448
  label = 15; //@line 11449
 } else if (!(($0 | 0) == 3 | ($0 | 0) == 1)) {
  $3 = $e + 8 | 0; //@line 11451
  if (($0 | 0) == 11) {
   $9 = HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$3 >> 2] << 2) >> 2] | 0; //@line 11458
   if (($9 & 63 | 0) == 20) {
    $12 = $fs + 20 | 0; //@line 11462
    HEAP32[$12 >> 2] = (HEAP32[$12 >> 2] | 0) + -1; //@line 11465
    $pc$0 = _condjump($fs, 27, $9 >>> 23, 0, 0) | 0; //@line 11468
    label = 15; //@line 11469
    break;
   } else label = 6; //@line 11472
  } else if (($0 | 0) == 6) label = 11; //@line 11475
 else label = 6; //@line 11477
  if ((label | 0) == 6) {
   $17 = $fs + 48 | 0; //@line 11480
   $18 = HEAP8[$17 >> 0] | 0; //@line 11481
   $20 = ($18 & 255) + 1 | 0; //@line 11483
   $22 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 11485
   do if ($20 >>> 0 > (HEAPU8[$22 >> 0] | 0) >>> 0) if ($20 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 11495
 else {
    HEAP8[$22 >> 0] = $20; //@line 11499
    $31 = HEAP8[$17 >> 0] | 0; //@line 11501
    break;
   } else $31 = $18; //@line 11505
 while (0);
   $32 = ($31 & 255) + 1 | 0; //@line 11509
   HEAP8[$17 >> 0] = $32; //@line 11511
   _discharge2reg($fs, $e, ($32 & 255) + -1 | 0); //@line 11514
   if ((HEAP32[$e >> 2] | 0) == 6) label = 11; //@line 11518
  }
  if ((label | 0) == 11) {
   $37 = HEAP32[$3 >> 2] | 0; //@line 11522
   if (!($37 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($37 | 0)) {
    $44 = $fs + 48 | 0; //@line 11531
    HEAP8[$44 >> 0] = (HEAP8[$44 >> 0] | 0) + -1 << 24 >> 24; //@line 11534
   }
  }
  $pc$0 = _condjump($fs, 28, 255, HEAP32[$3 >> 2] | 0, 1) | 0; //@line 11540
  label = 15; //@line 11541
 } while (0);
 do if ((label | 0) == 15) {
  $49 = $e + 16 | 0; //@line 11546
  if (($pc$0 | 0) != -1) {
   $51 = HEAP32[$49 >> 2] | 0; //@line 11549
   if (($51 | 0) == -1) {
    HEAP32[$49 >> 2] = $pc$0; //@line 11552
    break;
   }
   $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11557
   $list$0$i = $51; //@line 11558
   while (1) {
    $53 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 11560
    $54 = HEAP32[$53 >> 2] | 0; //@line 11561
    $56 = ($54 >>> 14) + -131071 | 0; //@line 11563
    if (($56 | 0) == -1) break;
    $59 = $list$0$i + 1 + $56 | 0; //@line 11569
    if (($59 | 0) == -1) break; else $list$0$i = $59; //@line 11574
   }
   $61 = $pc$0 + ~$list$0$i | 0; //@line 11578
   if (((($61 | 0) > -1 ? $61 : 0 - $61 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 11586
 else {
    HEAP32[$53 >> 2] = ($61 << 14) + 2147467264 | $54 & 16383; //@line 11593
    break;
   }
  }
 } while (0);
 $70 = $e + 20 | 0; //@line 11599
 $71 = HEAP32[$70 >> 2] | 0; //@line 11600
 HEAP32[$fs + 24 >> 2] = HEAP32[$fs + 20 >> 2]; //@line 11604
 $75 = $fs + 28 | 0; //@line 11605
 if (($71 | 0) == -1) {
  HEAP32[$70 >> 2] = -1; //@line 11608
  STACKTOP = sp; //@line 11609
  return;
 }
 $77 = HEAP32[$75 >> 2] | 0; //@line 11611
 if (($77 | 0) == -1) {
  HEAP32[$75 >> 2] = $71; //@line 11614
  HEAP32[$70 >> 2] = -1; //@line 11615
  STACKTOP = sp; //@line 11616
  return;
 }
 $fs$idx$val$idx$val$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 11620
 $list$0$i$i = $77; //@line 11621
 while (1) {
  $79 = $fs$idx$val$idx$val$i$i + ($list$0$i$i << 2) | 0; //@line 11623
  $80 = HEAP32[$79 >> 2] | 0; //@line 11624
  $82 = ($80 >>> 14) + -131071 | 0; //@line 11626
  if (($82 | 0) == -1) break;
  $85 = $list$0$i$i + 1 + $82 | 0; //@line 11632
  if (($85 | 0) == -1) break; else $list$0$i$i = $85; //@line 11637
 }
 $87 = $71 + ~$list$0$i$i | 0; //@line 11641
 if (((($87 | 0) > -1 ? $87 : 0 - $87 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 11649
 HEAP32[$79 >> 2] = ($87 << 14) + 2147467264 | $80 & 16383; //@line 11656
 HEAP32[$70 >> 2] = -1; //@line 11657
 STACKTOP = sp; //@line 11658
 return;
}
function _unroll($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var $$0$i$i = 0, $$1$i$i = 0, $$25$i$i3 = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $14 = 0, $2 = 0, $25 = 0, $27 = 0, $29 = 0, $39 = 0, $4 = 0, $42 = 0, $43 = 0, $45 = 0, $5 = 0, $53 = 0, $56 = 0, $6 = 0, $60 = 0, $62 = 0, $65 = 0, $7 = 0, $72 = 0, $73 = 0, $78 = 0, $79 = 0, $8 = 0, $86 = 0, $9 = 0, $i$03$i$i$lcssa = 0, $i$03$i$i5 = 0, $i$11$i$i = 0, $res$04$i$i$lcssa = 0, $res$04$i$i4 = 0, $res$1$lcssa$i$i = 0, $res$12$i$i = 0, sp = 0;
 sp = STACKTOP; //@line 16990
 $0 = $L + 16 | 0; //@line 16991
 $1 = HEAP32[$0 >> 2] | 0; //@line 16992
 $2 = $L + 72 | 0; //@line 16993
 if (($1 | 0) == ($2 | 0)) {
  STACKTOP = sp; //@line 16996
  return;
 }
 $4 = $L + 8 | 0; //@line 16998
 $5 = $L + 40 | 0; //@line 16999
 $6 = $L + 20 | 0; //@line 17000
 $7 = $L + 28 | 0; //@line 17001
 $8 = $L + 68 | 0; //@line 17002
 $10 = $1; //@line 17003
 do {
  $9 = $10 + 18 | 0; //@line 17005
  $11 = HEAP8[$9 >> 0] | 0; //@line 17006
  if (!($11 & 1)) {
   $14 = $11 & 255; //@line 17010
   if ($14 & 16) {
    HEAP8[$9 >> 0] = $14 & 239; //@line 17016
    HEAP32[$8 >> 2] = HEAP32[$10 + 32 >> 2]; //@line 17019
   }
   if ((HEAP16[$10 + 16 >> 1] | 0) == -1) {
    $25 = (HEAP32[$0 >> 2] | 0) + 4 | 0; //@line 17026
    $27 = HEAP32[$4 >> 2] | 0; //@line 17028
    if ((HEAP32[$25 >> 2] | 0) >>> 0 < $27 >>> 0) HEAP32[$25 >> 2] = $27; //@line 17031
   }
   $29 = HEAP8[$9 >> 0] | 0; //@line 17034
   if (!($29 & 32)) HEAP8[$10 + 37 >> 0] = 1; //@line 17039
   HEAP8[$9 >> 0] = $29 & 199 | 8; //@line 17045
   $39 = FUNCTION_TABLE_ii[HEAP32[$10 + 28 >> 2] & 255]($L) | 0; //@line 17048
   $42 = (HEAP32[$4 >> 2] | 0) + (0 - $39 << 4) | 0; //@line 17051
   $43 = HEAP32[$0 >> 2] | 0; //@line 17052
   $45 = HEAPU8[$5 >> 0] | 0; //@line 17054
   if (!($45 & 6)) {
    $$1$i$i = $42; //@line 17059
    $$pre$phi$i$iZ2D = $43 + 8 | 0; //@line 17059
   } else {
    if (!($45 & 2)) $$0$i$i = $42; //@line 17064
 else {
     $53 = $42 - (HEAP32[$7 >> 2] | 0) | 0; //@line 17069
     _luaD_hook($L, 1, -1); //@line 17070
     $$0$i$i = (HEAP32[$7 >> 2] | 0) + $53 | 0; //@line 17073
    }
    $56 = $43 + 8 | 0; //@line 17075
    HEAP32[$6 >> 2] = HEAP32[(HEAP32[$56 >> 2] | 0) + 28 >> 2]; //@line 17079
    $$1$i$i = $$0$i$i; //@line 17080
    $$pre$phi$i$iZ2D = $56; //@line 17080
   }
   $60 = HEAP32[$43 >> 2] | 0; //@line 17082
   $62 = HEAP16[$43 + 16 >> 1] | 0; //@line 17084
   HEAP32[$0 >> 2] = HEAP32[$$pre$phi$i$iZ2D >> 2]; //@line 17086
   L25 : do if (!($62 << 16 >> 16)) $res$1$lcssa$i$i = $60; //@line 17090
 else {
    $65 = $62 << 16 >> 16; //@line 17092
    if ($$1$i$i >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
     $$25$i$i3 = $$1$i$i; //@line 17096
     $i$03$i$i5 = $65; //@line 17096
     $res$04$i$i4 = $60; //@line 17096
     while (1) {
      $72 = $res$04$i$i4 + 16 | 0; //@line 17098
      $73 = $$25$i$i3; //@line 17099
      $78 = HEAP32[$73 + 4 >> 2] | 0; //@line 17104
      $79 = $res$04$i$i4; //@line 17105
      HEAP32[$79 >> 2] = HEAP32[$73 >> 2]; //@line 17107
      HEAP32[$79 + 4 >> 2] = $78; //@line 17110
      HEAP32[$res$04$i$i4 + 8 >> 2] = HEAP32[$$25$i$i3 + 8 >> 2]; //@line 17114
      $86 = $i$03$i$i5 + -1 | 0; //@line 17115
      $$25$i$i3 = $$25$i$i3 + 16 | 0; //@line 17117
      if (!$86) {
       $res$1$lcssa$i$i = $72; //@line 17119
       break L25;
      }
      if ($$25$i$i3 >>> 0 >= (HEAP32[$4 >> 2] | 0) >>> 0) {
       $i$03$i$i$lcssa = $86; //@line 17127
       $res$04$i$i$lcssa = $72; //@line 17127
       break;
      } else {
       $i$03$i$i5 = $86; //@line 17125
       $res$04$i$i4 = $72; //@line 17125
      }
     }
    } else {
     $i$03$i$i$lcssa = $65; //@line 17132
     $res$04$i$i$lcssa = $60; //@line 17132
    }
    if (($i$03$i$i$lcssa | 0) > 0) {
     $i$11$i$i = $i$03$i$i$lcssa; //@line 17136
     $res$12$i$i = $res$04$i$i$lcssa; //@line 17136
     while (1) {
      $i$11$i$i = $i$11$i$i + -1 | 0; //@line 17138
      HEAP32[$res$12$i$i + 8 >> 2] = 0; //@line 17141
      if (($i$11$i$i | 0) <= 0) break; else $res$12$i$i = $res$12$i$i + 16 | 0; //@line 17144
     }
     $res$1$lcssa$i$i = $res$04$i$i$lcssa + ($i$03$i$i$lcssa << 4) | 0; //@line 17150
    } else $res$1$lcssa$i$i = $res$04$i$i$lcssa; //@line 17152
   } while (0);
   HEAP32[$4 >> 2] = $res$1$lcssa$i$i; //@line 17156
  } else {
   _luaV_finishOp($L); //@line 17158
   _luaV_execute($L); //@line 17159
  }
  $10 = HEAP32[$0 >> 2] | 0; //@line 17161
 } while (($10 | 0) != ($2 | 0));
 STACKTOP = sp; //@line 17169
 return;
}
function _luaY_parser($L, $z, $buff, $dyd, $name, $firstchar) {
 $L = $L | 0;
 $z = $z | 0;
 $buff = $buff | 0;
 $dyd = $dyd | 0;
 $name = $name | 0;
 $firstchar = $firstchar | 0;
 var $0 = 0, $1 = 0, $12 = 0, $14 = 0, $18 = 0, $2 = 0, $26 = 0, $27 = 0, $30 = 0, $36 = 0, $41 = 0, $42 = 0, $47 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $66 = 0, $84 = 0, $87 = 0, $bl$i = 0, $funcstate = 0, $lexstate = 0, $ls$idx$val$i$i = 0, $v$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 8136
 STACKTOP = STACKTOP + 176 | 0; //@line 8137
 $bl$i = sp + 156 | 0; //@line 8138
 $v$i = sp + 80 | 0; //@line 8139
 $lexstate = sp; //@line 8140
 $funcstate = sp + 104 | 0; //@line 8141
 $0 = _luaF_newLclosure($L, 1) | 0; //@line 8142
 $1 = $L + 8 | 0; //@line 8143
 $2 = HEAP32[$1 >> 2] | 0; //@line 8144
 HEAP32[$2 >> 2] = $0; //@line 8145
 HEAP32[$2 + 8 >> 2] = 70; //@line 8147
 $5 = (HEAP32[$1 >> 2] | 0) + 16 | 0; //@line 8149
 HEAP32[$1 >> 2] = $5; //@line 8150
 if (((HEAP32[$L + 24 >> 2] | 0) - $5 | 0) < 16) _luaD_growstack($L, 0); //@line 8158
 $12 = _luaF_newproto($L) | 0; //@line 8160
 HEAP32[$0 + 12 >> 2] = $12; //@line 8162
 HEAP32[$funcstate >> 2] = $12; //@line 8163
 $14 = _luaS_new($L, $name) | 0; //@line 8164
 HEAP32[(HEAP32[$funcstate >> 2] | 0) + 36 >> 2] = $14; //@line 8167
 HEAP32[$lexstate + 60 >> 2] = $buff; //@line 8169
 $18 = $lexstate + 64 | 0; //@line 8170
 HEAP32[$18 >> 2] = $dyd; //@line 8171
 HEAP32[$dyd + 28 >> 2] = 0; //@line 8173
 HEAP32[$dyd + 16 >> 2] = 0; //@line 8175
 HEAP32[$dyd + 4 >> 2] = 0; //@line 8177
 _luaX_setinput($L, $lexstate, $z, HEAP32[(HEAP32[$funcstate >> 2] | 0) + 36 >> 2] | 0, $firstchar); //@line 8181
 $26 = HEAP32[$lexstate + 52 >> 2] | 0; //@line 8183
 $27 = $lexstate + 48 | 0; //@line 8184
 HEAP32[$funcstate + 8 >> 2] = HEAP32[$27 >> 2]; //@line 8187
 $30 = $funcstate + 12 | 0; //@line 8188
 HEAP32[$30 >> 2] = $lexstate; //@line 8189
 HEAP32[$27 >> 2] = $funcstate; //@line 8190
 HEAP32[$funcstate + 20 >> 2] = 0; //@line 8192
 HEAP32[$funcstate + 24 >> 2] = 0; //@line 8194
 HEAP32[$funcstate + 28 >> 2] = -1; //@line 8196
 HEAP32[$funcstate + 32 >> 2] = 0; //@line 8198
 HEAP32[$funcstate + 36 >> 2] = 0; //@line 8200
 $36 = $funcstate + 44 | 0; //@line 8201
 HEAP32[$36 + 0 >> 2] = 0; //@line 8202
 HEAP8[$36 + 4 >> 0] = 0; //@line 8202
 HEAP32[$funcstate + 40 >> 2] = HEAP32[(HEAP32[$18 >> 2] | 0) + 4 >> 2]; //@line 8207
 $41 = $funcstate + 16 | 0; //@line 8208
 HEAP32[$41 >> 2] = 0; //@line 8209
 $42 = HEAP32[$funcstate >> 2] | 0; //@line 8210
 HEAP32[$42 + 36 >> 2] = HEAP32[$lexstate + 68 >> 2]; //@line 8214
 HEAP8[$42 + 78 >> 0] = 2; //@line 8216
 $47 = _luaH_new($26) | 0; //@line 8217
 HEAP32[$funcstate + 4 >> 2] = $47; //@line 8219
 $49 = $26 + 8 | 0; //@line 8220
 $50 = HEAP32[$49 >> 2] | 0; //@line 8221
 HEAP32[$50 >> 2] = $47; //@line 8222
 HEAP32[$50 + 8 >> 2] = 69; //@line 8224
 $53 = (HEAP32[$49 >> 2] | 0) + 16 | 0; //@line 8226
 HEAP32[$49 >> 2] = $53; //@line 8227
 if (((HEAP32[$26 + 24 >> 2] | 0) - $53 | 0) < 16) _luaD_growstack($26, 0); //@line 8235
 HEAP8[$bl$i + 10 >> 0] = 0; //@line 8238
 HEAP8[$bl$i + 8 >> 0] = HEAP8[$funcstate + 46 >> 0] | 0; //@line 8242
 $66 = HEAP32[(HEAP32[$30 >> 2] | 0) + 64 >> 2] | 0; //@line 8245
 HEAP16[$bl$i + 4 >> 1] = HEAP32[$66 + 28 >> 2]; //@line 8250
 HEAP16[$bl$i + 6 >> 1] = HEAP32[$66 + 16 >> 2]; //@line 8255
 HEAP8[$bl$i + 9 >> 0] = 0; //@line 8257
 HEAP32[$bl$i >> 2] = HEAP32[$41 >> 2]; //@line 8259
 HEAP32[$41 >> 2] = $bl$i; //@line 8260
 HEAP8[(HEAP32[$funcstate >> 2] | 0) + 77 >> 0] = 1; //@line 8263
 HEAP32[$v$i + 16 >> 2] = -1; //@line 8265
 HEAP32[$v$i + 20 >> 2] = -1; //@line 8267
 HEAP32[$v$i >> 2] = 7; //@line 8268
 HEAP32[$v$i + 8 >> 2] = 0; //@line 8270
 _newupvalue($funcstate, HEAP32[$lexstate + 72 >> 2] | 0, $v$i) | 0; //@line 8273
 _luaX_next($lexstate); //@line 8274
 $84 = $lexstate + 16 | 0; //@line 8275
 L7 : while (1) {
  $ls$idx$val$i$i = HEAP32[$84 >> 2] | 0; //@line 8277
  switch ($ls$idx$val$i$i | 0) {
  case 277:
  case 286:
  case 262:
  case 261:
  case 260:
   {
    $87 = $ls$idx$val$i$i; //@line 8280
    break L7;
    break;
   }
  default:
   {}
  }
  _statement($lexstate); //@line 8288
  if (($ls$idx$val$i$i | 0) == 274) {
   label = 8; //@line 8290
   break;
  }
 }
 if ((label | 0) == 8) $87 = HEAP32[$84 >> 2] | 0; //@line 8296
 if (($87 | 0) == 286) {
  _close_func($lexstate); //@line 8300
  STACKTOP = sp; //@line 8301
  return $0 | 0; //@line 8301
 } else _error_expected($lexstate, 286); //@line 8303
 return 0; //@line 8306
}
function _luaH_next($L, $t, $key) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $100 = 0, $11 = 0, $15 = 0, $16 = 0, $17 = 0, $23 = 0, $37 = 0, $39 = 0, $4 = 0.0, $41 = 0, $44 = 0, $45 = 0, $46 = 0, $53 = 0, $58 = 0, $59 = 0, $6 = 0, $65 = 0, $69 = 0, $71 = 0, $72 = 0, $74 = 0, $79 = 0, $84 = 0, $85 = 0, $91 = 0, $94 = 0, $99 = 0, $i$0 = 0, $i$0$in = 0, $i$0$in$ph = 0, $i$13 = 0, $n$0$i = 0, $u$sroa$0$i$i = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16295
 STACKTOP = STACKTOP + 16 | 0; //@line 16296
 $vararg_buffer = sp + 8 | 0; //@line 16297
 $u$sroa$0$i$i = sp; //@line 16298
 $0 = $key + 8 | 0; //@line 16299
 $1 = HEAP32[$0 >> 2] | 0; //@line 16300
 do if (!$1) {
  $44 = HEAP32[$t + 28 >> 2] | 0; //@line 16306
  $i$0$in$ph = -1; //@line 16306
 } else {
  if (($1 | 0) == 3) {
   $4 = +HEAPF64[$key >> 3]; //@line 16310
   HEAPF64[$u$sroa$0$i$i >> 3] = $4 + 6755399441055744.0; //@line 16312
   $6 = HEAP32[$u$sroa$0$i$i >> 2] | 0; //@line 16313
   if (+($6 | 0) == $4) if (($6 | 0) > 0) {
    $11 = HEAP32[$t + 28 >> 2] | 0; //@line 16320
    if (($6 | 0) <= ($11 | 0)) {
     $44 = $11; //@line 16324
     $i$0$in$ph = $6 + -1 | 0; //@line 16324
     break;
    }
   }
  }
  $n$0$i = _mainposition($t, $key) | 0; //@line 16331
  while (1) {
   $15 = $n$0$i + 16 | 0; //@line 16333
   $16 = $n$0$i + 24 | 0; //@line 16334
   $17 = HEAP32[$16 >> 2] | 0; //@line 16335
   if (($17 | 0) == (HEAP32[$0 >> 2] | 0)) {
    if (_luaV_equalobj_(0, $15, $key) | 0) {
     label = 15; //@line 16342
     break;
    }
    $23 = HEAP32[$16 >> 2] | 0; //@line 16346
   } else $23 = $17; //@line 16348
   if (($23 | 0) == 11) if (HEAP32[$0 >> 2] & 64) if ((HEAP32[$15 >> 2] | 0) == (HEAP32[$key >> 2] | 0)) {
    label = 15; //@line 16360
    break;
   }
   $41 = HEAP32[$n$0$i + 28 >> 2] | 0; //@line 16366
   if (!$41) {
    label = 18; //@line 16369
    break;
   } else $n$0$i = $41; //@line 16372
  }
  if ((label | 0) == 15) {
   $37 = HEAP32[$t + 28 >> 2] | 0; //@line 16383
   $44 = $37; //@line 16385
   $i$0$in$ph = ($n$0$i - (HEAP32[$t + 16 >> 2] | 0) >> 5) + $37 | 0; //@line 16385
   break;
  } else if ((label | 0) == 18) _luaG_runerror($L, 10920, $vararg_buffer); //@line 16389
 } while (0);
 $39 = $t + 12 | 0; //@line 16394
 $i$0$in = $i$0$in$ph; //@line 16395
 while (1) {
  $i$0 = $i$0$in + 1 | 0; //@line 16397
  if (($i$0 | 0) >= ($44 | 0)) break;
  $45 = HEAP32[$39 >> 2] | 0; //@line 16402
  $46 = $45 + ($i$0 << 4) + 8 | 0; //@line 16403
  if (!(HEAP32[$46 >> 2] | 0)) $i$0$in = $i$0; //@line 16407
 else {
   label = 21; //@line 16409
   break;
  }
 }
 if ((label | 0) == 21) {
  HEAPF64[$key >> 3] = +($i$0$in + 2 | 0); //@line 16416
  HEAP32[$0 >> 2] = 3; //@line 16417
  $53 = $45 + ($i$0 << 4) | 0; //@line 16420
  $58 = HEAP32[$53 + 4 >> 2] | 0; //@line 16425
  $59 = $key + 16 | 0; //@line 16426
  HEAP32[$59 >> 2] = HEAP32[$53 >> 2]; //@line 16428
  HEAP32[$59 + 4 >> 2] = $58; //@line 16431
  HEAP32[$key + 24 >> 2] = HEAP32[$46 >> 2]; //@line 16434
  $$0 = 1; //@line 16435
  STACKTOP = sp; //@line 16436
  return $$0 | 0; //@line 16436
 }
 $65 = $i$0 - $44 | 0; //@line 16438
 $69 = 1 << (HEAPU8[$t + 7 >> 0] | 0); //@line 16442
 if (($65 | 0) >= ($69 | 0)) {
  $$0 = 0; //@line 16445
  STACKTOP = sp; //@line 16446
  return $$0 | 0; //@line 16446
 }
 $71 = $t + 16 | 0; //@line 16448
 $72 = HEAP32[$71 >> 2] | 0; //@line 16449
 $i$13 = $65; //@line 16450
 while (1) {
  $74 = $i$13 + 1 | 0; //@line 16455
  if (HEAP32[$72 + ($i$13 << 5) + 8 >> 2] | 0) break;
  if (($74 | 0) < ($69 | 0)) $i$13 = $74; //@line 16461
 else {
   $$0 = 0; //@line 16463
   label = 27; //@line 16464
   break;
  }
 }
 if ((label | 0) == 27) {
  STACKTOP = sp; //@line 16469
  return $$0 | 0; //@line 16469
 }
 $79 = $72 + ($i$13 << 5) + 16 | 0; //@line 16472
 $84 = HEAP32[$79 + 4 >> 2] | 0; //@line 16477
 $85 = $key; //@line 16478
 HEAP32[$85 >> 2] = HEAP32[$79 >> 2]; //@line 16480
 HEAP32[$85 + 4 >> 2] = $84; //@line 16483
 HEAP32[$0 >> 2] = HEAP32[$72 + ($i$13 << 5) + 24 >> 2]; //@line 16486
 $91 = HEAP32[$71 >> 2] | 0; //@line 16487
 $94 = $91 + ($i$13 << 5) | 0; //@line 16490
 $99 = HEAP32[$94 + 4 >> 2] | 0; //@line 16495
 $100 = $key + 16 | 0; //@line 16496
 HEAP32[$100 >> 2] = HEAP32[$94 >> 2]; //@line 16498
 HEAP32[$100 + 4 >> 2] = $99; //@line 16501
 HEAP32[$key + 24 >> 2] = HEAP32[$91 + ($i$13 << 5) + 8 >> 2]; //@line 16505
 $$0 = 1; //@line 16506
 STACKTOP = sp; //@line 16507
 return $$0 | 0; //@line 16507
}
function _luaV_settable($L, $t, $key, $val) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 $val = $val | 0;
 var $$015 = 0, $0 = 0, $103 = 0, $105 = 0, $110 = 0, $111 = 0, $12 = 0, $21 = 0, $25 = 0, $3 = 0, $30 = 0, $31 = 0, $35 = 0, $5 = 0, $51 = 0, $53 = 0, $56 = 0, $59 = 0, $6 = 0, $60 = 0, $62 = 0, $67 = 0, $68 = 0, $7 = 0, $74 = 0, $76 = 0, $81 = 0, $82 = 0, $88 = 0, $90 = 0, $95 = 0, $96 = 0, $loop$014 = 0, $oldval$0 = 0, $tm$0 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 1042
 STACKTOP = STACKTOP + 16 | 0; //@line 1043
 $vararg_buffer = sp; //@line 1044
 $0 = $L + 12 | 0; //@line 1045
 $$015 = $t; //@line 1048
 $5 = HEAP32[$t + 8 >> 2] | 0; //@line 1048
 $loop$014 = 0; //@line 1048
 while (1) {
  $3 = $$015 + 8 | 0; //@line 1050
  if (($5 | 0) == 69) {
   $6 = HEAP32[$$015 >> 2] | 0; //@line 1053
   $7 = _luaH_get($6, $key) | 0; //@line 1054
   if (HEAP32[$7 + 8 >> 2] | 0) {
    $oldval$0 = $7; //@line 1059
    break;
   }
   $12 = HEAP32[$6 + 8 >> 2] | 0; //@line 1063
   if (!$12) {
    label = 9; //@line 1066
    break;
   }
   if (HEAP8[$12 + 6 >> 0] & 2) {
    label = 9; //@line 1074
    break;
   }
   $21 = _luaT_gettm($12, 1, HEAP32[(HEAP32[$0 >> 2] | 0) + 188 >> 2] | 0) | 0; //@line 1080
   if (!$21) {
    label = 9; //@line 1083
    break;
   }
   $56 = HEAP32[$21 + 8 >> 2] | 0; //@line 1088
   $tm$0 = $21; //@line 1088
  } else {
   $51 = _luaT_gettmbyobj($L, $$015, 1) | 0; //@line 1090
   $53 = HEAP32[$51 + 8 >> 2] | 0; //@line 1092
   if (!$53) {
    label = 16; //@line 1095
    break;
   } else {
    $56 = $53; //@line 1098
    $tm$0 = $51; //@line 1098
   }
  }
  $loop$014 = $loop$014 + 1 | 0; //@line 1103
  if (($56 & 15 | 0) == 6) {
   label = 18; //@line 1105
   break;
  }
  if (($loop$014 | 0) >= 100) {
   label = 19; //@line 1112
   break;
  } else {
   $$015 = $tm$0; //@line 1110
   $5 = $56; //@line 1110
  }
 }
 if ((label | 0) == 9) if (($7 | 0) == 8048) $oldval$0 = _luaH_newkey($L, $6, $key) | 0; //@line 1120
 else $oldval$0 = $7; //@line 1122
 else if ((label | 0) == 16) _luaG_typeerror($L, $$015, 11800); //@line 1126
 else if ((label | 0) == 18) {
  $59 = $L + 8 | 0; //@line 1131
  $60 = HEAP32[$59 >> 2] | 0; //@line 1132
  HEAP32[$59 >> 2] = $60 + 16; //@line 1134
  $62 = $tm$0; //@line 1135
  $67 = HEAP32[$62 + 4 >> 2] | 0; //@line 1140
  $68 = $60; //@line 1141
  HEAP32[$68 >> 2] = HEAP32[$62 >> 2]; //@line 1143
  HEAP32[$68 + 4 >> 2] = $67; //@line 1146
  HEAP32[$60 + 8 >> 2] = HEAP32[$tm$0 + 8 >> 2]; //@line 1149
  $74 = HEAP32[$59 >> 2] | 0; //@line 1150
  HEAP32[$59 >> 2] = $74 + 16; //@line 1152
  $76 = $$015; //@line 1153
  $81 = HEAP32[$76 + 4 >> 2] | 0; //@line 1158
  $82 = $74; //@line 1159
  HEAP32[$82 >> 2] = HEAP32[$76 >> 2]; //@line 1161
  HEAP32[$82 + 4 >> 2] = $81; //@line 1164
  HEAP32[$74 + 8 >> 2] = HEAP32[$3 >> 2]; //@line 1167
  $88 = HEAP32[$59 >> 2] | 0; //@line 1168
  HEAP32[$59 >> 2] = $88 + 16; //@line 1170
  $90 = $key; //@line 1171
  $95 = HEAP32[$90 + 4 >> 2] | 0; //@line 1176
  $96 = $88; //@line 1177
  HEAP32[$96 >> 2] = HEAP32[$90 >> 2]; //@line 1179
  HEAP32[$96 + 4 >> 2] = $95; //@line 1182
  HEAP32[$88 + 8 >> 2] = HEAP32[$key + 8 >> 2]; //@line 1186
  $103 = HEAP32[$59 >> 2] | 0; //@line 1187
  HEAP32[$59 >> 2] = $103 + 16; //@line 1189
  $105 = $val; //@line 1190
  $110 = HEAP32[$105 + 4 >> 2] | 0; //@line 1195
  $111 = $103; //@line 1196
  HEAP32[$111 >> 2] = HEAP32[$105 >> 2]; //@line 1198
  HEAP32[$111 + 4 >> 2] = $110; //@line 1201
  HEAP32[$103 + 8 >> 2] = HEAP32[$val + 8 >> 2]; //@line 1205
  _luaD_call($L, (HEAP32[$59 >> 2] | 0) + -64 | 0, 0, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 1214
  STACKTOP = sp; //@line 1215
  return;
 } else if ((label | 0) == 19) _luaG_runerror($L, 11832, $vararg_buffer); //@line 1218
 $25 = $val; //@line 1221
 $30 = HEAP32[$25 + 4 >> 2] | 0; //@line 1226
 $31 = $oldval$0; //@line 1227
 HEAP32[$31 >> 2] = HEAP32[$25 >> 2]; //@line 1229
 HEAP32[$31 + 4 >> 2] = $30; //@line 1232
 $35 = $val + 8 | 0; //@line 1233
 HEAP32[$oldval$0 + 8 >> 2] = HEAP32[$35 >> 2]; //@line 1236
 HEAP8[$6 + 6 >> 0] = 0; //@line 1238
 if (!(HEAP32[$35 >> 2] & 64)) {
  STACKTOP = sp; //@line 1243
  return;
 }
 if (!(HEAP8[(HEAP32[$val >> 2] | 0) + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 1251
  return;
 }
 if (!(HEAP8[$6 + 5 >> 0] & 4)) {
  STACKTOP = sp; //@line 1258
  return;
 }
 _luaC_barrierback_($L, $6); //@line 1260
 STACKTOP = sp; //@line 1261
 return;
}
function _luaV_lessthan($L, $l, $r) {
 $L = $L | 0;
 $l = $l | 0;
 $r = $r | 0;
 var $$0 = 0, $$0$i = 0, $0 = 0, $1 = 0, $103 = 0, $105 = 0, $106 = 0, $107 = 0, $112 = 0, $113 = 0, $120 = 0, $122 = 0, $127 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $26 = 0, $28 = 0, $31 = 0, $36 = 0, $38 = 0, $39 = 0, $40 = 0, $44 = 0, $46 = 0, $50 = 0, $51 = 0, $53 = 0, $58 = 0, $59 = 0, $66 = 0, $68 = 0, $73 = 0, $74 = 0, $80 = 0, $82 = 0, $87 = 0, $88 = 0, $l$01$i = 0, $ll$02$i = 0, $lr$04$i = 0, $r$03$i = 0, $tm$01$i$i = 0, sp = 0;
 sp = STACKTOP; //@line 1275
 $0 = $l + 8 | 0; //@line 1276
 $1 = HEAP32[$0 >> 2] | 0; //@line 1277
 if (($1 | 0) == 3) {
  if ((HEAP32[$r + 8 >> 2] | 0) == 3) {
   $$0 = +HEAPF64[$l >> 3] < +HEAPF64[$r >> 3] & 1; //@line 1288
   STACKTOP = sp; //@line 1289
   return $$0 | 0; //@line 1289
  }
 } else if (($1 & 15 | 0) == 4) if ((HEAP32[$r + 8 >> 2] & 15 | 0) == 4) {
  $16 = HEAP32[$l >> 2] | 0; //@line 1300
  $17 = HEAP32[$r >> 2] | 0; //@line 1301
  $18 = $16 + 16 | 0; //@line 1302
  $19 = $17 + 16 | 0; //@line 1303
  $20 = _strcoll($18, $19) | 0; //@line 1304
  L5 : do if (!$20) {
   $l$01$i = $18; //@line 1312
   $ll$02$i = HEAP32[$16 + 12 >> 2] | 0; //@line 1312
   $lr$04$i = HEAP32[$17 + 12 >> 2] | 0; //@line 1312
   $r$03$i = $19; //@line 1312
   while (1) {
    $26 = _strlen($l$01$i | 0) | 0; //@line 1314
    $28 = ($26 | 0) == ($ll$02$i | 0); //@line 1316
    if (($26 | 0) == ($lr$04$i | 0)) break;
    if ($28) {
     $$0$i = -1; //@line 1321
     break L5;
    }
    $31 = $26 + 1 | 0; //@line 1324
    $l$01$i = $l$01$i + $31 | 0; //@line 1325
    $r$03$i = $r$03$i + $31 | 0; //@line 1327
    $36 = _strcoll($l$01$i, $r$03$i) | 0; //@line 1329
    if ($36) {
     $$0$i = $36; //@line 1334
     break L5;
    } else {
     $ll$02$i = $ll$02$i - $31 | 0; //@line 1332
     $lr$04$i = $lr$04$i - $31 | 0; //@line 1332
    }
   }
   $$0$i = $28 & 1 ^ 1; //@line 1340
  } else $$0$i = $20; //@line 1342
 while (0);
  $$0 = $$0$i >>> 31; //@line 1346
  STACKTOP = sp; //@line 1347
  return $$0 | 0; //@line 1347
 }
 $38 = $L + 8 | 0; //@line 1351
 $39 = HEAP32[$38 >> 2] | 0; //@line 1352
 $40 = _luaT_gettmbyobj($L, $l, 13) | 0; //@line 1353
 if (!(HEAP32[$40 + 8 >> 2] | 0)) {
  $44 = _luaT_gettmbyobj($L, $r, 13) | 0; //@line 1358
  if (!(HEAP32[$44 + 8 >> 2] | 0)) _luaG_ordererror($L, $l, $r); //@line 1363
 else $tm$01$i$i = $44; //@line 1366
 } else $tm$01$i$i = $40; //@line 1369
 $46 = $L + 28 | 0; //@line 1371
 $50 = $39 - (HEAP32[$46 >> 2] | 0) | 0; //@line 1375
 $51 = HEAP32[$38 >> 2] | 0; //@line 1376
 HEAP32[$38 >> 2] = $51 + 16; //@line 1378
 $53 = $tm$01$i$i; //@line 1379
 $58 = HEAP32[$53 + 4 >> 2] | 0; //@line 1384
 $59 = $51; //@line 1385
 HEAP32[$59 >> 2] = HEAP32[$53 >> 2]; //@line 1387
 HEAP32[$59 + 4 >> 2] = $58; //@line 1390
 HEAP32[$51 + 8 >> 2] = HEAP32[$tm$01$i$i + 8 >> 2]; //@line 1394
 $66 = HEAP32[$38 >> 2] | 0; //@line 1395
 HEAP32[$38 >> 2] = $66 + 16; //@line 1397
 $68 = $l; //@line 1398
 $73 = HEAP32[$68 + 4 >> 2] | 0; //@line 1403
 $74 = $66; //@line 1404
 HEAP32[$74 >> 2] = HEAP32[$68 >> 2]; //@line 1406
 HEAP32[$74 + 4 >> 2] = $73; //@line 1409
 HEAP32[$66 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 1412
 $80 = HEAP32[$38 >> 2] | 0; //@line 1413
 HEAP32[$38 >> 2] = $80 + 16; //@line 1415
 $82 = $r; //@line 1416
 $87 = HEAP32[$82 + 4 >> 2] | 0; //@line 1421
 $88 = $80; //@line 1422
 HEAP32[$88 >> 2] = HEAP32[$82 >> 2]; //@line 1424
 HEAP32[$88 + 4 >> 2] = $87; //@line 1427
 HEAP32[$80 + 8 >> 2] = HEAP32[$r + 8 >> 2]; //@line 1431
 _luaD_call($L, (HEAP32[$38 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 1440
 $103 = HEAP32[$46 >> 2] | 0; //@line 1441
 $105 = HEAP32[$38 >> 2] | 0; //@line 1443
 $106 = $105 + -16 | 0; //@line 1444
 HEAP32[$38 >> 2] = $106; //@line 1445
 $107 = $106; //@line 1446
 $112 = HEAP32[$107 + 4 >> 2] | 0; //@line 1451
 $113 = $103 + $50 | 0; //@line 1452
 HEAP32[$113 >> 2] = HEAP32[$107 >> 2]; //@line 1454
 HEAP32[$113 + 4 >> 2] = $112; //@line 1457
 HEAP32[$103 + ($50 + 8) >> 2] = HEAP32[$105 + -8 >> 2]; //@line 1462
 $120 = HEAP32[$38 >> 2] | 0; //@line 1463
 $122 = HEAP32[$120 + 8 >> 2] | 0; //@line 1465
 if (!$122) $127 = 0; //@line 1468
 else if (($122 | 0) == 1) $127 = (HEAP32[$120 >> 2] | 0) != 0; //@line 1474
 else $127 = 1; //@line 1476
 $$0 = $127 & 1; //@line 1480
 STACKTOP = sp; //@line 1481
 return $$0 | 0; //@line 1481
}
function _test_then_block($ls, $escapelist) {
 $ls = $ls | 0;
 $escapelist = $escapelist | 0;
 var $0 = 0, $1 = 0, $14 = 0, $2 = 0, $24 = 0, $27 = 0, $29 = 0, $31 = 0, $35 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $50 = 0, $52 = 0, $53 = 0, $73 = 0, $83 = 0, $bl = 0, $jf$0 = 0, $label$0$i = 0, $ls$idx$val$i = 0, $v = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 12407
 STACKTOP = STACKTOP + 48 | 0; //@line 12408
 $bl = sp + 24 | 0; //@line 12409
 $v = sp; //@line 12410
 $0 = $ls + 48 | 0; //@line 12411
 $1 = HEAP32[$0 >> 2] | 0; //@line 12412
 _luaX_next($ls); //@line 12413
 _subexpr($ls, $v, 0) | 0; //@line 12414
 $2 = $ls + 16 | 0; //@line 12415
 if ((HEAP32[$2 >> 2] | 0) != 275) _error_expected($ls, 275); //@line 12419
 _luaX_next($ls); //@line 12422
 $5 = HEAP32[$2 >> 2] | 0; //@line 12423
 do if (($5 | 0) == 258 | ($5 | 0) == 266) {
  _luaK_goiffalse(HEAP32[$0 >> 2] | 0, $v); //@line 12427
  HEAP8[$bl + 10 >> 0] = 0; //@line 12429
  HEAP8[$bl + 8 >> 0] = HEAP8[$1 + 46 >> 0] | 0; //@line 12433
  $14 = HEAP32[(HEAP32[$1 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 12437
  HEAP16[$bl + 4 >> 1] = HEAP32[$14 + 28 >> 2]; //@line 12442
  HEAP16[$bl + 6 >> 1] = HEAP32[$14 + 16 >> 2]; //@line 12447
  HEAP8[$bl + 9 >> 0] = 0; //@line 12449
  $24 = $1 + 16 | 0; //@line 12450
  HEAP32[$bl >> 2] = HEAP32[$24 >> 2]; //@line 12452
  HEAP32[$24 >> 2] = $bl; //@line 12453
  $27 = HEAP32[$v + 16 >> 2] | 0; //@line 12455
  $29 = HEAP32[$ls + 4 >> 2] | 0; //@line 12457
  $31 = (HEAP32[$2 >> 2] | 0) == 266; //@line 12459
  _luaX_next($ls); //@line 12460
  do if ($31) if ((HEAP32[$2 >> 2] | 0) == 288) {
   $35 = HEAP32[$ls + 24 >> 2] | 0; //@line 12467
   _luaX_next($ls); //@line 12468
   $label$0$i = $35; //@line 12469
   break;
  } else _error_expected($ls, 288); //@line 12472
 else $label$0$i = _luaS_new(HEAP32[$ls + 52 >> 2] | 0, 9160) | 0; //@line 12479
 while (0);
  $40 = HEAP32[$ls + 64 >> 2] | 0; //@line 12483
  $41 = $40 + 12 | 0; //@line 12484
  $42 = $40 + 16 | 0; //@line 12485
  $43 = HEAP32[$42 >> 2] | 0; //@line 12486
  $44 = $40 + 20 | 0; //@line 12487
  if (($43 | 0) < (HEAP32[$44 >> 2] | 0)) $52 = HEAP32[$41 >> 2] | 0; //@line 12492
 else {
   $50 = _luaM_growaux_(HEAP32[$ls + 52 >> 2] | 0, HEAP32[$41 >> 2] | 0, $44, 16, 32767, 9168) | 0; //@line 12497
   HEAP32[$41 >> 2] = $50; //@line 12498
   $52 = $50; //@line 12499
  }
  HEAP32[$52 + ($43 << 4) >> 2] = $label$0$i; //@line 12502
  $53 = HEAP32[$41 >> 2] | 0; //@line 12503
  HEAP32[$53 + ($43 << 4) + 8 >> 2] = $29; //@line 12505
  HEAP8[$53 + ($43 << 4) + 12 >> 0] = HEAP8[(HEAP32[$0 >> 2] | 0) + 46 >> 0] | 0; //@line 12510
  HEAP32[(HEAP32[$41 >> 2] | 0) + ($43 << 4) + 4 >> 2] = $27; //@line 12513
  HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + 1; //@line 12516
  _findlabel($ls, $43) | 0; //@line 12517
  L17 : while (1) {
   switch (HEAP32[$2 >> 2] | 0) {
   case 286:
   case 262:
   case 261:
   case 260:
    {
     break L17;
     break;
    }
   case 285:
   case 59:
    break;
   default:
    {
     label = 16; //@line 12529
     break L17;
    }
   }
   _statement($ls); //@line 12533
  }
  if ((label | 0) == 16) {
   $jf$0 = _luaK_jump($1) | 0; //@line 12537
   break;
  }
  _leaveblock($1); //@line 12540
  STACKTOP = sp; //@line 12541
  return;
 } else {
  _luaK_goiftrue(HEAP32[$0 >> 2] | 0, $v); //@line 12544
  HEAP8[$bl + 10 >> 0] = 0; //@line 12546
  HEAP8[$bl + 8 >> 0] = HEAP8[$1 + 46 >> 0] | 0; //@line 12550
  $73 = HEAP32[(HEAP32[$1 + 12 >> 2] | 0) + 64 >> 2] | 0; //@line 12554
  HEAP16[$bl + 4 >> 1] = HEAP32[$73 + 28 >> 2]; //@line 12559
  HEAP16[$bl + 6 >> 1] = HEAP32[$73 + 16 >> 2]; //@line 12564
  HEAP8[$bl + 9 >> 0] = 0; //@line 12566
  $83 = $1 + 16 | 0; //@line 12567
  HEAP32[$bl >> 2] = HEAP32[$83 >> 2]; //@line 12569
  HEAP32[$83 >> 2] = $bl; //@line 12570
  $jf$0 = HEAP32[$v + 20 >> 2] | 0; //@line 12573
 } while (0);
 L26 : do {
  $ls$idx$val$i = HEAP32[$2 >> 2] | 0; //@line 12577
  switch ($ls$idx$val$i | 0) {
  case 277:
  case 286:
  case 262:
  case 261:
  case 260:
   {
    break L26;
    break;
   }
  default:
   {}
  }
  _statement($ls); //@line 12587
 } while (($ls$idx$val$i | 0) != 274);
 _leaveblock($1); //@line 12592
 if (((HEAP32[$2 >> 2] | 0) + -260 | 0) >>> 0 < 2) _luaK_concat($1, $escapelist, _luaK_jump($1) | 0); //@line 12598
 _luaK_patchtohere($1, $jf$0); //@line 12600
 STACKTOP = sp; //@line 12601
 return;
}
function _scanexp($f, $pok) {
 $f = $f | 0;
 $pok = $pok | 0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $20 = 0, $34 = 0, $35 = 0, $46 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $57 = 0, $59 = 0, $60 = 0, $61 = 0, $75 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $95 = 0, $96 = 0, $c$0 = 0, $c$1$be = 0, $c$18 = 0, $c$2$be = 0, $c$2$lcssa = 0, $c$23 = 0, $c$3$be = 0, $neg$0 = 0, $x$09 = 0, sp = 0;
 sp = STACKTOP; //@line 12772
 $0 = $f + 4 | 0; //@line 12773
 $1 = HEAP32[$0 >> 2] | 0; //@line 12774
 $2 = $f + 100 | 0; //@line 12775
 if ($1 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
  HEAP32[$0 >> 2] = $1 + 1; //@line 12780
  $10 = HEAPU8[$1 >> 0] | 0; //@line 12783
 } else $10 = ___shgetc($f) | 0; //@line 12786
 if (($10 | 0) == 43 | ($10 | 0) == 45) {
  $11 = ($10 | 0) == 45 & 1; //@line 12790
  $12 = HEAP32[$0 >> 2] | 0; //@line 12791
  if ($12 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
   HEAP32[$0 >> 2] = $12 + 1; //@line 12796
   $20 = HEAPU8[$12 >> 0] | 0; //@line 12799
  } else $20 = ___shgetc($f) | 0; //@line 12802
  if (($20 + -48 | 0) >>> 0 < 10 | ($pok | 0) == 0) {
   $c$0 = $20; //@line 12809
   $neg$0 = $11; //@line 12809
  } else if (!(HEAP32[$2 >> 2] | 0)) {
   $c$0 = $20; //@line 12814
   $neg$0 = $11; //@line 12814
  } else {
   HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12818
   $c$0 = $20; //@line 12819
   $neg$0 = $11; //@line 12819
  }
 } else {
  $c$0 = $10; //@line 12823
  $neg$0 = 0; //@line 12823
 }
 if (($c$0 + -48 | 0) >>> 0 > 9) {
  if (!(HEAP32[$2 >> 2] | 0)) {
   $95 = -2147483648; //@line 12831
   $96 = 0; //@line 12831
   tempRet0 = $95; //@line 12832
   STACKTOP = sp; //@line 12833
   return $96 | 0; //@line 12833
  }
  HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12837
  $95 = -2147483648; //@line 12838
  $96 = 0; //@line 12838
  tempRet0 = $95; //@line 12839
  STACKTOP = sp; //@line 12840
  return $96 | 0; //@line 12840
 } else {
  $c$18 = $c$0; //@line 12842
  $x$09 = 0; //@line 12842
 }
 while (1) {
  $34 = $c$18 + -48 + $x$09 | 0; //@line 12846
  $35 = HEAP32[$0 >> 2] | 0; //@line 12847
  if ($35 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
   HEAP32[$0 >> 2] = $35 + 1; //@line 12852
   $c$1$be = HEAPU8[$35 >> 0] | 0; //@line 12855
  } else $c$1$be = ___shgetc($f) | 0; //@line 12858
  if (!(($c$1$be + -48 | 0) >>> 0 < 10 & ($34 | 0) < 214748364)) break;
  $c$18 = $c$1$be; //@line 12868
  $x$09 = $34 * 10 | 0; //@line 12868
 }
 $46 = (($34 | 0) < 0) << 31 >> 31; //@line 12871
 if (($c$1$be + -48 | 0) >>> 0 < 10) {
  $51 = $34; //@line 12875
  $52 = $46; //@line 12875
  $c$23 = $c$1$be; //@line 12875
  while (1) {
   $53 = ___muldi3($51 | 0, $52 | 0, 10, 0) | 0; //@line 12877
   $54 = tempRet0; //@line 12878
   $57 = _i64Add($c$23 | 0, (($c$23 | 0) < 0) << 31 >> 31 | 0, -48, -1) | 0; //@line 12881
   $59 = _i64Add($57 | 0, tempRet0 | 0, $53 | 0, $54 | 0) | 0; //@line 12883
   $60 = tempRet0; //@line 12884
   $61 = HEAP32[$0 >> 2] | 0; //@line 12885
   if ($61 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $61 + 1; //@line 12890
    $c$2$be = HEAPU8[$61 >> 0] | 0; //@line 12893
   } else $c$2$be = ___shgetc($f) | 0; //@line 12896
   if (($c$2$be + -48 | 0) >>> 0 < 10 & (($60 | 0) < 21474836 | ($60 | 0) == 21474836 & $59 >>> 0 < 2061584302)) {
    $51 = $59; //@line 12907
    $52 = $60; //@line 12907
    $c$23 = $c$2$be; //@line 12907
   } else {
    $89 = $59; //@line 12909
    $90 = $60; //@line 12909
    $c$2$lcssa = $c$2$be; //@line 12909
    break;
   }
  }
 } else {
  $89 = $34; //@line 12914
  $90 = $46; //@line 12914
  $c$2$lcssa = $c$1$be; //@line 12914
 }
 if (($c$2$lcssa + -48 | 0) >>> 0 < 10) do {
  $75 = HEAP32[$0 >> 2] | 0; //@line 12920
  if ($75 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
   HEAP32[$0 >> 2] = $75 + 1; //@line 12925
   $c$3$be = HEAPU8[$75 >> 0] | 0; //@line 12928
  } else $c$3$be = ___shgetc($f) | 0; //@line 12931
 } while (($c$3$be + -48 | 0) >>> 0 < 10);
 if (HEAP32[$2 >> 2] | 0) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1; //@line 12945
 $88 = ($neg$0 | 0) != 0; //@line 12947
 $91 = _i64Subtract(0, 0, $89 | 0, $90 | 0) | 0; //@line 12948
 $95 = $88 ? tempRet0 : $90; //@line 12952
 $96 = $88 ? $91 : $89; //@line 12952
 tempRet0 = $95; //@line 12953
 STACKTOP = sp; //@line 12954
 return $96 | 0; //@line 12954
}
function _auxsort($L, $l, $u) {
 $L = $L | 0;
 $l = $l | 0;
 $u = $u | 0;
 var $$018 = 0, $$09 = 0, $$lcssa = 0, $$lcssa4 = 0, $12 = 0, $13 = 0, $16 = 0, $20 = 0, $21 = 0, $25 = 0, $26 = 0, $3 = 0, $32 = 0, $33 = 0, $6 = 0, $i$0$lcssa = 0, $i$0$ph = 0, $j$0$ph = 0, $j$1$lcssa = 0, $vararg_buffer1 = 0, label = 0, sp = 0, $$018$looptemp = 0, $$09$looptemp = 0;
 sp = STACKTOP; //@line 18338
 STACKTOP = STACKTOP + 16 | 0; //@line 18339
 $vararg_buffer1 = sp; //@line 18340
 if (($l | 0) < ($u | 0)) {
  $$018 = $l; //@line 18343
  $$09 = $u; //@line 18343
 } else {
  STACKTOP = sp; //@line 18345
  return;
 }
 while (1) {
  _lua_rawgeti($L, 1, $$018); //@line 18348
  _lua_rawgeti($L, 1, $$09); //@line 18349
  if (!(_sort_comp($L, -1, -2) | 0)) _lua_settop($L, -3); //@line 18353
 else {
   _lua_rawseti($L, 1, $$018); //@line 18355
   _lua_rawseti($L, 1, $$09); //@line 18356
  }
  $3 = $$09 - $$018 | 0; //@line 18358
  if (($3 | 0) == 1) {
   label = 24; //@line 18361
   break;
  }
  $6 = ($$09 + $$018 | 0) / 2 | 0; //@line 18365
  _lua_rawgeti($L, 1, $6); //@line 18366
  _lua_rawgeti($L, 1, $$018); //@line 18367
  do if (!(_sort_comp($L, -2, -1) | 0)) {
   _lua_settop($L, -2); //@line 18372
   _lua_rawgeti($L, 1, $$09); //@line 18373
   if (!(_sort_comp($L, -1, -2) | 0)) {
    _lua_settop($L, -3); //@line 18377
    break;
   } else {
    _lua_rawseti($L, 1, $6); //@line 18380
    _lua_rawseti($L, 1, $$09); //@line 18381
    break;
   }
  } else {
   _lua_rawseti($L, 1, $6); //@line 18385
   _lua_rawseti($L, 1, $$018); //@line 18386
  } while (0);
  if (($3 | 0) == 2) {
   label = 24; //@line 18391
   break;
  }
  _lua_rawgeti($L, 1, $6); //@line 18394
  _lua_pushvalue($L, -1); //@line 18395
  $12 = $$09 + -1 | 0; //@line 18396
  _lua_rawgeti($L, 1, $12); //@line 18397
  _lua_rawseti($L, 1, $6); //@line 18398
  _lua_rawseti($L, 1, $12); //@line 18399
  $i$0$ph = $$018; //@line 18400
  $j$0$ph = $12; //@line 18400
  while (1) {
   $13 = $i$0$ph + 1 | 0; //@line 18402
   _lua_rawgeti($L, 1, $13); //@line 18403
   if (!(_sort_comp($L, -1, -2) | 0)) {
    $$lcssa4 = $13; //@line 18407
    $i$0$lcssa = $i$0$ph; //@line 18407
   } else {
    $20 = $13; //@line 18409
    while (1) {
     if (($20 | 0) >= ($$09 | 0)) _luaL_error($L, 11072, $vararg_buffer1) | 0; //@line 18413
     _lua_settop($L, -2); //@line 18415
     $21 = $20 + 1 | 0; //@line 18416
     _lua_rawgeti($L, 1, $21); //@line 18417
     if (!(_sort_comp($L, -1, -2) | 0)) {
      $$lcssa4 = $21; //@line 18421
      $i$0$lcssa = $20; //@line 18421
      break;
     } else $20 = $21; //@line 18424
    }
   }
   $16 = $j$0$ph + -1 | 0; //@line 18428
   _lua_rawgeti($L, 1, $16); //@line 18429
   if (!(_sort_comp($L, -3, -1) | 0)) {
    $$lcssa = $16; //@line 18433
    $j$1$lcssa = $j$0$ph; //@line 18433
   } else {
    $25 = $16; //@line 18435
    while (1) {
     if (($25 | 0) <= ($$018 | 0)) _luaL_error($L, 11072, $vararg_buffer1) | 0; //@line 18439
     _lua_settop($L, -2); //@line 18441
     $26 = $25 + -1 | 0; //@line 18442
     _lua_rawgeti($L, 1, $26); //@line 18443
     if (!(_sort_comp($L, -3, -1) | 0)) {
      $$lcssa = $26; //@line 18447
      $j$1$lcssa = $25; //@line 18447
      break;
     } else $25 = $26; //@line 18450
    }
   }
   if (($j$1$lcssa | 0) <= ($$lcssa4 | 0)) break;
   _lua_rawseti($L, 1, $$lcssa4); //@line 18458
   _lua_rawseti($L, 1, $$lcssa); //@line 18459
   $i$0$ph = $$lcssa4; //@line 18460
   $j$0$ph = $$lcssa; //@line 18460
  }
  _lua_settop($L, -4); //@line 18462
  _lua_rawgeti($L, 1, $12); //@line 18463
  _lua_rawgeti($L, 1, $$lcssa4); //@line 18464
  _lua_rawseti($L, 1, $12); //@line 18465
  _lua_rawseti($L, 1, $$lcssa4); //@line 18466
  $32 = ($$lcssa4 - $$018 | 0) < ($$09 - $$lcssa4 | 0); //@line 18469
  $33 = $i$0$lcssa + 2 | 0; //@line 18470
  $$018$looptemp = $$018;
  $$018 = $32 ? $33 : $$018; //@line 18471
  $$09$looptemp = $$09;
  $$09 = $32 ? $$09 : $i$0$lcssa; //@line 18472
  _auxsort($L, $32 ? $$018$looptemp : $33, $32 ? $i$0$lcssa : $$09$looptemp); //@line 18475
  if (($$018 | 0) >= ($$09 | 0)) {
   label = 24; //@line 18480
   break;
  }
 }
 if ((label | 0) == 24) {
  STACKTOP = sp; //@line 18485
  return;
 }
}
function _luaL_traceback($L, $L1, $msg, $level) {
 $L = $L | 0;
 $L1 = $L1 | 0;
 $msg = $msg | 0;
 $level = $level | 0;
 var $$0$be = 0, $$in = 0, $$le$1$i = 0, $0 = 0, $13 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $27 = 0, $34 = 0, $38 = 0, $45 = 0, $46 = 0, $6 = 0, $8 = 0, $ar = 0, $le$0$i = 0, $le$1$lcssa$i = 0, $le$11$i = 0, $li$0$i = 0, $li$0$i$phi = 0, $li$12$i = 0, $vararg_buffer13 = 0, sp = 0;
 sp = STACKTOP; //@line 5618
 STACKTOP = STACKTOP + 208 | 0; //@line 5619
 $vararg_buffer13 = sp; //@line 5620
 $ar = sp + 100 | 0; //@line 5621
 $0 = _lua_gettop($L) | 0; //@line 5622
 $le$0$i = 1; //@line 5623
 $li$0$i = 1; //@line 5623
 while (1) if (!(_lua_getstack($L1, $le$0$i, $vararg_buffer13) | 0)) break; else {
  $li$0$i$phi = $le$0$i; //@line 5631
  $le$0$i = $le$0$i << 1; //@line 5631
  $li$0$i = $li$0$i$phi; //@line 5631
 }
 if (($li$0$i | 0) < ($le$0$i | 0)) {
  $le$11$i = $le$0$i; //@line 5636
  $li$12$i = $li$0$i; //@line 5636
  while (1) {
   $6 = ($le$11$i + $li$12$i | 0) / 2 | 0; //@line 5639
   $8 = (_lua_getstack($L1, $6, $vararg_buffer13) | 0) == 0; //@line 5641
   $$le$1$i = $8 ? $6 : $le$11$i; //@line 5643
   $li$12$i = $8 ? $li$12$i : $6 + 1 | 0; //@line 5644
   if (($li$12$i | 0) >= ($$le$1$i | 0)) {
    $le$1$lcssa$i = $$le$1$i; //@line 5649
    break;
   } else $le$11$i = $$le$1$i; //@line 5647
  }
 } else $le$1$lcssa$i = $le$0$i; //@line 5654
 $13 = ($le$1$lcssa$i + -1 | 0) > 22 ? 12 : 0; //@line 5658
 if ($msg) {
  HEAP32[$vararg_buffer13 >> 2] = $msg; //@line 5661
  _lua_pushfstring($L, 32, $vararg_buffer13) | 0; //@line 5662
 }
 _lua_pushlstring($L, 40, 16) | 0; //@line 5664
 if (!(_lua_getstack($L1, $level, $ar) | 0)) {
  $45 = _lua_gettop($L) | 0; //@line 5668
  $46 = $45 - $0 | 0; //@line 5669
  _lua_concat($L, $46); //@line 5670
  STACKTOP = sp; //@line 5671
  return;
 }
 $17 = $le$1$lcssa$i + -11 | 0; //@line 5673
 $18 = $ar + 36 | 0; //@line 5674
 $19 = $ar + 20 | 0; //@line 5675
 $20 = $ar + 8 | 0; //@line 5676
 $21 = $ar + 12 | 0; //@line 5677
 $22 = $ar + 24 | 0; //@line 5678
 $23 = $ar + 35 | 0; //@line 5679
 $24 = $ar + 4 | 0; //@line 5680
 $$in = $level; //@line 5681
 while (1) {
  $25 = $$in + 1 | 0; //@line 5683
  if (($25 | 0) == ($13 | 0)) {
   _lua_pushlstring($L, 64, 5) | 0; //@line 5686
   $$0$be = $17; //@line 5687
  } else {
   _lua_getinfo($L1, 72, $ar) | 0; //@line 5689
   HEAP32[$vararg_buffer13 >> 2] = $18; //@line 5690
   _lua_pushfstring($L, 80, $vararg_buffer13) | 0; //@line 5691
   $27 = HEAP32[$19 >> 2] | 0; //@line 5692
   if (($27 | 0) > 0) {
    HEAP32[$vararg_buffer13 >> 2] = $27; //@line 5695
    _lua_pushfstring($L, 88, $vararg_buffer13) | 0; //@line 5696
   }
   _lua_pushlstring($L, 96, 4) | 0; //@line 5698
   do if (!(HEAP8[HEAP32[$20 >> 2] >> 0] | 0)) {
    $34 = HEAP8[HEAP32[$21 >> 2] >> 0] | 0; //@line 5705
    if ($34 << 24 >> 24 == 67) if (!(_pushglobalfuncname($L, $ar) | 0)) {
     _lua_pushlstring($L, 200, 1) | 0; //@line 5710
     break;
    } else {
     HEAP32[$vararg_buffer13 >> 2] = _lua_tolstring($L, -1, 0) | 0; //@line 5714
     _lua_pushfstring($L, 872, $vararg_buffer13) | 0; //@line 5715
     _lua_remove($L, -2); //@line 5716
     break;
    } else if ($34 << 24 >> 24 == 109) {
     _lua_pushlstring($L, 888, 10) | 0; //@line 5720
     break;
    } else {
     $38 = HEAP32[$22 >> 2] | 0; //@line 5723
     HEAP32[$vararg_buffer13 >> 2] = $18; //@line 5724
     HEAP32[$vararg_buffer13 + 4 >> 2] = $38; //@line 5726
     _lua_pushfstring($L, 904, $vararg_buffer13) | 0; //@line 5727
     break;
    }
   } else {
    HEAP32[$vararg_buffer13 >> 2] = HEAP32[$24 >> 2]; //@line 5732
    _lua_pushfstring($L, 872, $vararg_buffer13) | 0; //@line 5733
   } while (0);
   if (HEAP8[$23 >> 0] | 0) _lua_pushlstring($L, 104, 20) | 0; //@line 5739
   _lua_concat($L, (_lua_gettop($L) | 0) - $0 | 0); //@line 5743
   $$0$be = $25; //@line 5744
  }
  if (!(_lua_getstack($L1, $$0$be, $ar) | 0)) break; else $$in = $$0$be; //@line 5751
 }
 $45 = _lua_gettop($L) | 0; //@line 5754
 $46 = $45 - $0 | 0; //@line 5755
 _lua_concat($L, $46); //@line 5756
 STACKTOP = sp; //@line 5757
 return;
}
function _luaV_gettable($L, $t, $key, $val) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 $val = $val | 0;
 var $$09 = 0, $0 = 0, $100 = 0, $102 = 0, $103 = 0, $104 = 0, $109 = 0, $110 = 0, $12 = 0, $21 = 0, $23 = 0, $28 = 0, $29 = 0, $3 = 0, $35 = 0, $37 = 0, $40 = 0, $43 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $51 = 0, $56 = 0, $57 = 0, $6 = 0, $63 = 0, $65 = 0, $7 = 0, $70 = 0, $71 = 0, $77 = 0, $79 = 0, $8 = 0, $84 = 0, $85 = 0, $loop$08 = 0, $tm$0 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 833
 STACKTOP = STACKTOP + 16 | 0; //@line 834
 $vararg_buffer = sp; //@line 835
 $0 = $L + 12 | 0; //@line 836
 $$09 = $t; //@line 839
 $5 = HEAP32[$t + 8 >> 2] | 0; //@line 839
 $loop$08 = 0; //@line 839
 while (1) {
  $3 = $$09 + 8 | 0; //@line 841
  if (($5 | 0) == 69) {
   $6 = HEAP32[$$09 >> 2] | 0; //@line 844
   $7 = _luaH_get($6, $key) | 0; //@line 845
   $8 = $7 + 8 | 0; //@line 846
   if (HEAP32[$8 >> 2] | 0) {
    label = 9; //@line 850
    break;
   }
   $12 = HEAP32[$6 + 8 >> 2] | 0; //@line 854
   if (!$12) {
    label = 9; //@line 857
    break;
   }
   if (HEAP8[$12 + 6 >> 0] & 1) {
    label = 9; //@line 865
    break;
   }
   $21 = _luaT_gettm($12, 0, HEAP32[(HEAP32[$0 >> 2] | 0) + 184 >> 2] | 0) | 0; //@line 871
   if (!$21) {
    label = 9; //@line 874
    break;
   }
   $40 = HEAP32[$21 + 8 >> 2] | 0; //@line 879
   $tm$0 = $21; //@line 879
  } else {
   $35 = _luaT_gettmbyobj($L, $$09, 0) | 0; //@line 881
   $37 = HEAP32[$35 + 8 >> 2] | 0; //@line 883
   if (!$37) {
    label = 11; //@line 886
    break;
   } else {
    $40 = $37; //@line 889
    $tm$0 = $35; //@line 889
   }
  }
  $loop$08 = $loop$08 + 1 | 0; //@line 894
  if (($40 & 15 | 0) == 6) {
   label = 13; //@line 896
   break;
  }
  if (($loop$08 | 0) >= 100) {
   label = 14; //@line 903
   break;
  } else {
   $$09 = $tm$0; //@line 901
   $5 = $40; //@line 901
  }
 }
 if ((label | 0) == 9) {
  $23 = $7; //@line 908
  $28 = HEAP32[$23 + 4 >> 2] | 0; //@line 913
  $29 = $val; //@line 914
  HEAP32[$29 >> 2] = HEAP32[$23 >> 2]; //@line 916
  HEAP32[$29 + 4 >> 2] = $28; //@line 919
  HEAP32[$val + 8 >> 2] = HEAP32[$8 >> 2]; //@line 922
  STACKTOP = sp; //@line 923
  return;
 } else if ((label | 0) == 11) _luaG_typeerror($L, $$09, 11800); //@line 926
 else if ((label | 0) == 13) {
  $43 = $L + 28 | 0; //@line 931
  $47 = $val - (HEAP32[$43 >> 2] | 0) | 0; //@line 935
  $48 = $L + 8 | 0; //@line 936
  $49 = HEAP32[$48 >> 2] | 0; //@line 937
  HEAP32[$48 >> 2] = $49 + 16; //@line 939
  $51 = $tm$0; //@line 940
  $56 = HEAP32[$51 + 4 >> 2] | 0; //@line 945
  $57 = $49; //@line 946
  HEAP32[$57 >> 2] = HEAP32[$51 >> 2]; //@line 948
  HEAP32[$57 + 4 >> 2] = $56; //@line 951
  HEAP32[$49 + 8 >> 2] = HEAP32[$tm$0 + 8 >> 2]; //@line 954
  $63 = HEAP32[$48 >> 2] | 0; //@line 955
  HEAP32[$48 >> 2] = $63 + 16; //@line 957
  $65 = $$09; //@line 958
  $70 = HEAP32[$65 + 4 >> 2] | 0; //@line 963
  $71 = $63; //@line 964
  HEAP32[$71 >> 2] = HEAP32[$65 >> 2]; //@line 966
  HEAP32[$71 + 4 >> 2] = $70; //@line 969
  HEAP32[$63 + 8 >> 2] = HEAP32[$3 >> 2]; //@line 972
  $77 = HEAP32[$48 >> 2] | 0; //@line 973
  HEAP32[$48 >> 2] = $77 + 16; //@line 975
  $79 = $key; //@line 976
  $84 = HEAP32[$79 + 4 >> 2] | 0; //@line 981
  $85 = $77; //@line 982
  HEAP32[$85 >> 2] = HEAP32[$79 >> 2]; //@line 984
  HEAP32[$85 + 4 >> 2] = $84; //@line 987
  HEAP32[$77 + 8 >> 2] = HEAP32[$key + 8 >> 2]; //@line 991
  _luaD_call($L, (HEAP32[$48 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 1000
  $100 = HEAP32[$43 >> 2] | 0; //@line 1001
  $102 = HEAP32[$48 >> 2] | 0; //@line 1003
  $103 = $102 + -16 | 0; //@line 1004
  HEAP32[$48 >> 2] = $103; //@line 1005
  $104 = $103; //@line 1006
  $109 = HEAP32[$104 + 4 >> 2] | 0; //@line 1011
  $110 = $100 + $47 | 0; //@line 1012
  HEAP32[$110 >> 2] = HEAP32[$104 >> 2]; //@line 1014
  HEAP32[$110 + 4 >> 2] = $109; //@line 1017
  HEAP32[$100 + ($47 + 8) >> 2] = HEAP32[$102 + -8 >> 2]; //@line 1022
  STACKTOP = sp; //@line 1023
  return;
 } else if ((label | 0) == 14) _luaG_runerror($L, 11808, $vararg_buffer); //@line 1026
}
function _g_read($L, $f, $first) {
 $L = $L | 0;
 $f = $f | 0;
 $first = $first | 0;
 var $$0 = 0, $0 = 0, $10 = 0, $12 = 0, $16 = 0, $21 = 0, $27 = 0, $35 = 0, $42 = 0, $47 = 0, $49 = 0, $6 = 0, $7 = 0, $d$i = 0, $n$04 = 0, $n$1 = 0, $rlen$01$i = 0, $success$1 = 0, $success$2 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 2200
 STACKTOP = STACKTOP + 1056 | 0; //@line 2201
 $vararg_buffer = sp + 8 | 0; //@line 2202
 $d$i = sp; //@line 2203
 $0 = _lua_gettop($L) | 0; //@line 2204
 _clearerr($f | 0); //@line 2205
 L1 : do if (($0 | 0) == 1) {
  $n$1 = $first + 1 | 0; //@line 2211
  $success$2 = _read_line($L, $f, 1) | 0; //@line 2211
 } else {
  _luaL_checkstack($L, $0 + 19 | 0, 5296); //@line 2214
  $6 = $vararg_buffer + 8 | 0; //@line 2216
  $7 = $vararg_buffer + 8 | 0; //@line 2217
  $49 = $0 + -2 | 0; //@line 2218
  $n$04 = $first; //@line 2218
  L3 : while (1) {
   do if ((_lua_type($L, $n$04) | 0) == 3) {
    $10 = _lua_tointegerx($L, $n$04, 0) | 0; //@line 2224
    if (!$10) {
     $12 = _getc($f | 0) | 0; //@line 2227
     _ungetc($12 | 0, $f | 0) | 0; //@line 2228
     _lua_pushlstring($L, 0, 0) | 0; //@line 2229
     $success$1 = ($12 | 0) != -1 & 1; //@line 2232
     break;
    } else {
     _luaL_buffinit($L, $vararg_buffer); //@line 2235
     $16 = _fread(_luaL_prepbuffsize($vararg_buffer, $10) | 0, 1, $10 | 0, $f | 0) | 0; //@line 2237
     HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + $16; //@line 2240
     _luaL_pushresult($vararg_buffer); //@line 2241
     $success$1 = ($16 | 0) != 0 & 1; //@line 2244
     break;
    }
   } else {
    $21 = _lua_tolstring($L, $n$04, 0) | 0; //@line 2248
    if (!$21) label = 10; //@line 2251
 else if ((HEAP8[$21 >> 0] | 0) != 42) label = 10; //@line 2256
    if ((label | 0) == 10) {
     label = 0; //@line 2260
     _luaL_argerror($L, $n$04, 5320) | 0; //@line 2261
    }
    $27 = HEAP8[$21 + 1 >> 0] | 0; //@line 2265
    if (($27 | 0) == 97) {
     _luaL_buffinit($L, $vararg_buffer); //@line 2267
     $35 = _fread(_luaL_prepbuffsize($vararg_buffer, 1024) | 0, 1, 1024, $f | 0) | 0; //@line 2269
     HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + $35; //@line 2272
     if ($35 >>> 0 >= 1024) {
      $rlen$01$i = 1024; //@line 2275
      do {
       $rlen$01$i = $rlen$01$i << ($rlen$01$i >>> 0 < 1073741824 & 1); //@line 2279
       $42 = _fread(_luaL_prepbuffsize($vararg_buffer, $rlen$01$i) | 0, 1, $rlen$01$i | 0, $f | 0) | 0; //@line 2281
       HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + $42; //@line 2284
      } while ($42 >>> 0 >= $rlen$01$i >>> 0);
     }
     _luaL_pushresult($vararg_buffer); //@line 2293
     $success$1 = 1; //@line 2294
     break;
    } else if (($27 | 0) == 110) {
     HEAP32[$vararg_buffer >> 2] = $d$i; //@line 2297
     if ((_fscanf($f | 0, 5352, $vararg_buffer | 0) | 0) != 1) {
      label = 14; //@line 2301
      break L3;
     }
     _lua_pushnumber($L, +HEAPF64[$d$i >> 3]); //@line 2305
     $success$1 = 1; //@line 2306
     break;
    } else if (($27 | 0) == 76) {
     $success$1 = _read_line($L, $f, 0) | 0; //@line 2310
     break;
    } else if (($27 | 0) == 108) {
     $success$1 = _read_line($L, $f, 1) | 0; //@line 2314
     break;
    } else break L3;
   } while (0);
   $47 = $n$04 + 1 | 0; //@line 2321
   if (($49 | 0) == 0 | ($success$1 | 0) == 0) {
    $n$1 = $47; //@line 2327
    $success$2 = $success$1; //@line 2327
    break L1;
   } else {
    $49 = $49 + -1 | 0; //@line 2330
    $n$04 = $47; //@line 2330
   }
  }
  if ((label | 0) == 14) {
   _lua_pushnil($L); //@line 2334
   $n$1 = $n$04 + 1 | 0; //@line 2336
   $success$2 = 0; //@line 2336
   break;
  }
  $$0 = _luaL_argerror($L, $n$04, 5336) | 0; //@line 2340
  STACKTOP = sp; //@line 2341
  return $$0 | 0; //@line 2341
 } while (0);
 if (_ferror($f | 0) | 0) {
  $$0 = _luaL_fileresult($L, 0, 0) | 0; //@line 2348
  STACKTOP = sp; //@line 2349
  return $$0 | 0; //@line 2349
 }
 if (!$success$2) {
  _lua_settop($L, -2); //@line 2353
  _lua_pushnil($L); //@line 2354
 }
 $$0 = $n$1 - $first | 0; //@line 2357
 STACKTOP = sp; //@line 2358
 return $$0 | 0; //@line 2358
}
function _skip_sep($ls) {
 $ls = $ls | 0;
 var $$lcssa = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $15 = 0, $18 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $32 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $43 = 0, $45 = 0, $47 = 0, $49 = 0, $51 = 0, $52 = 0, $53 = 0, $56 = 0, $57 = 0, $6 = 0, $62 = 0, $63 = 0, $65 = 0, $7 = 0, $count$0$ = 0, $count$0$lcssa = 0, $count$011 = 0, $not$ = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5224
 $0 = HEAP32[$ls >> 2] | 0; //@line 5225
 $1 = $ls + 60 | 0; //@line 5226
 $2 = HEAP32[$1 >> 2] | 0; //@line 5227
 $3 = $2 + 4 | 0; //@line 5228
 $4 = HEAP32[$3 >> 2] | 0; //@line 5229
 $6 = $2 + 8 | 0; //@line 5231
 $7 = HEAP32[$6 >> 2] | 0; //@line 5232
 do if (($4 + 1 | 0) >>> 0 > $7 >>> 0) {
  if ($7 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 5238
  $10 = $7 << 1; //@line 5241
  $13 = HEAP32[$ls + 52 >> 2] | 0; //@line 5244
  if (($10 | 0) == -2) _luaM_toobig($13); //@line 5246
 else {
   $15 = _luaM_realloc_($13, HEAP32[$2 >> 2] | 0, $7, $10) | 0; //@line 5250
   HEAP32[$2 >> 2] = $15; //@line 5251
   HEAP32[$6 >> 2] = $10; //@line 5252
   $18 = HEAP32[$3 >> 2] | 0; //@line 5254
   $20 = $15; //@line 5254
   break;
  }
 } else {
  $18 = $4; //@line 5259
  $20 = HEAP32[$2 >> 2] | 0; //@line 5259
 } while (0);
 HEAP32[$3 >> 2] = $18 + 1; //@line 5264
 HEAP8[$20 + $18 >> 0] = $0; //@line 5266
 $21 = $ls + 56 | 0; //@line 5267
 $22 = HEAP32[$21 >> 2] | 0; //@line 5268
 $23 = HEAP32[$22 >> 2] | 0; //@line 5269
 HEAP32[$22 >> 2] = $23 + -1; //@line 5271
 if (!$23) $32 = _luaZ_fill($22) | 0; //@line 5275
 else {
  $26 = $22 + 4 | 0; //@line 5277
  $27 = HEAP32[$26 >> 2] | 0; //@line 5278
  HEAP32[$26 >> 2] = $27 + 1; //@line 5280
  $32 = HEAPU8[$27 >> 0] | 0; //@line 5283
 }
 HEAP32[$ls >> 2] = $32; //@line 5285
 if (($32 | 0) != 61) {
  $$lcssa = $32; //@line 5288
  $count$0$lcssa = 0; //@line 5288
  $not$ = ($$lcssa | 0) != ($0 | 0); //@line 5289
  $65 = $not$ << 31 >> 31; //@line 5290
  $count$0$ = $65 ^ $count$0$lcssa; //@line 5291
  STACKTOP = sp; //@line 5292
  return $count$0$ | 0; //@line 5292
 }
 $34 = $ls + 52 | 0; //@line 5294
 $count$011 = 0; //@line 5295
 while (1) {
  $35 = HEAP32[$1 >> 2] | 0; //@line 5297
  $36 = $35 + 4 | 0; //@line 5298
  $37 = HEAP32[$36 >> 2] | 0; //@line 5299
  $39 = $35 + 8 | 0; //@line 5301
  $40 = HEAP32[$39 >> 2] | 0; //@line 5302
  if (($37 + 1 | 0) >>> 0 > $40 >>> 0) {
   if ($40 >>> 0 > 2147483645) {
    label = 16; //@line 5307
    break;
   }
   $43 = $40 << 1; //@line 5310
   $45 = HEAP32[$34 >> 2] | 0; //@line 5312
   if (($43 | 0) == -2) {
    label = 18; //@line 5314
    break;
   }
   $47 = _luaM_realloc_($45, HEAP32[$35 >> 2] | 0, $40, $43) | 0; //@line 5318
   HEAP32[$35 >> 2] = $47; //@line 5319
   HEAP32[$39 >> 2] = $43; //@line 5320
   $49 = HEAP32[$36 >> 2] | 0; //@line 5322
   $51 = $47; //@line 5322
  } else {
   $49 = $37; //@line 5325
   $51 = HEAP32[$35 >> 2] | 0; //@line 5325
  }
  HEAP32[$36 >> 2] = $49 + 1; //@line 5328
  HEAP8[$51 + $49 >> 0] = 61; //@line 5330
  $52 = HEAP32[$21 >> 2] | 0; //@line 5331
  $53 = HEAP32[$52 >> 2] | 0; //@line 5332
  HEAP32[$52 >> 2] = $53 + -1; //@line 5334
  if (!$53) $62 = _luaZ_fill($52) | 0; //@line 5338
 else {
   $56 = $52 + 4 | 0; //@line 5340
   $57 = HEAP32[$56 >> 2] | 0; //@line 5341
   HEAP32[$56 >> 2] = $57 + 1; //@line 5343
   $62 = HEAPU8[$57 >> 0] | 0; //@line 5346
  }
  HEAP32[$ls >> 2] = $62; //@line 5348
  $63 = $count$011 + 1 | 0; //@line 5349
  if (($62 | 0) == 61) $count$011 = $63; //@line 5352
 else {
   $$lcssa = $62; //@line 5354
   $count$0$lcssa = $63; //@line 5354
   label = 24; //@line 5355
   break;
  }
 }
 if ((label | 0) == 16) _lexerror($ls, 5888, 0); //@line 5360
 else if ((label | 0) == 18) _luaM_toobig($45); //@line 5364
 else if ((label | 0) == 24) {
  $not$ = ($$lcssa | 0) != ($0 | 0); //@line 5368
  $65 = $not$ << 31 >> 31; //@line 5369
  $count$0$ = $65 ^ $count$0$lcssa; //@line 5370
  STACKTOP = sp; //@line 5371
  return $count$0$ | 0; //@line 5371
 }
 return 0; //@line 5373
}
function _os_date($L) {
 $L = $L | 0;
 var $$0$i = 0, $0 = 0, $35 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $47 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $b = 0, $buff = 0, $cc = 0, $s$0 = 0, $s$1 = 0, $stm$0 = 0, $t = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 7743
 STACKTOP = STACKTOP + 1264 | 0; //@line 7744
 $vararg_buffer = sp; //@line 7745
 $t = sp + 1048 | 0; //@line 7746
 $cc = sp + 1256 | 0; //@line 7747
 $b = sp + 8 | 0; //@line 7748
 $buff = sp + 1056 | 0; //@line 7749
 $0 = _luaL_optlstring($L, 1, 8920, 0) | 0; //@line 7750
 if ((_lua_type($L, 2) | 0) < 1) $6 = _time(0) | 0; //@line 7755
 else $6 = ~~+_luaL_checknumber($L, 2); //@line 7759
 HEAP32[$t >> 2] = $6; //@line 7761
 if ((HEAP8[$0 >> 0] | 0) == 33) {
  $s$0 = $0 + 1 | 0; //@line 7767
  $stm$0 = _gmtime($t | 0) | 0; //@line 7767
 } else {
  $s$0 = $0; //@line 7770
  $stm$0 = _localtime($t | 0) | 0; //@line 7770
 }
 if (!$stm$0) {
  _lua_pushnil($L); //@line 7774
  STACKTOP = sp; //@line 7775
  return 1; //@line 7775
 }
 if (!(_strcmp($s$0, 8928) | 0)) {
  _lua_createtable($L, 0, 9); //@line 7780
  _lua_pushinteger($L, HEAP32[$stm$0 >> 2] | 0); //@line 7782
  _lua_setfield($L, -2, 8720); //@line 7783
  _lua_pushinteger($L, HEAP32[$stm$0 + 4 >> 2] | 0); //@line 7786
  _lua_setfield($L, -2, 8728); //@line 7787
  _lua_pushinteger($L, HEAP32[$stm$0 + 8 >> 2] | 0); //@line 7790
  _lua_setfield($L, -2, 8736); //@line 7791
  _lua_pushinteger($L, HEAP32[$stm$0 + 12 >> 2] | 0); //@line 7794
  _lua_setfield($L, -2, 8744); //@line 7795
  _lua_pushinteger($L, (HEAP32[$stm$0 + 16 >> 2] | 0) + 1 | 0); //@line 7799
  _lua_setfield($L, -2, 8752); //@line 7800
  _lua_pushinteger($L, (HEAP32[$stm$0 + 20 >> 2] | 0) + 1900 | 0); //@line 7804
  _lua_setfield($L, -2, 8760); //@line 7805
  _lua_pushinteger($L, (HEAP32[$stm$0 + 24 >> 2] | 0) + 1 | 0); //@line 7809
  _lua_setfield($L, -2, 8936); //@line 7810
  _lua_pushinteger($L, (HEAP32[$stm$0 + 28 >> 2] | 0) + 1 | 0); //@line 7814
  _lua_setfield($L, -2, 8944); //@line 7815
  $35 = HEAP32[$stm$0 + 32 >> 2] | 0; //@line 7817
  if (($35 | 0) < 0) {
   STACKTOP = sp; //@line 7820
   return 1; //@line 7820
  }
  _lua_pushboolean($L, $35); //@line 7822
  _lua_setfield($L, -2, 8768); //@line 7823
  STACKTOP = sp; //@line 7824
  return 1; //@line 7824
 }
 HEAP8[$cc >> 0] = 37; //@line 7826
 _luaL_buffinit($L, $b); //@line 7827
 $37 = $b + 8 | 0; //@line 7828
 $38 = $b + 4 | 0; //@line 7829
 $39 = $cc + 1 | 0; //@line 7830
 $40 = $cc + 2 | 0; //@line 7831
 $s$1 = $s$0; //@line 7832
 while (1) {
  $41 = HEAP8[$s$1 >> 0] | 0; //@line 7834
  if (!($41 << 24 >> 24)) break; else if ($41 << 24 >> 24 != 37) {
   $42 = HEAP32[$37 >> 2] | 0; //@line 7838
   if ($42 >>> 0 < (HEAP32[$38 >> 2] | 0) >>> 0) {
    $47 = $42; //@line 7842
    $50 = $41; //@line 7842
   } else {
    _luaL_prepbuffsize($b, 1) | 0; //@line 7844
    $47 = HEAP32[$37 >> 2] | 0; //@line 7847
    $50 = HEAP8[$s$1 >> 0] | 0; //@line 7847
   }
   HEAP32[$37 >> 2] = $47 + 1; //@line 7851
   HEAP8[(HEAP32[$b >> 2] | 0) + $47 >> 0] = $50; //@line 7854
   $s$1 = $s$1 + 1 | 0; //@line 7855
   continue;
  }
  $51 = $s$1 + 1 | 0; //@line 7858
  $52 = $s$1 + 2 | 0; //@line 7859
  $53 = HEAP8[$51 >> 0] | 0; //@line 7860
  if (!($53 << 24 >> 24)) label = 20; //@line 7863
 else if (!(_memchr(8952, $53 << 24 >> 24, 23) | 0)) label = 20; //@line 7869
 else {
   HEAP8[$39 >> 0] = $53; //@line 7871
   HEAP8[$40 >> 0] = 0; //@line 7872
   $$0$i = $52; //@line 7873
  }
  if ((label | 0) == 20) {
   label = 0; //@line 7877
   HEAP32[$vararg_buffer >> 2] = $51; //@line 7878
   _luaL_argerror($L, 1, _lua_pushfstring($L, 8976, $vararg_buffer) | 0) | 0; //@line 7880
   $$0$i = $51; //@line 7881
  }
  _luaL_addlstring($b, $buff, _strftime($buff | 0, 200, $cc | 0, $stm$0 | 0) | 0); //@line 7884
  $s$1 = $$0$i; //@line 7885
 }
 _luaL_pushresult($b); //@line 7887
 STACKTOP = sp; //@line 7888
 return 1; //@line 7888
}
function _resume($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var $$0$i = 0, $$1$i = 0, $$25$i = 0, $$pre$phi$iZ2D = 0, $12 = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $28 = 0, $3 = 0, $33 = 0, $36 = 0, $44 = 0, $47 = 0, $5 = 0, $52 = 0, $54 = 0, $56 = 0, $6 = 0, $62 = 0, $63 = 0, $68 = 0, $69 = 0, $76 = 0, $firstArg$0 = 0, $i$03$i = 0, $i$11$i = 0, $res$04$i = 0, $res$1$lcssa$i = 0, $res$12$i = 0, sp = 0;
 sp = STACKTOP; //@line 16812
 $2 = $L + 16 | 0; //@line 16815
 $3 = HEAP32[$2 >> 2] | 0; //@line 16816
 if ((HEAPU16[$L + 38 >> 1] | 0) > 199) _resume_error($L, 4280, $ud); //@line 16819
 $5 = $L + 6 | 0; //@line 16822
 $6 = HEAP8[$5 >> 0] | 0; //@line 16823
 if (!($6 << 24 >> 24)) {
  if (($3 | 0) != ($L + 72 | 0)) _resume_error($L, 4488, $ud); //@line 16828
  if (_luaD_precall($L, $ud + -16 | 0, -1) | 0) {
   STACKTOP = sp; //@line 16835
   return;
  }
  _luaV_execute($L); //@line 16837
  STACKTOP = sp; //@line 16838
  return;
 } else if ($6 << 24 >> 24 == 1) {
  HEAP8[$5 >> 0] = 0; //@line 16840
  $12 = $L + 28 | 0; //@line 16841
  HEAP32[$3 >> 2] = (HEAP32[$12 >> 2] | 0) + (HEAP32[$3 + 20 >> 2] | 0); //@line 16846
  $17 = $3 + 18 | 0; //@line 16847
  $18 = HEAP8[$17 >> 0] | 0; //@line 16848
  if (!($18 & 1)) {
   $22 = HEAP32[$3 + 28 >> 2] | 0; //@line 16853
   if (!$22) $firstArg$0 = $ud; //@line 16856
 else {
    HEAP8[$3 + 37 >> 0] = 1; //@line 16859
    HEAP8[$17 >> 0] = $18 & 255 | 8; //@line 16863
    $28 = FUNCTION_TABLE_ii[$22 & 255]($L) | 0; //@line 16864
    $firstArg$0 = (HEAP32[$L + 8 >> 2] | 0) + (0 - $28 << 4) | 0; //@line 16869
   }
   $33 = HEAP32[$2 >> 2] | 0; //@line 16871
   $36 = HEAPU8[$L + 40 >> 0] | 0; //@line 16874
   if (!($36 & 6)) {
    $$1$i = $firstArg$0; //@line 16879
    $$pre$phi$iZ2D = $33 + 8 | 0; //@line 16879
   } else {
    if (!($36 & 2)) $$0$i = $firstArg$0; //@line 16884
 else {
     $44 = $firstArg$0 - (HEAP32[$12 >> 2] | 0) | 0; //@line 16889
     _luaD_hook($L, 1, -1); //@line 16890
     $$0$i = (HEAP32[$12 >> 2] | 0) + $44 | 0; //@line 16893
    }
    $47 = $33 + 8 | 0; //@line 16895
    HEAP32[$L + 20 >> 2] = HEAP32[(HEAP32[$47 >> 2] | 0) + 28 >> 2]; //@line 16900
    $$1$i = $$0$i; //@line 16901
    $$pre$phi$iZ2D = $47; //@line 16901
   }
   $52 = HEAP32[$33 >> 2] | 0; //@line 16903
   $54 = HEAP16[$33 + 16 >> 1] | 0; //@line 16905
   HEAP32[$2 >> 2] = HEAP32[$$pre$phi$iZ2D >> 2]; //@line 16907
   $56 = $L + 8 | 0; //@line 16908
   L27 : do if (!($54 << 16 >> 16)) $res$1$lcssa$i = $52; //@line 16912
 else {
    $$25$i = $$1$i; //@line 16915
    $i$03$i = $54 << 16 >> 16; //@line 16915
    $res$04$i = $52; //@line 16915
    while (1) {
     if ($$25$i >>> 0 >= (HEAP32[$56 >> 2] | 0) >>> 0) break;
     $62 = $res$04$i + 16 | 0; //@line 16922
     $63 = $$25$i; //@line 16923
     $68 = HEAP32[$63 + 4 >> 2] | 0; //@line 16928
     $69 = $res$04$i; //@line 16929
     HEAP32[$69 >> 2] = HEAP32[$63 >> 2]; //@line 16931
     HEAP32[$69 + 4 >> 2] = $68; //@line 16934
     HEAP32[$res$04$i + 8 >> 2] = HEAP32[$$25$i + 8 >> 2]; //@line 16938
     $76 = $i$03$i + -1 | 0; //@line 16939
     if (!$76) {
      $res$1$lcssa$i = $62; //@line 16942
      break L27;
     }
     $$25$i = $$25$i + 16 | 0; //@line 16946
     $i$03$i = $76; //@line 16946
     $res$04$i = $62; //@line 16946
    }
    if (($i$03$i | 0) > 0) {
     $i$11$i = $i$03$i; //@line 16950
     $res$12$i = $res$04$i; //@line 16950
     while (1) {
      $i$11$i = $i$11$i + -1 | 0; //@line 16952
      HEAP32[$res$12$i + 8 >> 2] = 0; //@line 16955
      if (($i$11$i | 0) <= 0) break; else $res$12$i = $res$12$i + 16 | 0; //@line 16958
     }
     $res$1$lcssa$i = $res$04$i + ($i$03$i << 4) | 0; //@line 16964
    } else $res$1$lcssa$i = $res$04$i; //@line 16966
   } while (0);
   HEAP32[$56 >> 2] = $res$1$lcssa$i; //@line 16970
  } else _luaV_execute($L); //@line 16972
  _unroll($L, 0); //@line 16974
  STACKTOP = sp; //@line 16975
  return;
 } else _resume_error($L, 4528, $ud); //@line 16977
}
function _new_localvar($ls, $name) {
 $ls = $ls | 0;
 $name = $name | 0;
 var $$pre$phiZ2D = 0, $1 = 0, $13 = 0, $17 = 0, $21 = 0, $3 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $44 = 0, $47 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $57 = 0, $6 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $oldsize$01$i = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, sp = 0;
 sp = STACKTOP; //@line 11652
 STACKTOP = STACKTOP + 16 | 0; //@line 11653
 $vararg_buffer1 = sp; //@line 11654
 $1 = HEAP32[$ls + 48 >> 2] | 0; //@line 11656
 $3 = HEAP32[$ls + 64 >> 2] | 0; //@line 11658
 $4 = HEAP32[$1 >> 2] | 0; //@line 11659
 $5 = $4 + 60 | 0; //@line 11660
 $6 = HEAP32[$5 >> 2] | 0; //@line 11661
 $7 = $1 + 44 | 0; //@line 11662
 if ((HEAP16[$7 >> 1] | 0) < ($6 | 0)) {
  $$pre$phiZ2D = $4 + 24 | 0; //@line 11668
  $17 = $6; //@line 11668
 } else {
  $13 = $4 + 24 | 0; //@line 11672
  HEAP32[$13 >> 2] = _luaM_growaux_(HEAP32[$ls + 52 >> 2] | 0, HEAP32[$13 >> 2] | 0, $5, 12, 32767, 9352) | 0; //@line 11675
  $$pre$phiZ2D = $13; //@line 11677
  $17 = HEAP32[$5 >> 2] | 0; //@line 11677
 }
 if (($6 | 0) < ($17 | 0)) {
  $oldsize$01$i = $6; //@line 11681
  do {
   HEAP32[(HEAP32[$$pre$phiZ2D >> 2] | 0) + ($oldsize$01$i * 12 | 0) >> 2] = 0; //@line 11686
   $oldsize$01$i = $oldsize$01$i + 1 | 0; //@line 11683
  } while (($oldsize$01$i | 0) != ($17 | 0));
 }
 $21 = HEAP16[$7 >> 1] | 0; //@line 11695
 HEAP32[(HEAP32[$$pre$phiZ2D >> 2] | 0) + (($21 << 16 >> 16) * 12 | 0) >> 2] = $name; //@line 11699
 if (!(HEAP8[$name + 5 >> 0] & 3)) $36 = $21; //@line 11705
 else if (!(HEAP8[$4 + 5 >> 0] & 4)) $36 = $21; //@line 11712
 else {
  _luaC_barrier_(HEAP32[$ls + 52 >> 2] | 0, $4, $name); //@line 11716
  $36 = HEAP16[$7 >> 1] | 0; //@line 11718
 }
 HEAP16[$7 >> 1] = $36 + 1 << 16 >> 16; //@line 11722
 $37 = $3 + 4 | 0; //@line 11723
 $38 = HEAP32[$37 >> 2] | 0; //@line 11724
 if (($38 + 1 - (HEAP32[$1 + 40 >> 2] | 0) | 0) > 200) {
  $44 = $1 + 12 | 0; //@line 11731
  $47 = HEAP32[(HEAP32[$44 >> 2] | 0) + 52 >> 2] | 0; //@line 11734
  $50 = HEAP32[(HEAP32[$1 >> 2] | 0) + 64 >> 2] | 0; //@line 11737
  if (!$50) {
   $53 = 9408; //@line 11740
   HEAP32[$vararg_buffer1 >> 2] = 9352; //@line 11741
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 11742
   HEAP32[$vararg_ptr4 >> 2] = 200; //@line 11743
   $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 11744
   HEAP32[$vararg_ptr5 >> 2] = $53; //@line 11745
   $54 = _luaO_pushfstring($47, 9448, $vararg_buffer1) | 0; //@line 11746
   $55 = HEAP32[$44 >> 2] | 0; //@line 11747
   _luaX_syntaxerror($55, $54); //@line 11748
  }
  HEAP32[$vararg_buffer1 >> 2] = $50; //@line 11751
  $53 = _luaO_pushfstring($47, 9424, $vararg_buffer1) | 0; //@line 11753
  HEAP32[$vararg_buffer1 >> 2] = 9352; //@line 11754
  $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 11755
  HEAP32[$vararg_ptr4 >> 2] = 200; //@line 11756
  $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 11757
  HEAP32[$vararg_ptr5 >> 2] = $53; //@line 11758
  $54 = _luaO_pushfstring($47, 9448, $vararg_buffer1) | 0; //@line 11759
  $55 = HEAP32[$44 >> 2] | 0; //@line 11760
  _luaX_syntaxerror($55, $54); //@line 11761
 }
 $57 = $3 + 8 | 0; //@line 11765
 if (($38 + 2 | 0) > (HEAP32[$57 >> 2] | 0)) {
  $63 = _luaM_growaux_(HEAP32[$ls + 52 >> 2] | 0, HEAP32[$3 >> 2] | 0, $57, 2, 2147483645, 9352) | 0; //@line 11772
  HEAP32[$3 >> 2] = $63; //@line 11773
  $65 = HEAP32[$37 >> 2] | 0; //@line 11775
  $67 = $63; //@line 11775
  $64 = $65 + 1 | 0; //@line 11776
  HEAP32[$37 >> 2] = $64; //@line 11777
  $66 = $67 + ($65 << 1) | 0; //@line 11778
  HEAP16[$66 >> 1] = $36; //@line 11779
  STACKTOP = sp; //@line 11780
  return;
 } else {
  $65 = $38; //@line 11783
  $67 = HEAP32[$3 >> 2] | 0; //@line 11783
  $64 = $65 + 1 | 0; //@line 11784
  HEAP32[$37 >> 2] = $64; //@line 11785
  $66 = $67 + ($65 << 1) | 0; //@line 11786
  HEAP16[$66 >> 1] = $36; //@line 11787
  STACKTOP = sp; //@line 11788
  return;
 }
}
function _luaK_exp2RK($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $$0 = 0, $$pre$phi2$iZ2D = 0, $0 = 0, $1 = 0, $12 = 0, $17 = 0, $3 = 0, $32 = 0, $34 = 0, $35 = 0.0, $39 = 0, $42 = 0, $43 = 0, $45 = 0, $5 = 0, $53 = 0, $58 = 0, $65 = 0, $66 = 0, $n$0$i = 0, $o$i1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 10748
 STACKTOP = STACKTOP + 32 | 0; //@line 10749
 $0 = sp + 16 | 0; //@line 10750
 $o$i1 = sp; //@line 10751
 $1 = $e + 16 | 0; //@line 10752
 $3 = $e + 20 | 0; //@line 10754
 $5 = (HEAP32[$1 >> 2] | 0) == (HEAP32[$3 >> 2] | 0); //@line 10756
 _luaK_dischargevars($fs, $e); //@line 10757
 do if (!$5) {
  if ((HEAP32[$e >> 2] | 0) == 6) {
   $12 = HEAP32[$e + 8 >> 2] | 0; //@line 10767
   if ((HEAP32[$1 >> 2] | 0) == (HEAP32[$3 >> 2] | 0)) break;
   if (($12 | 0) >= (HEAPU8[$fs + 46 >> 0] | 0 | 0)) {
    _exp2reg($fs, $e, $12); //@line 10776
    break;
   }
  }
  _luaK_exp2nextreg($fs, $e); //@line 10780
 } while (0);
 $17 = HEAP32[$e >> 2] | 0; //@line 10783
 switch ($17 | 0) {
 case 4:
  {
   $58 = HEAP32[$e + 8 >> 2] | 0; //@line 10788
   label = 18; //@line 10789
   break;
  }
 case 5:
  {
   $34 = $e + 8 | 0; //@line 10793
   $35 = +HEAPF64[$34 >> 3]; //@line 10794
   HEAPF64[$0 >> 3] = $35; //@line 10795
   $39 = HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0; //@line 10799
   HEAPF64[$o$i1 >> 3] = $35; //@line 10800
   HEAP32[$o$i1 + 8 >> 2] = 3; //@line 10802
   if ($35 != $35 | 0.0 != 0.0 | $35 == 0.0) {
    $42 = $39 + 8 | 0; //@line 10805
    $43 = HEAP32[$42 >> 2] | 0; //@line 10806
    HEAP32[$42 >> 2] = $43 + 16; //@line 10808
    $45 = _luaS_newlstr($39, $0, 8) | 0; //@line 10809
    HEAP32[$43 >> 2] = $45; //@line 10810
    HEAP32[$43 + 8 >> 2] = HEAPU8[$45 + 4 >> 0] | 0 | 64; //@line 10816
    $53 = _addk($fs, (HEAP32[$42 >> 2] | 0) + -16 | 0, $o$i1) | 0; //@line 10819
    HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + -16; //@line 10822
    $n$0$i = $53; //@line 10823
   } else $n$0$i = _addk($fs, $o$i1, $o$i1) | 0; //@line 10826
   HEAP32[$34 >> 2] = $n$0$i; //@line 10828
   HEAP32[$e >> 2] = 4; //@line 10829
   $58 = $n$0$i; //@line 10830
   label = 18; //@line 10831
   break;
  }
 case 1:
 case 3:
 case 2:
  {
   if ((HEAP32[$fs + 32 >> 2] | 0) < 256) {
    if (($17 | 0) == 1) {
     HEAP32[$o$i1 + 8 >> 2] = 0; //@line 10842
     HEAP32[$0 >> 2] = HEAP32[$fs + 4 >> 2]; //@line 10845
     HEAP32[$0 + 8 >> 2] = 69; //@line 10847
     $32 = _addk($fs, $0, $o$i1) | 0; //@line 10849
    } else {
     HEAP32[$0 >> 2] = ($17 | 0) == 2 & 1; //@line 10853
     HEAP32[$0 + 8 >> 2] = 1; //@line 10855
     $32 = _addk($fs, $0, $0) | 0; //@line 10857
    }
    HEAP32[$e + 8 >> 2] = $32; //@line 10860
    HEAP32[$e >> 2] = 4; //@line 10861
    $$0 = $32 | 256; //@line 10863
    STACKTOP = sp; //@line 10864
    return $$0 | 0; //@line 10864
   }
   break;
  }
 default:
  {}
 }
 if ((label | 0) == 18) if (($58 | 0) < 256) {
  $$0 = $58 | 256; //@line 10875
  STACKTOP = sp; //@line 10876
  return $$0 | 0; //@line 10876
 }
 _luaK_dischargevars($fs, $e); //@line 10879
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $65 = $e + 8 | 0; //@line 10886
  $66 = HEAP32[$65 >> 2] | 0; //@line 10887
  if ((HEAP32[$1 >> 2] | 0) == (HEAP32[$3 >> 2] | 0)) {
   $$0 = $66; //@line 10889
   STACKTOP = sp; //@line 10890
   return $$0 | 0; //@line 10890
  }
  if (($66 | 0) < (HEAPU8[$fs + 46 >> 0] | 0 | 0)) $$pre$phi2$iZ2D = $65; //@line 10897
 else {
   _exp2reg($fs, $e, $66); //@line 10899
   $$0 = HEAP32[$65 >> 2] | 0; //@line 10901
   STACKTOP = sp; //@line 10902
   return $$0 | 0; //@line 10902
  }
 } else $$pre$phi2$iZ2D = $e + 8 | 0; //@line 10906
 _luaK_exp2nextreg($fs, $e); //@line 10908
 $$0 = HEAP32[$$pre$phi2$iZ2D >> 2] | 0; //@line 10910
 STACKTOP = sp; //@line 10911
 return $$0 | 0; //@line 10911
}
function _db_getinfo($L) {
 $L = $L | 0;
 var $$0 = 0, $$0$i = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $ar = 0, $options$0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 13293
 STACKTOP = STACKTOP + 112 | 0; //@line 13294
 $vararg_buffer = sp; //@line 13295
 $ar = sp + 4 | 0; //@line 13296
 if ((_lua_type($L, 1) | 0) == 8) {
  $$0$i = _lua_tothread($L, 1) | 0; //@line 13301
  $4 = 1; //@line 13301
 } else {
  $$0$i = $L; //@line 13303
  $4 = 0; //@line 13303
 }
 $3 = $4 | 2; //@line 13305
 $5 = _luaL_optlstring($L, $3, 3568, 0) | 0; //@line 13306
 $6 = $4 + 1 | 0; //@line 13307
 do if (!(_lua_isnumber($L, $6) | 0)) {
  if ((_lua_type($L, $6) | 0) == 6) {
   HEAP32[$vararg_buffer >> 2] = $5; //@line 13315
   _lua_pushfstring($L, 3576, $vararg_buffer) | 0; //@line 13316
   $14 = _lua_tolstring($L, -1, 0) | 0; //@line 13317
   _lua_pushvalue($L, $6); //@line 13318
   _lua_xmove($L, $$0$i, 1); //@line 13319
   $options$0 = $14; //@line 13320
   break;
  }
  $$0 = _luaL_argerror($L, $6, 3584) | 0; //@line 13324
  STACKTOP = sp; //@line 13325
  return $$0 | 0; //@line 13325
 } else if (!(_lua_getstack($$0$i, _lua_tointegerx($L, $6, 0) | 0, $ar) | 0)) {
  _lua_pushnil($L); //@line 13331
  $$0 = 1; //@line 13332
  STACKTOP = sp; //@line 13333
  return $$0 | 0; //@line 13333
 } else $options$0 = $5; //@line 13335
 while (0);
 if (!(_lua_getinfo($$0$i, $options$0, $ar) | 0)) {
  $$0 = _luaL_argerror($L, $3, 3616) | 0; //@line 13343
  STACKTOP = sp; //@line 13344
  return $$0 | 0; //@line 13344
 }
 _lua_createtable($L, 0, 2); //@line 13346
 if (_strchr($options$0, 83) | 0) {
  _lua_pushstring($L, HEAP32[$ar + 16 >> 2] | 0) | 0; //@line 13352
  _lua_setfield($L, -2, 3632); //@line 13353
  _lua_pushstring($L, $ar + 36 | 0) | 0; //@line 13355
  _lua_setfield($L, -2, 3640); //@line 13356
  _lua_pushinteger($L, HEAP32[$ar + 24 >> 2] | 0); //@line 13359
  _lua_setfield($L, -2, 3656); //@line 13360
  _lua_pushinteger($L, HEAP32[$ar + 28 >> 2] | 0); //@line 13363
  _lua_setfield($L, -2, 3672); //@line 13364
  _lua_pushstring($L, HEAP32[$ar + 12 >> 2] | 0) | 0; //@line 13367
  _lua_setfield($L, -2, 3688); //@line 13368
 }
 if (_strchr($options$0, 108) | 0) {
  _lua_pushinteger($L, HEAP32[$ar + 20 >> 2] | 0); //@line 13375
  _lua_setfield($L, -2, 3696); //@line 13376
 }
 if (_strchr($options$0, 117) | 0) {
  _lua_pushinteger($L, HEAPU8[$ar + 32 >> 0] | 0); //@line 13384
  _lua_setfield($L, -2, 3712); //@line 13385
  _lua_pushinteger($L, HEAPU8[$ar + 33 >> 0] | 0); //@line 13389
  _lua_setfield($L, -2, 3720); //@line 13390
  _lua_pushboolean($L, HEAP8[$ar + 34 >> 0] | 0); //@line 13394
  _lua_setfield($L, -2, 3728); //@line 13395
 }
 if (_strchr($options$0, 110) | 0) {
  _lua_pushstring($L, HEAP32[$ar + 4 >> 2] | 0) | 0; //@line 13402
  _lua_setfield($L, -2, 3744); //@line 13403
  _lua_pushstring($L, HEAP32[$ar + 8 >> 2] | 0) | 0; //@line 13406
  _lua_setfield($L, -2, 3752); //@line 13407
 }
 if (_strchr($options$0, 116) | 0) {
  _lua_pushboolean($L, HEAP8[$ar + 35 >> 0] | 0); //@line 13415
  _lua_setfield($L, -2, 3768); //@line 13416
 }
 if (_strchr($options$0, 76) | 0) {
  if (($$0$i | 0) == ($L | 0)) {
   _lua_pushvalue($L, -2); //@line 13423
   _lua_remove($L, -3); //@line 13424
  } else _lua_xmove($$0$i, $L, 1); //@line 13426
  _lua_setfield($L, -2, 3784); //@line 13428
 }
 if (!(_strchr($options$0, 102) | 0)) {
  $$0 = 1; //@line 13433
  STACKTOP = sp; //@line 13434
  return $$0 | 0; //@line 13434
 }
 if (($$0$i | 0) == ($L | 0)) {
  _lua_pushvalue($L, -2); //@line 13438
  _lua_remove($L, -3); //@line 13439
 } else _lua_xmove($$0$i, $L, 1); //@line 13441
 _lua_setfield($L, -2, 3800); //@line 13443
 $$0 = 1; //@line 13444
 STACKTOP = sp; //@line 13445
 return $$0 | 0; //@line 13445
}
function _lua_setupvalue($L, $funcindex, $n) {
 $L = $L | 0;
 $funcindex = $funcindex | 0;
 $n = $n | 0;
 var $$0$i = 0, $$0$i12 = 0, $$0$i16 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $31 = 0, $39 = 0, $4 = 0, $41 = 0, $46 = 0, $49 = 0, $51 = 0, $55 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $66 = 0, $67 = 0, $68 = 0, $75 = 0, $80 = 0, $86 = 0, sp = 0;
 sp = STACKTOP; //@line 5170
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 5172
 do if (($funcindex | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($funcindex << 4) | 0; //@line 5177
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 5182
 } else {
  if (($funcindex | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($funcindex << 4) | 0; //@line 5189
   break;
  }
  if (($funcindex | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5197
   break;
  }
  $16 = -1001e3 - $funcindex | 0; //@line 5200
  $17 = HEAP32[$1 >> 2] | 0; //@line 5201
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 5206
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 5208
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 5214
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 5218
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 63; //@line 5225
 do if (($30 | 0) == 6) {
  $39 = HEAP32[$$0$i >> 2] | 0; //@line 5228
  $41 = HEAP32[$39 + 12 >> 2] | 0; //@line 5230
  if (($n | 0) <= 0) {
   $$0$i12 = 0; //@line 5233
   STACKTOP = sp; //@line 5234
   return $$0$i12 | 0; //@line 5234
  }
  if ((HEAP32[$41 + 40 >> 2] | 0) < ($n | 0)) {
   $$0$i12 = 0; //@line 5240
   STACKTOP = sp; //@line 5241
   return $$0$i12 | 0; //@line 5241
  }
  $46 = $n + -1 | 0; //@line 5243
  $49 = HEAP32[$39 + 16 + ($46 << 2) >> 2] | 0; //@line 5246
  $51 = HEAP32[$49 + 8 >> 2] | 0; //@line 5248
  $55 = HEAP32[(HEAP32[$41 + 28 >> 2] | 0) + ($46 << 3) >> 2] | 0; //@line 5252
  if (!$55) {
   $$0$i16 = 24; //@line 5255
   $68 = $51; //@line 5255
   $86 = $49; //@line 5255
  } else {
   $$0$i16 = $55 + 16 | 0; //@line 5258
   $68 = $51; //@line 5258
   $86 = $49; //@line 5258
  }
 } else if (($30 | 0) == 38) {
  $31 = HEAP32[$$0$i >> 2] | 0; //@line 5261
  if (($n | 0) <= 0) {
   $$0$i12 = 0; //@line 5264
   STACKTOP = sp; //@line 5265
   return $$0$i12 | 0; //@line 5265
  }
  if ((HEAPU8[$31 + 6 >> 0] | 0 | 0) < ($n | 0)) {
   $$0$i12 = 0; //@line 5272
   STACKTOP = sp; //@line 5273
   return $$0$i12 | 0; //@line 5273
  } else {
   $$0$i16 = 24; //@line 5277
   $68 = $31 + ($n + -1 << 4) + 16 | 0; //@line 5277
   $86 = $31; //@line 5277
   break;
  }
 } else {
  $$0$i12 = 0; //@line 5281
  STACKTOP = sp; //@line 5282
  return $$0$i12 | 0; //@line 5282
 } while (0);
 $58 = $L + 8 | 0; //@line 5285
 $59 = HEAP32[$58 >> 2] | 0; //@line 5286
 $60 = $59 + -16 | 0; //@line 5287
 HEAP32[$58 >> 2] = $60; //@line 5288
 $61 = $60; //@line 5289
 $66 = HEAP32[$61 + 4 >> 2] | 0; //@line 5294
 $67 = $68; //@line 5295
 HEAP32[$67 >> 2] = HEAP32[$61 >> 2]; //@line 5297
 HEAP32[$67 + 4 >> 2] = $66; //@line 5300
 HEAP32[$68 + 8 >> 2] = HEAP32[$59 + -8 >> 2]; //@line 5304
 $75 = HEAP32[$58 >> 2] | 0; //@line 5305
 if (!(HEAP32[$75 + 8 >> 2] & 64)) {
  $$0$i12 = $$0$i16; //@line 5311
  STACKTOP = sp; //@line 5312
  return $$0$i12 | 0; //@line 5312
 }
 $80 = HEAP32[$75 >> 2] | 0; //@line 5314
 if (!(HEAP8[$80 + 5 >> 0] & 3)) {
  $$0$i12 = $$0$i16; //@line 5320
  STACKTOP = sp; //@line 5321
  return $$0$i12 | 0; //@line 5321
 }
 if (!(HEAP8[$86 + 5 >> 0] & 4)) {
  $$0$i12 = $$0$i16; //@line 5328
  STACKTOP = sp; //@line 5329
  return $$0$i12 | 0; //@line 5329
 }
 _luaC_barrier_($L, $86, $80); //@line 5331
 $$0$i12 = $$0$i16; //@line 5332
 STACKTOP = sp; //@line 5333
 return $$0$i12 | 0; //@line 5333
}
function _luaV_arith($L, $ra, $rb, $rc, $op) {
 $L = $L | 0;
 $ra = $ra | 0;
 $rb = $rb | 0;
 $rc = $rc | 0;
 $op = $op | 0;
 var $$0$i$ph = 0, $0 = 0, $1 = 0, $104 = 0, $105 = 0, $14 = 0, $18 = 0, $28 = 0.0, $31 = 0, $35 = 0, $37 = 0, $41 = 0, $42 = 0, $43 = 0, $45 = 0, $5 = 0, $50 = 0, $51 = 0, $58 = 0, $60 = 0, $65 = 0, $66 = 0, $72 = 0, $74 = 0, $79 = 0, $80 = 0, $95 = 0, $97 = 0, $98 = 0, $99 = 0, $num$i = 0, $num$i1 = 0, $tempb = 0, $tm$01$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 2765
 STACKTOP = STACKTOP + 32 | 0; //@line 2766
 $num$i1 = sp + 24 | 0; //@line 2767
 $num$i = sp + 16 | 0; //@line 2768
 $tempb = sp; //@line 2769
 $0 = $rb + 8 | 0; //@line 2770
 $1 = HEAP32[$0 >> 2] | 0; //@line 2771
 if (($1 | 0) == 3) {
  $$0$i$ph = $rb; //@line 2774
  label = 5; //@line 2775
 } else if (($1 & 15 | 0) == 4) {
  $5 = HEAP32[$rb >> 2] | 0; //@line 2780
  if (_luaO_str2d($5 + 16 | 0, HEAP32[$5 + 12 >> 2] | 0, $num$i) | 0) {
   HEAPF64[$tempb >> 3] = +HEAPF64[$num$i >> 3]; //@line 2788
   HEAP32[$tempb + 8 >> 2] = 3; //@line 2790
   $$0$i$ph = $tempb; //@line 2791
   label = 5; //@line 2792
  }
 }
 do if ((label | 0) == 5) {
  $14 = HEAP32[$rc + 8 >> 2] | 0; //@line 2799
  if (($14 | 0) == 3) {
   if (!$rc) break;
   $28 = +HEAPF64[$rc >> 3]; //@line 2807
  } else {
   if (($14 & 15 | 0) != 4) break;
   $18 = HEAP32[$rc >> 2] | 0; //@line 2814
   if (!(_luaO_str2d($18 + 16 | 0, HEAP32[$18 + 12 >> 2] | 0, $num$i1) | 0)) break;
   $28 = +HEAPF64[$num$i1 >> 3]; //@line 2824
  }
  HEAPF64[$ra >> 3] = +_luaO_arith($op + -6 | 0, +HEAPF64[$$0$i$ph >> 3], $28); //@line 2829
  HEAP32[$ra + 8 >> 2] = 3; //@line 2831
  STACKTOP = sp; //@line 2832
  return;
 } while (0);
 $31 = _luaT_gettmbyobj($L, $rb, $op) | 0; //@line 2835
 if (!(HEAP32[$31 + 8 >> 2] | 0)) {
  $35 = _luaT_gettmbyobj($L, $rc, $op) | 0; //@line 2840
  if (!(HEAP32[$35 + 8 >> 2] | 0)) _luaG_aritherror($L, $rb, $rc); //@line 2845
 else $tm$01$i = $35; //@line 2848
 } else $tm$01$i = $31; //@line 2851
 $37 = $L + 28 | 0; //@line 2853
 $41 = $ra - (HEAP32[$37 >> 2] | 0) | 0; //@line 2857
 $42 = $L + 8 | 0; //@line 2858
 $43 = HEAP32[$42 >> 2] | 0; //@line 2859
 HEAP32[$42 >> 2] = $43 + 16; //@line 2861
 $45 = $tm$01$i; //@line 2862
 $50 = HEAP32[$45 + 4 >> 2] | 0; //@line 2867
 $51 = $43; //@line 2868
 HEAP32[$51 >> 2] = HEAP32[$45 >> 2]; //@line 2870
 HEAP32[$51 + 4 >> 2] = $50; //@line 2873
 HEAP32[$43 + 8 >> 2] = HEAP32[$tm$01$i + 8 >> 2]; //@line 2877
 $58 = HEAP32[$42 >> 2] | 0; //@line 2878
 HEAP32[$42 >> 2] = $58 + 16; //@line 2880
 $60 = $rb; //@line 2881
 $65 = HEAP32[$60 + 4 >> 2] | 0; //@line 2886
 $66 = $58; //@line 2887
 HEAP32[$66 >> 2] = HEAP32[$60 >> 2]; //@line 2889
 HEAP32[$66 + 4 >> 2] = $65; //@line 2892
 HEAP32[$58 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 2895
 $72 = HEAP32[$42 >> 2] | 0; //@line 2896
 HEAP32[$42 >> 2] = $72 + 16; //@line 2898
 $74 = $rc; //@line 2899
 $79 = HEAP32[$74 + 4 >> 2] | 0; //@line 2904
 $80 = $72; //@line 2905
 HEAP32[$80 >> 2] = HEAP32[$74 >> 2]; //@line 2907
 HEAP32[$80 + 4 >> 2] = $79; //@line 2910
 HEAP32[$72 + 8 >> 2] = HEAP32[$rc + 8 >> 2]; //@line 2914
 _luaD_call($L, (HEAP32[$42 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 2923
 $95 = HEAP32[$37 >> 2] | 0; //@line 2924
 $97 = HEAP32[$42 >> 2] | 0; //@line 2926
 $98 = $97 + -16 | 0; //@line 2927
 HEAP32[$42 >> 2] = $98; //@line 2928
 $99 = $98; //@line 2929
 $104 = HEAP32[$99 + 4 >> 2] | 0; //@line 2934
 $105 = $95 + $41 | 0; //@line 2935
 HEAP32[$105 >> 2] = HEAP32[$99 >> 2]; //@line 2937
 HEAP32[$105 + 4 >> 2] = $104; //@line 2940
 HEAP32[$95 + ($41 + 8) >> 2] = HEAP32[$97 + -8 >> 2]; //@line 2945
 STACKTOP = sp; //@line 2946
 return;
}
function _discharge2reg($fs, $e, $reg) {
 $fs = $fs | 0;
 $e = $e | 0;
 $reg = $reg | 0;
 var $$from$i = 0, $0 = 0, $1 = 0, $12 = 0, $13 = 0, $17 = 0, $19 = 0, $2 = 0, $4 = 0, $43 = 0, $45 = 0, $53 = 0.0, $57 = 0, $60 = 0, $61 = 0, $63 = 0, $71 = 0, $76 = 0, $88 = 0, $95 = 0, $n$0$i = 0, $o$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 12762
 STACKTOP = STACKTOP + 32 | 0; //@line 12763
 $0 = sp + 16 | 0; //@line 12764
 $o$i = sp; //@line 12765
 _luaK_dischargevars($fs, $e); //@line 12766
 $1 = HEAP32[$e >> 2] | 0; //@line 12767
 L1 : do switch ($1 | 0) {
 case 1:
  {
   $2 = $reg + 1 | 0; //@line 12771
   $4 = HEAP32[$fs + 20 >> 2] | 0; //@line 12773
   do if (($4 | 0) > (HEAP32[$fs + 24 >> 2] | 0)) {
    $12 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + ($4 + -1 << 2) | 0; //@line 12783
    $13 = HEAP32[$12 >> 2] | 0; //@line 12784
    if (($13 & 63 | 0) == 4) {
     $17 = $13 >>> 6 & 255; //@line 12789
     $19 = $17 + ($13 >>> 23) | 0; //@line 12791
     if (($17 | 0) > ($reg | 0)) label = 6; //@line 12794
 else if (($19 + 1 | 0) < ($reg | 0)) label = 6; //@line 12799
     if ((label | 0) == 6) if (($17 | 0) < ($reg | 0) | ($17 | 0) > ($2 | 0)) break;
     $$from$i = ($17 | 0) < ($reg | 0) ? $17 : $reg; //@line 12811
     HEAP32[$12 >> 2] = $$from$i << 6 & 16320 | $13 & 8372287 | (($19 | 0) > ($reg | 0) ? $19 : $reg) - $$from$i << 23; //@line 12821
     break L1;
    }
   } while (0);
   _luaK_code($fs, $reg << 6 | 4) | 0; //@line 12828
   break;
  }
 case 11:
  {
   $88 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$e + 8 >> 2] << 2) | 0; //@line 12837
   HEAP32[$88 >> 2] = HEAP32[$88 >> 2] & -16321 | $reg << 6 & 16320; //@line 12843
   break;
  }
 case 2:
 case 3:
  {
   _luaK_code($fs, $reg << 6 | (($1 | 0) == 2 & 1) << 23 | 3) | 0; //@line 12853
   break;
  }
 case 4:
  {
   $43 = HEAP32[$e + 8 >> 2] | 0; //@line 12858
   $45 = $reg << 6; //@line 12860
   if (($43 | 0) < 262144) {
    _luaK_code($fs, $45 | $43 << 14 | 1) | 0; //@line 12865
    break L1;
   } else {
    _luaK_code($fs, $45 | 2) | 0; //@line 12869
    _luaK_code($fs, $43 << 6 | 39) | 0; //@line 12872
    break L1;
   }
   break;
  }
 case 5:
  {
   $53 = +HEAPF64[$e + 8 >> 3]; //@line 12879
   HEAPF64[$0 >> 3] = $53; //@line 12880
   $57 = HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0; //@line 12884
   HEAPF64[$o$i >> 3] = $53; //@line 12885
   HEAP32[$o$i + 8 >> 2] = 3; //@line 12887
   if ($53 != $53 | 0.0 != 0.0 | $53 == 0.0) {
    $60 = $57 + 8 | 0; //@line 12890
    $61 = HEAP32[$60 >> 2] | 0; //@line 12891
    HEAP32[$60 >> 2] = $61 + 16; //@line 12893
    $63 = _luaS_newlstr($57, $0, 8) | 0; //@line 12894
    HEAP32[$61 >> 2] = $63; //@line 12895
    HEAP32[$61 + 8 >> 2] = HEAPU8[$63 + 4 >> 0] | 0 | 64; //@line 12901
    $71 = _addk($fs, (HEAP32[$60 >> 2] | 0) + -16 | 0, $o$i) | 0; //@line 12904
    HEAP32[$60 >> 2] = (HEAP32[$60 >> 2] | 0) + -16; //@line 12907
    $n$0$i = $71; //@line 12908
   } else $n$0$i = _addk($fs, $o$i, $o$i) | 0; //@line 12911
   $76 = $reg << 6; //@line 12914
   if (($n$0$i | 0) < 262144) {
    _luaK_code($fs, $76 | $n$0$i << 14 | 1) | 0; //@line 12919
    break L1;
   } else {
    _luaK_code($fs, $76 | 2) | 0; //@line 12923
    _luaK_code($fs, $n$0$i << 6 | 39) | 0; //@line 12926
    break L1;
   }
   break;
  }
 case 6:
  {
   $95 = HEAP32[$e + 8 >> 2] | 0; //@line 12933
   if (($95 | 0) != ($reg | 0)) _luaK_code($fs, $95 << 23 | $reg << 6) | 0; //@line 12939
   break;
  }
 default:
  {
   STACKTOP = sp; //@line 12944
   return;
  }
 } while (0);
 HEAP32[$e + 8 >> 2] = $reg; //@line 12949
 HEAP32[$e >> 2] = 6; //@line 12950
 STACKTOP = sp; //@line 12951
 return;
}
function _luaC_fullgc($L, $isemergency) {
 $L = $L | 0;
 $isemergency = $isemergency | 0;
 var $$pre = 0, $$pre13 = 0, $0 = 0, $1 = 0, $10 = 0, $2 = 0, $21 = 0, $24 = 0, $25 = 0, $28 = 0, $29 = 0, $3 = 0, $32 = 0, $33 = 0, $38 = 0, $39 = 0, $4 = 0, $41 = 0, $50 = 0, $51 = 0, $53 = 0, $58 = 0, $6 = 0, $64 = 0, $66 = 0, $68 = 0, $7 = 0, $70 = 0, $75 = 0, $78 = 0, $79 = 0, $81 = 0, $82 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 346
 $0 = $L + 12 | 0; //@line 347
 $1 = HEAP32[$0 >> 2] | 0; //@line 348
 $2 = $1 + 62 | 0; //@line 349
 $3 = HEAP8[$2 >> 0] | 0; //@line 350
 $4 = ($isemergency | 0) != 0; //@line 351
 if ($4) {
  HEAP8[$2 >> 0] = 1; //@line 353
  label = 6; //@line 354
 } else {
  HEAP8[$2 >> 0] = 0; //@line 356
  $6 = (HEAP32[$0 >> 2] | 0) + 104 | 0; //@line 358
  $7 = HEAP32[$6 >> 2] | 0; //@line 359
  if (!$7) label = 6; //@line 362
 else {
   $10 = $7; //@line 364
   do {
    $9 = $10 + 5 | 0; //@line 366
    HEAP8[$9 >> 0] = HEAPU8[$9 >> 0] & 191; //@line 371
    _GCTM($L, 1); //@line 372
    $10 = HEAP32[$6 >> 2] | 0; //@line 373
   } while (($10 | 0) != 0);
   if ((HEAP8[$2 >> 0] | 0) == 2) label = 7; //@line 384
 else label = 6; //@line 386
  }
 }
 if ((label | 0) == 6) if ((HEAPU8[$1 + 61 >> 0] | 0) < 2) label = 7; //@line 395
 if ((label | 0) == 7) {
  $21 = HEAP32[$0 >> 2] | 0; //@line 399
  HEAP8[$21 + 61 >> 0] = 2; //@line 401
  HEAP32[$21 + 64 >> 2] = 0; //@line 403
  $24 = $21 + 72 | 0; //@line 404
  do $25 = _sweeplist($L, $24, 1) | 0; //@line 406
 while (($25 | 0) == ($24 | 0));
  HEAP32[$21 + 80 >> 2] = $25; //@line 413
  $28 = $21 + 68 | 0; //@line 414
  do $29 = _sweeplist($L, $28, 1) | 0; //@line 416
 while (($29 | 0) == ($28 | 0));
  HEAP32[$21 + 76 >> 2] = $29; //@line 423
 }
 $32 = HEAP32[$0 >> 2] | 0; //@line 425
 $33 = $32 + 61 | 0; //@line 426
 if ((HEAP8[$33 >> 0] | 0) == 5) {
  $39 = $32; //@line 430
  $41 = 5; //@line 430
 } else {
  do _singlestep($L) | 0; //@line 433
 while ((HEAP8[$33 >> 0] | 0) != 5);
  $$pre = HEAP32[$0 >> 2] | 0; //@line 440
  $39 = $$pre; //@line 443
  $41 = HEAP8[$$pre + 61 >> 0] | 0; //@line 443
 }
 $38 = $39 + 61 | 0; //@line 445
 if (!(1 << ($41 & 255) & -33)) {
  do _singlestep($L) | 0; //@line 452
 while ((1 << HEAPU8[$38 >> 0] & -33 | 0) == 0);
  $$pre13 = HEAP32[$0 >> 2] | 0; //@line 462
  $51 = $$pre13; //@line 465
  $53 = HEAP8[$$pre13 + 61 >> 0] | 0; //@line 465
 } else {
  $51 = $39; //@line 467
  $53 = $41; //@line 467
 }
 $50 = $51 + 61 | 0; //@line 469
 if ($53 << 24 >> 24 != 5) do _singlestep($L) | 0; //@line 473
 while ((HEAP8[$50 >> 0] | 0) != 5);
 if ($3 << 24 >> 24 == 2) {
  $58 = (HEAP32[$0 >> 2] | 0) + 61 | 0; //@line 484
  if (HEAP8[$58 >> 0] | 0) do _singlestep($L) | 0; //@line 489
 while ((HEAP8[$58 >> 0] | 0) != 0);
 }
 HEAP8[$2 >> 0] = $3; //@line 498
 $64 = HEAP32[$1 + 8 >> 2] | 0; //@line 500
 $66 = HEAP32[$1 + 12 >> 2] | 0; //@line 502
 $68 = ($66 + $64 | 0) / 100 | 0; //@line 504
 $70 = HEAP32[$1 + 156 >> 2] | 0; //@line 506
 if (($70 | 0) < (2147483644 / ($68 | 0) | 0 | 0)) $75 = Math_imul($70, $68) | 0; //@line 511
 else $75 = 2147483644; //@line 513
 _luaE_setdebt($1, $64 - $75 + $66 | 0); //@line 517
 if ($4) {
  STACKTOP = sp; //@line 519
  return;
 }
 $78 = (HEAP32[$0 >> 2] | 0) + 104 | 0; //@line 522
 $79 = HEAP32[$78 >> 2] | 0; //@line 523
 if (!$79) {
  STACKTOP = sp; //@line 526
  return;
 } else $82 = $79; //@line 528
 do {
  $81 = $82 + 5 | 0; //@line 531
  HEAP8[$81 >> 0] = HEAPU8[$81 >> 0] & 191; //@line 536
  _GCTM($L, 1); //@line 537
  $82 = HEAP32[$78 >> 2] | 0; //@line 538
 } while (($82 | 0) != 0);
 STACKTOP = sp; //@line 546
 return;
}
function _luaV_finishOp($L) {
 $L = $L | 0;
 var $1 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $2 = 0, $20 = 0, $21 = 0, $28 = 0, $29 = 0, $3 = 0, $31 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $47 = 0, $53 = 0, $54 = 0, $57 = 0, $61 = 0, $63 = 0, $68 = 0, $69 = 0, $7 = 0, $78 = 0, $8 = 0, $80 = 0, $82 = 0, $84 = 0, $89 = 0, $9 = 0, $90 = 0, $res$0 = 0, sp = 0;
 sp = STACKTOP; //@line 2956
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2958
 $2 = $1 + 24 | 0; //@line 2959
 $3 = HEAP32[$2 >> 2] | 0; //@line 2960
 $4 = $1 + 28 | 0; //@line 2961
 $7 = HEAP32[(HEAP32[$4 >> 2] | 0) + -4 >> 2] | 0; //@line 2964
 $8 = $7 & 63; //@line 2965
 switch ($8 | 0) {
 case 29:
  {
   if (!($7 & 8372224)) {
    STACKTOP = sp; //@line 2971
    return;
   }
   HEAP32[$L + 8 >> 2] = HEAP32[$1 + 4 >> 2]; //@line 2976
   STACKTOP = sp; //@line 2977
   return;
  }
 case 22:
  {
   $53 = $L + 8 | 0; //@line 2981
   $54 = HEAP32[$53 >> 2] | 0; //@line 2982
   $57 = $54 + -32 | 0; //@line 2985
   $61 = $57 - ($3 + ($7 >>> 23 << 4)) | 0; //@line 2989
   $63 = $54 + -16 | 0; //@line 2991
   $68 = HEAP32[$63 + 4 >> 2] | 0; //@line 2996
   $69 = $54 + -48 | 0; //@line 2997
   HEAP32[$69 >> 2] = HEAP32[$63 >> 2]; //@line 2999
   HEAP32[$69 + 4 >> 2] = $68; //@line 3002
   HEAP32[$54 + -40 >> 2] = HEAP32[$54 + -8 >> 2]; //@line 3006
   if (($61 | 0) > 16) {
    HEAP32[$53 >> 2] = $57; //@line 3010
    _luaV_concat($L, $61 >> 4); //@line 3011
   }
   $78 = HEAP32[$53 >> 2] | 0; //@line 3013
   $80 = HEAP32[$2 >> 2] | 0; //@line 3015
   $82 = $7 >>> 6 & 255; //@line 3017
   $84 = $78 + -16 | 0; //@line 3019
   $89 = HEAP32[$84 + 4 >> 2] | 0; //@line 3024
   $90 = $80 + ($82 << 4) | 0; //@line 3025
   HEAP32[$90 >> 2] = HEAP32[$84 >> 2]; //@line 3027
   HEAP32[$90 + 4 >> 2] = $89; //@line 3030
   HEAP32[$80 + ($82 << 4) + 8 >> 2] = HEAP32[$78 + -8 >> 2]; //@line 3034
   HEAP32[$53 >> 2] = HEAP32[$1 + 4 >> 2]; //@line 3037
   STACKTOP = sp; //@line 3038
   return;
  }
 case 24:
 case 25:
 case 26:
  {
   $28 = $L + 8 | 0; //@line 3042
   $29 = HEAP32[$28 >> 2] | 0; //@line 3043
   $31 = HEAP32[$29 + -8 >> 2] | 0; //@line 3045
   if (!$31) $38 = 1; //@line 3048
 else if (($31 | 0) == 1) $38 = (HEAP32[$29 + -16 >> 2] | 0) == 0; //@line 3055
 else $38 = 0; //@line 3057
   $37 = $38 & 1; //@line 3060
   $39 = $37 ^ 1; //@line 3061
   HEAP32[$28 >> 2] = $29 + -16; //@line 3063
   if (($8 | 0) == 26) {
    $47 = (HEAP32[(_luaT_gettmbyobj($L, $3 + ($7 >>> 23 << 4) | 0, 14) | 0) + 8 >> 2] | 0) == 0; //@line 3071
    $res$0 = $47 ? $37 : $39; //@line 3073
   } else $res$0 = $39; //@line 3075
   if (($res$0 | 0) == ($7 >>> 6 & 255 | 0)) {
    STACKTOP = sp; //@line 3081
    return;
   }
   HEAP32[$4 >> 2] = (HEAP32[$4 >> 2] | 0) + 4; //@line 3085
   STACKTOP = sp; //@line 3086
   return;
  }
 case 34:
  {
   HEAP32[$L + 8 >> 2] = HEAP32[$1 + 4 >> 2]; //@line 3093
   STACKTOP = sp; //@line 3094
   return;
  }
 case 12:
 case 7:
 case 6:
 case 21:
 case 19:
 case 18:
 case 17:
 case 16:
 case 15:
 case 14:
 case 13:
  {
   $9 = $L + 8 | 0; //@line 3098
   $10 = HEAP32[$9 >> 2] | 0; //@line 3099
   $11 = $10 + -16 | 0; //@line 3100
   HEAP32[$9 >> 2] = $11; //@line 3101
   $13 = $7 >>> 6 & 255; //@line 3103
   $15 = $11; //@line 3105
   $20 = HEAP32[$15 + 4 >> 2] | 0; //@line 3110
   $21 = $3 + ($13 << 4) | 0; //@line 3111
   HEAP32[$21 >> 2] = HEAP32[$15 >> 2]; //@line 3113
   HEAP32[$21 + 4 >> 2] = $20; //@line 3116
   HEAP32[$3 + ($13 << 4) + 8 >> 2] = HEAP32[$10 + -8 >> 2]; //@line 3120
   STACKTOP = sp; //@line 3121
   return;
  }
 default:
  {
   STACKTOP = sp; //@line 3125
   return;
  }
 }
}
function _luaL_loadfilex($L, $filename, $mode) {
 $L = $L | 0;
 $filename = $filename | 0;
 $mode = $mode | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $18 = 0, $2 = 0, $20 = 0, $22 = 0, $26 = 0, $28 = 0, $30 = 0, $32 = 0, $36 = 0, $38 = 0, $39 = 0, $43 = 0, $45 = 0, $5 = 0, $c = 0, $lf = 0, $vararg_buffer11 = 0, sp = 0;
 sp = STACKTOP; //@line 6658
 STACKTOP = STACKTOP + 1056 | 0; //@line 6659
 $vararg_buffer11 = sp; //@line 6660
 $lf = sp + 16 | 0; //@line 6661
 $c = sp + 12 | 0; //@line 6662
 $1 = (_lua_gettop($L) | 0) + 1 | 0; //@line 6664
 $2 = ($filename | 0) == 0; //@line 6665
 if ($2) {
  _lua_pushlstring($L, 384, 6) | 0; //@line 6667
  HEAP32[$lf + 4 >> 2] = HEAP32[_stdin >> 2]; //@line 6670
 } else {
  HEAP32[$vararg_buffer11 >> 2] = $filename; //@line 6672
  _lua_pushfstring($L, 392, $vararg_buffer11) | 0; //@line 6673
  $5 = _fopen($filename | 0, 400) | 0; //@line 6674
  HEAP32[$lf + 4 >> 2] = $5; //@line 6676
  if (!$5) {
   $10 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 6681
   $12 = (_lua_tolstring($L, $1, 0) | 0) + 1 | 0; //@line 6683
   HEAP32[$vararg_buffer11 >> 2] = 408; //@line 6684
   HEAP32[$vararg_buffer11 + 4 >> 2] = $12; //@line 6686
   HEAP32[$vararg_buffer11 + 8 >> 2] = $10; //@line 6688
   _lua_pushfstring($L, 808, $vararg_buffer11) | 0; //@line 6689
   _lua_remove($L, $1); //@line 6690
   $$0 = 7; //@line 6691
   STACKTOP = sp; //@line 6692
   return $$0 | 0; //@line 6692
  }
 }
 if (_skipcomment($lf, $c) | 0) {
  $15 = HEAP32[$lf >> 2] | 0; //@line 6698
  HEAP32[$lf >> 2] = $15 + 1; //@line 6700
  HEAP8[$lf + $15 + 8 >> 0] = 10; //@line 6702
 }
 $18 = HEAP32[$c >> 2] | 0; //@line 6704
 do if (($18 | 0) != 27 | $2) $30 = $18; //@line 6709
 else {
  $20 = $lf + 4 | 0; //@line 6711
  $22 = _freopen($filename | 0, 416, HEAP32[$20 >> 2] | 0) | 0; //@line 6713
  HEAP32[$20 >> 2] = $22; //@line 6714
  if ($22) {
   _skipcomment($lf, $c) | 0; //@line 6717
   $30 = HEAP32[$c >> 2] | 0; //@line 6719
   break;
  }
  $26 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 6724
  $28 = (_lua_tolstring($L, $1, 0) | 0) + 1 | 0; //@line 6726
  HEAP32[$vararg_buffer11 >> 2] = 424; //@line 6727
  HEAP32[$vararg_buffer11 + 4 >> 2] = $28; //@line 6729
  HEAP32[$vararg_buffer11 + 8 >> 2] = $26; //@line 6731
  _lua_pushfstring($L, 808, $vararg_buffer11) | 0; //@line 6732
  _lua_remove($L, $1); //@line 6733
  $$0 = 7; //@line 6734
  STACKTOP = sp; //@line 6735
  return $$0 | 0; //@line 6735
 } while (0);
 if (($30 | 0) != -1) {
  $32 = HEAP32[$lf >> 2] | 0; //@line 6741
  HEAP32[$lf >> 2] = $32 + 1; //@line 6743
  HEAP8[$lf + $32 + 8 >> 0] = $30; //@line 6745
 }
 $36 = _lua_load($L, 19, $lf, _lua_tolstring($L, -1, 0) | 0, $mode) | 0; //@line 6748
 $38 = HEAP32[$lf + 4 >> 2] | 0; //@line 6750
 $39 = _ferror($38 | 0) | 0; //@line 6751
 if (!$2) _fclose($38 | 0) | 0; //@line 6753
 if (!$39) {
  _lua_remove($L, $1); //@line 6757
  $$0 = $36; //@line 6758
  STACKTOP = sp; //@line 6759
  return $$0 | 0; //@line 6759
 } else {
  _lua_settop($L, $1); //@line 6761
  $43 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 6764
  $45 = (_lua_tolstring($L, $1, 0) | 0) + 1 | 0; //@line 6766
  HEAP32[$vararg_buffer11 >> 2] = 432; //@line 6767
  HEAP32[$vararg_buffer11 + 4 >> 2] = $45; //@line 6769
  HEAP32[$vararg_buffer11 + 8 >> 2] = $43; //@line 6771
  _lua_pushfstring($L, 808, $vararg_buffer11) | 0; //@line 6772
  _lua_remove($L, $1); //@line 6773
  $$0 = 7; //@line 6774
  STACKTOP = sp; //@line 6775
  return $$0 | 0; //@line 6775
 }
 return 0; //@line 6777
}
function _sweeplist($L, $p, $count) {
 $L = $L | 0;
 $p = $p | 0;
 $count = $count | 0;
 var $$ = 0, $$0 = 0, $$01$be = 0, $$0111 = 0, $$018 = 0, $$0210 = 0, $$3 = 0, $$4 = 0, $0 = 0, $1 = 0, $10 = 0, $14 = 0, $15 = 0, $17 = 0, $39 = 0, $4 = 0, $5 = 0, $64 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 19378
 $0 = $L + 12 | 0; //@line 19379
 $1 = HEAP32[$0 >> 2] | 0; //@line 19380
 $4 = HEAPU8[$1 + 60 >> 0] | 0; //@line 19383
 $5 = $4 ^ 3; //@line 19384
 $8 = (HEAP8[$1 + 62 >> 0] | 0) == 2; //@line 19387
 $$ = $8 ? 255 : 184; //@line 19389
 $$3 = $8 ? 64 : $4 & 3; //@line 19390
 $$4 = $8 ? 64 : 0; //@line 19391
 $10 = HEAP32[$p >> 2] | 0; //@line 19392
 L1 : do if (!$10) {
  $$018 = $p; //@line 19396
  $64 = 0; //@line 19396
 } else {
  $$0111 = $p; //@line 19398
  $$0210 = $count; //@line 19398
  $15 = $10; //@line 19398
  L2 : while (1) {
   if (!$$0210) {
    $$018 = $$0111; //@line 19403
    $64 = $15; //@line 19403
    break L1;
   }
   $$0210 = $$0210 + -1 | 0; //@line 19400
   $14 = $15 + 5 | 0; //@line 19406
   $17 = HEAPU8[$14 >> 0] | 0; //@line 19408
   L5 : do if (!(($17 ^ 3) & $5)) {
    HEAP32[$$0111 >> 2] = HEAP32[$15 >> 2]; //@line 19415
    switch (HEAPU8[$15 + 4 >> 0] | 0) {
    case 38:
     {
      _luaM_realloc_($L, $15, (HEAPU8[$15 + 6 >> 0] << 4) + 16 | 0, 0) | 0; //@line 19426
      $$01$be = $$0111; //@line 19427
      break L5;
      break;
     }
    case 4:
     {
      $39 = (HEAP32[$0 >> 2] | 0) + 28 | 0; //@line 19433
      HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + -1; //@line 19436
      break;
     }
    case 6:
     {
      _luaM_realloc_($L, $15, (HEAPU8[$15 + 6 >> 0] << 2) + 16 | 0, 0) | 0; //@line 19445
      $$01$be = $$0111; //@line 19446
      break L5;
      break;
     }
    case 20:
     break;
    case 8:
     {
      _luaE_freethread($L, $15); //@line 19454
      $$01$be = $$0111; //@line 19455
      break L5;
      break;
     }
    case 9:
     {
      _luaF_freeproto($L, $15); //@line 19460
      $$01$be = $$0111; //@line 19461
      break L5;
      break;
     }
    case 7:
     {
      _luaM_realloc_($L, $15, (HEAP32[$15 + 16 >> 2] | 0) + 24 | 0, 0) | 0; //@line 19469
      $$01$be = $$0111; //@line 19470
      break L5;
      break;
     }
    case 10:
     {
      _luaF_freeupval($L, $15); //@line 19475
      $$01$be = $$0111; //@line 19476
      break L5;
      break;
     }
    case 5:
     {
      _luaH_free($L, $15); //@line 19481
      $$01$be = $$0111; //@line 19482
      break L5;
      break;
     }
    default:
     {
      $$01$be = $$0111; //@line 19487
      break L5;
     }
    }
    _luaM_realloc_($L, $15, (HEAP32[$15 + 12 >> 2] | 0) + 17 | 0, 0) | 0; //@line 19494
    $$01$be = $$0111; //@line 19495
   } else {
    if ($17 & $$4) {
     $$0 = 0; //@line 19500
     break L2;
    }
    if ((HEAP8[$15 + 4 >> 0] | 0) == 8) if (HEAP32[$15 + 28 >> 2] | 0) {
     _sweeplist($L, $15 + 56 | 0, -3) | 0; //@line 19512
     _luaE_freeCI($15); //@line 19513
     if ((HEAP8[(HEAP32[$0 >> 2] | 0) + 62 >> 0] | 0) != 1) _luaD_shrinkstack($15); //@line 19519
    }
    HEAP8[$14 >> 0] = $17 & $$ | $$3; //@line 19526
    $$01$be = $15; //@line 19527
   } while (0);
   $15 = HEAP32[$$01$be >> 2] | 0; //@line 19530
   if (!$15) {
    $$018 = $$01$be; //@line 19533
    $64 = 0; //@line 19533
    break L1;
   } else $$0111 = $$01$be; //@line 19536
  }
  STACKTOP = sp; //@line 19539
  return $$0 | 0; //@line 19539
 } while (0);
 $$0 = ($64 | 0) == 0 ? 0 : $$018; //@line 19544
 STACKTOP = sp; //@line 19545
 return $$0 | 0; //@line 19545
}
function _newupvalue($fs, $name, $v) {
 $fs = $fs | 0;
 $name = $name | 0;
 $v = $v | 0;
 var $0 = 0, $1 = 0, $11 = 0, $13 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $24 = 0, $28 = 0, $29 = 0, $3 = 0, $5 = 0, $64 = 0, $65 = 0, $66 = 0, $8 = 0, $oldsize$01 = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, sp = 0;
 sp = STACKTOP; //@line 8316
 STACKTOP = STACKTOP + 16 | 0; //@line 8317
 $vararg_buffer1 = sp; //@line 8318
 $0 = HEAP32[$fs >> 2] | 0; //@line 8319
 $1 = $0 + 40 | 0; //@line 8320
 $2 = HEAP32[$1 >> 2] | 0; //@line 8321
 $3 = $fs + 47 | 0; //@line 8322
 $5 = HEAPU8[$3 >> 0] | 0; //@line 8324
 if (($5 + 1 | 0) >>> 0 > 255) {
  $8 = $fs + 12 | 0; //@line 8328
  $11 = HEAP32[(HEAP32[$8 >> 2] | 0) + 52 >> 2] | 0; //@line 8331
  $13 = HEAP32[$0 + 64 >> 2] | 0; //@line 8333
  if (!$13) {
   $16 = 9408; //@line 8336
   HEAP32[$vararg_buffer1 >> 2] = 9736; //@line 8337
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 8338
   HEAP32[$vararg_ptr4 >> 2] = 255; //@line 8339
   $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 8340
   HEAP32[$vararg_ptr5 >> 2] = $16; //@line 8341
   $17 = _luaO_pushfstring($11, 9448, $vararg_buffer1) | 0; //@line 8342
   $18 = HEAP32[$8 >> 2] | 0; //@line 8343
   _luaX_syntaxerror($18, $17); //@line 8344
  }
  HEAP32[$vararg_buffer1 >> 2] = $13; //@line 8347
  $16 = _luaO_pushfstring($11, 9424, $vararg_buffer1) | 0; //@line 8349
  HEAP32[$vararg_buffer1 >> 2] = 9736; //@line 8350
  $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 8351
  HEAP32[$vararg_ptr4 >> 2] = 255; //@line 8352
  $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 8353
  HEAP32[$vararg_ptr5 >> 2] = $16; //@line 8354
  $17 = _luaO_pushfstring($11, 9448, $vararg_buffer1) | 0; //@line 8355
  $18 = HEAP32[$8 >> 2] | 0; //@line 8356
  _luaX_syntaxerror($18, $17); //@line 8357
 }
 if (($5 | 0) < ($2 | 0)) $28 = $2; //@line 8362
 else {
  $24 = $0 + 28 | 0; //@line 8368
  HEAP32[$24 >> 2] = _luaM_growaux_(HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0, HEAP32[$24 >> 2] | 0, $1, 8, 255, 9736) | 0; //@line 8371
  $28 = HEAP32[$1 >> 2] | 0; //@line 8373
 }
 $29 = $0 + 28 | 0; //@line 8376
 if (($2 | 0) < ($28 | 0)) {
  $oldsize$01 = $2; //@line 8378
  do {
   HEAP32[(HEAP32[$29 >> 2] | 0) + ($oldsize$01 << 3) >> 2] = 0; //@line 8383
   $oldsize$01 = $oldsize$01 + 1 | 0; //@line 8380
  } while (($oldsize$01 | 0) < ($28 | 0));
 }
 HEAP8[(HEAP32[$29 >> 2] | 0) + ((HEAPU8[$3 >> 0] | 0) << 3) + 4 >> 0] = (HEAP32[$v >> 2] | 0) == 7 & 1; //@line 8399
 HEAP8[(HEAP32[$29 >> 2] | 0) + ((HEAPU8[$3 >> 0] | 0) << 3) + 5 >> 0] = HEAP32[$v + 8 >> 2]; //@line 8407
 HEAP32[(HEAP32[$29 >> 2] | 0) + ((HEAPU8[$3 >> 0] | 0) << 3) >> 2] = $name; //@line 8412
 if (!(HEAP8[$name + 5 >> 0] & 3)) {
  $64 = HEAP8[$3 >> 0] | 0; //@line 8418
  $65 = $64 + 1 << 24 >> 24; //@line 8419
  HEAP8[$3 >> 0] = $65; //@line 8420
  $66 = $64 & 255; //@line 8421
  STACKTOP = sp; //@line 8422
  return $66 | 0; //@line 8422
 }
 if (!(HEAP8[$0 + 5 >> 0] & 4)) {
  $64 = HEAP8[$3 >> 0] | 0; //@line 8429
  $65 = $64 + 1 << 24 >> 24; //@line 8430
  HEAP8[$3 >> 0] = $65; //@line 8431
  $66 = $64 & 255; //@line 8432
  STACKTOP = sp; //@line 8433
  return $66 | 0; //@line 8433
 }
 _luaC_barrier_(HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0, $0, $name); //@line 8439
 $64 = HEAP8[$3 >> 0] | 0; //@line 8440
 $65 = $64 + 1 << 24 >> 24; //@line 8441
 HEAP8[$3 >> 0] = $65; //@line 8442
 $66 = $64 & 255; //@line 8443
 STACKTOP = sp; //@line 8444
 return $66 | 0; //@line 8444
}
function _luaK_patchlist($fs, $list, $target) {
 $fs = $fs | 0;
 $list = $list | 0;
 $target = $target | 0;
 var $$0$i$i = 0, $$0$i$i5 = 0, $$02$i = 0, $11 = 0, $14 = 0, $16 = 0, $26 = 0, $27 = 0, $29 = 0, $34 = 0, $35 = 0, $4 = 0, $41 = 0, $47 = 0, $57 = 0, $6 = 0, $8 = 0, $9 = 0, $fs$idx$val$idx$val$i$i = 0, $fs$idx$val$idx$val$i$pre = 0, $list$0$i$i = 0, $storemerge = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 8854
 if ((HEAP32[$fs + 20 >> 2] | 0) == ($target | 0)) {
  HEAP32[$fs + 24 >> 2] = $target; //@line 8860
  $4 = $fs + 28 | 0; //@line 8861
  if (($list | 0) == -1) {
   STACKTOP = sp; //@line 8864
   return;
  }
  $6 = HEAP32[$4 >> 2] | 0; //@line 8866
  if (($6 | 0) == -1) {
   HEAP32[$4 >> 2] = $list; //@line 8869
   STACKTOP = sp; //@line 8870
   return;
  }
  $fs$idx$val$idx$val$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 8874
  $list$0$i$i = $6; //@line 8875
  while (1) {
   $8 = $fs$idx$val$idx$val$i$i + ($list$0$i$i << 2) | 0; //@line 8877
   $9 = HEAP32[$8 >> 2] | 0; //@line 8878
   $11 = ($9 >>> 14) + -131071 | 0; //@line 8880
   if (($11 | 0) == -1) break;
   $14 = $list$0$i$i + 1 + $11 | 0; //@line 8886
   if (($14 | 0) == -1) break; else $list$0$i$i = $14; //@line 8891
  }
  $16 = ~$list$0$i$i + $list | 0; //@line 8895
  if (((($16 | 0) > -1 ? $16 : 0 - $16 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 8903
  HEAP32[$8 >> 2] = ($16 << 14) + 2147467264 | $9 & 16383; //@line 8910
  STACKTOP = sp; //@line 8911
  return;
 }
 if (($list | 0) == -1) {
  STACKTOP = sp; //@line 8915
  return;
 }
 $fs$idx$val$idx$val$i$pre = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 8919
 $$02$i = $list; //@line 8920
 while (1) {
  $26 = $fs$idx$val$idx$val$i$pre + ($$02$i << 2) | 0; //@line 8922
  $27 = HEAP32[$26 >> 2] | 0; //@line 8923
  $29 = ($27 >>> 14) + -131071 | 0; //@line 8925
  if (($29 | 0) == -1) $$0$i$i = -1; //@line 8928
 else $$0$i$i = $$02$i + 1 + $29 | 0; //@line 8932
  if (($$02$i | 0) > 0) {
   $34 = $fs$idx$val$idx$val$i$pre + ($$02$i + -1 << 2) | 0; //@line 8937
   $35 = HEAP32[$34 >> 2] | 0; //@line 8938
   if ((HEAP8[8440 + ($35 & 63) >> 0] | 0) < 0) {
    $$0$i$i5 = $34; //@line 8944
    $41 = $35; //@line 8944
   } else label = 17; //@line 8946
  } else label = 17; //@line 8949
  if ((label | 0) == 17) {
   label = 0; //@line 8952
   $$0$i$i5 = $26; //@line 8953
   $41 = $27; //@line 8953
  }
  if (($41 & 63 | 0) == 28) {
   HEAP32[$$0$i$i5 >> 2] = $41 & 8372224 | $41 >>> 23 << 6 | 27; //@line 8963
   $47 = ~$$02$i + $target | 0; //@line 8965
   if (((($47 | 0) > -1 ? $47 : 0 - $47 | 0) | 0) > 131071) {
    label = 20; //@line 8971
    break;
   }
   $storemerge = HEAP32[$26 >> 2] & 16383 | ($47 << 14) + 2147467264; //@line 8979
  } else {
   $57 = ~$$02$i + $target | 0; //@line 8982
   if (((($57 | 0) > -1 ? $57 : 0 - $57 | 0) | 0) > 131071) {
    label = 23; //@line 8988
    break;
   }
   $storemerge = $27 & 16383 | ($57 << 14) + 2147467264; //@line 8995
  }
  HEAP32[$26 >> 2] = $storemerge; //@line 8997
  if (($$0$i$i | 0) == -1) {
   label = 26; //@line 9000
   break;
  } else $$02$i = $$0$i$i; //@line 9003
 }
 if ((label | 0) == 20) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9009
 else if ((label | 0) == 23) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9015
 else if ((label | 0) == 26) {
  STACKTOP = sp; //@line 9019
  return;
 }
}
function _luaS_newlstr($L, $str, $l) {
 $L = $L | 0;
 $str = $str | 0;
 $l = $l | 0;
 var $$0 = 0, $17 = 0, $2 = 0, $20 = 0, $21 = 0, $24 = 0, $25 = 0, $37 = 0, $40 = 0, $49 = 0, $5 = 0, $55 = 0, $58 = 0, $60 = 0, $64 = 0, $7 = 0, $73 = 0, $75 = 0, $79 = 0, $h$0$lcssa$i$i = 0, $h$02$i$i = 0, $l1$01$i$i = 0, $o$0$i = 0, $o$02$i = 0, $o$03$i = 0, sp = 0;
 sp = STACKTOP; //@line 13337
 if ($l >>> 0 >= 41) {
  if (($l + 1 | 0) >>> 0 > 4294967277) _luaM_toobig($L); //@line 13343
  $73 = HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 56 >> 2] | 0; //@line 13349
  $75 = _luaC_newobj($L, 20, $l + 17 | 0, 0, 0) | 0; //@line 13351
  HEAP32[$75 + 12 >> 2] = $l; //@line 13354
  HEAP32[$75 + 8 >> 2] = $73; //@line 13357
  HEAP8[$75 + 6 >> 0] = 0; //@line 13359
  $79 = $75 + 16 | 0; //@line 13360
  _memcpy($79 | 0, $str | 0, $l | 0) | 0; //@line 13361
  HEAP8[$79 + $l >> 0] = 0; //@line 13363
  $$0 = $75; //@line 13364
  STACKTOP = sp; //@line 13365
  return $$0 | 0; //@line 13365
 }
 $2 = HEAP32[$L + 12 >> 2] | 0; //@line 13368
 $5 = HEAP32[$2 + 56 >> 2] ^ $l; //@line 13371
 $7 = ($l >>> 5) + 1 | 0; //@line 13373
 if ($7 >>> 0 > $l >>> 0) $h$0$lcssa$i$i = $5; //@line 13376
 else {
  $h$02$i$i = $5; //@line 13378
  $l1$01$i$i = $l; //@line 13378
  while (1) {
   $17 = ($h$02$i$i << 5) + ($h$02$i$i >>> 2) + (HEAPU8[$str + ($l1$01$i$i + -1) >> 0] | 0) ^ $h$02$i$i; //@line 13388
   $l1$01$i$i = $l1$01$i$i - $7 | 0; //@line 13389
   if ($l1$01$i$i >>> 0 < $7 >>> 0) {
    $h$0$lcssa$i$i = $17; //@line 13392
    break;
   } else $h$02$i$i = $17; //@line 13395
  }
 }
 $20 = $2 + 32 | 0; //@line 13399
 $21 = HEAP32[$20 >> 2] | 0; //@line 13400
 $24 = $2 + 24 | 0; //@line 13403
 $25 = HEAP32[$24 >> 2] | 0; //@line 13404
 $o$02$i = HEAP32[$25 + (($21 + -1 & $h$0$lcssa$i$i) << 2) >> 2] | 0; //@line 13406
 L12 : do if ($o$02$i) {
  $o$03$i = $o$02$i; //@line 13410
  while (1) {
   if (($h$0$lcssa$i$i | 0) == (HEAP32[$o$03$i + 8 >> 2] | 0)) if ((HEAP32[$o$03$i + 12 >> 2] | 0) == ($l | 0)) if (!(_memcmp($str, $o$03$i + 16 | 0, $l) | 0)) break;
   $o$0$i = HEAP32[$o$03$i >> 2] | 0; //@line 13428
   if (!$o$0$i) break L12; else $o$03$i = $o$0$i; //@line 13433
  }
  $37 = $o$03$i + 5 | 0; //@line 13436
  $40 = (HEAPU8[$37 >> 0] | 0) ^ 3; //@line 13439
  if (((HEAPU8[$2 + 60 >> 0] | 0) ^ 3) & $40) {
   $$0 = $o$03$i; //@line 13447
   STACKTOP = sp; //@line 13448
   return $$0 | 0; //@line 13448
  }
  HEAP8[$37 >> 0] = $40; //@line 13451
  $$0 = $o$03$i; //@line 13452
  STACKTOP = sp; //@line 13453
  return $$0 | 0; //@line 13453
 } while (0);
 $49 = $2 + 28 | 0; //@line 13456
 if (($21 | 0) < 1073741823 ? (HEAP32[$49 >> 2] | 0) >>> 0 >= $21 >>> 0 : 0) {
  _luaS_resize($L, $21 << 1); //@line 13463
  $55 = HEAP32[$20 >> 2] | 0; //@line 13466
  $58 = HEAP32[$24 >> 2] | 0; //@line 13466
 } else {
  $55 = $21; //@line 13468
  $58 = $25; //@line 13468
 }
 $60 = _luaC_newobj($L, 4, $l + 17 | 0, $58 + (($55 + -1 & $h$0$lcssa$i$i) << 2) | 0, 0) | 0; //@line 13474
 HEAP32[$60 + 12 >> 2] = $l; //@line 13477
 HEAP32[$60 + 8 >> 2] = $h$0$lcssa$i$i; //@line 13480
 HEAP8[$60 + 6 >> 0] = 0; //@line 13482
 $64 = $60 + 16 | 0; //@line 13483
 _memcpy($64 | 0, $str | 0, $l | 0) | 0; //@line 13484
 HEAP8[$64 + $l >> 0] = 0; //@line 13486
 HEAP32[$49 >> 2] = (HEAP32[$49 >> 2] | 0) + 1; //@line 13489
 $$0 = $60; //@line 13490
 STACKTOP = sp; //@line 13491
 return $$0 | 0; //@line 13491
}
function _luaC_forcestep($L) {
 $L = $L | 0;
 var $$$i = 0, $$pre$phiZ2D = 0, $1 = 0, $11 = 0, $13 = 0, $19 = 0, $21 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $33 = 0, $38 = 0, $39 = 0, $42 = 0, $45 = 0, $49 = 0, $5 = 0, $54 = 0, $57 = 0, $59 = 0, $6 = 0, $67 = 0, $71 = 0, $9 = 0, $debt$0$i = 0, $debt$0$ph$i = 0, $i$03 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 7
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 9
 do if ((HEAP8[$1 + 62 >> 0] | 0) == 2) {
  $5 = $1 + 20 | 0; //@line 15
  $6 = HEAP32[$5 >> 2] | 0; //@line 16
  do if (!$6) {
   _luaC_fullgc($L, 0); //@line 20
   $9 = HEAP32[$1 + 8 >> 2] | 0; //@line 22
   $11 = HEAP32[$1 + 12 >> 2] | 0; //@line 24
   HEAP32[$5 >> 2] = $11 + $9; //@line 26
   $29 = $9; //@line 27
   $30 = $11; //@line 27
  } else {
   $13 = $1 + 61 | 0; //@line 29
   if ((HEAP8[$13 >> 0] | 0) != 5) do _singlestep($L) | 0; //@line 34
 while ((HEAP8[$13 >> 0] | 0) != 5);
   HEAP8[$13 >> 0] = 0; //@line 42
   $19 = HEAP32[$1 + 8 >> 2] | 0; //@line 44
   $21 = HEAP32[$1 + 12 >> 2] | 0; //@line 46
   if (($21 + $19 | 0) >>> 0 > (Math_imul(HEAP32[$1 + 160 >> 2] | 0, ($6 >>> 0) / 100 | 0) | 0) >>> 0) {
    HEAP32[$5 >> 2] = 0; //@line 54
    $29 = $19; //@line 55
    $30 = $21; //@line 55
    break;
   } else {
    HEAP32[$5 >> 2] = $6; //@line 58
    $29 = $19; //@line 59
    $30 = $21; //@line 59
    break;
   }
  } while (0);
  $28 = $29 + $30 | 0; //@line 64
  $31 = ($28 | 0) / 100 | 0; //@line 65
  $33 = HEAP32[$1 + 156 >> 2] | 0; //@line 67
  if (($33 | 0) < (2147483644 / ($31 | 0) | 0 | 0)) $38 = Math_imul($33, $31) | 0; //@line 72
 else $38 = 2147483644; //@line 74
  _luaE_setdebt($1, $28 - $38 | 0); //@line 77
  $$pre$phiZ2D = $1 + 61 | 0; //@line 79
 } else {
  $39 = $1 + 12 | 0; //@line 81
  $42 = HEAP32[$1 + 164 >> 2] | 0; //@line 84
  $$$i = ($42 | 0) < 40 ? 40 : $42; //@line 86
  $45 = ((HEAP32[$39 >> 2] | 0) / 200 | 0) + 1 | 0; //@line 88
  if (($45 | 0) < (2147483644 / ($$$i | 0) | 0 | 0)) $debt$0$ph$i = Math_imul($45, $$$i) | 0; //@line 93
 else $debt$0$ph$i = 2147483644; //@line 95
  $49 = $1 + 61 | 0; //@line 97
  $debt$0$i = $debt$0$ph$i; //@line 98
  do {
   $debt$0$i = $debt$0$i - (_singlestep($L) | 0) | 0; //@line 101
   $54 = (HEAP8[$49 >> 0] | 0) == 5; //@line 104
   if (($debt$0$i | 0) <= -1600) {
    label = 17; //@line 106
    break;
   }
  } while (!$54);
  if ((label | 0) == 17) if (!$54) {
   _luaE_setdebt($1, (($debt$0$i | 0) / ($$$i | 0) | 0) * 200 | 0); //@line 119
   $$pre$phiZ2D = $49; //@line 120
   break;
  }
  $57 = (HEAP32[$1 + 20 >> 2] | 0) / 100 | 0; //@line 126
  $59 = HEAP32[$1 + 156 >> 2] | 0; //@line 128
  if (($59 | 0) < (2147483644 / ($57 | 0) | 0 | 0)) $67 = Math_imul($59, $57) | 0; //@line 133
 else $67 = 2147483644; //@line 135
  _luaE_setdebt($1, (HEAP32[$1 + 8 >> 2] | 0) - $67 + (HEAP32[$39 >> 2] | 0) | 0); //@line 142
  $$pre$phiZ2D = $49; //@line 143
 } while (0);
 $71 = $1 + 104 | 0; //@line 146
 if (!(HEAP32[$71 >> 2] | 0)) {
  STACKTOP = sp; //@line 150
  return;
 } else $i$03 = 0; //@line 152
 while (1) {
  if (($i$03 | 0) >= 4) if ((HEAP8[$$pre$phiZ2D >> 0] | 0) != 5) {
   label = 26; //@line 160
   break;
  }
  _GCTM($L, 1); //@line 164
  if (!(HEAP32[$71 >> 2] | 0)) {
   label = 26; //@line 169
   break;
  } else $i$03 = $i$03 + 1 | 0; //@line 172
 }
 if ((label | 0) == 26) {
  STACKTOP = sp; //@line 176
  return;
 }
}
function _lua_newstate($f, $ud) {
 $f = $f | 0;
 $ud = $ud | 0;
 var $$0 = 0, $0 = 0, $2 = 0, $24 = 0, $32 = 0, $36 = 0, $42 = 0, $44 = 0, $buff$i = 0, $h$i = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP; //@line 12818
 STACKTOP = STACKTOP + 32 | 0; //@line 12819
 $buff$i = sp + 8 | 0; //@line 12820
 $h$i = sp; //@line 12821
 $0 = FUNCTION_TABLE_iiiii[$f & 31]($ud, 0, 8, 400) | 0; //@line 12822
 if (!$0) {
  $$0 = 0; //@line 12825
  STACKTOP = sp; //@line 12826
  return $$0 | 0; //@line 12826
 }
 $2 = $0 + 112 | 0; //@line 12828
 HEAP32[$0 >> 2] = 0; //@line 12829
 HEAP8[$0 + 4 >> 0] = 8; //@line 12831
 HEAP8[$0 + 172 >> 0] = 33; //@line 12833
 HEAP8[$0 + 5 >> 0] = 1; //@line 12835
 HEAP8[$0 + 174 >> 0] = 0; //@line 12837
 HEAP32[$0 + 12 >> 2] = $2; //@line 12839
 HEAP32[$0 + 28 >> 2] = 0; //@line 12841
 HEAP32[$0 + 16 >> 2] = 0; //@line 12843
 HEAP32[$0 + 32 >> 2] = 0; //@line 12845
 HEAP32[$0 + 64 >> 2] = 0; //@line 12847
 HEAP16[$0 + 38 >> 1] = 0; //@line 12849
 HEAP32[$0 + 52 >> 2] = 0; //@line 12851
 HEAP8[$0 + 40 >> 0] = 0; //@line 12853
 HEAP32[$0 + 44 >> 2] = 0; //@line 12855
 HEAP8[$0 + 41 >> 0] = 1; //@line 12857
 HEAP32[$0 + 48 >> 2] = 0; //@line 12859
 HEAP32[$0 + 56 >> 2] = 0; //@line 12861
 HEAP16[$0 + 36 >> 1] = 1; //@line 12863
 HEAP8[$0 + 6 >> 0] = 0; //@line 12865
 HEAP32[$0 + 68 >> 2] = 0; //@line 12867
 HEAP32[$2 >> 2] = $f; //@line 12868
 HEAP32[$0 + 116 >> 2] = $ud; //@line 12870
 HEAP32[$0 + 284 >> 2] = $0; //@line 12872
 $24 = _time(0) | 0; //@line 12873
 HEAP32[$h$i >> 2] = $24; //@line 12874
 HEAP32[$buff$i >> 2] = $0; //@line 12876
 HEAP32[$buff$i + 4 >> 2] = $h$i; //@line 12879
 HEAP32[$buff$i + 8 >> 2] = 8048; //@line 12881
 HEAP32[$buff$i + 12 >> 2] = 18; //@line 12883
 HEAP32[$0 + 168 >> 2] = _luaS_hash($buff$i, 16, $24) | 0; //@line 12886
 $32 = $0 + 224 | 0; //@line 12887
 HEAP32[$0 + 240 >> 2] = $32; //@line 12889
 HEAP32[$0 + 244 >> 2] = $32; //@line 12891
 HEAP8[$0 + 175 >> 0] = 0; //@line 12893
 $36 = $0 + 132 | 0; //@line 12894
 HEAP32[$0 + 160 >> 2] = 0; //@line 12896
 HEAP32[$0 + 256 >> 2] = 0; //@line 12898
 HEAP32[$0 + 264 >> 2] = 0; //@line 12900
 HEAP32[$0 + 280 >> 2] = 0; //@line 12902
 HEAP32[$0 + 288 >> 2] = 0; //@line 12904
 $42 = $0 + 173 | 0; //@line 12905
 HEAP32[$36 + 0 >> 2] = 0; //@line 12906
 HEAP32[$36 + 4 >> 2] = 0; //@line 12906
 HEAP32[$36 + 8 >> 2] = 0; //@line 12906
 HEAP32[$36 + 12 >> 2] = 0; //@line 12906
 HEAP8[$42 >> 0] = 5; //@line 12907
 $44 = $0 + 120 | 0; //@line 12909
 dest = $0 + 180 | 0; //@line 12910
 stop = dest + 40 | 0; //@line 12910
 do {
  HEAP32[dest >> 2] = 0; //@line 12910
  dest = dest + 4 | 0; //@line 12910
 } while ((dest | 0) < (stop | 0));
 HEAP32[$44 >> 2] = 400; //@line 12911
 HEAP32[$0 + 124 >> 2] = 0; //@line 12913
 HEAP32[$0 + 268 >> 2] = 200; //@line 12915
 HEAP32[$0 + 272 >> 2] = 200; //@line 12917
 HEAP32[$0 + 276 >> 2] = 200; //@line 12919
 dest = $0 + 364 | 0; //@line 12921
 stop = dest + 36 | 0; //@line 12921
 do {
  HEAP32[dest >> 2] = 0; //@line 12921
  dest = dest + 4 | 0; //@line 12921
 } while ((dest | 0) < (stop | 0));
 if (!(_luaD_rawrunprotected($0, 25, 0) | 0)) {
  $$0 = $0; //@line 12925
  STACKTOP = sp; //@line 12926
  return $$0 | 0; //@line 12926
 }
 _close_state($0); //@line 12928
 $$0 = 0; //@line 12929
 STACKTOP = sp; //@line 12930
 return $$0 | 0; //@line 12930
}
function _luaH_get($t, $key) {
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $0 = 0, $2 = 0, $22 = 0, $24 = 0.0, $26 = 0, $27 = 0.0, $29 = 0, $3 = 0, $40 = 0, $42 = 0, $62 = 0, $73 = 0, $i$1$i$i = 0, $n$0$i = 0, $n$0$i1 = 0, $n1$0 = 0, $u$sroa$0 = 0, $u$sroa$0$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 17551
 STACKTOP = STACKTOP + 16 | 0; //@line 17552
 $u$sroa$0$i$i = sp + 8 | 0; //@line 17553
 $u$sroa$0 = sp; //@line 17554
 $0 = $key + 8 | 0; //@line 17555
 $2 = HEAP32[$0 >> 2] & 63; //@line 17557
 if (!$2) {
  $$0 = 8048; //@line 17559
  STACKTOP = sp; //@line 17560
  return $$0 | 0; //@line 17560
 } else if (($2 | 0) == 4) {
  $3 = HEAP32[$key >> 2] | 0; //@line 17562
  $n$0$i = (HEAP32[$t + 16 >> 2] | 0) + (((1 << (HEAPU8[$t + 7 >> 0] | 0)) + -1 & HEAP32[$3 + 8 >> 2]) << 5) | 0; //@line 17574
  while (1) {
   if ((HEAP32[$n$0$i + 24 >> 2] | 0) == 68) if ((HEAP32[$n$0$i + 16 >> 2] | 0) == ($3 | 0)) break;
   $22 = HEAP32[$n$0$i + 28 >> 2] | 0; //@line 17588
   if (!$22) {
    $$0 = 8048; //@line 17591
    label = 22; //@line 17592
    break;
   } else $n$0$i = $22; //@line 17595
  }
  if ((label | 0) == 22) {
   STACKTOP = sp; //@line 17599
   return $$0 | 0; //@line 17599
  }
  $$0 = $n$0$i; //@line 17601
  STACKTOP = sp; //@line 17602
  return $$0 | 0; //@line 17602
 } else if (($2 | 0) == 3) {
  $24 = +HEAPF64[$key >> 3]; //@line 17604
  HEAPF64[$u$sroa$0 >> 3] = $24 + 6755399441055744.0; //@line 17606
  $26 = HEAP32[$u$sroa$0 >> 2] | 0; //@line 17607
  $27 = +($26 | 0); //@line 17608
  if ($27 == $24) {
   $29 = $26 + -1 | 0; //@line 17611
   if ($29 >>> 0 < (HEAP32[$t + 28 >> 2] | 0) >>> 0) {
    $$0 = (HEAP32[$t + 12 >> 2] | 0) + ($29 << 4) | 0; //@line 17619
    STACKTOP = sp; //@line 17620
    return $$0 | 0; //@line 17620
   }
   HEAPF64[$u$sroa$0$i$i >> 3] = $27 + 1.0; //@line 17623
   $40 = (HEAP32[$u$sroa$0$i$i + 4 >> 2] | 0) + (HEAP32[$u$sroa$0$i$i >> 2] | 0) | 0; //@line 17627
   if (($40 | 0) < 0) {
    $42 = 0 - $40 | 0; //@line 17630
    $i$1$i$i = ($40 | 0) == ($42 | 0) ? 0 : $42; //@line 17633
   } else $i$1$i$i = $40; //@line 17635
   $n$0$i1 = (HEAP32[$t + 16 >> 2] | 0) + ((($i$1$i$i | 0) % ((1 << (HEAPU8[$t + 7 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17647
   while (1) {
    if ((HEAP32[$n$0$i1 + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0$i1 + 16 >> 3] == $27) break;
    $62 = HEAP32[$n$0$i1 + 28 >> 2] | 0; //@line 17661
    if (!$62) {
     $$0 = 8048; //@line 17664
     label = 22; //@line 17665
     break;
    } else $n$0$i1 = $62; //@line 17668
   }
   if ((label | 0) == 22) {
    STACKTOP = sp; //@line 17672
    return $$0 | 0; //@line 17672
   }
   $$0 = $n$0$i1; //@line 17674
   STACKTOP = sp; //@line 17675
   return $$0 | 0; //@line 17675
  }
 }
 $n1$0 = _mainposition($t, $key) | 0; //@line 17679
 while (1) {
  if ((HEAP32[$n1$0 + 24 >> 2] | 0) == (HEAP32[$0 >> 2] | 0)) if (_luaV_equalobj_(0, $n1$0 + 16 | 0, $key) | 0) break;
  $73 = HEAP32[$n1$0 + 28 >> 2] | 0; //@line 17694
  if (!$73) {
   $$0 = 8048; //@line 17697
   label = 22; //@line 17698
   break;
  } else $n1$0 = $73; //@line 17701
 }
 if ((label | 0) == 22) {
  STACKTOP = sp; //@line 17705
  return $$0 | 0; //@line 17705
 }
 $$0 = $n1$0; //@line 17707
 STACKTOP = sp; //@line 17708
 return $$0 | 0; //@line 17708
}
function _suffixedexp($ls, $v) {
 $ls = $ls | 0;
 $v = $v | 0;
 var $$pre$phi2Z2D = 0, $0 = 0, $1 = 0, $12 = 0, $13 = 0, $14 = 0, $17 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0, $key = 0, $key$i$i = 0, $key1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 10353
 STACKTOP = STACKTOP + 80 | 0; //@line 10354
 $key$i$i = sp + 48 | 0; //@line 10355
 $key = sp + 24 | 0; //@line 10356
 $key1 = sp; //@line 10357
 $0 = $ls + 48 | 0; //@line 10358
 $1 = HEAP32[$0 >> 2] | 0; //@line 10359
 $3 = HEAP32[$ls + 4 >> 2] | 0; //@line 10361
 $4 = $ls + 16 | 0; //@line 10362
 $5 = HEAP32[$4 >> 2] | 0; //@line 10363
 if (($5 | 0) == 288) {
  $7 = $ls + 24 | 0; //@line 10365
  $8 = HEAP32[$7 >> 2] | 0; //@line 10366
  _luaX_next($ls); //@line 10367
  $9 = HEAP32[$0 >> 2] | 0; //@line 10368
  if (!(_singlevaraux($9, $8, $v, 1) | 0)) {
   _singlevaraux($9, HEAP32[$ls + 72 >> 2] | 0, $v, 1) | 0; //@line 10374
   $17 = _luaK_stringK(HEAP32[$0 >> 2] | 0, $8) | 0; //@line 10376
   HEAP32[$key$i$i + 16 >> 2] = -1; //@line 10378
   HEAP32[$key$i$i + 20 >> 2] = -1; //@line 10380
   HEAP32[$key$i$i >> 2] = 4; //@line 10381
   HEAP32[$key$i$i + 8 >> 2] = $17; //@line 10383
   _luaK_indexed($9, $v, $key$i$i); //@line 10384
   $$pre$phi2Z2D = $7; //@line 10385
  } else $$pre$phi2Z2D = $7; //@line 10387
 } else if (($5 | 0) == 40) {
  _luaX_next($ls); //@line 10390
  _subexpr($ls, $v, 0) | 0; //@line 10391
  _check_match($ls, 41, 40, $3); //@line 10392
  _luaK_dischargevars(HEAP32[$0 >> 2] | 0, $v); //@line 10394
  $$pre$phi2Z2D = $ls + 24 | 0; //@line 10396
 } else _luaX_syntaxerror($ls, 9512); //@line 10398
 $12 = $key1 + 16 | 0; //@line 10401
 $13 = $key1 + 20 | 0; //@line 10402
 $14 = $key1 + 8 | 0; //@line 10403
 L7 : while (1) switch (HEAP32[$4 >> 2] | 0) {
 case 46:
  {
   _fieldsel($ls, $v); //@line 10408
   continue L7;
   break;
  }
 case 123:
 case 289:
 case 40:
  {
   _luaK_exp2nextreg($1, $v); //@line 10413
   _funcargs($ls, $v, $3); //@line 10414
   continue L7;
   break;
  }
 case 91:
  {
   _luaK_exp2anyregup($1, $v); //@line 10419
   _luaX_next($ls); //@line 10420
   _subexpr($ls, $key, 0) | 0; //@line 10421
   _luaK_exp2val(HEAP32[$0 >> 2] | 0, $key); //@line 10423
   if ((HEAP32[$4 >> 2] | 0) != 93) {
    label = 10; //@line 10427
    break L7;
   }
   _luaX_next($ls); //@line 10430
   _luaK_indexed($1, $v, $key); //@line 10431
   continue L7;
   break;
  }
 case 58:
  {
   _luaX_next($ls); //@line 10436
   if ((HEAP32[$4 >> 2] | 0) != 288) {
    label = 13; //@line 10440
    break L7;
   }
   $27 = HEAP32[$$pre$phi2Z2D >> 2] | 0; //@line 10443
   _luaX_next($ls); //@line 10444
   $28 = _luaK_stringK(HEAP32[$0 >> 2] | 0, $27) | 0; //@line 10446
   HEAP32[$12 >> 2] = -1; //@line 10447
   HEAP32[$13 >> 2] = -1; //@line 10448
   HEAP32[$key1 >> 2] = 4; //@line 10449
   HEAP32[$14 >> 2] = $28; //@line 10450
   _luaK_self($1, $v, $key1); //@line 10451
   _funcargs($ls, $v, $3); //@line 10452
   continue L7;
   break;
  }
 default:
  {
   label = 16; //@line 10457
   break L7;
  }
 }
 if ((label | 0) == 10) _error_expected($ls, 93); //@line 10463
 else if ((label | 0) == 13) _error_expected($ls, 288); //@line 10467
 else if ((label | 0) == 16) {
  STACKTOP = sp; //@line 10471
  return;
 }
}
function _recfield($ls, $cc) {
 $ls = $ls | 0;
 $cc = $cc | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $16 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $23 = 0, $24 = 0, $3 = 0, $35 = 0, $39 = 0, $4 = 0, $7 = 0, $key = 0, $val = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, $vararg_ptr5 = 0, sp = 0;
 sp = STACKTOP; //@line 11797
 STACKTOP = STACKTOP + 64 | 0; //@line 11798
 $vararg_buffer1 = sp + 48 | 0; //@line 11799
 $key = sp + 24 | 0; //@line 11800
 $val = sp; //@line 11801
 $0 = $ls + 48 | 0; //@line 11802
 $1 = HEAP32[$0 >> 2] | 0; //@line 11803
 $2 = $1 + 48 | 0; //@line 11804
 $3 = HEAP8[$2 >> 0] | 0; //@line 11805
 $4 = $ls + 16 | 0; //@line 11806
 do if ((HEAP32[$4 >> 2] | 0) == 288) {
  $7 = $cc + 28 | 0; //@line 11811
  if ((HEAP32[$7 >> 2] | 0) <= 2147483645) {
   $23 = HEAP32[$ls + 24 >> 2] | 0; //@line 11816
   _luaX_next($ls); //@line 11817
   $24 = _luaK_stringK(HEAP32[$0 >> 2] | 0, $23) | 0; //@line 11819
   HEAP32[$key + 16 >> 2] = -1; //@line 11821
   HEAP32[$key + 20 >> 2] = -1; //@line 11823
   HEAP32[$key >> 2] = 4; //@line 11824
   HEAP32[$key + 8 >> 2] = $24; //@line 11826
   $$pre$phiZ2D = $7; //@line 11827
   break;
  }
  $10 = $1 + 12 | 0; //@line 11830
  $13 = HEAP32[(HEAP32[$10 >> 2] | 0) + 52 >> 2] | 0; //@line 11833
  $16 = HEAP32[(HEAP32[$1 >> 2] | 0) + 64 >> 2] | 0; //@line 11836
  if (!$16) {
   $19 = 9408; //@line 11839
   HEAP32[$vararg_buffer1 >> 2] = 9384; //@line 11840
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 11841
   HEAP32[$vararg_ptr4 >> 2] = 2147483645; //@line 11842
   $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 11843
   HEAP32[$vararg_ptr5 >> 2] = $19; //@line 11844
   $20 = _luaO_pushfstring($13, 9448, $vararg_buffer1) | 0; //@line 11845
   $21 = HEAP32[$10 >> 2] | 0; //@line 11846
   _luaX_syntaxerror($21, $20); //@line 11847
  }
  HEAP32[$vararg_buffer1 >> 2] = $16; //@line 11850
  $19 = _luaO_pushfstring($13, 9424, $vararg_buffer1) | 0; //@line 11852
  HEAP32[$vararg_buffer1 >> 2] = 9384; //@line 11853
  $vararg_ptr4 = $vararg_buffer1 + 4 | 0; //@line 11854
  HEAP32[$vararg_ptr4 >> 2] = 2147483645; //@line 11855
  $vararg_ptr5 = $vararg_buffer1 + 8 | 0; //@line 11856
  HEAP32[$vararg_ptr5 >> 2] = $19; //@line 11857
  $20 = _luaO_pushfstring($13, 9448, $vararg_buffer1) | 0; //@line 11858
  $21 = HEAP32[$10 >> 2] | 0; //@line 11859
  _luaX_syntaxerror($21, $20); //@line 11860
 } else {
  _luaX_next($ls); //@line 11863
  _subexpr($ls, $key, 0) | 0; //@line 11864
  _luaK_exp2val(HEAP32[$0 >> 2] | 0, $key); //@line 11866
  if ((HEAP32[$4 >> 2] | 0) == 93) {
   _luaX_next($ls); //@line 11870
   $$pre$phiZ2D = $cc + 28 | 0; //@line 11872
   break;
  } else _error_expected($ls, 93); //@line 11875
 } while (0);
 HEAP32[$$pre$phiZ2D >> 2] = (HEAP32[$$pre$phiZ2D >> 2] | 0) + 1; //@line 11882
 if ((HEAP32[$4 >> 2] | 0) == 61) {
  _luaX_next($ls); //@line 11886
  $35 = _luaK_exp2RK($1, $key) | 0; //@line 11887
  _subexpr($ls, $val, 0) | 0; //@line 11888
  $39 = HEAP32[(HEAP32[$cc + 24 >> 2] | 0) + 8 >> 2] | 0; //@line 11892
  _luaK_codeABC($1, 10, $39, $35, _luaK_exp2RK($1, $val) | 0) | 0; //@line 11894
  HEAP8[$2 >> 0] = $3; //@line 11895
  STACKTOP = sp; //@line 11896
  return;
 } else _error_expected($ls, 61); //@line 11898
}
function _memchr($src, $c, $n) {
 $src = $src | 0;
 $c = $c | 0;
 $n = $n | 0;
 var $$0$lcssa = 0, $$0$lcssa34 = 0, $$013 = 0, $$1$lcssa = 0, $$17 = 0, $$24 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $13 = 0, $15 = 0, $17 = 0, $20 = 0, $26 = 0, $27 = 0, $32 = 0, $4 = 0, $5 = 0, $8 = 0, $9 = 0, $s$0$lcssa = 0, $s$0$lcssa33 = 0, $s$014 = 0, $s$15 = 0, $s$2 = 0, $w$0$lcssa = 0, $w$08 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16735
 $0 = $c & 255; //@line 16736
 $4 = ($n | 0) == 0; //@line 16740
 L1 : do if (($src & 3 | 0) == 0 | $4) {
  $$0$lcssa = $n; //@line 16744
  $$lcssa = $4; //@line 16744
  $s$0$lcssa = $src; //@line 16744
  label = 5; //@line 16745
 } else {
  $5 = $c & 255; //@line 16747
  $$013 = $n; //@line 16748
  $s$014 = $src; //@line 16748
  while (1) {
   if ((HEAP8[$s$014 >> 0] | 0) == $5 << 24 >> 24) {
    $$0$lcssa34 = $$013; //@line 16753
    $s$0$lcssa33 = $s$014; //@line 16753
    label = 6; //@line 16754
    break L1;
   }
   $8 = $s$014 + 1 | 0; //@line 16757
   $9 = $$013 + -1 | 0; //@line 16758
   $13 = ($9 | 0) == 0; //@line 16762
   if (($8 & 3 | 0) == 0 | $13) {
    $$0$lcssa = $9; //@line 16765
    $$lcssa = $13; //@line 16765
    $s$0$lcssa = $8; //@line 16765
    label = 5; //@line 16766
    break;
   } else {
    $$013 = $9; //@line 16769
    $s$014 = $8; //@line 16769
   }
  }
 } while (0);
 if ((label | 0) == 5) if ($$lcssa) {
  $$3 = 0; //@line 16776
  $s$2 = $s$0$lcssa; //@line 16776
 } else {
  $$0$lcssa34 = $$0$lcssa; //@line 16778
  $s$0$lcssa33 = $s$0$lcssa; //@line 16778
  label = 6; //@line 16779
 }
 L8 : do if ((label | 0) == 6) {
  $15 = $c & 255; //@line 16785
  if ((HEAP8[$s$0$lcssa33 >> 0] | 0) == $15 << 24 >> 24) {
   $$3 = $$0$lcssa34; //@line 16788
   $s$2 = $s$0$lcssa33; //@line 16788
  } else {
   $17 = Math_imul($0, 16843009) | 0; //@line 16790
   L11 : do if ($$0$lcssa34 >>> 0 > 3) {
    $$17 = $$0$lcssa34; //@line 16794
    $w$08 = $s$0$lcssa33; //@line 16794
    while (1) {
     $20 = HEAP32[$w$08 >> 2] ^ $17; //@line 16797
     if (($20 & -2139062144 ^ -2139062144) & $20 + -16843009) {
      $$1$lcssa = $$17; //@line 16804
      $w$0$lcssa = $w$08; //@line 16804
      break L11;
     }
     $26 = $w$08 + 4 | 0; //@line 16807
     $27 = $$17 + -4 | 0; //@line 16808
     if ($27 >>> 0 > 3) {
      $$17 = $27; //@line 16811
      $w$08 = $26; //@line 16811
     } else {
      $$1$lcssa = $27; //@line 16813
      $w$0$lcssa = $26; //@line 16813
      break;
     }
    }
   } else {
    $$1$lcssa = $$0$lcssa34; //@line 16818
    $w$0$lcssa = $s$0$lcssa33; //@line 16818
   } while (0);
   if (!$$1$lcssa) {
    $$3 = 0; //@line 16823
    $s$2 = $w$0$lcssa; //@line 16823
   } else {
    $$24 = $$1$lcssa; //@line 16825
    $s$15 = $w$0$lcssa; //@line 16825
    while (1) {
     if ((HEAP8[$s$15 >> 0] | 0) == $15 << 24 >> 24) {
      $$3 = $$24; //@line 16830
      $s$2 = $s$15; //@line 16830
      break L8;
     }
     $32 = $s$15 + 1 | 0; //@line 16833
     $$24 = $$24 + -1 | 0; //@line 16834
     if (!$$24) {
      $$3 = 0; //@line 16837
      $s$2 = $32; //@line 16837
      break;
     } else $s$15 = $32; //@line 16840
    }
   }
  }
 } while (0);
 STACKTOP = sp; //@line 16849
 return (($$3 | 0) != 0 ? $s$2 : 0) | 0; //@line 16849
}
function _luaD_pcall($L, $func, $u, $old_top, $ef) {
 $L = $L | 0;
 $func = $func | 0;
 $u = $u | 0;
 $old_top = $old_top | 0;
 $ef = $ef | 0;
 var $$$i = 0, $$lim$0$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $2 = 0, $22 = 0, $29 = 0, $3 = 0, $31 = 0, $36 = 0, $37 = 0, $4 = 0, $44 = 0, $48 = 0, $5 = 0, $55 = 0, $57 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $ci$03$i$i = 0, $lim$0$lcssa$i$i = 0, $lim$02$i$i = 0, sp = 0;
 sp = STACKTOP; //@line 17250
 $0 = $L + 16 | 0; //@line 17251
 $1 = HEAP32[$0 >> 2] | 0; //@line 17252
 $2 = $L + 41 | 0; //@line 17253
 $3 = HEAP8[$2 >> 0] | 0; //@line 17254
 $4 = $L + 36 | 0; //@line 17255
 $5 = HEAP16[$4 >> 1] | 0; //@line 17256
 $6 = $L + 68 | 0; //@line 17257
 $7 = HEAP32[$6 >> 2] | 0; //@line 17258
 HEAP32[$6 >> 2] = $ef; //@line 17259
 $8 = _luaD_rawrunprotected($L, $func, $u) | 0; //@line 17260
 if (!$8) {
  HEAP32[$6 >> 2] = $7; //@line 17263
  STACKTOP = sp; //@line 17264
  return $8 | 0; //@line 17264
 }
 $10 = $L + 28 | 0; //@line 17266
 $11 = HEAP32[$10 >> 2] | 0; //@line 17267
 $12 = $11 + $old_top | 0; //@line 17268
 _luaF_close($L, $12); //@line 17269
 if (($8 | 0) == 4) {
  $16 = HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 180 >> 2] | 0; //@line 17274
  HEAP32[$12 >> 2] = $16; //@line 17275
  HEAP32[$11 + ($old_top + 8) >> 2] = HEAPU8[$16 + 4 >> 0] | 0 | 64; //@line 17282
 } else if (($8 | 0) == 6) {
  $22 = _luaS_newlstr($L, 4464, 23) | 0; //@line 17284
  HEAP32[$12 >> 2] = $22; //@line 17285
  HEAP32[$11 + ($old_top + 8) >> 2] = HEAPU8[$22 + 4 >> 0] | 0 | 64; //@line 17292
 } else {
  $29 = HEAP32[$L + 8 >> 2] | 0; //@line 17295
  $31 = $29 + -16 | 0; //@line 17297
  $36 = HEAP32[$31 + 4 >> 2] | 0; //@line 17302
  $37 = $12; //@line 17303
  HEAP32[$37 >> 2] = HEAP32[$31 >> 2]; //@line 17305
  HEAP32[$37 + 4 >> 2] = $36; //@line 17308
  HEAP32[$11 + ($old_top + 8) >> 2] = HEAP32[$29 + -8 >> 2]; //@line 17313
 }
 $44 = $11 + ($old_top + 16) | 0; //@line 17316
 HEAP32[$L + 8 >> 2] = $44; //@line 17318
 HEAP32[$0 >> 2] = $1; //@line 17319
 HEAP8[$2 >> 0] = $3; //@line 17320
 HEAP16[$4 >> 1] = $5; //@line 17321
 if (!$1) $lim$0$lcssa$i$i = $44; //@line 17324
 else {
  $ci$03$i$i = $1; //@line 17326
  $lim$02$i$i = $44; //@line 17326
  while (1) {
   $48 = HEAP32[$ci$03$i$i + 4 >> 2] | 0; //@line 17329
   $$lim$0$i$i = $lim$02$i$i >>> 0 < $48 >>> 0 ? $48 : $lim$02$i$i; //@line 17331
   $ci$03$i$i = HEAP32[$ci$03$i$i + 8 >> 2] | 0; //@line 17333
   if (!$ci$03$i$i) {
    $lim$0$lcssa$i$i = $$lim$0$i$i; //@line 17336
    break;
   } else $lim$02$i$i = $$lim$0$i$i; //@line 17339
  }
 }
 $55 = $lim$0$lcssa$i$i - (HEAP32[$10 >> 2] | 0) | 0; //@line 17346
 $57 = ($55 >> 4) + 1 | 0; //@line 17348
 $60 = (($57 | 0) / 8 | 0) + 10 + $57 | 0; //@line 17351
 $$$i = ($60 | 0) > 1e6 ? 1e6 : $60; //@line 17353
 if (($55 | 0) > 15999984) {
  HEAP32[$6 >> 2] = $7; //@line 17356
  STACKTOP = sp; //@line 17357
  return $8 | 0; //@line 17357
 }
 if (($$$i | 0) >= (HEAP32[$L + 32 >> 2] | 0)) {
  HEAP32[$6 >> 2] = $7; //@line 17363
  STACKTOP = sp; //@line 17364
  return $8 | 0; //@line 17364
 }
 _luaD_reallocstack($L, $$$i); //@line 17366
 HEAP32[$6 >> 2] = $7; //@line 17367
 STACKTOP = sp; //@line 17368
 return $8 | 0; //@line 17368
}
function _close_func($ls) {
 $ls = $ls | 0;
 var $1 = 0, $11 = 0, $17 = 0, $2 = 0, $20 = 0, $22 = 0, $28 = 0, $29 = 0, $3 = 0, $32 = 0, $34 = 0, $4 = 0, $40 = 0, $41 = 0, $44 = 0, $46 = 0, $5 = 0, $52 = 0, $54 = 0, $57 = 0, $59 = 0, $6 = 0, $66 = 0, $69 = 0, $71 = 0, $83 = 0, $87 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 8453
 $1 = HEAP32[$ls + 52 >> 2] | 0; //@line 8455
 $2 = $ls + 48 | 0; //@line 8456
 $3 = HEAP32[$2 >> 2] | 0; //@line 8457
 $4 = HEAP32[$3 >> 2] | 0; //@line 8458
 _luaK_ret($3, 0, 0); //@line 8459
 _leaveblock($3); //@line 8460
 $5 = $3 + 20 | 0; //@line 8461
 $6 = HEAP32[$5 >> 2] | 0; //@line 8462
 if (($6 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($1); //@line 8466
 $9 = $4 + 12 | 0; //@line 8469
 $11 = $4 + 48 | 0; //@line 8471
 HEAP32[$9 >> 2] = _luaM_realloc_($1, HEAP32[$9 >> 2] | 0, HEAP32[$11 >> 2] << 2, $6 << 2) | 0; //@line 8476
 HEAP32[$11 >> 2] = HEAP32[$5 >> 2]; //@line 8478
 $17 = HEAP32[$5 >> 2] | 0; //@line 8479
 if (($17 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($1); //@line 8483
 $20 = $4 + 20 | 0; //@line 8486
 $22 = $4 + 52 | 0; //@line 8488
 HEAP32[$20 >> 2] = _luaM_realloc_($1, HEAP32[$20 >> 2] | 0, HEAP32[$22 >> 2] << 2, $17 << 2) | 0; //@line 8493
 HEAP32[$22 >> 2] = HEAP32[$5 >> 2]; //@line 8495
 $28 = $3 + 32 | 0; //@line 8496
 $29 = HEAP32[$28 >> 2] | 0; //@line 8497
 if (($29 + 1 | 0) >>> 0 > 268435455) _luaM_toobig($1); //@line 8501
 $32 = $4 + 8 | 0; //@line 8504
 $34 = $4 + 44 | 0; //@line 8506
 HEAP32[$32 >> 2] = _luaM_realloc_($1, HEAP32[$32 >> 2] | 0, HEAP32[$34 >> 2] << 4, $29 << 4) | 0; //@line 8511
 HEAP32[$34 >> 2] = HEAP32[$28 >> 2]; //@line 8513
 $40 = $3 + 36 | 0; //@line 8514
 $41 = HEAP32[$40 >> 2] | 0; //@line 8515
 if (($41 + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($1); //@line 8519
 $44 = $4 + 16 | 0; //@line 8522
 $46 = $4 + 56 | 0; //@line 8524
 HEAP32[$44 >> 2] = _luaM_realloc_($1, HEAP32[$44 >> 2] | 0, HEAP32[$46 >> 2] << 2, $41 << 2) | 0; //@line 8529
 HEAP32[$46 >> 2] = HEAP32[$40 >> 2]; //@line 8531
 $52 = $3 + 44 | 0; //@line 8532
 $54 = HEAP16[$52 >> 1] | 0; //@line 8534
 if (($54 + 1 | 0) >>> 0 > 357913941) _luaM_toobig($1); //@line 8538
 $57 = $4 + 24 | 0; //@line 8541
 $59 = $4 + 60 | 0; //@line 8543
 HEAP32[$57 >> 2] = _luaM_realloc_($1, HEAP32[$57 >> 2] | 0, (HEAP32[$59 >> 2] | 0) * 12 | 0, $54 * 12 | 0) | 0; //@line 8548
 HEAP32[$59 >> 2] = HEAP16[$52 >> 1]; //@line 8551
 $66 = $3 + 47 | 0; //@line 8552
 $69 = $4 + 28 | 0; //@line 8555
 $71 = $4 + 40 | 0; //@line 8557
 HEAP32[$69 >> 2] = _luaM_realloc_($1, HEAP32[$69 >> 2] | 0, HEAP32[$71 >> 2] << 3, HEAPU8[$66 >> 0] << 3) | 0; //@line 8562
 HEAP32[$71 >> 2] = HEAPU8[$66 >> 0]; //@line 8565
 HEAP32[$2 >> 2] = HEAP32[$3 + 8 >> 2]; //@line 8568
 if (((HEAP32[$ls + 16 >> 2] | 0) + -288 | 0) >>> 0 < 2) {
  $83 = HEAP32[$ls + 24 >> 2] | 0; //@line 8575
  _luaX_newstring($ls, $83 + 16 | 0, HEAP32[$83 + 12 >> 2] | 0) | 0; //@line 8579
 }
 $87 = $1 + 8 | 0; //@line 8581
 HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + -16; //@line 8584
 if ((HEAP32[(HEAP32[$1 + 12 >> 2] | 0) + 12 >> 2] | 0) <= 0) {
  STACKTOP = sp; //@line 8591
  return;
 }
 _luaC_step($1); //@line 8593
 STACKTOP = sp; //@line 8594
 return;
}
function _luaG_typeerror($L, $o, $op) {
 $L = $L | 0;
 $o = $o | 0;
 $op = $op | 0;
 var $$0$i$i = 0, $1 = 0, $12 = 0, $14 = 0, $16 = 0, $17 = 0, $19 = 0, $28 = 0, $32 = 0, $34 = 0, $40 = 0, $52 = 0, $54 = 0, $7 = 0, $i$02$i = 0, $kind$08 = 0, $name = 0, $p$01$i = 0, $vararg_buffer4 = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr3 = 0, sp = 0;
 sp = STACKTOP; //@line 14627
 STACKTOP = STACKTOP + 32 | 0; //@line 14628
 $vararg_buffer4 = sp; //@line 14629
 $name = sp + 16 | 0; //@line 14630
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 14632
 HEAP32[$name >> 2] = 0; //@line 14633
 $7 = HEAP32[11384 + ((HEAP32[$o + 8 >> 2] & 15) + 1 << 2) >> 2] | 0; //@line 14639
 L1 : do if (HEAP8[$1 + 18 >> 0] & 1) {
  $12 = HEAP32[HEAP32[$1 >> 2] >> 2] | 0; //@line 14647
  $14 = HEAP8[$12 + 6 >> 0] | 0; //@line 14649
  L3 : do if ($14 << 24 >> 24) {
   $16 = $12 + 16 | 0; //@line 14653
   $17 = $14 & 255; //@line 14654
   $i$02$i = 0; //@line 14655
   while (1) {
    $19 = $i$02$i + 1 | 0; //@line 14662
    if ((HEAP32[(HEAP32[$16 + ($i$02$i << 2) >> 2] | 0) + 8 >> 2] | 0) == ($o | 0)) break;
    if (($19 | 0) < ($17 | 0)) $i$02$i = $19; //@line 14668
 else break L3;
   }
   $28 = HEAP32[(HEAP32[(HEAP32[$12 + 12 >> 2] | 0) + 28 >> 2] | 0) + ($i$02$i << 3) >> 2] | 0; //@line 14678
   if (!$28) $$0$i$i = 4144; //@line 14681
 else $$0$i$i = $28 + 16 | 0; //@line 14684
   HEAP32[$name >> 2] = $$0$i$i; //@line 14686
   $54 = $$0$i$i; //@line 14687
   $kind$08 = 4112; //@line 14687
   HEAP32[$vararg_buffer4 >> 2] = $op; //@line 14688
   $vararg_ptr1 = $vararg_buffer4 + 4 | 0; //@line 14689
   HEAP32[$vararg_ptr1 >> 2] = $kind$08; //@line 14690
   $vararg_ptr2 = $vararg_buffer4 + 8 | 0; //@line 14691
   HEAP32[$vararg_ptr2 >> 2] = $54; //@line 14692
   $vararg_ptr3 = $vararg_buffer4 + 12 | 0; //@line 14693
   HEAP32[$vararg_ptr3 >> 2] = $7; //@line 14694
   _luaG_runerror($L, 3880, $vararg_buffer4); //@line 14695
  } while (0);
  $32 = HEAP32[$1 + 24 >> 2] | 0; //@line 14700
  $34 = HEAP32[$1 + 4 >> 2] | 0; //@line 14702
  if ($32 >>> 0 < $34 >>> 0) {
   $p$01$i = $32; //@line 14705
   while (1) {
    if (($p$01$i | 0) == ($o | 0)) break;
    $p$01$i = $p$01$i + 16 | 0; //@line 14708
    if ($p$01$i >>> 0 >= $34 >>> 0) break L1;
   }
   $40 = HEAP32[$12 + 12 >> 2] | 0; //@line 14720
   $52 = _getobjname($40, ((HEAP32[$1 + 28 >> 2] | 0) - (HEAP32[$40 + 12 >> 2] | 0) >> 2) + -1 | 0, $o - $32 >> 4, $name) | 0; //@line 14734
   if ($52) {
    $54 = HEAP32[$name >> 2] | 0; //@line 14738
    $kind$08 = $52; //@line 14738
    HEAP32[$vararg_buffer4 >> 2] = $op; //@line 14739
    $vararg_ptr1 = $vararg_buffer4 + 4 | 0; //@line 14740
    HEAP32[$vararg_ptr1 >> 2] = $kind$08; //@line 14741
    $vararg_ptr2 = $vararg_buffer4 + 8 | 0; //@line 14742
    HEAP32[$vararg_ptr2 >> 2] = $54; //@line 14743
    $vararg_ptr3 = $vararg_buffer4 + 12 | 0; //@line 14744
    HEAP32[$vararg_ptr3 >> 2] = $7; //@line 14745
    _luaG_runerror($L, 3880, $vararg_buffer4); //@line 14746
   }
  }
 } while (0);
 HEAP32[$vararg_buffer4 >> 2] = $op; //@line 14752
 HEAP32[$vararg_buffer4 + 4 >> 2] = $7; //@line 14754
 _luaG_runerror($L, 3920, $vararg_buffer4); //@line 14755
}
function _lua_topointer($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0 = 0, $$0$i = 0, $$0$i$i = 0, $1 = 0, $16 = 0, $17 = 0, $2 = 0, $21 = 0, $37 = 0, $4 = 0, $49 = 0, $50 = 0, $54 = 0, $63 = 0, sp = 0;
 sp = STACKTOP; //@line 2380
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2382
 $2 = ($idx | 0) > 0; //@line 2383
 do if ($2) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2387
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2392
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2399
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2407
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2410
  $17 = HEAP32[$1 >> 2] | 0; //@line 2411
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2416
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2418
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2424
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2428
  }
 } while (0);
 switch (HEAP32[$$0$i + 8 >> 2] & 63 | 0) {
 case 5:
  {
   $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2439
   STACKTOP = sp; //@line 2440
   return $$0 | 0; //@line 2440
  }
 case 6:
  {
   $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2445
   STACKTOP = sp; //@line 2446
   return $$0 | 0; //@line 2446
  }
 case 38:
  {
   $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2451
   STACKTOP = sp; //@line 2452
   return $$0 | 0; //@line 2452
  }
 case 22:
  {
   $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2457
   STACKTOP = sp; //@line 2458
   return $$0 | 0; //@line 2458
  }
 case 8:
  {
   $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2463
   STACKTOP = sp; //@line 2464
   return $$0 | 0; //@line 2464
  }
 case 2:
 case 7:
  {
   do if ($2) {
    $37 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2471
    $$0$i$i = $37 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $37 : 8048; //@line 2476
   } else {
    if (($idx | 0) >= -1000999) {
     $$0$i$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2483
     break;
    }
    if (($idx | 0) == -1001e3) {
     $$0$i$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2491
     break;
    }
    $49 = -1001e3 - $idx | 0; //@line 2494
    $50 = HEAP32[$1 >> 2] | 0; //@line 2495
    if ((HEAP32[$50 + 8 >> 2] | 0) == 22) $$0$i$i = 8048; //@line 2500
 else {
     $54 = HEAP32[$50 >> 2] | 0; //@line 2502
     if (($49 | 0) > (HEAPU8[$54 + 6 >> 0] | 0 | 0)) $$0$i$i = 8048; //@line 2508
 else $$0$i$i = $54 + ($49 + -1 << 4) + 16 | 0; //@line 2512
    }
   } while (0);
   $63 = HEAP32[$$0$i$i + 8 >> 2] & 15; //@line 2519
   if (($63 | 0) == 7) {
    $$0 = (HEAP32[$$0$i$i >> 2] | 0) + 24 | 0; //@line 2523
    STACKTOP = sp; //@line 2524
    return $$0 | 0; //@line 2524
   } else if (($63 | 0) == 2) {
    $$0 = HEAP32[$$0$i$i >> 2] | 0; //@line 2527
    STACKTOP = sp; //@line 2528
    return $$0 | 0; //@line 2528
   } else {
    $$0 = 0; //@line 2530
    STACKTOP = sp; //@line 2531
    return $$0 | 0; //@line 2531
   }
   break;
  }
 default:
  {
   $$0 = 0; //@line 2536
   STACKTOP = sp; //@line 2537
   return $$0 | 0; //@line 2537
  }
 }
 return 0; //@line 2540
}
function _os_time($L) {
 $L = $L | 0;
 var $$ = 0, $$0$i = 0, $$0$i12 = 0, $$0$i16 = 0, $$18 = 0, $10 = 0, $14 = 0, $19 = 0, $25 = 0, $3 = 0, $35 = 0, $6 = 0, $isnum$i14 = 0, $res$0$i2 = 0, $t$0 = 0, $ts = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP; //@line 7998
 STACKTOP = STACKTOP + 64 | 0; //@line 7999
 $vararg_buffer4 = sp; //@line 8000
 $isnum$i14 = sp + 48 | 0; //@line 8001
 $ts = sp + 4 | 0; //@line 8002
 if ((_lua_type($L, 1) | 0) < 1) $t$0 = _time(0) | 0; //@line 8007
 else {
  _luaL_checktype($L, 1, 5); //@line 8009
  _lua_settop($L, 1); //@line 8010
  _lua_getfield($L, -1, 8720); //@line 8011
  $3 = _lua_tointegerx($L, -1, $vararg_buffer4) | 0; //@line 8012
  $$ = (HEAP32[$vararg_buffer4 >> 2] | 0) == 0 ? 0 : $3; //@line 8015
  _lua_settop($L, -2); //@line 8016
  HEAP32[$ts >> 2] = $$; //@line 8017
  _lua_getfield($L, -1, 8728); //@line 8018
  $6 = _lua_tointegerx($L, -1, $vararg_buffer4) | 0; //@line 8019
  $res$0$i2 = (HEAP32[$vararg_buffer4 >> 2] | 0) == 0 ? 0 : $6; //@line 8022
  _lua_settop($L, -2); //@line 8023
  HEAP32[$ts + 4 >> 2] = $res$0$i2; //@line 8025
  _lua_getfield($L, -1, 8736); //@line 8026
  $10 = _lua_tointegerx($L, -1, $vararg_buffer4) | 0; //@line 8027
  $$18 = (HEAP32[$vararg_buffer4 >> 2] | 0) == 0 ? 12 : $10; //@line 8030
  _lua_settop($L, -2); //@line 8031
  HEAP32[$ts + 8 >> 2] = $$18; //@line 8033
  _lua_getfield($L, -1, 8744); //@line 8034
  $14 = _lua_tointegerx($L, -1, $isnum$i14) | 0; //@line 8035
  if (!(HEAP32[$isnum$i14 >> 2] | 0)) {
   HEAP32[$vararg_buffer4 >> 2] = 8744; //@line 8039
   $$0$i = _luaL_error($L, 8776, $vararg_buffer4) | 0; //@line 8041
  } else {
   _lua_settop($L, -2); //@line 8043
   $$0$i = $14; //@line 8044
  }
  HEAP32[$ts + 12 >> 2] = $$0$i; //@line 8047
  _lua_getfield($L, -1, 8752); //@line 8048
  $19 = _lua_tointegerx($L, -1, $isnum$i14) | 0; //@line 8049
  if (!(HEAP32[$isnum$i14 >> 2] | 0)) {
   HEAP32[$vararg_buffer4 >> 2] = 8752; //@line 8053
   $$0$i12 = _luaL_error($L, 8776, $vararg_buffer4) | 0; //@line 8055
  } else {
   _lua_settop($L, -2); //@line 8057
   $$0$i12 = $19; //@line 8058
  }
  HEAP32[$ts + 16 >> 2] = $$0$i12 + -1; //@line 8062
  _lua_getfield($L, -1, 8760); //@line 8063
  $25 = _lua_tointegerx($L, -1, $isnum$i14) | 0; //@line 8064
  if (!(HEAP32[$isnum$i14 >> 2] | 0)) {
   HEAP32[$vararg_buffer4 >> 2] = 8760; //@line 8068
   $$0$i16 = _luaL_error($L, 8776, $vararg_buffer4) | 0; //@line 8070
  } else {
   _lua_settop($L, -2); //@line 8072
   $$0$i16 = $25; //@line 8073
  }
  HEAP32[$ts + 20 >> 2] = $$0$i16 + -1900; //@line 8077
  _lua_getfield($L, -1, 8768); //@line 8078
  if (!(_lua_type($L, -1) | 0)) $35 = -1; //@line 8082
 else $35 = _lua_toboolean($L, -1) | 0; //@line 8085
  _lua_settop($L, -2); //@line 8087
  HEAP32[$ts + 32 >> 2] = $35; //@line 8089
  $t$0 = _mktime($ts | 0) | 0; //@line 8091
 }
 if (($t$0 | 0) == -1) {
  _lua_pushnil($L); //@line 8095
  STACKTOP = sp; //@line 8096
  return 1; //@line 8096
 } else {
  _lua_pushnumber($L, +($t$0 | 0)); //@line 8099
  STACKTOP = sp; //@line 8100
  return 1; //@line 8100
 }
 return 0; //@line 8102
}
function _luaU_undump($L, $Z, $buff, $name) {
 $L = $L | 0;
 $Z = $Z | 0;
 $buff = $buff | 0;
 $name = $name | 0;
 var $0 = 0, $15 = 0, $27 = 0, $28 = 0, $29 = 0, $32 = 0, $39 = 0, $40 = 0, $41 = 0, $43 = 0, $45 = 0, $47 = 0, $S = 0, $cl$0 = 0, $h$i = 0, $s$i = 0, sp = 0;
 sp = STACKTOP; //@line 18618
 STACKTOP = STACKTOP + 64 | 0; //@line 18619
 $h$i = sp + 16 | 0; //@line 18620
 $s$i = sp + 34 | 0; //@line 18621
 $S = sp; //@line 18622
 $0 = HEAP8[$name >> 0] | 0; //@line 18623
 if ($0 << 24 >> 24 == 61 | $0 << 24 >> 24 == 64) HEAP32[$S + 12 >> 2] = $name + 1; //@line 18627
 else if ($0 << 24 >> 24 == 27) HEAP32[$S + 12 >> 2] = 11656; //@line 18630
 else HEAP32[$S + 12 >> 2] = $name; //@line 18633
 HEAP32[$S >> 2] = $L; //@line 18635
 HEAP32[$S + 4 >> 2] = $Z; //@line 18637
 HEAP32[$S + 8 >> 2] = $buff; //@line 18639
 HEAP32[$h$i >> 2] = 1635077147; //@line 18640
 HEAP8[$h$i + 4 >> 0] = 82; //@line 18643
 HEAP8[$h$i + 5 >> 0] = 0; //@line 18645
 HEAP8[$h$i + 6 >> 0] = 1; //@line 18647
 HEAP8[$h$i + 7 >> 0] = 4; //@line 18649
 HEAP8[$h$i + 8 >> 0] = 4; //@line 18651
 HEAP8[$h$i + 9 >> 0] = 4; //@line 18653
 HEAP8[$h$i + 10 >> 0] = 8; //@line 18655
 $15 = $h$i + 12 | 0; //@line 18656
 HEAP8[$h$i + 11 >> 0] = 0; //@line 18657
 HEAP8[$15 + 0 >> 0] = HEAP8[11672] | 0; //@line 18658
 HEAP8[$15 + 1 >> 0] = HEAP8[11673] | 0; //@line 18658
 HEAP8[$15 + 2 >> 0] = HEAP8[11674] | 0; //@line 18658
 HEAP8[$15 + 3 >> 0] = HEAP8[11675] | 0; //@line 18658
 HEAP8[$15 + 4 >> 0] = HEAP8[11676] | 0; //@line 18658
 HEAP8[$15 + 5 >> 0] = HEAP8[11677] | 0; //@line 18658
 HEAP8[$s$i >> 0] = 27; //@line 18659
 if (_luaZ_read($Z, $s$i + 1 | 0, 17) | 0) _error($S, 11680); //@line 18664
 if (!(_memcmp($h$i, $s$i, 18) | 0)) {
  $27 = _luaF_newLclosure($L, 1) | 0; //@line 18670
  $28 = $L + 8 | 0; //@line 18671
  $29 = HEAP32[$28 >> 2] | 0; //@line 18672
  HEAP32[$29 >> 2] = $27; //@line 18673
  HEAP32[$29 + 8 >> 2] = 70; //@line 18675
  $32 = (HEAP32[$28 >> 2] | 0) + 16 | 0; //@line 18677
  HEAP32[$28 >> 2] = $32; //@line 18678
  if (((HEAP32[$L + 24 >> 2] | 0) - $32 | 0) < 16) _luaD_growstack($L, 0); //@line 18686
  $39 = _luaF_newproto($L) | 0; //@line 18688
  $40 = $27 + 12 | 0; //@line 18689
  HEAP32[$40 >> 2] = $39; //@line 18690
  _LoadFunction($S, $39); //@line 18691
  $41 = HEAP32[$40 >> 2] | 0; //@line 18692
  $43 = HEAP32[$41 + 40 >> 2] | 0; //@line 18694
  if (($43 | 0) == 1) {
   $cl$0 = $27; //@line 18697
   STACKTOP = sp; //@line 18698
   return $cl$0 | 0; //@line 18698
  }
  $45 = _luaF_newLclosure($L, $43) | 0; //@line 18700
  HEAP32[$45 + 12 >> 2] = $41; //@line 18702
  $47 = HEAP32[$28 >> 2] | 0; //@line 18703
  HEAP32[$47 + -16 >> 2] = $45; //@line 18705
  HEAP32[$47 + -8 >> 2] = 70; //@line 18707
  $cl$0 = $45; //@line 18708
  STACKTOP = sp; //@line 18709
  return $cl$0 | 0; //@line 18709
 }
 if (_memcmp($h$i, $s$i, 4) | 0) _error($S, 11744); //@line 18714
 if (_memcmp($h$i, $s$i, 6) | 0) _error($S, 11752); //@line 18720
 if (!(_memcmp($h$i, $s$i, 12) | 0)) _error($S, 11728); //@line 18726
 else _error($S, 11776); //@line 18729
 return 0; //@line 18732
}
function _luaD_poscall($L, $firstResult) {
 $L = $L | 0;
 $firstResult = $firstResult | 0;
 var $$0 = 0, $$1 = 0, $$25 = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $13 = 0, $16 = 0, $21 = 0, $23 = 0, $24 = 0, $26 = 0, $32 = 0, $33 = 0, $38 = 0, $39 = 0, $4 = 0, $46 = 0, $52 = 0, $9 = 0, $i$03 = 0, $i$11 = 0, $res$04 = 0, $res$1$lcssa = 0, $res$12 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16371
 $0 = $L + 16 | 0; //@line 16372
 $1 = HEAP32[$0 >> 2] | 0; //@line 16373
 $4 = HEAPU8[$L + 40 >> 0] | 0; //@line 16376
 if (!($4 & 6)) {
  $$1 = $firstResult; //@line 16381
  $$pre$phiZ2D = $1 + 8 | 0; //@line 16381
 } else {
  if (!($4 & 2)) $$0 = $firstResult; //@line 16386
 else {
   $9 = $L + 28 | 0; //@line 16388
   $13 = $firstResult - (HEAP32[$9 >> 2] | 0) | 0; //@line 16392
   _luaD_hook($L, 1, -1); //@line 16393
   $$0 = (HEAP32[$9 >> 2] | 0) + $13 | 0; //@line 16396
  }
  $16 = $1 + 8 | 0; //@line 16398
  HEAP32[$L + 20 >> 2] = HEAP32[(HEAP32[$16 >> 2] | 0) + 28 >> 2]; //@line 16403
  $$1 = $$0; //@line 16404
  $$pre$phiZ2D = $16; //@line 16404
 }
 $21 = HEAP32[$1 >> 2] | 0; //@line 16406
 $23 = HEAP16[$1 + 16 >> 1] | 0; //@line 16408
 $24 = $23 << 16 >> 16; //@line 16409
 HEAP32[$0 >> 2] = HEAP32[$$pre$phiZ2D >> 2]; //@line 16411
 $26 = $L + 8 | 0; //@line 16412
 if (!($23 << 16 >> 16)) {
  $res$1$lcssa = $21; //@line 16415
  HEAP32[$26 >> 2] = $res$1$lcssa; //@line 16416
  $52 = $24 + 1 | 0; //@line 16417
  STACKTOP = sp; //@line 16418
  return $52 | 0; //@line 16418
 } else {
  $$25 = $$1; //@line 16420
  $i$03 = $24; //@line 16420
  $res$04 = $21; //@line 16420
 }
 while (1) {
  if ($$25 >>> 0 >= (HEAP32[$26 >> 2] | 0) >>> 0) break;
  $32 = $res$04 + 16 | 0; //@line 16429
  $33 = $$25; //@line 16430
  $38 = HEAP32[$33 + 4 >> 2] | 0; //@line 16435
  $39 = $res$04; //@line 16436
  HEAP32[$39 >> 2] = HEAP32[$33 >> 2]; //@line 16438
  HEAP32[$39 + 4 >> 2] = $38; //@line 16441
  HEAP32[$res$04 + 8 >> 2] = HEAP32[$$25 + 8 >> 2]; //@line 16445
  $46 = $i$03 + -1 | 0; //@line 16446
  if (!$46) {
   $res$1$lcssa = $32; //@line 16449
   label = 12; //@line 16450
   break;
  } else {
   $$25 = $$25 + 16 | 0; //@line 16453
   $i$03 = $46; //@line 16453
   $res$04 = $32; //@line 16453
  }
 }
 if ((label | 0) == 12) {
  HEAP32[$26 >> 2] = $res$1$lcssa; //@line 16457
  $52 = $24 + 1 | 0; //@line 16458
  STACKTOP = sp; //@line 16459
  return $52 | 0; //@line 16459
 }
 if (($i$03 | 0) > 0) {
  $i$11 = $i$03; //@line 16463
  $res$12 = $res$04; //@line 16463
 } else {
  $res$1$lcssa = $res$04; //@line 16465
  HEAP32[$26 >> 2] = $res$1$lcssa; //@line 16466
  $52 = $24 + 1 | 0; //@line 16467
  STACKTOP = sp; //@line 16468
  return $52 | 0; //@line 16468
 }
 while (1) {
  $i$11 = $i$11 + -1 | 0; //@line 16471
  HEAP32[$res$12 + 8 >> 2] = 0; //@line 16474
  if (($i$11 | 0) <= 0) break; else $res$12 = $res$12 + 16 | 0; //@line 16477
 }
 $res$1$lcssa = $res$04 + ($i$03 << 4) | 0; //@line 16483
 HEAP32[$26 >> 2] = $res$1$lcssa; //@line 16484
 $52 = $24 + 1 | 0; //@line 16485
 STACKTOP = sp; //@line 16486
 return $52 | 0; //@line 16486
}
function _lexerror($ls, $msg, $token) {
 $ls = $ls | 0;
 $msg = $msg | 0;
 $token = $token | 0;
 var $$0$i = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $15 = 0, $16 = 0, $19 = 0, $22 = 0, $24 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $41 = 0, $44 = 0, $6 = 0, $7 = 0, $9 = 0, $buff = 0, $vararg_buffer15 = 0, sp = 0;
 sp = STACKTOP; //@line 2922
 STACKTOP = STACKTOP + 80 | 0; //@line 2923
 $vararg_buffer15 = sp; //@line 2924
 $buff = sp + 12 | 0; //@line 2925
 _luaO_chunkid($buff, (HEAP32[$ls + 68 >> 2] | 0) + 16 | 0, 60); //@line 2929
 $3 = $ls + 52 | 0; //@line 2930
 $4 = HEAP32[$3 >> 2] | 0; //@line 2931
 $6 = HEAP32[$ls + 4 >> 2] | 0; //@line 2933
 HEAP32[$vararg_buffer15 >> 2] = $buff; //@line 2934
 HEAP32[$vararg_buffer15 + 4 >> 2] = $6; //@line 2936
 HEAP32[$vararg_buffer15 + 8 >> 2] = $msg; //@line 2938
 $7 = _luaO_pushfstring($4, 6112, $vararg_buffer15) | 0; //@line 2939
 if (!$token) {
  $44 = HEAP32[$3 >> 2] | 0; //@line 2942
  _luaD_throw($44, 3); //@line 2943
 }
 $9 = HEAP32[$3 >> 2] | 0; //@line 2946
 do if (($token + -287 | 0) >>> 0 < 3) {
  $10 = $ls + 60 | 0; //@line 2951
  $11 = HEAP32[$10 >> 2] | 0; //@line 2952
  $12 = $11 + 4 | 0; //@line 2953
  $13 = HEAP32[$12 >> 2] | 0; //@line 2954
  $15 = $11 + 8 | 0; //@line 2956
  $16 = HEAP32[$15 >> 2] | 0; //@line 2957
  do if (($13 + 1 | 0) >>> 0 > $16 >>> 0) {
   if ($16 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 2963
   $19 = $16 << 1; //@line 2966
   if (($19 | 0) == -2) _luaM_toobig($9); //@line 2969
 else {
    $22 = _luaM_realloc_($9, HEAP32[$11 >> 2] | 0, $16, $19) | 0; //@line 2973
    HEAP32[$11 >> 2] = $22; //@line 2974
    HEAP32[$15 >> 2] = $19; //@line 2975
    $24 = HEAP32[$12 >> 2] | 0; //@line 2977
    $26 = $22; //@line 2977
    break;
   }
  } else {
   $24 = $13; //@line 2982
   $26 = HEAP32[$11 >> 2] | 0; //@line 2982
  } while (0);
  HEAP32[$12 >> 2] = $24 + 1; //@line 2986
  HEAP8[$26 + $24 >> 0] = 0; //@line 2988
  $27 = HEAP32[$3 >> 2] | 0; //@line 2989
  HEAP32[$vararg_buffer15 >> 2] = HEAP32[HEAP32[$10 >> 2] >> 2]; //@line 2992
  $$0$i = _luaO_pushfstring($27, 5776, $vararg_buffer15) | 0; //@line 2994
 } else {
  if (($token | 0) >= 257) {
   $41 = HEAP32[5616 + ($token + -257 << 2) >> 2] | 0; //@line 3000
   if (($token | 0) >= 286) {
    $$0$i = $41; //@line 3003
    break;
   }
   HEAP32[$vararg_buffer15 >> 2] = $41; //@line 3006
   $$0$i = _luaO_pushfstring($9, 5776, $vararg_buffer15) | 0; //@line 3008
   break;
  }
  if (!(HEAP8[$token + 2697 >> 0] & 4)) {
   HEAP32[$vararg_buffer15 >> 2] = $token; //@line 3017
   $$0$i = _luaO_pushfstring($9, 5760, $vararg_buffer15) | 0; //@line 3019
   break;
  } else {
   HEAP32[$vararg_buffer15 >> 2] = $token; //@line 3022
   $$0$i = _luaO_pushfstring($9, 5752, $vararg_buffer15) | 0; //@line 3024
   break;
  }
 } while (0);
 HEAP32[$vararg_buffer15 >> 2] = $7; //@line 3029
 HEAP32[$vararg_buffer15 + 4 >> 2] = $$0$i; //@line 3031
 _luaO_pushfstring($9, 6128, $vararg_buffer15) | 0; //@line 3032
 $44 = HEAP32[$3 >> 2] | 0; //@line 3033
 _luaD_throw($44, 3); //@line 3034
}
function _lua_pcallk($L, $nargs, $nresults, $errfunc, $ctx, $k) {
 $L = $L | 0;
 $nargs = $nargs | 0;
 $nresults = $nresults | 0;
 $errfunc = $errfunc | 0;
 $ctx = $ctx | 0;
 $k = $k | 0;
 var $$0$i = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $34 = 0, $37 = 0, $5 = 0, $50 = 0, $63 = 0, $65 = 0, $66 = 0, $80 = 0, $82 = 0, $c = 0, $func$0 = 0, $status$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 4365
 STACKTOP = STACKTOP + 16 | 0; //@line 4366
 $c = sp; //@line 4367
 if (!$errfunc) $func$0 = 0; //@line 4370
 else {
  $2 = HEAP32[$L + 16 >> 2] | 0; //@line 4373
  do if (($errfunc | 0) > 0) {
   $5 = (HEAP32[$2 >> 2] | 0) + ($errfunc << 4) | 0; //@line 4378
   $$0$i = $5 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $5 : 8048; //@line 4383
  } else {
   if (($errfunc | 0) >= -1000999) {
    $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($errfunc << 4) | 0; //@line 4390
    break;
   }
   if (($errfunc | 0) == -1001e3) {
    $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 4398
    break;
   }
   $17 = -1001e3 - $errfunc | 0; //@line 4401
   $18 = HEAP32[$2 >> 2] | 0; //@line 4402
   if ((HEAP32[$18 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 4407
 else {
    $22 = HEAP32[$18 >> 2] | 0; //@line 4409
    if (($17 | 0) > (HEAPU8[$22 + 6 >> 0] | 0)) $$0$i = 8048; //@line 4415
 else $$0$i = $22 + ($17 + -1 << 4) + 16 | 0; //@line 4419
   }
  } while (0);
  $func$0 = $$0$i - (HEAP32[$L + 28 >> 2] | 0) | 0; //@line 4429
 }
 $34 = $L + 8 | 0; //@line 4431
 $37 = (HEAP32[$34 >> 2] | 0) + (~$nargs << 4) | 0; //@line 4434
 HEAP32[$c >> 2] = $37; //@line 4435
 if (!$k) label = 14; //@line 4438
 else if (!(HEAP16[$L + 36 >> 1] | 0)) {
  $50 = HEAP32[$L + 16 >> 2] | 0; //@line 4445
  HEAP32[$50 + 28 >> 2] = $k; //@line 4447
  HEAP32[$50 + 24 >> 2] = $ctx; //@line 4449
  HEAP32[$50 + 20 >> 2] = (HEAP32[$c >> 2] | 0) - (HEAP32[$L + 28 >> 2] | 0); //@line 4457
  HEAP8[$50 + 36 >> 0] = HEAP8[$L + 41 >> 0] | 0; //@line 4461
  $63 = $L + 68 | 0; //@line 4462
  $65 = $50 + 32 | 0; //@line 4464
  HEAP32[$65 >> 2] = HEAP32[$63 >> 2]; //@line 4465
  HEAP32[$63 >> 2] = $func$0; //@line 4466
  $66 = $50 + 18 | 0; //@line 4467
  HEAP8[$66 >> 0] = HEAPU8[$66 >> 0] | 16; //@line 4472
  _luaD_call($L, HEAP32[$c >> 2] | 0, $nresults, 1); //@line 4474
  HEAP8[$66 >> 0] = HEAPU8[$66 >> 0] & 239; //@line 4479
  HEAP32[$63 >> 2] = HEAP32[$65 >> 2]; //@line 4481
  $status$0 = 0; //@line 4482
 } else label = 14; //@line 4484
 if ((label | 0) == 14) {
  HEAP32[$c + 4 >> 2] = $nresults; //@line 4489
  $status$0 = _luaD_pcall($L, 19, $c, $37 - (HEAP32[$L + 28 >> 2] | 0) | 0, $func$0) | 0; //@line 4496
 }
 if (($nresults | 0) != -1) {
  STACKTOP = sp; //@line 4500
  return $status$0 | 0; //@line 4500
 }
 $80 = (HEAP32[$L + 16 >> 2] | 0) + 4 | 0; //@line 4504
 $82 = HEAP32[$34 >> 2] | 0; //@line 4506
 if ((HEAP32[$80 >> 2] | 0) >>> 0 >= $82 >>> 0) {
  STACKTOP = sp; //@line 4509
  return $status$0 | 0; //@line 4509
 }
 HEAP32[$80 >> 2] = $82; //@line 4511
 STACKTOP = sp; //@line 4512
 return $status$0 | 0; //@line 4512
}
function _lua_getupvalue($L, $funcindex, $n) {
 $L = $L | 0;
 $funcindex = $funcindex | 0;
 $n = $n | 0;
 var $$0$i = 0, $$0$i12 = 0, $$0$i15 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $31 = 0, $39 = 0, $4 = 0, $41 = 0, $46 = 0, $51 = 0, $55 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $66 = 0, $67 = 0, sp = 0;
 sp = STACKTOP; //@line 5022
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 5024
 do if (($funcindex | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($funcindex << 4) | 0; //@line 5029
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 5034
 } else {
  if (($funcindex | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($funcindex << 4) | 0; //@line 5041
   break;
  }
  if (($funcindex | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5049
   break;
  }
  $16 = -1001e3 - $funcindex | 0; //@line 5052
  $17 = HEAP32[$1 >> 2] | 0; //@line 5053
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 5058
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 5060
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 5066
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 5070
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 63; //@line 5077
 do if (($30 | 0) == 38) {
  $31 = HEAP32[$$0$i >> 2] | 0; //@line 5080
  if (($n | 0) <= 0) {
   $$0$i12 = 0; //@line 5083
   STACKTOP = sp; //@line 5084
   return $$0$i12 | 0; //@line 5084
  }
  if ((HEAPU8[$31 + 6 >> 0] | 0 | 0) < ($n | 0)) {
   $$0$i12 = 0; //@line 5091
   STACKTOP = sp; //@line 5092
   return $$0$i12 | 0; //@line 5092
  } else {
   $$0$i15 = 24; //@line 5096
   $61 = $31 + ($n + -1 << 4) + 16 | 0; //@line 5096
   break;
  }
 } else if (($30 | 0) == 6) {
  $39 = HEAP32[$$0$i >> 2] | 0; //@line 5100
  $41 = HEAP32[$39 + 12 >> 2] | 0; //@line 5102
  if (($n | 0) <= 0) {
   $$0$i12 = 0; //@line 5105
   STACKTOP = sp; //@line 5106
   return $$0$i12 | 0; //@line 5106
  }
  if ((HEAP32[$41 + 40 >> 2] | 0) < ($n | 0)) {
   $$0$i12 = 0; //@line 5112
   STACKTOP = sp; //@line 5113
   return $$0$i12 | 0; //@line 5113
  }
  $46 = $n + -1 | 0; //@line 5115
  $51 = HEAP32[(HEAP32[$39 + 16 + ($46 << 2) >> 2] | 0) + 8 >> 2] | 0; //@line 5120
  $55 = HEAP32[(HEAP32[$41 + 28 >> 2] | 0) + ($46 << 3) >> 2] | 0; //@line 5124
  if (!$55) {
   $$0$i15 = 24; //@line 5127
   $61 = $51; //@line 5127
  } else {
   $$0$i15 = $55 + 16 | 0; //@line 5130
   $61 = $51; //@line 5130
  }
 } else {
  $$0$i12 = 0; //@line 5133
  STACKTOP = sp; //@line 5134
  return $$0$i12 | 0; //@line 5134
 } while (0);
 $58 = $L + 8 | 0; //@line 5137
 $59 = HEAP32[$58 >> 2] | 0; //@line 5138
 $60 = $61; //@line 5139
 $66 = HEAP32[$60 + 4 >> 2] | 0; //@line 5144
 $67 = $59; //@line 5145
 HEAP32[$67 >> 2] = HEAP32[$60 >> 2]; //@line 5147
 HEAP32[$67 + 4 >> 2] = $66; //@line 5150
 HEAP32[$59 + 8 >> 2] = HEAP32[$61 + 8 >> 2]; //@line 5154
 HEAP32[$58 >> 2] = (HEAP32[$58 >> 2] | 0) + 16; //@line 5157
 $$0$i12 = $$0$i15; //@line 5158
 STACKTOP = sp; //@line 5159
 return $$0$i12 | 0; //@line 5159
}
function _lua_setmetatable($L, $objindex) {
 $L = $L | 0;
 $objindex = $objindex | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $37 = 0, $4 = 0, $45 = 0, $58 = 0, $67 = 0, $68 = 0, $mt$0 = 0, sp = 0;
 sp = STACKTOP; //@line 4024
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 4026
 do if (($objindex | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($objindex << 4) | 0; //@line 4031
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 4036
 } else {
  if (($objindex | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($objindex << 4) | 0; //@line 4043
   break;
  }
  if (($objindex | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 4051
   break;
  }
  $16 = -1001e3 - $objindex | 0; //@line 4054
  $17 = HEAP32[$1 >> 2] | 0; //@line 4055
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 4060
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 4062
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 4068
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 4072
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 4077
 $29 = HEAP32[$28 >> 2] | 0; //@line 4078
 if (!(HEAP32[$29 + -8 >> 2] | 0)) $mt$0 = 0; //@line 4083
 else $mt$0 = HEAP32[$29 + -16 >> 2] | 0; //@line 4087
 $37 = HEAP32[$$0$i + 8 >> 2] & 15; //@line 4091
 if (($37 | 0) == 5) {
  HEAP32[(HEAP32[$$0$i >> 2] | 0) + 8 >> 2] = $mt$0; //@line 4095
  if (!$mt$0) {
   $67 = HEAP32[$28 >> 2] | 0; //@line 4098
   $68 = $67 + -16 | 0; //@line 4099
   HEAP32[$28 >> 2] = $68; //@line 4100
   STACKTOP = sp; //@line 4101
   return 1; //@line 4101
  }
  if (HEAP8[$mt$0 + 5 >> 0] & 3) {
   $45 = HEAP32[$$0$i >> 2] | 0; //@line 4108
   if (HEAP8[$45 + 5 >> 0] & 4) _luaC_barrierback_($L, $45); //@line 4114
  }
  _luaC_checkfinalizer($L, HEAP32[$$0$i >> 2] | 0, $mt$0); //@line 4118
  $67 = HEAP32[$28 >> 2] | 0; //@line 4119
  $68 = $67 + -16 | 0; //@line 4120
  HEAP32[$28 >> 2] = $68; //@line 4121
  STACKTOP = sp; //@line 4122
  return 1; //@line 4122
 } else if (($37 | 0) == 7) {
  HEAP32[(HEAP32[$$0$i >> 2] | 0) + 8 >> 2] = $mt$0; //@line 4126
  if (!$mt$0) {
   $67 = HEAP32[$28 >> 2] | 0; //@line 4129
   $68 = $67 + -16 | 0; //@line 4130
   HEAP32[$28 >> 2] = $68; //@line 4131
   STACKTOP = sp; //@line 4132
   return 1; //@line 4132
  }
  if (HEAP8[$mt$0 + 5 >> 0] & 3) {
   $58 = HEAP32[$$0$i >> 2] | 0; //@line 4139
   if (HEAP8[$58 + 5 >> 0] & 4) _luaC_barrier_($L, $58, $mt$0); //@line 4145
  }
  _luaC_checkfinalizer($L, HEAP32[$$0$i >> 2] | 0, $mt$0); //@line 4149
  $67 = HEAP32[$28 >> 2] | 0; //@line 4150
  $68 = $67 + -16 | 0; //@line 4151
  HEAP32[$28 >> 2] = $68; //@line 4152
  STACKTOP = sp; //@line 4153
  return 1; //@line 4153
 } else {
  HEAP32[(HEAP32[$L + 12 >> 2] | 0) + ($37 << 2) + 252 >> 2] = $mt$0; //@line 4158
  $67 = HEAP32[$28 >> 2] | 0; //@line 4159
  $68 = $67 + -16 | 0; //@line 4160
  HEAP32[$28 >> 2] = $68; //@line 4161
  STACKTOP = sp; //@line 4162
  return 1; //@line 4162
 }
 return 0; //@line 4164
}
function _luaV_objlen($L, $ra, $rb) {
 $L = $L | 0;
 $ra = $ra | 0;
 $rb = $rb | 0;
 var $0 = 0, $15 = 0, $2 = 0, $25 = 0, $29 = 0, $3 = 0, $33 = 0, $34 = 0, $35 = 0, $37 = 0, $42 = 0, $43 = 0, $5 = 0, $50 = 0, $52 = 0, $57 = 0, $58 = 0, $64 = 0, $66 = 0, $71 = 0, $72 = 0, $86 = 0, $88 = 0, $89 = 0, $90 = 0, $95 = 0, $96 = 0, $tm$0 = 0, sp = 0;
 sp = STACKTOP; //@line 2602
 $0 = $rb + 8 | 0; //@line 2603
 $2 = HEAP32[$0 >> 2] & 15; //@line 2605
 do if (($2 | 0) == 4) {
  HEAPF64[$ra >> 3] = +((HEAP32[(HEAP32[$rb >> 2] | 0) + 12 >> 2] | 0) >>> 0); //@line 2612
  HEAP32[$ra + 8 >> 2] = 3; //@line 2614
  STACKTOP = sp; //@line 2615
  return;
 } else if (($2 | 0) == 5) {
  $3 = HEAP32[$rb >> 2] | 0; //@line 2617
  $5 = HEAP32[$3 + 8 >> 2] | 0; //@line 2619
  if ($5) if (!(HEAP8[$5 + 6 >> 0] & 16)) {
   $15 = _luaT_gettm($5, 4, HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 200 >> 2] | 0) | 0; //@line 2631
   if ($15) {
    $tm$0 = $15; //@line 2634
    break;
   }
  }
  HEAPF64[$ra >> 3] = +(_luaH_getn($3) | 0); //@line 2641
  HEAP32[$ra + 8 >> 2] = 3; //@line 2643
  STACKTOP = sp; //@line 2644
  return;
 } else {
  $25 = _luaT_gettmbyobj($L, $rb, 4) | 0; //@line 2646
  if (!(HEAP32[$25 + 8 >> 2] | 0)) _luaG_typeerror($L, $rb, 11880); //@line 2651
 else $tm$0 = $25; //@line 2654
 } while (0);
 $29 = $L + 28 | 0; //@line 2658
 $33 = $ra - (HEAP32[$29 >> 2] | 0) | 0; //@line 2662
 $34 = $L + 8 | 0; //@line 2663
 $35 = HEAP32[$34 >> 2] | 0; //@line 2664
 HEAP32[$34 >> 2] = $35 + 16; //@line 2666
 $37 = $tm$0; //@line 2667
 $42 = HEAP32[$37 + 4 >> 2] | 0; //@line 2672
 $43 = $35; //@line 2673
 HEAP32[$43 >> 2] = HEAP32[$37 >> 2]; //@line 2675
 HEAP32[$43 + 4 >> 2] = $42; //@line 2678
 HEAP32[$35 + 8 >> 2] = HEAP32[$tm$0 + 8 >> 2]; //@line 2682
 $50 = HEAP32[$34 >> 2] | 0; //@line 2683
 HEAP32[$34 >> 2] = $50 + 16; //@line 2685
 $52 = $rb; //@line 2686
 $57 = HEAP32[$52 + 4 >> 2] | 0; //@line 2691
 $58 = $50; //@line 2692
 HEAP32[$58 >> 2] = HEAP32[$52 >> 2]; //@line 2694
 HEAP32[$58 + 4 >> 2] = $57; //@line 2697
 HEAP32[$50 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 2700
 $64 = HEAP32[$34 >> 2] | 0; //@line 2701
 HEAP32[$34 >> 2] = $64 + 16; //@line 2703
 $66 = $rb; //@line 2704
 $71 = HEAP32[$66 + 4 >> 2] | 0; //@line 2709
 $72 = $64; //@line 2710
 HEAP32[$72 >> 2] = HEAP32[$66 >> 2]; //@line 2712
 HEAP32[$72 + 4 >> 2] = $71; //@line 2715
 HEAP32[$64 + 8 >> 2] = HEAP32[$0 >> 2]; //@line 2718
 _luaD_call($L, (HEAP32[$34 >> 2] | 0) + -48 | 0, 1, (HEAPU8[(HEAP32[$L + 16 >> 2] | 0) + 18 >> 0] | 0) & 1); //@line 2727
 $86 = HEAP32[$29 >> 2] | 0; //@line 2728
 $88 = HEAP32[$34 >> 2] | 0; //@line 2730
 $89 = $88 + -16 | 0; //@line 2731
 HEAP32[$34 >> 2] = $89; //@line 2732
 $90 = $89; //@line 2733
 $95 = HEAP32[$90 + 4 >> 2] | 0; //@line 2738
 $96 = $86 + $33 | 0; //@line 2739
 HEAP32[$96 >> 2] = HEAP32[$90 >> 2]; //@line 2741
 HEAP32[$96 + 4 >> 2] = $95; //@line 2744
 HEAP32[$86 + ($33 + 8) >> 2] = HEAP32[$88 + -8 >> 2]; //@line 2749
 STACKTOP = sp; //@line 2750
 return;
}
function _GCTM($L, $propagateerrors) {
 $L = $L | 0;
 $propagateerrors = $propagateerrors | 0;
 var $1 = 0, $2 = 0, $26 = 0, $27 = 0, $29 = 0, $3 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $44 = 0, $45 = 0, $5 = 0, $51 = 0, $53 = 0, $58 = 0, $59 = 0, $65 = 0, $7 = 0, $72 = 0, $76 = 0, $84 = 0, $9 = 0, $status$0 = 0, $v = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 187
 STACKTOP = STACKTOP + 32 | 0; //@line 188
 $vararg_buffer = sp + 16 | 0; //@line 189
 $v = sp; //@line 190
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 192
 $2 = $1 + 104 | 0; //@line 193
 $3 = HEAP32[$2 >> 2] | 0; //@line 194
 HEAP32[$2 >> 2] = HEAP32[$3 >> 2]; //@line 196
 $5 = $1 + 68 | 0; //@line 197
 HEAP32[$3 >> 2] = HEAP32[$5 >> 2]; //@line 199
 HEAP32[$5 >> 2] = $3; //@line 200
 $7 = $3 + 5 | 0; //@line 201
 $9 = HEAPU8[$7 >> 0] | 0; //@line 203
 HEAP8[$7 >> 0] = $9 & 239; //@line 206
 if ((HEAPU8[$1 + 61 >> 0] | 0) >= 2) HEAP8[$7 >> 0] = (HEAPU8[$1 + 60 >> 0] | 0) & 3 | $9 & 168; //@line 218
 HEAP32[$v >> 2] = $3; //@line 220
 $26 = $v + 8 | 0; //@line 225
 HEAP32[$26 >> 2] = HEAPU8[$3 + 4 >> 0] | 0 | 64; //@line 226
 $27 = _luaT_gettmbyobj($L, $v, 2) | 0; //@line 227
 if (!$27) {
  STACKTOP = sp; //@line 230
  return;
 }
 $29 = $27 + 8 | 0; //@line 232
 if ((HEAP32[$29 >> 2] & 15 | 0) != 6) {
  STACKTOP = sp; //@line 237
  return;
 }
 $33 = $L + 41 | 0; //@line 239
 $34 = HEAP8[$33 >> 0] | 0; //@line 240
 $35 = $1 + 63 | 0; //@line 241
 $36 = HEAP8[$35 >> 0] | 0; //@line 242
 HEAP8[$33 >> 0] = 0; //@line 243
 HEAP8[$35 >> 0] = 0; //@line 244
 $37 = $L + 8 | 0; //@line 245
 $38 = HEAP32[$37 >> 2] | 0; //@line 246
 $39 = $27; //@line 247
 $44 = HEAP32[$39 + 4 >> 2] | 0; //@line 252
 $45 = $38; //@line 253
 HEAP32[$45 >> 2] = HEAP32[$39 >> 2]; //@line 255
 HEAP32[$45 + 4 >> 2] = $44; //@line 258
 HEAP32[$38 + 8 >> 2] = HEAP32[$29 >> 2]; //@line 261
 $51 = HEAP32[$37 >> 2] | 0; //@line 262
 $53 = $v; //@line 264
 $58 = HEAP32[$53 + 4 >> 2] | 0; //@line 269
 $59 = $51 + 16 | 0; //@line 270
 HEAP32[$59 >> 2] = HEAP32[$53 >> 2]; //@line 272
 HEAP32[$59 + 4 >> 2] = $58; //@line 275
 HEAP32[$51 + 24 >> 2] = HEAP32[$26 >> 2]; //@line 278
 $65 = HEAP32[$37 >> 2] | 0; //@line 279
 HEAP32[$37 >> 2] = $65 + 32; //@line 281
 $72 = _luaD_pcall($L, 24, 0, $65 - (HEAP32[$L + 28 >> 2] | 0) | 0, 0) | 0; //@line 287
 HEAP8[$33 >> 0] = $34; //@line 288
 HEAP8[$35 >> 0] = $36; //@line 289
 if (($72 | 0) == 0 | ($propagateerrors | 0) == 0) {
  STACKTOP = sp; //@line 294
  return;
 }
 if (($72 | 0) != 2) {
  $status$0 = $72; //@line 298
  _luaD_throw($L, $status$0); //@line 299
 }
 $76 = HEAP32[$37 >> 2] | 0; //@line 302
 if ((HEAP32[$76 + -8 >> 2] & 15 | 0) == 4) $84 = (HEAP32[$76 + -16 >> 2] | 0) + 16 | 0; //@line 311
 else $84 = 4568; //@line 313
 HEAP32[$vararg_buffer >> 2] = $84; //@line 315
 _luaO_pushfstring($L, 4584, $vararg_buffer) | 0; //@line 316
 $status$0 = 5; //@line 317
 _luaD_throw($L, $status$0); //@line 318
}
function _luaH_resize($L, $t, $nasize, $nhsize) {
 $L = $L | 0;
 $t = $t | 0;
 $nasize = $nasize | 0;
 $nhsize = $nhsize | 0;
 var $$0$i = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $14 = 0, $15 = 0, $20 = 0, $21 = 0, $26 = 0, $29 = 0, $34 = 0, $36 = 0, $4 = 0, $41 = 0, $42 = 0, $45 = 0, $50 = 0, $51 = 0, $6 = 0, $i$01$i = 0, $i$03 = 0, $i$12$in = 0, sp = 0;
 sp = STACKTOP; //@line 16518
 $0 = $t + 28 | 0; //@line 16519
 $1 = HEAP32[$0 >> 2] | 0; //@line 16520
 $4 = HEAPU8[$t + 7 >> 0] | 0; //@line 16523
 $6 = HEAP32[$t + 16 >> 2] | 0; //@line 16525
 if (($1 | 0) < ($nasize | 0)) {
  if (($nasize + 1 | 0) >>> 0 > 268435455) _luaM_toobig($L); //@line 16531
  $10 = $t + 12 | 0; //@line 16534
  $14 = _luaM_realloc_($L, HEAP32[$10 >> 2] | 0, $1 << 4, $nasize << 4) | 0; //@line 16538
  HEAP32[$10 >> 2] = $14; //@line 16539
  $15 = HEAP32[$0 >> 2] | 0; //@line 16540
  if (($15 | 0) < ($nasize | 0)) {
   $i$01$i = $15; //@line 16543
   do {
    HEAP32[$14 + ($i$01$i << 4) + 8 >> 2] = 0; //@line 16546
    $i$01$i = $i$01$i + 1 | 0; //@line 16547
   } while (($i$01$i | 0) != ($nasize | 0));
  }
  HEAP32[$0 >> 2] = $nasize; //@line 16556
 }
 _setnodevector($L, $t, $nhsize); //@line 16558
 do if (($1 | 0) > ($nasize | 0)) {
  HEAP32[$0 >> 2] = $nasize; //@line 16562
  $20 = $t + 12 | 0; //@line 16563
  $i$03 = $nasize; //@line 16564
  while (1) {
   $21 = HEAP32[$20 >> 2] | 0; //@line 16566
   if (!(HEAP32[$21 + ($i$03 << 4) + 8 >> 2] | 0)) $$pre$phiZ2D = $i$03 + 1 | 0; //@line 16572
 else {
    $26 = $i$03 + 1 | 0; //@line 16575
    _luaH_setint($L, $t, $26, $21 + ($i$03 << 4) | 0); //@line 16576
    $$pre$phiZ2D = $26; //@line 16577
   }
   if (($$pre$phiZ2D | 0) == ($1 | 0)) break; else $i$03 = $$pre$phiZ2D; //@line 16583
  }
  if (($nasize + 1 | 0) >>> 0 > 268435455) _luaM_toobig($L); //@line 16589
 else {
   $29 = $t + 12 | 0; //@line 16592
   HEAP32[$29 >> 2] = _luaM_realloc_($L, HEAP32[$29 >> 2] | 0, $1 << 4, $nasize << 4) | 0; //@line 16597
   break;
  }
 } while (0);
 $34 = 1 << $4; //@line 16602
 if (($34 | 0) > 0) {
  $i$12$in = $34; //@line 16605
  do {
   $i$12$in = $i$12$in + -1 | 0; //@line 16607
   $36 = $6 + ($i$12$in << 5) + 8 | 0; //@line 16608
   if (HEAP32[$36 >> 2] | 0) {
    $41 = $6 + ($i$12$in << 5) + 16 | 0; //@line 16613
    $42 = _luaH_get($t, $41) | 0; //@line 16614
    if (($42 | 0) == 8048) $$0$i = _luaH_newkey($L, $t, $41) | 0; //@line 16618
 else $$0$i = $42; //@line 16620
    $45 = $6 + ($i$12$in << 5) | 0; //@line 16622
    $50 = HEAP32[$45 + 4 >> 2] | 0; //@line 16627
    $51 = $$0$i; //@line 16628
    HEAP32[$51 >> 2] = HEAP32[$45 >> 2]; //@line 16630
    HEAP32[$51 + 4 >> 2] = $50; //@line 16633
    HEAP32[$$0$i + 8 >> 2] = HEAP32[$36 >> 2]; //@line 16636
   }
  } while (($i$12$in | 0) > 0);
 }
 if (($6 | 0) == 10872) {
  STACKTOP = sp; //@line 16648
  return;
 }
 _luaM_realloc_($L, $6, $34 << 5, 0) | 0; //@line 16651
 STACKTOP = sp; //@line 16652
 return;
}
function _saveSetjmp(env, label, table) {
 env = env | 0;
 label = label | 0;
 table = table | 0;
 var i = 0;
 setjmpId = setjmpId + 1 | 0; //@line 16956
 HEAP32[env >> 2] = setjmpId; //@line 16957
 while ((i | 0) < 20) {
  if (!(HEAP32[table + (i << 3) >> 2] | 0)) {
   HEAP32[table + (i << 3) >> 2] = setjmpId; //@line 16960
   HEAP32[table + ((i << 3) + 4) >> 2] = label; //@line 16961
   HEAP32[table + ((i << 3) + 8) >> 2] = 0; //@line 16963
   return 0; //@line 16964
  }
  i = i + 1 | 0; //@line 16966
 }
 _putchar(116); //@line 16968
 _putchar(111); //@line 16968
 _putchar(111); //@line 16968
 _putchar(32); //@line 16968
 _putchar(109); //@line 16968
 _putchar(97); //@line 16968
 _putchar(110); //@line 16968
 _putchar(121); //@line 16968
 _putchar(32); //@line 16968
 _putchar(115); //@line 16968
 _putchar(101); //@line 16968
 _putchar(116); //@line 16968
 _putchar(106); //@line 16968
 _putchar(109); //@line 16968
 _putchar(112); //@line 16968
 _putchar(115); //@line 16968
 _putchar(32); //@line 16968
 _putchar(105); //@line 16968
 _putchar(110); //@line 16968
 _putchar(32); //@line 16968
 _putchar(97); //@line 16968
 _putchar(32); //@line 16968
 _putchar(102); //@line 16968
 _putchar(117); //@line 16968
 _putchar(110); //@line 16968
 _putchar(99); //@line 16968
 _putchar(116); //@line 16968
 _putchar(105); //@line 16968
 _putchar(111); //@line 16968
 _putchar(110); //@line 16968
 _putchar(32); //@line 16968
 _putchar(99); //@line 16968
 _putchar(97); //@line 16968
 _putchar(108); //@line 16968
 _putchar(108); //@line 16968
 _putchar(44); //@line 16968
 _putchar(32); //@line 16968
 _putchar(98); //@line 16968
 _putchar(117); //@line 16968
 _putchar(105); //@line 16968
 _putchar(108); //@line 16968
 _putchar(100); //@line 16968
 _putchar(32); //@line 16968
 _putchar(119); //@line 16968
 _putchar(105); //@line 16968
 _putchar(116); //@line 16968
 _putchar(104); //@line 16968
 _putchar(32); //@line 16968
 _putchar(97); //@line 16968
 _putchar(32); //@line 16968
 _putchar(104); //@line 16968
 _putchar(105); //@line 16968
 _putchar(103); //@line 16968
 _putchar(104); //@line 16968
 _putchar(101); //@line 16968
 _putchar(114); //@line 16968
 _putchar(32); //@line 16968
 _putchar(118); //@line 16968
 _putchar(97); //@line 16968
 _putchar(108); //@line 16968
 _putchar(117); //@line 16968
 _putchar(101); //@line 16968
 _putchar(32); //@line 16968
 _putchar(102); //@line 16968
 _putchar(111); //@line 16968
 _putchar(114); //@line 16968
 _putchar(32); //@line 16968
 _putchar(77); //@line 16968
 _putchar(65); //@line 16968
 _putchar(88); //@line 16968
 _putchar(95); //@line 16968
 _putchar(83); //@line 16968
 _putchar(69); //@line 16968
 _putchar(84); //@line 16968
 _putchar(74); //@line 16968
 _putchar(77); //@line 16968
 _putchar(80); //@line 16968
 _putchar(83); //@line 16968
 _putchar(10); //@line 16968
 abort(0); //@line 16969
 return 0; //@line 16970
}
function _lua_compare($L, $index1, $index2, $op) {
 $L = $L | 0;
 $index1 = $index1 | 0;
 $index2 = $index2 | 0;
 $op = $op | 0;
 var $$0$i = 0, $$0$i2 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, $42 = 0, $43 = 0, $47 = 0, $64 = 0, $i$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1416
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1418
 do if (($index1 | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($index1 << 4) | 0; //@line 1423
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1428
 } else {
  if (($index1 | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($index1 << 4) | 0; //@line 1435
   break;
  }
  if (($index1 | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1443
   break;
  }
  $16 = -1001e3 - $index1 | 0; //@line 1446
  $17 = HEAP32[$1 >> 2] | 0; //@line 1447
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1452
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1454
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1460
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1464
  }
 } while (0);
 do if (($index2 | 0) > 0) {
  $30 = (HEAP32[$1 >> 2] | 0) + ($index2 << 4) | 0; //@line 1473
  $$0$i2 = $30 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $30 : 8048; //@line 1478
 } else {
  if (($index2 | 0) >= -1000999) {
   $$0$i2 = (HEAP32[$L + 8 >> 2] | 0) + ($index2 << 4) | 0; //@line 1485
   break;
  }
  if (($index2 | 0) == -1001e3) {
   $$0$i2 = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1493
   break;
  }
  $42 = -1001e3 - $index2 | 0; //@line 1496
  $43 = HEAP32[$1 >> 2] | 0; //@line 1497
  if ((HEAP32[$43 + 8 >> 2] | 0) == 22) {
   $i$0 = 0; //@line 1502
   STACKTOP = sp; //@line 1503
   return $i$0 | 0; //@line 1503
  }
  $47 = HEAP32[$43 >> 2] | 0; //@line 1505
  if (($42 | 0) > (HEAPU8[$47 + 6 >> 0] | 0 | 0)) {
   $i$0 = 0; //@line 1511
   STACKTOP = sp; //@line 1512
   return $i$0 | 0; //@line 1512
  } else {
   $$0$i2 = $47 + ($42 + -1 << 4) + 16 | 0; //@line 1516
   break;
  }
 } while (0);
 if (($$0$i | 0) == 8048 | ($$0$i2 | 0) == 8048) {
  $i$0 = 0; //@line 1525
  STACKTOP = sp; //@line 1526
  return $i$0 | 0; //@line 1526
 }
 if (!$op) {
  if ((HEAP32[$$0$i + 8 >> 2] | 0) == (HEAP32[$$0$i2 + 8 >> 2] | 0)) $64 = (_luaV_equalobj_($L, $$0$i, $$0$i2) | 0) != 0; //@line 1537
 else $64 = 0; //@line 1539
  $i$0 = $64 & 1; //@line 1542
  STACKTOP = sp; //@line 1543
  return $i$0 | 0; //@line 1543
 } else if (($op | 0) == 1) {
  $i$0 = _luaV_lessthan($L, $$0$i, $$0$i2) | 0; //@line 1546
  STACKTOP = sp; //@line 1547
  return $i$0 | 0; //@line 1547
 } else if (($op | 0) == 2) {
  $i$0 = _luaV_lessequal($L, $$0$i, $$0$i2) | 0; //@line 1550
  STACKTOP = sp; //@line 1551
  return $i$0 | 0; //@line 1551
 } else {
  $i$0 = 0; //@line 1553
  STACKTOP = sp; //@line 1554
  return $i$0 | 0; //@line 1554
 }
 return 0; //@line 1556
}
function _lua_gc($L, $what, $data) {
 $L = $L | 0;
 $what = $what | 0;
 $data = $data | 0;
 var $$ = 0, $1 = 0, $22 = 0, $24 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $debt$0 = 0, $res$0 = 0, sp = 0;
 sp = STACKTOP; //@line 4644
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 4646
 L1 : do switch ($what | 0) {
 case 2:
  {
   _luaC_fullgc($L, 0); //@line 4650
   $res$0 = 0; //@line 4651
   break;
  }
 case 3:
  {
   $res$0 = ((HEAP32[$1 + 12 >> 2] | 0) + (HEAP32[$1 + 8 >> 2] | 0) | 0) >>> 10; //@line 4661
   break;
  }
 case 5:
  {
   if ((HEAP8[$1 + 62 >> 0] | 0) == 2) {
    $22 = (HEAP32[$1 + 20 >> 2] | 0) == 0 & 1; //@line 4672
    _luaC_forcestep($L); //@line 4673
    $res$0 = $22; //@line 4674
    break L1;
   }
   $24 = ($data << 10) + -1600 | 0; //@line 4678
   if (!(HEAP8[$1 + 63 >> 0] | 0)) {
    $debt$0 = $24; //@line 4683
    _luaE_setdebt($1, $debt$0); //@line 4684
    _luaC_forcestep($L); //@line 4685
    $31 = $1 + 61 | 0; //@line 4686
    $32 = HEAP8[$31 >> 0] | 0; //@line 4687
    $33 = $32 << 24 >> 24 == 5; //@line 4688
    $$ = $33 & 1; //@line 4689
    STACKTOP = sp; //@line 4690
    return $$ | 0; //@line 4690
   }
   $debt$0 = (HEAP32[$1 + 12 >> 2] | 0) + $24 | 0; //@line 4695
   _luaE_setdebt($1, $debt$0); //@line 4696
   _luaC_forcestep($L); //@line 4697
   $31 = $1 + 61 | 0; //@line 4698
   $32 = HEAP8[$31 >> 0] | 0; //@line 4699
   $33 = $32 << 24 >> 24 == 5; //@line 4700
   $$ = $33 & 1; //@line 4701
   STACKTOP = sp; //@line 4702
   return $$ | 0; //@line 4702
  }
 case 4:
  {
   $res$0 = (HEAP32[$1 + 12 >> 2] | 0) + (HEAP32[$1 + 8 >> 2] | 0) & 1023; //@line 4712
   break;
  }
 case 0:
  {
   HEAP8[$1 + 63 >> 0] = 0; //@line 4717
   $res$0 = 0; //@line 4718
   break;
  }
 case 1:
  {
   _luaE_setdebt($1, 0); //@line 4722
   HEAP8[$1 + 63 >> 0] = 1; //@line 4724
   $res$0 = 0; //@line 4725
   break;
  }
 case 6:
  {
   $34 = $1 + 156 | 0; //@line 4729
   $35 = HEAP32[$34 >> 2] | 0; //@line 4730
   HEAP32[$34 >> 2] = $data; //@line 4731
   $res$0 = $35; //@line 4732
   break;
  }
 case 8:
  {
   $36 = $1 + 160 | 0; //@line 4736
   $37 = HEAP32[$36 >> 2] | 0; //@line 4737
   HEAP32[$36 >> 2] = $data; //@line 4738
   $res$0 = $37; //@line 4739
   break;
  }
 case 7:
  {
   $38 = $1 + 164 | 0; //@line 4743
   $39 = HEAP32[$38 >> 2] | 0; //@line 4744
   HEAP32[$38 >> 2] = $data; //@line 4745
   $res$0 = $39; //@line 4746
   break;
  }
 case 9:
  {
   $res$0 = HEAPU8[$1 + 63 >> 0] | 0; //@line 4753
   break;
  }
 case 10:
  {
   _luaC_changemode($L, 2); //@line 4757
   $res$0 = 0; //@line 4758
   break;
  }
 case 11:
  {
   _luaC_changemode($L, 0); //@line 4762
   $res$0 = 0; //@line 4763
   break;
  }
 default:
  $res$0 = -1; //@line 4767
 } while (0);
 STACKTOP = sp; //@line 4771
 return $res$0 | 0; //@line 4771
}
function _addk($fs, $key, $v) {
 $fs = $fs | 0;
 $key = $key | 0;
 $v = $v | 0;
 var $$0 = 0, $13 = 0, $15 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $29 = 0, $3 = 0, $31 = 0, $35 = 0, $37 = 0, $43 = 0, $48 = 0, $49 = 0, $53 = 0, $6 = 0, $61 = 0, $7 = 0, $8 = 0, $oldsize$01 = 0, $u$sroa$0 = 0, sp = 0;
 sp = STACKTOP; //@line 9440
 STACKTOP = STACKTOP + 16 | 0; //@line 9441
 $u$sroa$0 = sp; //@line 9442
 $3 = HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0; //@line 9446
 $6 = _luaH_set($3, HEAP32[$fs + 4 >> 2] | 0, $key) | 0; //@line 9449
 $7 = HEAP32[$fs >> 2] | 0; //@line 9450
 $8 = $6 + 8 | 0; //@line 9451
 if ((HEAP32[$8 >> 2] | 0) == 3) {
  HEAPF64[$u$sroa$0 >> 3] = +HEAPF64[$6 >> 3] + 6755399441055744.0; //@line 9457
  $13 = HEAP32[$u$sroa$0 >> 2] | 0; //@line 9458
  $15 = HEAP32[$7 + 8 >> 2] | 0; //@line 9460
  if ((HEAP32[$15 + ($13 << 4) + 8 >> 2] | 0) == (HEAP32[$v + 8 >> 2] | 0)) if (_luaV_equalobj_(0, $15 + ($13 << 4) | 0, $v) | 0) {
   $$0 = $13; //@line 9471
   STACKTOP = sp; //@line 9472
   return $$0 | 0; //@line 9472
  }
 }
 $24 = $7 + 44 | 0; //@line 9476
 $25 = HEAP32[$24 >> 2] | 0; //@line 9477
 $26 = $fs + 32 | 0; //@line 9478
 $27 = HEAP32[$26 >> 2] | 0; //@line 9479
 HEAPF64[$6 >> 3] = +($27 | 0); //@line 9481
 HEAP32[$8 >> 2] = 3; //@line 9482
 $29 = HEAP32[$24 >> 2] | 0; //@line 9483
 if (($27 | 0) < ($29 | 0)) $35 = $29; //@line 9486
 else {
  $31 = $7 + 8 | 0; //@line 9488
  HEAP32[$31 >> 2] = _luaM_growaux_($3, HEAP32[$31 >> 2] | 0, $24, 16, 67108863, 2384) | 0; //@line 9491
  $35 = HEAP32[$24 >> 2] | 0; //@line 9493
 }
 $37 = HEAP32[$7 + 8 >> 2] | 0; //@line 9497
 if (($25 | 0) < ($35 | 0)) {
  $oldsize$01 = $25; //@line 9499
  do {
   HEAP32[$37 + ($oldsize$01 << 4) + 8 >> 2] = 0; //@line 9503
   $oldsize$01 = $oldsize$01 + 1 | 0; //@line 9501
  } while (($oldsize$01 | 0) < (HEAP32[$24 >> 2] | 0));
 }
 $43 = $v; //@line 9514
 $48 = HEAP32[$43 + 4 >> 2] | 0; //@line 9519
 $49 = $37 + ($27 << 4) | 0; //@line 9520
 HEAP32[$49 >> 2] = HEAP32[$43 >> 2]; //@line 9522
 HEAP32[$49 + 4 >> 2] = $48; //@line 9525
 $53 = $v + 8 | 0; //@line 9526
 HEAP32[$37 + ($27 << 4) + 8 >> 2] = HEAP32[$53 >> 2]; //@line 9529
 HEAP32[$26 >> 2] = (HEAP32[$26 >> 2] | 0) + 1; //@line 9532
 if (!(HEAP32[$53 >> 2] & 64)) {
  $$0 = $27; //@line 9537
  STACKTOP = sp; //@line 9538
  return $$0 | 0; //@line 9538
 }
 $61 = HEAP32[$v >> 2] | 0; //@line 9540
 if (!(HEAP8[$61 + 5 >> 0] & 3)) {
  $$0 = $27; //@line 9546
  STACKTOP = sp; //@line 9547
  return $$0 | 0; //@line 9547
 }
 if (!(HEAP8[$7 + 5 >> 0] & 4)) {
  $$0 = $27; //@line 9554
  STACKTOP = sp; //@line 9555
  return $$0 | 0; //@line 9555
 }
 _luaC_barrier_($3, $7, $61); //@line 9557
 $$0 = $27; //@line 9558
 STACKTOP = sp; //@line 9559
 return $$0 | 0; //@line 9559
}
function _singlevaraux($fs, $n, $var, $base) {
 $fs = $fs | 0;
 $n = $n | 0;
 $var = $var | 0;
 $base = $base | 0;
 var $$0 = 0, $24 = 0, $25 = 0, $31 = 0, $bl$0$in$i = 0, $fs$idx$val$i = 0, $fs$idx1$i = 0, $fs$idx2$i = 0, $i$0$in$i = 0, $i$01$i = 0, $idx$0 = 0, label = 0, sp = 0, $i$0$in$i$looptemp = 0;
 sp = STACKTOP; //@line 12034
 if (!$fs) {
  $$0 = 0; //@line 12037
  STACKTOP = sp; //@line 12038
  return $$0 | 0; //@line 12038
 }
 $fs$idx1$i = $fs + 12 | 0; //@line 12043
 $fs$idx2$i = $fs + 40 | 0; //@line 12044
 $i$0$in$i = HEAPU8[$fs + 46 >> 0] | 0; //@line 12045
 while (1) {
  $i$0$in$i$looptemp = $i$0$in$i;
  $i$0$in$i = $i$0$in$i + -1 | 0; //@line 12047
  $fs$idx$val$i = HEAP32[$fs >> 2] | 0; //@line 12049
  if (($i$0$in$i$looptemp | 0) <= 0) break;
  if (_luaS_eqstr($n, HEAP32[(HEAP32[$fs$idx$val$i + 24 >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[(HEAP32[$fs$idx1$i >> 2] | 0) + 64 >> 2] >> 2] | 0) + ((HEAP32[$fs$idx2$i >> 2] | 0) + $i$0$in$i << 1) >> 1] | 0) * 12 | 0) >> 2] | 0) | 0) {
   label = 5; //@line 12071
   break;
  }
 }
 if ((label | 0) == 5) {
  HEAP32[$var + 16 >> 2] = -1; //@line 12077
  HEAP32[$var + 20 >> 2] = -1; //@line 12079
  HEAP32[$var >> 2] = 7; //@line 12080
  HEAP32[$var + 8 >> 2] = $i$0$in$i; //@line 12082
  if ($base) {
   $$0 = 7; //@line 12085
   STACKTOP = sp; //@line 12086
   return $$0 | 0; //@line 12086
  }
  $bl$0$in$i = $fs + 16 | 0; //@line 12089
  do $bl$0$in$i = HEAP32[$bl$0$in$i >> 2] | 0; //@line 12091
 while ((HEAPU8[$bl$0$in$i + 8 >> 0] | 0) > ($i$0$in$i | 0));
  HEAP8[$bl$0$in$i + 9 >> 0] = 1; //@line 12103
  $$0 = 7; //@line 12104
  STACKTOP = sp; //@line 12105
  return $$0 | 0; //@line 12105
 }
 $24 = HEAP32[$fs$idx$val$i + 28 >> 2] | 0; //@line 12108
 $25 = $fs + 47 | 0; //@line 12109
 L17 : do if (!(HEAP8[$25 >> 0] | 0)) label = 13; //@line 12114
 else {
  $i$01$i = 0; //@line 12116
  while (1) {
   $31 = $i$01$i + 1 | 0; //@line 12122
   if (_luaS_eqstr(HEAP32[$24 + ($i$01$i << 3) >> 2] | 0, $n) | 0) break;
   if (($31 | 0) < (HEAPU8[$25 >> 0] | 0)) $i$01$i = $31; //@line 12130
 else {
    label = 13; //@line 12132
    break L17;
   }
  }
  if (($i$01$i | 0) < 0) label = 13; //@line 12138
 else $idx$0 = $i$01$i; //@line 12140
 } while (0);
 do if ((label | 0) == 13) if (!(_singlevaraux(HEAP32[$fs + 8 >> 2] | 0, $n, $var, 0) | 0)) {
  $$0 = 0; //@line 12151
  STACKTOP = sp; //@line 12152
  return $$0 | 0; //@line 12152
 } else {
  $idx$0 = _newupvalue($fs, $n, $var) | 0; //@line 12155
  break;
 } while (0);
 HEAP32[$var + 16 >> 2] = -1; //@line 12161
 HEAP32[$var + 20 >> 2] = -1; //@line 12163
 HEAP32[$var >> 2] = 8; //@line 12164
 HEAP32[$var + 8 >> 2] = $idx$0; //@line 12166
 $$0 = 8; //@line 12167
 STACKTOP = sp; //@line 12168
 return $$0 | 0; //@line 12168
}
function _luaS_resize($L, $newsize) {
 $L = $L | 0;
 $newsize = $newsize | 0;
 var $$lcssa = 0, $1 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $2 = 0, $21 = 0, $22 = 0, $27 = 0, $3 = 0, $33 = 0, $4 = 0, $41 = 0, $49 = 0, $7 = 0, $8 = 0, $i$05 = 0, $i$12 = 0, $p$01 = 0, sp = 0, $p$01$looptemp = 0;
 sp = STACKTOP; //@line 13211
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 13213
 $2 = $1 + 24 | 0; //@line 13214
 _luaC_runtilstate($L, -5); //@line 13215
 $3 = $1 + 32 | 0; //@line 13216
 $4 = HEAP32[$3 >> 2] | 0; //@line 13217
 L1 : do if (($4 | 0) < ($newsize | 0)) {
  if (($newsize + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($L); //@line 13224
  $14 = _luaM_realloc_($L, HEAP32[$2 >> 2] | 0, $4 << 2, $newsize << 2) | 0; //@line 13230
  HEAP32[$2 >> 2] = $14; //@line 13231
  $15 = HEAP32[$3 >> 2] | 0; //@line 13232
  if (($15 | 0) < ($newsize | 0)) {
   $18 = $14; //@line 13235
   $i$05 = $15; //@line 13235
   while (1) {
    HEAP32[$18 + ($i$05 << 2) >> 2] = 0; //@line 13238
    $19 = $i$05 + 1 | 0; //@line 13239
    if (($19 | 0) == ($newsize | 0)) {
     $7 = $15; //@line 13242
     break L1;
    }
    $18 = HEAP32[$2 >> 2] | 0; //@line 13246
    $i$05 = $19; //@line 13246
   }
  } else $7 = $15; //@line 13249
 } else $7 = $4; //@line 13252
 while (0);
 if (($7 | 0) > 0) {
  $8 = $newsize + -1 | 0; //@line 13257
  $49 = $7; //@line 13258
  $i$12 = 0; //@line 13258
  while (1) {
   $21 = (HEAP32[$2 >> 2] | 0) + ($i$12 << 2) | 0; //@line 13261
   $22 = HEAP32[$21 >> 2] | 0; //@line 13262
   HEAP32[$21 >> 2] = 0; //@line 13263
   if (!$22) $41 = $49; //@line 13266
 else {
    $p$01 = $22; //@line 13268
    do {
     $p$01$looptemp = $p$01;
     $p$01 = HEAP32[$p$01 >> 2] | 0; //@line 13270
     $27 = HEAP32[$p$01$looptemp + 8 >> 2] & $8; //@line 13273
     HEAP32[$p$01$looptemp >> 2] = HEAP32[(HEAP32[$2 >> 2] | 0) + ($27 << 2) >> 2]; //@line 13277
     HEAP32[(HEAP32[$2 >> 2] | 0) + ($27 << 2) >> 2] = $p$01$looptemp; //@line 13280
     $33 = $p$01$looptemp + 5 | 0; //@line 13281
     HEAP8[$33 >> 0] = (HEAPU8[$33 >> 0] | 0) & 191; //@line 13286
    } while (($p$01 | 0) != 0);
    $41 = HEAP32[$3 >> 2] | 0; //@line 13295
   }
   $i$12 = $i$12 + 1 | 0; //@line 13297
   if (($i$12 | 0) >= ($41 | 0)) {
    $$lcssa = $41; //@line 13302
    break;
   } else $49 = $41; //@line 13300
  }
 } else $$lcssa = $7; //@line 13307
 if (($$lcssa | 0) <= ($newsize | 0)) {
  HEAP32[$3 >> 2] = $newsize; //@line 13311
  STACKTOP = sp; //@line 13312
  return;
 }
 if (($newsize + 1 | 0) >>> 0 > 1073741823) _luaM_toobig($L); //@line 13317
 HEAP32[$2 >> 2] = _luaM_realloc_($L, HEAP32[$2 >> 2] | 0, $$lcssa << 2, $newsize << 2) | 0; //@line 13324
 HEAP32[$3 >> 2] = $newsize; //@line 13325
 STACKTOP = sp; //@line 13326
 return;
}
function _lua_copy($L, $fromidx, $toidx) {
 $L = $L | 0;
 $fromidx = $fromidx | 0;
 $toidx = $toidx | 0;
 var $$0$i = 0, $$0$i2 = 0, $0 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, $42 = 0, $43 = 0, $47 = 0, $54 = 0, $59 = 0, $60 = 0, $64 = 0, $71 = 0, $78 = 0, sp = 0;
 sp = STACKTOP; //@line 612
 $0 = $L + 16 | 0; //@line 613
 $1 = HEAP32[$0 >> 2] | 0; //@line 614
 do if (($fromidx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($fromidx << 4) | 0; //@line 619
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 624
 } else {
  if (($fromidx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($fromidx << 4) | 0; //@line 631
   break;
  }
  if (($fromidx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 639
   break;
  }
  $16 = -1001e3 - $fromidx | 0; //@line 642
  $17 = HEAP32[$1 >> 2] | 0; //@line 643
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 648
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 650
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 656
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 660
  }
 } while (0);
 do if (($toidx | 0) > 0) {
  $30 = (HEAP32[$1 >> 2] | 0) + ($toidx << 4) | 0; //@line 669
  $$0$i2 = $30 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $30 : 8048; //@line 674
 } else {
  if (($toidx | 0) >= -1000999) {
   $$0$i2 = (HEAP32[$L + 8 >> 2] | 0) + ($toidx << 4) | 0; //@line 681
   break;
  }
  if (($toidx | 0) == -1001e3) {
   $$0$i2 = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 689
   break;
  }
  $42 = -1001e3 - $toidx | 0; //@line 692
  $43 = HEAP32[$1 >> 2] | 0; //@line 693
  if ((HEAP32[$43 + 8 >> 2] | 0) == 22) $$0$i2 = 8048; //@line 698
 else {
   $47 = HEAP32[$43 >> 2] | 0; //@line 700
   if (($42 | 0) > (HEAPU8[$47 + 6 >> 0] | 0 | 0)) $$0$i2 = 8048; //@line 706
 else $$0$i2 = $47 + ($42 + -1 << 4) + 16 | 0; //@line 710
  }
 } while (0);
 $54 = $$0$i; //@line 715
 $59 = HEAP32[$54 + 4 >> 2] | 0; //@line 720
 $60 = $$0$i2; //@line 721
 HEAP32[$60 >> 2] = HEAP32[$54 >> 2]; //@line 723
 HEAP32[$60 + 4 >> 2] = $59; //@line 726
 $64 = $$0$i + 8 | 0; //@line 727
 HEAP32[$$0$i2 + 8 >> 2] = HEAP32[$64 >> 2]; //@line 730
 if (($toidx | 0) >= -1001e3) {
  STACKTOP = sp; //@line 733
  return;
 }
 if (!(HEAP32[$64 >> 2] & 64)) {
  STACKTOP = sp; //@line 739
  return;
 }
 $71 = HEAP32[$$0$i >> 2] | 0; //@line 741
 if (!(HEAP8[$71 + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 747
  return;
 }
 $78 = HEAP32[HEAP32[HEAP32[$0 >> 2] >> 2] >> 2] | 0; //@line 751
 if (!(HEAP8[$78 + 5 >> 0] & 4)) {
  STACKTOP = sp; //@line 757
  return;
 }
 _luaC_barrier_($L, $78, $71); //@line 759
 STACKTOP = sp; //@line 760
 return;
}
function _lua_tolstring($L, $idx, $len) {
 $L = $L | 0;
 $idx = $idx | 0;
 $len = $len | 0;
 var $$0 = 0, $$0$i = 0, $$pre = 0, $0 = 0, $1 = 0, $16 = 0, $17 = 0, $2 = 0, $21 = 0, $35 = 0, $4 = 0, $40 = 0, $42 = 0, $53 = 0, $54 = 0, $58 = 0, $o$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1926
 $0 = $L + 16 | 0; //@line 1927
 $1 = HEAP32[$0 >> 2] | 0; //@line 1928
 $2 = ($idx | 0) > 0; //@line 1929
 do if ($2) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1933
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1938
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1945
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1953
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1956
  $17 = HEAP32[$1 >> 2] | 0; //@line 1957
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1962
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1964
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1970
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1974
  }
 } while (0);
 do if ((HEAP32[$$0$i + 8 >> 2] & 15 | 0) == 4) $o$0 = $$0$i; //@line 1985
 else {
  if (!(_luaV_tostring($L, $$0$i) | 0)) {
   if (!$len) {
    $$0 = 0; //@line 1992
    STACKTOP = sp; //@line 1993
    return $$0 | 0; //@line 1993
   }
   HEAP32[$len >> 2] = 0; //@line 1995
   $$0 = 0; //@line 1996
   STACKTOP = sp; //@line 1997
   return $$0 | 0; //@line 1997
  }
  $35 = $L + 12 | 0; //@line 1999
  if ((HEAP32[(HEAP32[$35 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2005
  $40 = HEAP32[$0 >> 2] | 0; //@line 2007
  if ($2) {
   $42 = (HEAP32[$40 >> 2] | 0) + ($idx << 4) | 0; //@line 2010
   $o$0 = $42 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $42 : 8048; //@line 2015
   break;
  }
  if (($idx | 0) >= -1000999) {
   $o$0 = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2023
   break;
  }
  if (($idx | 0) == -1001e3) {
   $o$0 = (HEAP32[$35 >> 2] | 0) + 40 | 0; //@line 2030
   break;
  }
  $53 = -1001e3 - $idx | 0; //@line 2033
  $54 = HEAP32[$40 >> 2] | 0; //@line 2034
  if ((HEAP32[$54 + 8 >> 2] | 0) == 22) $o$0 = 8048; //@line 2039
 else {
   $58 = HEAP32[$54 >> 2] | 0; //@line 2041
   if (($53 | 0) > (HEAPU8[$58 + 6 >> 0] | 0 | 0)) $o$0 = 8048; //@line 2047
 else $o$0 = $58 + ($53 + -1 << 4) + 16 | 0; //@line 2051
  }
 } while (0);
 $$pre = HEAP32[$o$0 >> 2] | 0; //@line 2057
 if ($len) HEAP32[$len >> 2] = HEAP32[$$pre + 12 >> 2]; //@line 2061
 $$0 = $$pre + 16 | 0; //@line 2064
 STACKTOP = sp; //@line 2065
 return $$0 | 0; //@line 2065
}
function _mainposition($t, $key) {
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $10 = 0, $23 = 0, $24 = 0, $30 = 0, $34 = 0, $8 = 0, $i$1$i = 0, $u$sroa$0$i = 0, sp = 0;
 sp = STACKTOP; //@line 17262
 STACKTOP = STACKTOP + 16 | 0; //@line 17263
 $u$sroa$0$i = sp; //@line 17264
 switch (HEAP32[$key + 8 >> 2] & 63 | 0) {
 case 1:
  {
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + (((1 << HEAPU8[$t + 7 >> 0]) + -1 & HEAP32[$key >> 2]) << 5) | 0; //@line 17280
   STACKTOP = sp; //@line 17281
   return $$0 | 0; //@line 17281
  }
 case 22:
  {
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + ((((HEAP32[$key >> 2] | 0) >>> 0) % (((1 << HEAPU8[$t + 7 >> 0]) + -1 | 1) >>> 0) | 0) << 5) | 0; //@line 17297
   STACKTOP = sp; //@line 17298
   return $$0 | 0; //@line 17298
  }
 case 20:
  {
   $23 = HEAP32[$key >> 2] | 0; //@line 17302
   $24 = $23 + 6 | 0; //@line 17303
   if (!(HEAP8[$24 >> 0] | 0)) {
    $30 = $23 + 8 | 0; //@line 17310
    HEAP32[$30 >> 2] = _luaS_hash($23 + 16 | 0, HEAP32[$23 + 12 >> 2] | 0, HEAP32[$30 >> 2] | 0) | 0; //@line 17314
    HEAP8[$24 >> 0] = 1; //@line 17315
    $34 = HEAP32[$key >> 2] | 0; //@line 17317
   } else $34 = $23; //@line 17319
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + (((1 << HEAPU8[$t + 7 >> 0]) + -1 & HEAP32[$34 + 8 >> 2]) << 5) | 0; //@line 17332
   STACKTOP = sp; //@line 17333
   return $$0 | 0; //@line 17333
  }
 case 3:
  {
   HEAPF64[$u$sroa$0$i >> 3] = +HEAPF64[$key >> 3] + 1.0; //@line 17339
   $8 = (HEAP32[$u$sroa$0$i + 4 >> 2] | 0) + (HEAP32[$u$sroa$0$i >> 2] | 0) | 0; //@line 17343
   if (($8 | 0) < 0) {
    $10 = 0 - $8 | 0; //@line 17346
    $i$1$i = ($8 | 0) == ($10 | 0) ? 0 : $10; //@line 17349
   } else $i$1$i = $8; //@line 17351
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + ((($i$1$i | 0) % ((1 << HEAPU8[$t + 7 >> 0]) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17363
   STACKTOP = sp; //@line 17364
   return $$0 | 0; //@line 17364
  }
 case 4:
  {
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + (((1 << HEAPU8[$t + 7 >> 0]) + -1 & HEAP32[(HEAP32[$key >> 2] | 0) + 8 >> 2]) << 5) | 0; //@line 17380
   STACKTOP = sp; //@line 17381
   return $$0 | 0; //@line 17381
  }
 case 2:
  {
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + ((((HEAP32[$key >> 2] | 0) >>> 0) % (((1 << HEAPU8[$t + 7 >> 0]) + -1 | 1) >>> 0) | 0) << 5) | 0; //@line 17397
   STACKTOP = sp; //@line 17398
   return $$0 | 0; //@line 17398
  }
 default:
  {
   $$0 = (HEAP32[$t + 16 >> 2] | 0) + ((((HEAP32[$key >> 2] | 0) >>> 0) % (((1 << HEAPU8[$t + 7 >> 0]) + -1 | 1) >>> 0) | 0) << 5) | 0; //@line 17414
   STACKTOP = sp; //@line 17415
   return $$0 | 0; //@line 17415
  }
 }
 return 0; //@line 17418
}
function _luaM_growaux_($L, $block, $size, $size_elems, $limit, $what) {
 $L = $L | 0;
 $block = $block | 0;
 $size = $size | 0;
 $size_elems = $size_elems | 0;
 $limit = $limit | 0;
 $what = $what | 0;
 var $$neg$i = 0, $0 = 0, $10 = 0, $12 = 0, $13 = 0, $15 = 0, $17 = 0, $25 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $4 = 0, $9 = 0, $newblock$1$i = 0, $newsize$0 = 0, $osize$op$i = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6236
 STACKTOP = STACKTOP + 16 | 0; //@line 6237
 $vararg_buffer = sp; //@line 6238
 $0 = HEAP32[$size >> 2] | 0; //@line 6239
 if (($0 | 0) < (($limit | 0) / 2 | 0 | 0)) {
  $4 = $0 << 1; //@line 6243
  $newsize$0 = ($4 | 0) < 4 ? 4 : $4; //@line 6246
 } else if (($0 | 0) < ($limit | 0)) $newsize$0 = $limit; //@line 6250
 else {
  HEAP32[$vararg_buffer >> 2] = $what; //@line 6252
  HEAP32[$vararg_buffer + 4 >> 2] = $limit; //@line 6254
  _luaG_runerror($L, 6968, $vararg_buffer); //@line 6255
 }
 if (($newsize$0 + 1 | 0) >>> 0 > (4294967293 / ($size_elems >>> 0) | 0) >>> 0) _luaM_toobig($L); //@line 6263
 $9 = Math_imul($0, $size_elems) | 0; //@line 6266
 $10 = Math_imul($newsize$0, $size_elems) | 0; //@line 6267
 $12 = HEAP32[$L + 12 >> 2] | 0; //@line 6269
 $13 = ($block | 0) != 0; //@line 6270
 $15 = $12 + 4 | 0; //@line 6272
 $17 = FUNCTION_TABLE_iiiii[HEAP32[$12 >> 2] & 31](HEAP32[$15 >> 2] | 0, $block, $9, $10) | 0; //@line 6274
 if (($17 | 0) != 0 | ($10 | 0) == 0) {
  $newblock$1$i = $17; //@line 6279
  $27 = $12 + 12 | 0; //@line 6280
  $28 = HEAP32[$27 >> 2] | 0; //@line 6281
  $osize$op$i = 0 - $9 | 0; //@line 6282
  $$neg$i = $13 ? $osize$op$i : 0; //@line 6283
  $29 = $$neg$i + $10 | 0; //@line 6284
  $30 = $29 + $28 | 0; //@line 6285
  HEAP32[$27 >> 2] = $30; //@line 6286
  HEAP32[$size >> 2] = $newsize$0; //@line 6287
  STACKTOP = sp; //@line 6288
  return $newblock$1$i | 0; //@line 6288
 }
 if (!(HEAP8[$12 + 63 >> 0] | 0)) _luaD_throw($L, 4); //@line 6294
 _luaC_fullgc($L, 1); //@line 6297
 $25 = FUNCTION_TABLE_iiiii[HEAP32[$12 >> 2] & 31](HEAP32[$15 >> 2] | 0, $block, $9, $10) | 0; //@line 6300
 if (!$25) _luaD_throw($L, 4); //@line 6303
 else {
  $newblock$1$i = $25; //@line 6306
  $27 = $12 + 12 | 0; //@line 6307
  $28 = HEAP32[$27 >> 2] | 0; //@line 6308
  $osize$op$i = 0 - $9 | 0; //@line 6309
  $$neg$i = $13 ? $osize$op$i : 0; //@line 6310
  $29 = $$neg$i + $10 | 0; //@line 6311
  $30 = $29 + $28 | 0; //@line 6312
  HEAP32[$27 >> 2] = $30; //@line 6313
  HEAP32[$size >> 2] = $newsize$0; //@line 6314
  STACKTOP = sp; //@line 6315
  return $newblock$1$i | 0; //@line 6315
 }
 return 0; //@line 6317
}
function _luaO_chunkid($out, $source, $bufflen) {
 $out = $out | 0;
 $source = $source | 0;
 $bufflen = $bufflen | 0;
 var $$0 = 0, $$l$0 = 0, $$sum2$pn = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $13 = 0, $15 = 0, $20 = 0, $3 = 0, $4 = 0, $l$0 = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP; //@line 7652
 $0 = _strlen($source | 0) | 0; //@line 7653
 $1 = HEAP8[$source >> 0] | 0; //@line 7654
 if ($1 << 24 >> 24 == 64) if ($0 >>> 0 > $bufflen >>> 0) {
  HEAP8[$out + 0 >> 0] = HEAP8[8408] | 0; //@line 7658
  HEAP8[$out + 1 >> 0] = HEAP8[8409] | 0; //@line 7658
  HEAP8[$out + 2 >> 0] = HEAP8[8410] | 0; //@line 7658
  _memcpy($out + 3 | 0, $source + (4 - $bufflen + $0) | 0, $bufflen + -3 | 0) | 0; //@line 7664
  STACKTOP = sp; //@line 7665
  return;
 } else {
  _memcpy($out | 0, $source + 1 | 0, $0 | 0) | 0; //@line 7668
  STACKTOP = sp; //@line 7669
  return;
 } else if ($1 << 24 >> 24 == 61) {
  $3 = $source + 1 | 0; //@line 7673
  if ($0 >>> 0 > $bufflen >>> 0) {
   $4 = $bufflen + -1 | 0; //@line 7675
   _memcpy($out | 0, $3 | 0, $4 | 0) | 0; //@line 7676
   HEAP8[$out + $4 >> 0] = 0; //@line 7678
   STACKTOP = sp; //@line 7679
   return;
  } else {
   _memcpy($out | 0, $3 | 0, $0 | 0) | 0; //@line 7681
   STACKTOP = sp; //@line 7682
   return;
  }
 } else {
  $11 = _strchr($source, 10) | 0; //@line 7685
  dest = $out + 0 | 0; //@line 7686
  src = 8416 | 0; //@line 7686
  stop = dest + 9 | 0; //@line 7686
  do {
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0; //@line 7686
   dest = dest + 1 | 0; //@line 7686
   src = src + 1 | 0; //@line 7686
  } while ((dest | 0) < (stop | 0));
  $12 = $out + 9 | 0; //@line 7687
  $13 = $bufflen + -15 | 0; //@line 7688
  $15 = ($11 | 0) == 0; //@line 7690
  if ($0 >>> 0 < $13 >>> 0 & $15) {
   _memcpy($12 | 0, $source | 0, $0 | 0) | 0; //@line 7693
   $$sum2$pn = $0 + 9 | 0; //@line 7695
  } else {
   if ($15) $l$0 = $0; //@line 7698
 else $l$0 = $11 - $source | 0; //@line 7703
   $$l$0 = $l$0 >>> 0 > $13 >>> 0 ? $13 : $l$0; //@line 7706
   _memcpy($12 | 0, $source | 0, $$l$0 | 0) | 0; //@line 7707
   $20 = $out + ($$l$0 + 9) | 0; //@line 7709
   HEAP8[$20 + 0 >> 0] = HEAP8[8408] | 0; //@line 7710
   HEAP8[$20 + 1 >> 0] = HEAP8[8409] | 0; //@line 7710
   HEAP8[$20 + 2 >> 0] = HEAP8[8410] | 0; //@line 7710
   $$sum2$pn = $$l$0 + 12 | 0; //@line 7712
  }
  $$0 = $out + $$sum2$pn | 0; //@line 7714
  HEAP8[$$0 + 0 >> 0] = HEAP8[8432] | 0; //@line 7715
  HEAP8[$$0 + 1 >> 0] = HEAP8[8433] | 0; //@line 7715
  HEAP8[$$0 + 2 >> 0] = HEAP8[8434] | 0; //@line 7715
  STACKTOP = sp; //@line 7716
  return;
 }
}
function _reallymarkobject($g, $o) {
 $g = $g | 0;
 $o = $o | 0;
 var $0 = 0, $12 = 0, $19 = 0, $28 = 0, $29 = 0, $34 = 0, $41 = 0, $42 = 0, $45 = 0, $48 = 0, $51 = 0, $54 = 0, $61 = 0, $size$0 = 0, sp = 0;
 sp = STACKTOP; //@line 18747
 $0 = $o + 5 | 0; //@line 18748
 HEAP8[$0 >> 0] = (HEAPU8[$0 >> 0] | 0) & 252; //@line 18753
 switch (HEAPU8[$o + 4 >> 0] | 0 | 0) {
 case 38:
  {
   $45 = $g + 84 | 0; //@line 18759
   HEAP32[$o + 8 >> 2] = HEAP32[$45 >> 2]; //@line 18762
   HEAP32[$45 >> 2] = $o; //@line 18763
   STACKTOP = sp; //@line 18764
   return;
  }
 case 8:
  {
   $51 = $g + 84 | 0; //@line 18768
   HEAP32[$o + 60 >> 2] = HEAP32[$51 >> 2]; //@line 18771
   HEAP32[$51 >> 2] = $o; //@line 18772
   STACKTOP = sp; //@line 18773
   return;
  }
 case 7:
  {
   $12 = HEAP32[$o + 8 >> 2] | 0; //@line 18778
   if ($12) if (HEAP8[$12 + 5 >> 0] & 3) _reallymarkobject($g, $12); //@line 18786
   $19 = HEAP32[$o + 12 >> 2] | 0; //@line 18790
   if ($19) if (HEAP8[$19 + 5 >> 0] & 3) _reallymarkobject($g, $19); //@line 18798
   $size$0 = (HEAP32[$o + 16 >> 2] | 0) + 24 | 0; //@line 18804
   break;
  }
 case 20:
 case 4:
  {
   $size$0 = (HEAP32[$o + 12 >> 2] | 0) + 17 | 0; //@line 18811
   break;
  }
 case 9:
  {
   $54 = $g + 84 | 0; //@line 18815
   HEAP32[$o + 72 >> 2] = HEAP32[$54 >> 2]; //@line 18818
   HEAP32[$54 >> 2] = $o; //@line 18819
   STACKTOP = sp; //@line 18820
   return;
  }
 case 10:
  {
   $28 = $o + 8 | 0; //@line 18824
   $29 = HEAP32[$28 >> 2] | 0; //@line 18825
   if (!(HEAP32[$29 + 8 >> 2] & 64)) $41 = $29; //@line 18831
 else {
    $34 = HEAP32[$29 >> 2] | 0; //@line 18833
    if (!(HEAP8[$34 + 5 >> 0] & 3)) $41 = $29; //@line 18839
 else {
     _reallymarkobject($g, $34); //@line 18841
     $41 = HEAP32[$28 >> 2] | 0; //@line 18843
    }
   }
   if (($41 | 0) == ($o + 16 | 0)) $size$0 = 32; //@line 18849
 else {
    STACKTOP = sp; //@line 18851
    return;
   }
   break;
  }
 case 5:
  {
   $48 = $g + 84 | 0; //@line 18856
   HEAP32[$o + 24 >> 2] = HEAP32[$48 >> 2]; //@line 18860
   HEAP32[$48 >> 2] = $o; //@line 18861
   STACKTOP = sp; //@line 18862
   return;
  }
 case 6:
  {
   $42 = $g + 84 | 0; //@line 18866
   HEAP32[$o + 8 >> 2] = HEAP32[$42 >> 2]; //@line 18869
   HEAP32[$42 >> 2] = $o; //@line 18870
   STACKTOP = sp; //@line 18871
   return;
  }
 default:
  {
   STACKTOP = sp; //@line 18875
   return;
  }
 }
 HEAP8[$0 >> 0] = HEAPU8[$0 >> 0] | 0 | 4; //@line 18882
 $61 = $g + 16 | 0; //@line 18883
 HEAP32[$61 >> 2] = (HEAP32[$61 >> 2] | 0) + $size$0; //@line 18886
 STACKTOP = sp; //@line 18887
 return;
}
function _lua_newthread($L) {
 $L = $L | 0;
 var $0 = 0, $13 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $20 = 0, $22 = 0, $30 = 0, $33 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $i$01$i = 0, sp = 0;
 sp = STACKTOP; //@line 12667
 $0 = $L + 12 | 0; //@line 12668
 if ((HEAP32[(HEAP32[$0 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 12674
 $5 = _luaC_newobj($L, 8, 112, 0, 0) | 0; //@line 12676
 $6 = $L + 8 | 0; //@line 12677
 $7 = HEAP32[$6 >> 2] | 0; //@line 12678
 HEAP32[$7 >> 2] = $5; //@line 12679
 HEAP32[$7 + 8 >> 2] = 72; //@line 12681
 HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + 16; //@line 12684
 HEAP32[$5 + 12 >> 2] = HEAP32[$0 >> 2]; //@line 12687
 $13 = $5 + 28 | 0; //@line 12688
 HEAP32[$13 >> 2] = 0; //@line 12689
 $14 = $5 + 16 | 0; //@line 12690
 HEAP32[$14 >> 2] = 0; //@line 12691
 $15 = $5 + 32 | 0; //@line 12692
 HEAP32[$15 >> 2] = 0; //@line 12693
 HEAP32[$5 + 64 >> 2] = 0; //@line 12695
 HEAP16[$5 + 38 >> 1] = 0; //@line 12697
 $18 = $5 + 52 | 0; //@line 12698
 HEAP32[$18 >> 2] = 0; //@line 12699
 $19 = $5 + 40 | 0; //@line 12700
 HEAP8[$19 >> 0] = 0; //@line 12701
 $20 = $5 + 44 | 0; //@line 12702
 HEAP32[$20 >> 2] = 0; //@line 12703
 HEAP8[$5 + 41 >> 0] = 1; //@line 12705
 $22 = $5 + 48 | 0; //@line 12706
 HEAP32[$22 >> 2] = 0; //@line 12707
 HEAP32[$5 + 56 >> 2] = 0; //@line 12709
 HEAP16[$5 + 36 >> 1] = 1; //@line 12711
 HEAP8[$5 + 6 >> 0] = 0; //@line 12713
 HEAP32[$5 + 68 >> 2] = 0; //@line 12715
 HEAP8[$19 >> 0] = HEAP8[$L + 40 >> 0] | 0; //@line 12718
 $30 = HEAP32[$L + 44 >> 2] | 0; //@line 12720
 HEAP32[$20 >> 2] = $30; //@line 12721
 HEAP32[$18 >> 2] = HEAP32[$L + 52 >> 2]; //@line 12724
 HEAP32[$22 >> 2] = $30; //@line 12725
 $33 = _luaM_realloc_($L, 0, 0, 640) | 0; //@line 12726
 HEAP32[$13 >> 2] = $33; //@line 12727
 HEAP32[$15 >> 2] = 40; //@line 12728
 $i$01$i = 0; //@line 12729
 do {
  HEAP32[$33 + ($i$01$i << 4) + 8 >> 2] = 0; //@line 12732
  $i$01$i = $i$01$i + 1 | 0; //@line 12733
 } while (($i$01$i | 0) != 40);
 HEAP32[$5 + 24 >> 2] = $33 + ((HEAP32[$15 >> 2] | 0) + -5 << 4); //@line 12747
 $40 = $5 + 72 | 0; //@line 12748
 HEAP32[$5 + 80 >> 2] = 0; //@line 12750
 HEAP32[$5 + 84 >> 2] = 0; //@line 12752
 HEAP8[$5 + 90 >> 0] = 0; //@line 12754
 HEAP32[$40 >> 2] = $33; //@line 12755
 HEAP32[$5 + 8 >> 2] = $33 + 16; //@line 12757
 HEAP32[$33 + 8 >> 2] = 0; //@line 12759
 HEAP32[$5 + 76 >> 2] = $33 + 336; //@line 12762
 HEAP32[$14 >> 2] = $40; //@line 12763
 STACKTOP = sp; //@line 12764
 return $5 | 0; //@line 12764
}
function _lua_rawsetp($L, $idx, $p) {
 $L = $L | 0;
 $idx = $idx | 0;
 $p = $p | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $30 = 0, $33 = 0, $34 = 0, $39 = 0, $4 = 0, $40 = 0, $47 = 0, $58 = 0, $63 = 0, $64 = 0, $k = 0, sp = 0;
 sp = STACKTOP; //@line 3897
 STACKTOP = STACKTOP + 16 | 0; //@line 3898
 $k = sp; //@line 3899
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3901
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3906
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3911
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3918
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3926
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3929
  $17 = HEAP32[$1 >> 2] | 0; //@line 3930
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3935
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3937
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3943
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3947
  }
 } while (0);
 HEAP32[$k >> 2] = $p; //@line 3952
 HEAP32[$k + 8 >> 2] = 2; //@line 3954
 $29 = $L + 8 | 0; //@line 3955
 $30 = HEAP32[$29 >> 2] | 0; //@line 3956
 $33 = _luaH_set($L, HEAP32[$$0$i >> 2] | 0, $k) | 0; //@line 3959
 $34 = $30 + -16 | 0; //@line 3960
 $39 = HEAP32[$34 + 4 >> 2] | 0; //@line 3965
 $40 = $33; //@line 3966
 HEAP32[$40 >> 2] = HEAP32[$34 >> 2]; //@line 3968
 HEAP32[$40 + 4 >> 2] = $39; //@line 3971
 HEAP32[$33 + 8 >> 2] = HEAP32[$30 + -8 >> 2]; //@line 3975
 $47 = HEAP32[$29 >> 2] | 0; //@line 3976
 if (!(HEAP32[$47 + -8 >> 2] & 64)) {
  $64 = $47; //@line 3982
  $63 = $64 + -16 | 0; //@line 3983
  HEAP32[$29 >> 2] = $63; //@line 3984
  STACKTOP = sp; //@line 3985
  return;
 }
 if (!(HEAP8[(HEAP32[$47 + -16 >> 2] | 0) + 5 >> 0] & 3)) {
  $64 = $47; //@line 3994
  $63 = $64 + -16 | 0; //@line 3995
  HEAP32[$29 >> 2] = $63; //@line 3996
  STACKTOP = sp; //@line 3997
  return;
 }
 $58 = HEAP32[$$0$i >> 2] | 0; //@line 3999
 if (!(HEAP8[$58 + 5 >> 0] & 4)) {
  $64 = $47; //@line 4005
  $63 = $64 + -16 | 0; //@line 4006
  HEAP32[$29 >> 2] = $63; //@line 4007
  STACKTOP = sp; //@line 4008
  return;
 }
 _luaC_barrierback_($L, $58); //@line 4010
 $64 = HEAP32[$29 >> 2] | 0; //@line 4012
 $63 = $64 + -16 | 0; //@line 4013
 HEAP32[$29 >> 2] = $63; //@line 4014
 STACKTOP = sp; //@line 4015
 return;
}
function _luaB_tonumber($L) {
 $L = $L | 0;
 var $10 = 0, $11 = 0, $12 = 0, $19 = 0.0, $2 = 0.0, $20 = 0, $21 = 0, $27 = 0, $30 = 0.0, $31 = 0, $41 = 0.0, $5 = 0, $7 = 0, $8 = 0, $isnum = 0, $l = 0, $n1$0 = 0.0, $n1$1 = 0.0, $neg$0 = 0, $s$0 = 0, $s$1 = 0, $s$2 = 0, sp = 0;
 sp = STACKTOP; //@line 8032
 STACKTOP = STACKTOP + 16 | 0; //@line 8033
 $isnum = sp + 4 | 0; //@line 8034
 $l = sp; //@line 8035
 do if ((_lua_type($L, 2) | 0) < 1) {
  $2 = +_lua_tonumberx($L, 1, $isnum); //@line 8040
  if (!(HEAP32[$isnum >> 2] | 0)) {
   _luaL_checkany($L, 1); //@line 8044
   break;
  }
  _lua_pushnumber($L, $2); //@line 8047
  STACKTOP = sp; //@line 8048
  return 1; //@line 8048
 } else {
  $5 = _luaL_checklstring($L, 1, $l) | 0; //@line 8050
  $7 = $5 + (HEAP32[$l >> 2] | 0) | 0; //@line 8052
  $8 = _luaL_checkinteger($L, 2) | 0; //@line 8053
  if (($8 + -2 | 0) >>> 0 >= 35) _luaL_argerror($L, 2, 1432) | 0; //@line 8057
  $10 = _strspn($5, 1456) | 0; //@line 8059
  $11 = $5 + $10 | 0; //@line 8060
  $12 = HEAP8[$11 >> 0] | 0; //@line 8061
  if ($12 << 24 >> 24 == 43) {
   $neg$0 = 0; //@line 8065
   $s$0 = $5 + ($10 + 1) | 0; //@line 8065
  } else if ($12 << 24 >> 24 == 45) {
   $neg$0 = 1; //@line 8069
   $s$0 = $5 + ($10 + 1) | 0; //@line 8069
  } else {
   $neg$0 = 0; //@line 8071
   $s$0 = $11; //@line 8071
  }
  if (_isalnum(HEAPU8[$s$0 >> 0] | 0) | 0) {
   $19 = +($8 | 0); //@line 8078
   $n1$0 = 0.0; //@line 8079
   $s$1 = $s$0; //@line 8079
   while (1) {
    $20 = HEAP8[$s$1 >> 0] | 0; //@line 8081
    $21 = $20 & 255; //@line 8082
    if (($21 + -48 | 0) >>> 0 < 10) $27 = ($20 << 24 >> 24) + -48 | 0; //@line 8088
 else $27 = (_toupper($21) | 0) + -55 | 0; //@line 8092
    if (($27 | 0) >= ($8 | 0)) {
     $n1$1 = $n1$0; //@line 8096
     $s$2 = $s$1; //@line 8096
     break;
    }
    $30 = $19 * $n1$0 + +($27 | 0); //@line 8101
    $31 = $s$1 + 1 | 0; //@line 8102
    if (!(_isalnum(HEAPU8[$31 >> 0] | 0) | 0)) {
     $n1$1 = $30; //@line 8108
     $s$2 = $31; //@line 8108
     break;
    } else {
     $n1$0 = $30; //@line 8111
     $s$1 = $31; //@line 8111
    }
   }
   if (($s$2 + (_strspn($s$2, 1456) | 0) | 0) == ($7 | 0)) {
    if (!$neg$0) $41 = $n1$1; //@line 8120
 else $41 = -$n1$1; //@line 8123
    _lua_pushnumber($L, $41); //@line 8125
    STACKTOP = sp; //@line 8126
    return 1; //@line 8126
   }
  }
 } while (0);
 _lua_pushnil($L); //@line 8131
 STACKTOP = sp; //@line 8132
 return 1; //@line 8132
}
function _lua_upvaluejoin($L, $fidx1, $n1, $fidx2, $n2) {
 $L = $L | 0;
 $fidx1 = $fidx1 | 0;
 $n1 = $n1 | 0;
 $fidx2 = $fidx2 | 0;
 $n2 = $n2 | 0;
 var $$0$i$i = 0, $$0$i$i2 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $31 = 0, $34 = 0, $4 = 0, $46 = 0, $47 = 0, $51 = 0, $61 = 0, $63 = 0, sp = 0;
 sp = STACKTOP; //@line 5478
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 5480
 do if (($fidx1 | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($fidx1 << 4) | 0; //@line 5485
  $$0$i$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 5490
 } else {
  if (($fidx1 | 0) >= -1000999) {
   $$0$i$i = (HEAP32[$L + 8 >> 2] | 0) + ($fidx1 << 4) | 0; //@line 5497
   break;
  }
  if (($fidx1 | 0) == -1001e3) {
   $$0$i$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5505
   break;
  }
  $16 = -1001e3 - $fidx1 | 0; //@line 5508
  $17 = HEAP32[$1 >> 2] | 0; //@line 5509
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i$i = 8048; //@line 5514
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 5516
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i$i = 8048; //@line 5522
 else $$0$i$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 5526
  }
 } while (0);
 $28 = HEAP32[$$0$i$i >> 2] | 0; //@line 5531
 $31 = $28 + 16 + ($n1 + -1 << 2) | 0; //@line 5534
 do if (($fidx2 | 0) > 0) {
  $34 = (HEAP32[$1 >> 2] | 0) + ($fidx2 << 4) | 0; //@line 5539
  $$0$i$i2 = $34 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $34 : 8048; //@line 5544
 } else {
  if (($fidx2 | 0) >= -1000999) {
   $$0$i$i2 = (HEAP32[$L + 8 >> 2] | 0) + ($fidx2 << 4) | 0; //@line 5551
   break;
  }
  if (($fidx2 | 0) == -1001e3) {
   $$0$i$i2 = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5559
   break;
  }
  $46 = -1001e3 - $fidx2 | 0; //@line 5562
  $47 = HEAP32[$1 >> 2] | 0; //@line 5563
  if ((HEAP32[$47 + 8 >> 2] | 0) == 22) $$0$i$i2 = 8048; //@line 5568
 else {
   $51 = HEAP32[$47 >> 2] | 0; //@line 5570
   if (($46 | 0) > (HEAPU8[$51 + 6 >> 0] | 0 | 0)) $$0$i$i2 = 8048; //@line 5576
 else $$0$i$i2 = $51 + ($46 + -1 << 4) + 16 | 0; //@line 5580
  }
 } while (0);
 $61 = (HEAP32[$$0$i$i2 >> 2] | 0) + 16 + ($n2 + -1 << 2) | 0; //@line 5588
 HEAP32[$31 >> 2] = HEAP32[$61 >> 2]; //@line 5590
 $63 = HEAP32[$61 >> 2] | 0; //@line 5591
 if (!(HEAP8[$63 + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 5597
  return;
 }
 if (!(HEAP8[$28 + 5 >> 0] & 4)) {
  STACKTOP = sp; //@line 5604
  return;
 }
 _luaC_barrier_($L, $28, $63); //@line 5606
 STACKTOP = sp; //@line 5607
 return;
}
function _codearith($fs, $op, $e1, $e2, $line) {
 $fs = $fs | 0;
 $op = $op | 0;
 $e1 = $e1 | 0;
 $e2 = $e2 | 0;
 $line = $line | 0;
 var $19 = 0.0, $22 = 0, $26 = 0, $28 = 0, $32 = 0, $39 = 0, $45 = 0, $52 = 0, $58 = 0, $65 = 0, $71 = 0, $78 = 0, sp = 0;
 sp = STACKTOP; //@line 12069
 if ((HEAP32[$e1 >> 2] | 0) == 5) if ((HEAP32[$e1 + 16 >> 2] | 0) == -1) if ((HEAP32[$e1 + 20 >> 2] | 0) == -1) if ((HEAP32[$e2 >> 2] | 0) == 5) if ((HEAP32[$e2 + 16 >> 2] | 0) == -1) if ((HEAP32[$e2 + 20 >> 2] | 0) == -1) {
  $19 = +HEAPF64[$e2 + 8 >> 3]; //@line 12095
  if (!(($op & -2 | 0) == 16 & $19 == 0.0)) {
   $22 = $e1 + 8 | 0; //@line 12100
   HEAPF64[$22 >> 3] = +_luaO_arith($op + -13 | 0, +HEAPF64[$22 >> 3], $19); //@line 12103
   STACKTOP = sp; //@line 12104
   return;
  }
 }
 if (($op | 0) == 19 | ($op | 0) == 21) $28 = 0; //@line 12113
 else $28 = _luaK_exp2RK($fs, $e2) | 0; //@line 12116
 $26 = _luaK_exp2RK($fs, $e1) | 0; //@line 12118
 if (($26 | 0) > ($28 | 0)) {
  if ((HEAP32[$e1 >> 2] | 0) == 6) {
   $32 = HEAP32[$e1 + 8 >> 2] | 0; //@line 12125
   if (!($32 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($32 | 0)) {
    $39 = $fs + 48 | 0; //@line 12134
    HEAP8[$39 >> 0] = (HEAP8[$39 >> 0] | 0) + -1 << 24 >> 24; //@line 12137
   }
  }
  if ((HEAP32[$e2 >> 2] | 0) == 6) {
   $45 = HEAP32[$e2 + 8 >> 2] | 0; //@line 12145
   if (!($45 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($45 | 0)) {
    $52 = $fs + 48 | 0; //@line 12154
    HEAP8[$52 >> 0] = (HEAP8[$52 >> 0] | 0) + -1 << 24 >> 24; //@line 12157
   }
  }
 } else {
  if ((HEAP32[$e2 >> 2] | 0) == 6) {
   $58 = HEAP32[$e2 + 8 >> 2] | 0; //@line 12166
   if (!($58 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($58 | 0)) {
    $65 = $fs + 48 | 0; //@line 12175
    HEAP8[$65 >> 0] = (HEAP8[$65 >> 0] | 0) + -1 << 24 >> 24; //@line 12178
   }
  }
  if ((HEAP32[$e1 >> 2] | 0) == 6) {
   $71 = HEAP32[$e1 + 8 >> 2] | 0; //@line 12186
   if (!($71 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($71 | 0)) {
    $78 = $fs + 48 | 0; //@line 12195
    HEAP8[$78 >> 0] = (HEAP8[$78 >> 0] | 0) + -1 << 24 >> 24; //@line 12198
   }
  }
 }
 HEAP32[$e1 + 8 >> 2] = _luaK_code($fs, $28 << 14 | $op | $26 << 23) | 0; //@line 12209
 HEAP32[$e1 >> 2] = 11; //@line 12210
 HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 20 >> 2] | 0) + ((HEAP32[$fs + 20 >> 2] | 0) + -1 << 2) >> 2] = $line; //@line 12218
 STACKTOP = sp; //@line 12219
 return;
}
function _lua_rawequal($L, $index1, $index2) {
 $L = $L | 0;
 $index1 = $index1 | 0;
 $index2 = $index2 | 0;
 var $$0$i = 0, $$0$i2 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, $42 = 0, $43 = 0, $47 = 0, $64 = 0, $65 = 0, sp = 0;
 sp = STACKTOP; //@line 1216
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1218
 do if (($index1 | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($index1 << 4) | 0; //@line 1223
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1228
 } else {
  if (($index1 | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($index1 << 4) | 0; //@line 1235
   break;
  }
  if (($index1 | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1243
   break;
  }
  $16 = -1001e3 - $index1 | 0; //@line 1246
  $17 = HEAP32[$1 >> 2] | 0; //@line 1247
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1252
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1254
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1260
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1264
  }
 } while (0);
 do if (($index2 | 0) > 0) {
  $30 = (HEAP32[$1 >> 2] | 0) + ($index2 << 4) | 0; //@line 1273
  $$0$i2 = $30 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $30 : 8048; //@line 1278
 } else {
  if (($index2 | 0) >= -1000999) {
   $$0$i2 = (HEAP32[$L + 8 >> 2] | 0) + ($index2 << 4) | 0; //@line 1285
   break;
  }
  if (($index2 | 0) == -1001e3) {
   $$0$i2 = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1293
   break;
  }
  $42 = -1001e3 - $index2 | 0; //@line 1296
  $43 = HEAP32[$1 >> 2] | 0; //@line 1297
  if ((HEAP32[$43 + 8 >> 2] | 0) == 22) {
   $65 = 0; //@line 1302
   STACKTOP = sp; //@line 1303
   return $65 | 0; //@line 1303
  }
  $47 = HEAP32[$43 >> 2] | 0; //@line 1305
  if (($42 | 0) > (HEAPU8[$47 + 6 >> 0] | 0 | 0)) {
   $65 = 0; //@line 1311
   STACKTOP = sp; //@line 1312
   return $65 | 0; //@line 1312
  } else {
   $$0$i2 = $47 + ($42 + -1 << 4) + 16 | 0; //@line 1316
   break;
  }
 } while (0);
 if (($$0$i | 0) == 8048 | ($$0$i2 | 0) == 8048) {
  $65 = 0; //@line 1325
  STACKTOP = sp; //@line 1326
  return $65 | 0; //@line 1326
 }
 if ((HEAP32[$$0$i + 8 >> 2] | 0) == (HEAP32[$$0$i2 + 8 >> 2] | 0)) $64 = (_luaV_equalobj_(0, $$0$i, $$0$i2) | 0) != 0; //@line 1336
 else $64 = 0; //@line 1338
 $65 = $64 & 1; //@line 1341
 STACKTOP = sp; //@line 1342
 return $65 | 0; //@line 1342
}
function _luaK_self($fs, $e, $key) {
 $fs = $fs | 0;
 $e = $e | 0;
 $key = $key | 0;
 var $$pre$phi5Z2D = 0, $$pre4$pre$phiZZ2D = 0, $13 = 0, $22 = 0, $25 = 0, $28 = 0, $30 = 0, $32 = 0, $41 = 0, $44 = 0, $55 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11046
 _luaK_dischargevars($fs, $e); //@line 11047
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $7 = $e + 8 | 0; //@line 11056
  $8 = HEAP32[$7 >> 2] | 0; //@line 11057
  if ((HEAP32[$e + 16 >> 2] | 0) == (HEAP32[$e + 20 >> 2] | 0)) $$pre$phi5Z2D = $7; //@line 11059
 else if (($8 | 0) < (HEAPU8[$fs + 46 >> 0] | 0 | 0)) {
   $$pre4$pre$phiZZ2D = $7; //@line 11066
   label = 6; //@line 11067
  } else {
   _exp2reg($fs, $e, $8); //@line 11069
   $$pre$phi5Z2D = $7; //@line 11070
  }
 } else {
  $$pre4$pre$phiZZ2D = $e + 8 | 0; //@line 11075
  label = 6; //@line 11076
 }
 if ((label | 0) == 6) {
  _luaK_exp2nextreg($fs, $e); //@line 11079
  $$pre$phi5Z2D = $$pre4$pre$phiZZ2D; //@line 11080
 }
 $13 = HEAP32[$$pre$phi5Z2D >> 2] | 0; //@line 11082
 if ((HEAP32[$e >> 2] | 0) == 6) if (!($13 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($13 | 0)) {
  $22 = $fs + 48 | 0; //@line 11094
  HEAP8[$22 >> 0] = (HEAP8[$22 >> 0] | 0) + -1 << 24 >> 24; //@line 11097
 }
 $25 = $fs + 48 | 0; //@line 11101
 HEAP32[$$pre$phi5Z2D >> 2] = HEAPU8[$25 >> 0]; //@line 11104
 HEAP32[$e >> 2] = 6; //@line 11105
 $28 = HEAP8[$25 >> 0] | 0; //@line 11106
 $30 = ($28 & 255) + 2 | 0; //@line 11108
 $32 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 11110
 do if ($30 >>> 0 > (HEAPU8[$32 >> 0] | 0) >>> 0) if ($30 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 11120
 else {
  HEAP8[$32 >> 0] = $30; //@line 11124
  $41 = HEAP8[$25 >> 0] | 0; //@line 11126
  break;
 } else $41 = $28; //@line 11130
 while (0);
 HEAP8[$25 >> 0] = ($41 & 255) + 2; //@line 11136
 $44 = HEAP32[$$pre$phi5Z2D >> 2] | 0; //@line 11137
 _luaK_code($fs, $13 << 23 | $44 << 6 | (_luaK_exp2RK($fs, $key) | 0) << 14 | 12) | 0; //@line 11145
 if ((HEAP32[$key >> 2] | 0) != 6) {
  STACKTOP = sp; //@line 11149
  return;
 }
 $55 = HEAP32[$key + 8 >> 2] | 0; //@line 11152
 if ($55 & 256) {
  STACKTOP = sp; //@line 11156
  return;
 }
 if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) > ($55 | 0)) {
  STACKTOP = sp; //@line 11163
  return;
 }
 HEAP8[$25 >> 0] = (HEAP8[$25 >> 0] | 0) + -1 << 24 >> 24; //@line 11167
 STACKTOP = sp; //@line 11168
 return;
}
function _get_equalTM($L, $mt1, $mt2) {
 $L = $L | 0;
 $mt1 = $mt1 | 0;
 $mt2 = $mt2 | 0;
 var $$0 = 0, $$0$i = 0, $20 = 0, $23 = 0, $5 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 2094
 L1 : do if (!$mt1) $$0 = 0; //@line 2098
 else if (!(HEAP8[$mt1 + 6 >> 0] & 32)) {
  $5 = $L + 12 | 0; //@line 2105
  $9 = _luaT_gettm($mt1, 5, HEAP32[(HEAP32[$5 >> 2] | 0) + 204 >> 2] | 0) | 0; //@line 2109
  if (!$9) $$0 = 0; //@line 2112
 else if (($mt1 | 0) == ($mt2 | 0)) $$0 = $9; //@line 2116
 else if (!$mt2) $$0 = 0; //@line 2120
 else if (!(HEAP8[$mt2 + 6 >> 0] & 32)) {
   $20 = _luaT_gettm($mt2, 5, HEAP32[(HEAP32[$5 >> 2] | 0) + 204 >> 2] | 0) | 0; //@line 2130
   if (!$20) $$0 = 0; //@line 2133
 else {
    $23 = HEAP32[$9 + 8 >> 2] | 0; //@line 2136
    L9 : do if (($23 | 0) == (HEAP32[$20 + 8 >> 2] | 0)) {
     switch ($23 & 63 | 0) {
     case 4:
      {
       $$0$i = (HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0) & 1; //@line 2149
       break;
      }
     case 22:
      {
       $$0$i = (HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0) & 1; //@line 2157
       break;
      }
     case 2:
      {
       $$0$i = (HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0) & 1; //@line 2165
       break;
      }
     case 7:
      {
       if ((HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0)) {
        $$0 = $9; //@line 2173
        break L1;
       } else break L9;
       break;
      }
     case 5:
      {
       if ((HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0)) {
        $$0 = $9; //@line 2185
        break L1;
       } else break L9;
       break;
      }
     case 0:
      {
       $$0 = $9; //@line 2193
       break L1;
       break;
      }
     case 1:
      {
       $$0$i = (HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0) & 1; //@line 2202
       break;
      }
     case 20:
      {
       $$0$i = _luaS_eqlngstr(HEAP32[$9 >> 2] | 0, HEAP32[$20 >> 2] | 0) | 0; //@line 2209
       break;
      }
     case 3:
      {
       $$0$i = +HEAPF64[$9 >> 3] == +HEAPF64[$20 >> 3] & 1; //@line 2217
       break;
      }
     default:
      $$0$i = (HEAP32[$9 >> 2] | 0) == (HEAP32[$20 >> 2] | 0) & 1; //@line 2225
     }
     if ($$0$i) {
      $$0 = $9; //@line 2230
      break L1;
     }
    } while (0);
    $$0 = 0; //@line 2235
   }
  } else $$0 = 0; //@line 2238
 } else $$0 = 0; //@line 2244
 while (0);
 STACKTOP = sp; //@line 2248
 return $$0 | 0; //@line 2248
}
function _luaD_reallocstack($L, $newsize) {
 $L = $L | 0;
 $newsize = $newsize | 0;
 var $0 = 0, $1 = 0, $14 = 0, $17 = 0, $2 = 0, $23 = 0, $3 = 0, $30 = 0, $39 = 0, $56 = 0, $8 = 0, $ci$02$i = 0, $ci$03$i = 0, $lim$04 = 0, $up$0$i2 = 0, $up$0$i3 = 0, $up$04$i = 0, sp = 0;
 sp = STACKTOP; //@line 15427
 $0 = $L + 28 | 0; //@line 15428
 $1 = HEAP32[$0 >> 2] | 0; //@line 15429
 $2 = $L + 32 | 0; //@line 15430
 $3 = HEAP32[$2 >> 2] | 0; //@line 15431
 if (($newsize + 1 | 0) >>> 0 > 268435455) _luaM_toobig($L); //@line 15435
 $8 = _luaM_realloc_($L, $1, $3 << 4, $newsize << 4) | 0; //@line 15440
 HEAP32[$0 >> 2] = $8; //@line 15441
 if (($3 | 0) < ($newsize | 0)) {
  $lim$04 = $3; //@line 15444
  do {
   HEAP32[$8 + ($lim$04 << 4) + 8 >> 2] = 0; //@line 15447
   $lim$04 = $lim$04 + 1 | 0; //@line 15448
  } while (($lim$04 | 0) != ($newsize | 0));
 }
 HEAP32[$2 >> 2] = $newsize; //@line 15457
 HEAP32[$L + 24 >> 2] = $8 + ($newsize + -5 << 4); //@line 15461
 $14 = $L + 8 | 0; //@line 15462
 $17 = $1; //@line 15465
 HEAP32[$14 >> 2] = $8 + ((HEAP32[$14 >> 2] | 0) - $17 >> 4 << 4); //@line 15469
 $up$04$i = HEAP32[$L + 56 >> 2] | 0; //@line 15471
 if ($up$04$i) {
  $23 = $up$04$i + 8 | 0; //@line 15474
  HEAP32[$23 >> 2] = $8 + ((HEAP32[$23 >> 2] | 0) - $17 >> 4 << 4); //@line 15480
  $up$0$i2 = HEAP32[$up$04$i >> 2] | 0; //@line 15481
  if ($up$0$i2) {
   $up$0$i3 = $up$0$i2; //@line 15484
   do {
    $30 = $up$0$i3 + 8 | 0; //@line 15487
    HEAP32[$30 >> 2] = (HEAP32[$0 >> 2] | 0) + ((HEAP32[$30 >> 2] | 0) - $17 >> 4 << 4); //@line 15493
    $up$0$i3 = HEAP32[$up$0$i3 >> 2] | 0; //@line 15494
   } while (($up$0$i3 | 0) != 0);
  }
 }
 $ci$02$i = HEAP32[$L + 16 >> 2] | 0; //@line 15505
 if (!$ci$02$i) {
  STACKTOP = sp; //@line 15508
  return;
 } else $ci$03$i = $ci$02$i; //@line 15510
 do {
  $39 = $ci$03$i + 4 | 0; //@line 15513
  HEAP32[$39 >> 2] = (HEAP32[$0 >> 2] | 0) + ((HEAP32[$39 >> 2] | 0) - $17 >> 4 << 4); //@line 15520
  HEAP32[$ci$03$i >> 2] = (HEAP32[$0 >> 2] | 0) + ((HEAP32[$ci$03$i >> 2] | 0) - $17 >> 4 << 4); //@line 15527
  if (HEAP8[$ci$03$i + 18 >> 0] & 1) {
   $56 = $ci$03$i + 24 | 0; //@line 15533
   HEAP32[$56 >> 2] = (HEAP32[$0 >> 2] | 0) + ((HEAP32[$56 >> 2] | 0) - $17 >> 4 << 4); //@line 15541
  }
  $ci$03$i = HEAP32[$ci$03$i + 8 >> 2] | 0; //@line 15544
 } while (($ci$03$i | 0) != 0);
 STACKTOP = sp; //@line 15552
 return;
}
function _lua_upvalueid($L, $fidx, $n) {
 $L = $L | 0;
 $fidx = $fidx | 0;
 $n = $n | 0;
 var $$0 = 0, $$0$i = 0, $$0$i$i = 0, $1 = 0, $16 = 0, $17 = 0, $2 = 0, $21 = 0, $30 = 0, $32 = 0, $4 = 0, $44 = 0, $45 = 0, $49 = 0, sp = 0;
 sp = STACKTOP; //@line 5343
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 5345
 $2 = ($fidx | 0) > 0; //@line 5346
 do if ($2) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($fidx << 4) | 0; //@line 5350
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 5355
 } else {
  if (($fidx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($fidx << 4) | 0; //@line 5362
   break;
  }
  if (($fidx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5370
   break;
  }
  $16 = -1001e3 - $fidx | 0; //@line 5373
  $17 = HEAP32[$1 >> 2] | 0; //@line 5374
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 5379
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 5381
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 5387
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 5391
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 63; //@line 5398
 if (($30 | 0) == 38) {
  $$0 = (HEAP32[$$0$i >> 2] | 0) + ($n + -1 << 4) + 16 | 0; //@line 5403
  STACKTOP = sp; //@line 5404
  return $$0 | 0; //@line 5404
 } else if (($30 | 0) == 6) {
  do if ($2) {
   $32 = (HEAP32[$1 >> 2] | 0) + ($fidx << 4) | 0; //@line 5409
   $$0$i$i = $32 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $32 : 8048; //@line 5414
  } else {
   if (($fidx | 0) >= -1000999) {
    $$0$i$i = (HEAP32[$L + 8 >> 2] | 0) + ($fidx << 4) | 0; //@line 5421
    break;
   }
   if (($fidx | 0) == -1001e3) {
    $$0$i$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 5429
    break;
   }
   $44 = -1001e3 - $fidx | 0; //@line 5432
   $45 = HEAP32[$1 >> 2] | 0; //@line 5433
   if ((HEAP32[$45 + 8 >> 2] | 0) == 22) $$0$i$i = 8048; //@line 5438
 else {
    $49 = HEAP32[$45 >> 2] | 0; //@line 5440
    if (($44 | 0) > (HEAPU8[$49 + 6 >> 0] | 0 | 0)) $$0$i$i = 8048; //@line 5446
 else $$0$i$i = $49 + ($44 + -1 << 4) + 16 | 0; //@line 5450
   }
  } while (0);
  $$0 = HEAP32[(HEAP32[$$0$i$i >> 2] | 0) + 16 + ($n + -1 << 2) >> 2] | 0; //@line 5460
  STACKTOP = sp; //@line 5461
  return $$0 | 0; //@line 5461
 } else {
  $$0 = 0; //@line 5463
  STACKTOP = sp; //@line 5464
  return $$0 | 0; //@line 5464
 }
 return 0; //@line 5466
}
function _lua_rawset($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $33 = 0, $34 = 0, $39 = 0, $4 = 0, $40 = 0, $49 = 0, $60 = 0, $65 = 0, $66 = 0, sp = 0;
 sp = STACKTOP; //@line 3664
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3666
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3671
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3676
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3683
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3691
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3694
  $17 = HEAP32[$1 >> 2] | 0; //@line 3695
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3700
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3702
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3708
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3712
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 3717
 $29 = HEAP32[$28 >> 2] | 0; //@line 3718
 $33 = _luaH_set($L, HEAP32[$$0$i >> 2] | 0, $29 + -32 | 0) | 0; //@line 3722
 $34 = $29 + -16 | 0; //@line 3723
 $39 = HEAP32[$34 + 4 >> 2] | 0; //@line 3728
 $40 = $33; //@line 3729
 HEAP32[$40 >> 2] = HEAP32[$34 >> 2]; //@line 3731
 HEAP32[$40 + 4 >> 2] = $39; //@line 3734
 HEAP32[$33 + 8 >> 2] = HEAP32[$29 + -8 >> 2]; //@line 3738
 HEAP8[(HEAP32[$$0$i >> 2] | 0) + 6 >> 0] = 0; //@line 3741
 $49 = HEAP32[$28 >> 2] | 0; //@line 3742
 if (!(HEAP32[$49 + -8 >> 2] & 64)) {
  $66 = $49; //@line 3748
  $65 = $66 + -32 | 0; //@line 3749
  HEAP32[$28 >> 2] = $65; //@line 3750
  STACKTOP = sp; //@line 3751
  return;
 }
 if (!(HEAP8[(HEAP32[$49 + -16 >> 2] | 0) + 5 >> 0] & 3)) {
  $66 = $49; //@line 3760
  $65 = $66 + -32 | 0; //@line 3761
  HEAP32[$28 >> 2] = $65; //@line 3762
  STACKTOP = sp; //@line 3763
  return;
 }
 $60 = HEAP32[$$0$i >> 2] | 0; //@line 3765
 if (!(HEAP8[$60 + 5 >> 0] & 4)) {
  $66 = $49; //@line 3771
  $65 = $66 + -32 | 0; //@line 3772
  HEAP32[$28 >> 2] = $65; //@line 3773
  STACKTOP = sp; //@line 3774
  return;
 }
 _luaC_barrierback_($L, $60); //@line 3776
 $66 = HEAP32[$28 >> 2] | 0; //@line 3778
 $65 = $66 + -32 | 0; //@line 3779
 HEAP32[$28 >> 2] = $65; //@line 3780
 STACKTOP = sp; //@line 3781
 return;
}
function _luaD_rawrunprotected($L, $f, $ud) {
 $L = $L | 0;
 $f = $f | 0;
 $ud = $ud | 0;
 var $$reg2mem23$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $6 = 0, $7 = 0, $lj = 0, _setjmpTable = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 15367
 STACKTOP = STACKTOP + 176 | 0; //@line 15368
 _setjmpTable = STACKTOP; //@line 15369
 STACKTOP = STACKTOP + 168 | 0; //@line 15369
 HEAP32[_setjmpTable >> 2] = 0; //@line 15369
 $lj = sp; //@line 15370
 $0 = $L + 38 | 0; //@line 15371
 $1 = HEAP16[$0 >> 1] | 0; //@line 15372
 $2 = $lj + 160 | 0; //@line 15373
 HEAP32[$2 >> 2] = 0; //@line 15374
 $3 = $L + 64 | 0; //@line 15375
 HEAP32[$lj >> 2] = HEAP32[$3 >> 2]; //@line 15377
 HEAP32[$3 >> 2] = $lj; //@line 15378
 _saveSetjmp($lj + 4 | 0, 1, _setjmpTable | 0) | 0; //@line 15380
 __THREW__ = 0; //@line 15381
 $6 = __THREW__; //@line 15382
 __THREW__ = 0; //@line 15382
 if (($6 | 0) != 0 & (threwValue | 0) != 0) {
  $7 = _testSetjmp(HEAP32[$6 >> 2] | 0, _setjmpTable) | 0; //@line 15383
  if (!$7) _longjmp($6 | 0, threwValue | 0); //@line 15383
  tempRet0 = threwValue; //@line 15383
 } else $7 = -1; //@line 15383
 if (($7 | 0) == 1) $$reg2mem23$0 = tempRet0; //@line 15386
 else $$reg2mem23$0 = 0; //@line 15388
 while (1) {
  if ($$reg2mem23$0) {
   label = 6; //@line 15393
   break;
  }
  __THREW__ = 0; //@line 15396
  invoke_vii($f | 0, $L | 0, $ud | 0); //@line 15397
  $10 = __THREW__; //@line 15398
  __THREW__ = 0; //@line 15398
  if (($10 | 0) != 0 & (threwValue | 0) != 0) {
   $11 = _testSetjmp(HEAP32[$10 >> 2] | 0, _setjmpTable) | 0; //@line 15399
   if (!$11) _longjmp($10 | 0, threwValue | 0); //@line 15399
   tempRet0 = threwValue; //@line 15399
  } else $11 = -1; //@line 15399
  if (($11 | 0) == 1) $$reg2mem23$0 = tempRet0; //@line 15402
 else break;
 }
 if ((label | 0) == 6) {
  $13 = HEAP32[$lj >> 2] | 0; //@line 15408
  HEAP32[$3 >> 2] = $13; //@line 15409
  HEAP16[$0 >> 1] = $1; //@line 15410
  $14 = HEAP32[$2 >> 2] | 0; //@line 15411
  STACKTOP = sp; //@line 15412
  return $14 | 0; //@line 15412
 }
 $13 = HEAP32[$lj >> 2] | 0; //@line 15414
 HEAP32[$3 >> 2] = $13; //@line 15415
 HEAP16[$0 >> 1] = $1; //@line 15416
 $14 = HEAP32[$2 >> 2] | 0; //@line 15417
 STACKTOP = sp; //@line 15418
 return $14 | 0; //@line 15418
}
function _luaK_storevar($fs, $var, $ex) {
 $fs = $fs | 0;
 $var = $var | 0;
 $ex = $ex | 0;
 var $$0$i = 0, $$pre$phi2$iZ2D = 0, $0 = 0, $11 = 0, $23 = 0, $24 = 0, $37 = 0, $4 = 0, $41 = 0, $42 = 0, $57 = 0, $64 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 10921
 $0 = HEAP32[$var >> 2] | 0; //@line 10922
 if (($0 | 0) == 8) {
  _luaK_dischargevars($fs, $ex); //@line 10924
  if ((HEAP32[$ex >> 2] | 0) == 6) {
   $23 = $ex + 8 | 0; //@line 10933
   $24 = HEAP32[$23 >> 2] | 0; //@line 10934
   if ((HEAP32[$ex + 16 >> 2] | 0) == (HEAP32[$ex + 20 >> 2] | 0)) $$0$i = $24; //@line 10936
 else if (($24 | 0) < (HEAPU8[$fs + 46 >> 0] | 0)) {
    $$pre$phi2$iZ2D = $23; //@line 10943
    label = 12; //@line 10944
   } else {
    _exp2reg($fs, $ex, $24); //@line 10946
    $$0$i = HEAP32[$23 >> 2] | 0; //@line 10948
   }
  } else {
   $$pre$phi2$iZ2D = $ex + 8 | 0; //@line 10953
   label = 12; //@line 10954
  }
  if ((label | 0) == 12) {
   _luaK_exp2nextreg($fs, $ex); //@line 10957
   $$0$i = HEAP32[$$pre$phi2$iZ2D >> 2] | 0; //@line 10959
  }
  _luaK_code($fs, $$0$i << 6 | HEAP32[$var + 8 >> 2] << 23 | 9) | 0; //@line 10967
 } else if (($0 | 0) == 9) {
  $37 = $var + 8 | 0; //@line 10969
  $41 = (HEAP8[$37 + 3 >> 0] | 0) == 7 ? 10 : 8; //@line 10973
  $42 = _luaK_exp2RK($fs, $ex) | 0; //@line 10974
  _luaK_code($fs, $42 << 14 | $41 | HEAPU8[$37 + 2 >> 0] << 6 | HEAPU16[$37 >> 1] << 23) | 0; //@line 10986
 } else if (($0 | 0) == 7) {
  if ((HEAP32[$ex >> 2] | 0) == 6) {
   $4 = HEAP32[$ex + 8 >> 2] | 0; //@line 10992
   if (!($4 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0) <= ($4 | 0)) {
    $11 = $fs + 48 | 0; //@line 11001
    HEAP8[$11 >> 0] = (HEAP8[$11 >> 0] | 0) + -1 << 24 >> 24; //@line 11004
   }
  }
  _exp2reg($fs, $ex, HEAP32[$var + 8 >> 2] | 0); //@line 11010
  STACKTOP = sp; //@line 11011
  return;
 }
 if ((HEAP32[$ex >> 2] | 0) != 6) {
  STACKTOP = sp; //@line 11016
  return;
 }
 $57 = HEAP32[$ex + 8 >> 2] | 0; //@line 11019
 if ($57 & 256) {
  STACKTOP = sp; //@line 11023
  return;
 }
 if ((HEAPU8[$fs + 46 >> 0] | 0) > ($57 | 0)) {
  STACKTOP = sp; //@line 11030
  return;
 }
 $64 = $fs + 48 | 0; //@line 11032
 HEAP8[$64 >> 0] = (HEAP8[$64 >> 0] | 0) + -1 << 24 >> 24; //@line 11035
 STACKTOP = sp; //@line 11036
 return;
}
function _closegoto($ls, $g, $label) {
 $ls = $ls | 0;
 $g = $g | 0;
 $label = $label | 0;
 var $$lcssa3 = 0, $1 = 0, $19 = 0, $24 = 0, $25 = 0, $3 = 0, $31 = 0, $33 = 0, $35 = 0, $36 = 0, $38 = 0, $4 = 0, $40 = 0, $5 = 0, $7 = 0, $i$04 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 8976
 STACKTOP = STACKTOP + 16 | 0; //@line 8977
 $vararg_buffer = sp; //@line 8978
 $1 = HEAP32[$ls + 48 >> 2] | 0; //@line 8980
 $3 = HEAP32[$ls + 64 >> 2] | 0; //@line 8982
 $4 = $3 + 12 | 0; //@line 8983
 $5 = HEAP32[$4 >> 2] | 0; //@line 8984
 $7 = HEAP8[$5 + ($g << 4) + 12 >> 0] | 0; //@line 8986
 if (($7 & 255) < (HEAPU8[$label + 12 >> 0] | 0)) {
  $19 = HEAP32[$ls + 52 >> 2] | 0; //@line 9009
  $24 = HEAP32[$5 + ($g << 4) + 8 >> 2] | 0; //@line 9014
  $25 = (HEAP32[(HEAP32[(HEAP32[$1 >> 2] | 0) + 24 >> 2] | 0) + ((HEAP16[(HEAP32[HEAP32[(HEAP32[$1 + 12 >> 2] | 0) + 64 >> 2] >> 2] | 0) + ((HEAP32[$1 + 40 >> 2] | 0) + ($7 & 255) << 1) >> 1] | 0) * 12 | 0) >> 2] | 0) + 16 | 0; //@line 9015
  HEAP32[$vararg_buffer >> 2] = (HEAP32[$5 + ($g << 4) >> 2] | 0) + 16; //@line 9016
  HEAP32[$vararg_buffer + 4 >> 2] = $24; //@line 9018
  HEAP32[$vararg_buffer + 8 >> 2] = $25; //@line 9020
  _semerror($ls, _luaO_pushfstring($19, 9104, $vararg_buffer) | 0); //@line 9022
 }
 _luaK_patchlist($1, HEAP32[$5 + ($g << 4) + 4 >> 2] | 0, HEAP32[$label + 4 >> 2] | 0); //@line 9029
 $31 = $3 + 16 | 0; //@line 9030
 $33 = (HEAP32[$31 >> 2] | 0) + -1 | 0; //@line 9032
 if (($33 | 0) > ($g | 0)) $i$04 = $g; //@line 9035
 else {
  $$lcssa3 = $33; //@line 9037
  HEAP32[$31 >> 2] = $$lcssa3; //@line 9038
  STACKTOP = sp; //@line 9039
  return;
 }
 do {
  $35 = HEAP32[$4 >> 2] | 0; //@line 9042
  $36 = $35 + ($i$04 << 4) | 0; //@line 9043
  $i$04 = $i$04 + 1 | 0; //@line 9044
  $38 = $35 + ($i$04 << 4) | 0; //@line 9045
  HEAP32[$36 + 0 >> 2] = HEAP32[$38 + 0 >> 2]; //@line 9046
  HEAP32[$36 + 4 >> 2] = HEAP32[$38 + 4 >> 2]; //@line 9046
  HEAP32[$36 + 8 >> 2] = HEAP32[$38 + 8 >> 2]; //@line 9046
  HEAP32[$36 + 12 >> 2] = HEAP32[$38 + 12 >> 2]; //@line 9046
  $40 = (HEAP32[$31 >> 2] | 0) + -1 | 0; //@line 9048
 } while (($i$04 | 0) < ($40 | 0));
 $$lcssa3 = $40; //@line 9053
 HEAP32[$31 >> 2] = $$lcssa3; //@line 9057
 STACKTOP = sp; //@line 9058
 return;
}
function _luaD_hook($L, $event, $line) {
 $L = $L | 0;
 $event = $event | 0;
 $line = $line | 0;
 var $$$$i = 0, $$$i = 0, $1 = 0, $10 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $18 = 0, $27 = 0, $3 = 0, $30 = 0, $31 = 0, $36 = 0, $37 = 0, $7 = 0, $8 = 0, $9 = 0, $ar = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 15656
 STACKTOP = STACKTOP + 112 | 0; //@line 15657
 $vararg_buffer = sp; //@line 15658
 $ar = sp + 4 | 0; //@line 15659
 $1 = HEAP32[$L + 52 >> 2] | 0; //@line 15661
 if (!$1) {
  STACKTOP = sp; //@line 15664
  return;
 }
 $3 = $L + 41 | 0; //@line 15666
 if (!(HEAP8[$3 >> 0] | 0)) {
  STACKTOP = sp; //@line 15670
  return;
 }
 $7 = HEAP32[$L + 16 >> 2] | 0; //@line 15673
 $8 = $L + 8 | 0; //@line 15674
 $9 = HEAP32[$8 >> 2] | 0; //@line 15675
 $10 = $L + 28 | 0; //@line 15676
 $12 = $9; //@line 15678
 $13 = HEAP32[$10 >> 2] | 0; //@line 15679
 $14 = $12 - $13 | 0; //@line 15680
 $15 = $7 + 4 | 0; //@line 15681
 $18 = (HEAP32[$15 >> 2] | 0) - $13 | 0; //@line 15684
 HEAP32[$ar >> 2] = $event; //@line 15685
 HEAP32[$ar + 20 >> 2] = $line; //@line 15687
 HEAP32[$ar + 96 >> 2] = $7; //@line 15689
 do if (((HEAP32[$L + 24 >> 2] | 0) - $12 | 0) < 336) {
  $27 = HEAP32[$L + 32 >> 2] | 0; //@line 15698
  if (($27 | 0) > 1e6) _luaD_throw($L, 6); //@line 15701
  $30 = ($14 >> 4) + 25 | 0; //@line 15705
  $31 = $27 << 1; //@line 15706
  $$$i = ($31 | 0) > 1e6 ? 1e6 : $31; //@line 15708
  $$$$i = ($$$i | 0) < ($30 | 0) ? $30 : $$$i; //@line 15710
  if (($$$$i | 0) > 1e6) {
   _luaD_reallocstack($L, 1000200); //@line 15713
   _luaG_runerror($L, 4264, $vararg_buffer); //@line 15714
  } else {
   _luaD_reallocstack($L, $$$$i); //@line 15717
   $36 = HEAP32[$8 >> 2] | 0; //@line 15719
   break;
  }
 } else $36 = $9; //@line 15723
 while (0);
 HEAP32[$15 >> 2] = $36 + 320; //@line 15727
 HEAP8[$3 >> 0] = 0; //@line 15728
 $37 = $7 + 18 | 0; //@line 15729
 HEAP8[$37 >> 0] = HEAPU8[$37 >> 0] | 2; //@line 15734
 FUNCTION_TABLE_vii[$1 & 31]($L, $ar); //@line 15735
 HEAP8[$3 >> 0] = 1; //@line 15736
 HEAP32[$15 >> 2] = (HEAP32[$10 >> 2] | 0) + $18; //@line 15739
 HEAP32[$8 >> 2] = (HEAP32[$10 >> 2] | 0) + $14; //@line 15742
 HEAP8[$37 >> 0] = HEAPU8[$37 >> 0] & 253; //@line 15747
 STACKTOP = sp; //@line 15748
 return;
}
function _gmatch_aux($L) {
 $L = $L | 0;
 var $$$i = 0, $$0 = 0, $0 = 0, $1 = 0, $11 = 0, $14 = 0, $17 = 0, $18 = 0, $2 = 0, $25 = 0, $6 = 0, $i$01$i = 0, $lp = 0, $ls = 0, $ms = 0, $src$04 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16189
 STACKTOP = STACKTOP + 288 | 0; //@line 16190
 $ms = sp + 8 | 0; //@line 16191
 $ls = sp + 4 | 0; //@line 16192
 $lp = sp; //@line 16193
 $0 = _lua_tolstring($L, -1001001, $ls) | 0; //@line 16194
 $1 = _lua_tolstring($L, -1001002, $lp) | 0; //@line 16195
 $2 = $ms + 16 | 0; //@line 16196
 HEAP32[$2 >> 2] = $L; //@line 16197
 HEAP32[$ms >> 2] = 200; //@line 16198
 HEAP32[$ms + 4 >> 2] = $0; //@line 16200
 $6 = $ms + 8 | 0; //@line 16203
 HEAP32[$6 >> 2] = $0 + (HEAP32[$ls >> 2] | 0); //@line 16204
 HEAP32[$ms + 12 >> 2] = $1 + (HEAP32[$lp >> 2] | 0); //@line 16208
 $11 = $0 + (_lua_tointegerx($L, -1001003, 0) | 0) | 0; //@line 16210
 if ($11 >>> 0 > (HEAP32[$6 >> 2] | 0) >>> 0) {
  $$0 = 0; //@line 16214
  STACKTOP = sp; //@line 16215
  return $$0 | 0; //@line 16215
 }
 $14 = $ms + 20 | 0; //@line 16217
 $src$04 = $11; //@line 16218
 while (1) {
  HEAP32[$14 >> 2] = 0; //@line 16220
  $18 = _match($ms, $src$04, $1) | 0; //@line 16221
  $17 = $src$04 + 1 | 0; //@line 16223
  if ($18) break;
  if ($17 >>> 0 > (HEAP32[$6 >> 2] | 0) >>> 0) {
   $$0 = 0; //@line 16230
   label = 7; //@line 16231
   break;
  } else $src$04 = $17; //@line 16234
 }
 if ((label | 0) == 7) {
  STACKTOP = sp; //@line 16238
  return $$0 | 0; //@line 16238
 }
 _lua_pushinteger($L, $18 - $0 + (($18 | 0) == ($src$04 | 0) & 1) | 0); //@line 16246
 _lua_replace($L, -1001003); //@line 16247
 $25 = HEAP32[$14 >> 2] | 0; //@line 16248
 $$$i = ($25 | 0) != 0 | ($src$04 | 0) == 0 ? $25 : 1; //@line 16252
 _luaL_checkstack(HEAP32[$2 >> 2] | 0, $$$i, 10056); //@line 16254
 if (($$$i | 0) > 0) $i$01$i = 0; //@line 16257
 else {
  $$0 = $25; //@line 16259
  STACKTOP = sp; //@line 16260
  return $$0 | 0; //@line 16260
 }
 do {
  _push_onecapture($ms, $i$01$i, $src$04, $18); //@line 16263
  $i$01$i = $i$01$i + 1 | 0; //@line 16264
 } while (($i$01$i | 0) != ($$$i | 0));
 $$0 = $$$i; //@line 16267
 STACKTOP = sp; //@line 16273
 return $$0 | 0; //@line 16273
}
function _clearvalues($g, $l, $f) {
 $g = $g | 0;
 $l = $l | 0;
 $f = $f | 0;
 var $$08 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $20 = 0, $34 = 0, $35 = 0, $36 = 0, $42 = 0, $5 = 0, $52 = 0, $6 = 0, $7 = 0, $8 = 0, $i$03 = 0, $n$04 = 0, sp = 0;
 sp = STACKTOP; //@line 1490
 if (($l | 0) == ($f | 0)) {
  STACKTOP = sp; //@line 1493
  return;
 } else $$08 = $l; //@line 1495
 do {
  $5 = $$08 + 16 | 0; //@line 1502
  $6 = HEAP32[$5 >> 2] | 0; //@line 1503
  $7 = $6 + (1 << (HEAPU8[$$08 + 7 >> 0] | 0) << 5) | 0; //@line 1504
  $8 = $$08 + 28 | 0; //@line 1505
  if ((HEAP32[$8 >> 2] | 0) > 0) {
   $11 = $$08 + 12 | 0; //@line 1509
   $i$03 = 0; //@line 1510
   do {
    $12 = HEAP32[$11 >> 2] | 0; //@line 1512
    $13 = $12 + ($i$03 << 4) + 8 | 0; //@line 1513
    $14 = HEAP32[$13 >> 2] | 0; //@line 1514
    do if ($14 & 64) {
     $20 = HEAP32[$12 + ($i$03 << 4) >> 2] | 0; //@line 1522
     if (($14 & 15 | 0) != 4) {
      if (!(HEAP8[$20 + 5 >> 0] & 3)) break;
      HEAP32[$13 >> 2] = 0; //@line 1531
      break;
     }
     if ($20) if (HEAP8[$20 + 5 >> 0] & 3) _reallymarkobject($g, $20); //@line 1541
    } while (0);
    $i$03 = $i$03 + 1 | 0; //@line 1546
   } while (($i$03 | 0) < (HEAP32[$8 >> 2] | 0));
   $34 = HEAP32[$5 >> 2] | 0; //@line 1556
  } else $34 = $6; //@line 1558
  if ($34 >>> 0 < $7 >>> 0) {
   $n$04 = $34; //@line 1562
   do {
    $35 = $n$04 + 8 | 0; //@line 1564
    $36 = HEAP32[$35 >> 2] | 0; //@line 1565
    do if (!(($36 | 0) == 0 | ($36 & 64 | 0) == 0)) {
     $42 = HEAP32[$n$04 >> 2] | 0; //@line 1574
     if (($36 & 15 | 0) == 4) {
      if (!$42) break;
      if (!(HEAP8[$42 + 5 >> 0] & 3)) break;
      _reallymarkobject($g, $42); //@line 1587
      break;
     }
     if (HEAP8[$42 + 5 >> 0] & 3) {
      HEAP32[$35 >> 2] = 0; //@line 1595
      $52 = $n$04 + 24 | 0; //@line 1596
      if (HEAP32[$52 >> 2] & 64) if (HEAP8[(HEAP32[$n$04 + 16 >> 2] | 0) + 5 >> 0] & 3) HEAP32[$52 >> 2] = 11; //@line 1608
     }
    } while (0);
    $n$04 = $n$04 + 32 | 0; //@line 1614
   } while ($n$04 >>> 0 < $7 >>> 0);
  }
  $$08 = HEAP32[$$08 + 24 >> 2] | 0; //@line 1624
 } while (($$08 | 0) != ($f | 0));
 STACKTOP = sp; //@line 1632
 return;
}
function _funcargs($ls, $f, $line) {
 $ls = $ls | 0;
 $f = $f | 0;
 $line = $line | 0;
 var $0 = 0, $1 = 0, $13 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $23 = 0, $3 = 0, $args = 0, $nparams$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 11942
 STACKTOP = STACKTOP + 32 | 0; //@line 11943
 $args = sp; //@line 11944
 $0 = $ls + 48 | 0; //@line 11945
 $1 = HEAP32[$0 >> 2] | 0; //@line 11946
 $2 = $ls + 16 | 0; //@line 11947
 $3 = HEAP32[$2 >> 2] | 0; //@line 11948
 if (($3 | 0) == 40) {
  _luaX_next($ls); //@line 11950
  if ((HEAP32[$2 >> 2] | 0) == 41) HEAP32[$args >> 2] = 0; //@line 11954
 else {
   _subexpr($ls, $args, 0) | 0; //@line 11956
   if ((HEAP32[$2 >> 2] | 0) == 44) do {
    _luaX_next($ls); //@line 11961
    _luaK_exp2nextreg(HEAP32[$0 >> 2] | 0, $args); //@line 11963
    _subexpr($ls, $args, 0) | 0; //@line 11964
   } while ((HEAP32[$2 >> 2] | 0) == 44);
   _luaK_setreturns($1, $args, -1); //@line 11972
  }
  _check_match($ls, 41, 40, $line); //@line 11974
 } else if (($3 | 0) == 289) {
  $13 = _luaK_stringK($1, HEAP32[$ls + 24 >> 2] | 0) | 0; //@line 11978
  HEAP32[$args + 16 >> 2] = -1; //@line 11980
  HEAP32[$args + 20 >> 2] = -1; //@line 11982
  HEAP32[$args >> 2] = 4; //@line 11983
  HEAP32[$args + 8 >> 2] = $13; //@line 11985
  _luaX_next($ls); //@line 11986
 } else if (($3 | 0) == 123) _constructor($ls, $args); //@line 11988
 else _luaX_syntaxerror($ls, 9480); //@line 11990
 $17 = $f + 8 | 0; //@line 11993
 $18 = HEAP32[$17 >> 2] | 0; //@line 11994
 $19 = HEAP32[$args >> 2] | 0; //@line 11995
 if (!$19) label = 13; //@line 11997
 else if (($19 | 0) == 13 | ($19 | 0) == 12) $nparams$0 = 0; //@line 11999
 else {
  _luaK_exp2nextreg($1, $args); //@line 12001
  label = 13; //@line 12002
 }
 if ((label | 0) == 13) $nparams$0 = (HEAPU8[$1 + 48 >> 0] | 0) - $18 | 0; //@line 12009
 $23 = _luaK_codeABC($1, 29, $18, $nparams$0, 2) | 0; //@line 12011
 HEAP32[$f + 16 >> 2] = -1; //@line 12013
 HEAP32[$f + 20 >> 2] = -1; //@line 12015
 HEAP32[$f >> 2] = 12; //@line 12016
 HEAP32[$17 >> 2] = $23; //@line 12017
 _luaK_fixline($1, $line); //@line 12018
 HEAP8[$1 + 48 >> 0] = $18 + 1; //@line 12022
 STACKTOP = sp; //@line 12023
 return;
}
function _luaC_freeallobjects($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $16 = 0, $18 = 0, $19 = 0, $20 = 0, $22 = 0, $23 = 0, $3 = 0, $33 = 0, $36 = 0, $5 = 0, $6 = 0, $8 = 0, $9 = 0, $i$01 = 0, $lastnext$0$i = 0, $lastnext$13$i = 0, $lastnext$13$i$phi = 0, sp = 0;
 sp = STACKTOP; //@line 19274
 $0 = $L + 12 | 0; //@line 19275
 $1 = HEAP32[$0 >> 2] | 0; //@line 19276
 $lastnext$0$i = $1 + 104 | 0; //@line 19278
 while (1) {
  $3 = HEAP32[$lastnext$0$i >> 2] | 0; //@line 19280
  if (!$3) break; else $lastnext$0$i = $3; //@line 19285
 }
 $5 = $1 + 72 | 0; //@line 19288
 $6 = HEAP32[$5 >> 2] | 0; //@line 19289
 if (!$6) $19 = $1; //@line 19292
 else {
  $9 = $6; //@line 19294
  $lastnext$13$i = $lastnext$0$i; //@line 19294
  while (1) {
   $8 = $9 + 5 | 0; //@line 19296
   HEAP8[$8 >> 0] = HEAPU8[$8 >> 0] | 0 | 8; //@line 19301
   HEAP32[$5 >> 2] = HEAP32[$9 >> 2]; //@line 19303
   HEAP32[$9 >> 2] = HEAP32[$lastnext$13$i >> 2]; //@line 19305
   HEAP32[$lastnext$13$i >> 2] = $9; //@line 19306
   $16 = HEAP32[$5 >> 2] | 0; //@line 19307
   if (!$16) break; else {
    $lastnext$13$i$phi = $9; //@line 19312
    $9 = $16; //@line 19312
    $lastnext$13$i = $lastnext$13$i$phi; //@line 19312
   }
  }
  $19 = HEAP32[$0 >> 2] | 0; //@line 19316
 }
 $18 = $19 + 104 | 0; //@line 19318
 $20 = HEAP32[$18 >> 2] | 0; //@line 19319
 if ($20) {
  $23 = $20; //@line 19322
  do {
   $22 = $23 + 5 | 0; //@line 19324
   HEAP8[$22 >> 0] = (HEAPU8[$22 >> 0] | 0) & 191; //@line 19329
   _GCTM($L, 0); //@line 19330
   $23 = HEAP32[$18 >> 2] | 0; //@line 19331
  } while (($23 | 0) != 0);
 }
 HEAP8[$1 + 60 >> 0] = 3; //@line 19341
 HEAP8[$1 + 62 >> 0] = 0; //@line 19343
 _sweeplist($L, $5, -3) | 0; //@line 19344
 _sweeplist($L, $1 + 68 | 0, -3) | 0; //@line 19346
 $33 = $1 + 32 | 0; //@line 19347
 if ((HEAP32[$33 >> 2] | 0) <= 0) {
  STACKTOP = sp; //@line 19351
  return;
 }
 $36 = $1 + 24 | 0; //@line 19353
 $i$01 = 0; //@line 19354
 do {
  _sweeplist($L, (HEAP32[$36 >> 2] | 0) + ($i$01 << 2) | 0, -3) | 0; //@line 19358
  $i$01 = $i$01 + 1 | 0; //@line 19359
 } while (($i$01 | 0) < (HEAP32[$33 >> 2] | 0));
 STACKTOP = sp; //@line 19368
 return;
}
function _luaH_setint($L, $t, $key, $value) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 $value = $value | 0;
 var $$0$i = 0, $$pre$phiZ2D = 0.0, $0 = 0, $12 = 0, $14 = 0, $34 = 0, $39 = 0, $44 = 0, $45 = 0, $7 = 0.0, $cell$0 = 0, $i$1$i$i = 0, $k = 0, $n$0$i = 0, $u$sroa$0$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 16733
 STACKTOP = STACKTOP + 32 | 0; //@line 16734
 $u$sroa$0$i$i = sp + 16 | 0; //@line 16735
 $k = sp; //@line 16736
 $0 = $key + -1 | 0; //@line 16737
 L1 : do if ($0 >>> 0 < (HEAP32[$t + 28 >> 2] | 0) >>> 0) {
  $$0$i = (HEAP32[$t + 12 >> 2] | 0) + ($0 << 4) | 0; //@line 16746
  label = 10; //@line 16747
 } else {
  $7 = +($key | 0); //@line 16749
  HEAPF64[$u$sroa$0$i$i >> 3] = $7 + 1.0; //@line 16751
  $12 = (HEAP32[$u$sroa$0$i$i + 4 >> 2] | 0) + (HEAP32[$u$sroa$0$i$i >> 2] | 0) | 0; //@line 16755
  if (($12 | 0) < 0) {
   $14 = 0 - $12 | 0; //@line 16758
   $i$1$i$i = ($12 | 0) == ($14 | 0) ? 0 : $14; //@line 16761
  } else $i$1$i$i = $12; //@line 16763
  $n$0$i = (HEAP32[$t + 16 >> 2] | 0) + ((($i$1$i$i | 0) % ((1 << (HEAPU8[$t + 7 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 16775
  while (1) {
   if ((HEAP32[$n$0$i + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0$i + 16 >> 3] == $7) break;
   $34 = HEAP32[$n$0$i + 28 >> 2] | 0; //@line 16789
   if (!$34) {
    $$pre$phiZ2D = $7; //@line 16792
    label = 12; //@line 16793
    break L1;
   } else $n$0$i = $34; //@line 16796
  }
  $$0$i = $n$0$i; //@line 16799
  label = 10; //@line 16800
 } while (0);
 if ((label | 0) == 10) if (($$0$i | 0) == 8048) {
  $$pre$phiZ2D = +($key | 0); //@line 16807
  label = 12; //@line 16808
 } else $cell$0 = $$0$i; //@line 16810
 if ((label | 0) == 12) {
  HEAPF64[$k >> 3] = $$pre$phiZ2D; //@line 16814
  HEAP32[$k + 8 >> 2] = 3; //@line 16816
  $cell$0 = _luaH_newkey($L, $t, $k) | 0; //@line 16818
 }
 $39 = $value; //@line 16820
 $44 = HEAP32[$39 + 4 >> 2] | 0; //@line 16825
 $45 = $cell$0; //@line 16826
 HEAP32[$45 >> 2] = HEAP32[$39 >> 2]; //@line 16828
 HEAP32[$45 + 4 >> 2] = $44; //@line 16831
 HEAP32[$cell$0 + 8 >> 2] = HEAP32[$value + 8 >> 2]; //@line 16835
 STACKTOP = sp; //@line 16836
 return;
}
function _lua_setuservalue($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $4 = 0, $41 = 0, $46 = 0, $51 = 0, $52 = 0, sp = 0;
 sp = STACKTOP; //@line 4172
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 4174
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 4179
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 4184
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 4191
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 4199
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 4202
  $17 = HEAP32[$1 >> 2] | 0; //@line 4203
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 4208
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 4210
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 4216
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 4220
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 4225
 $29 = HEAP32[$28 >> 2] | 0; //@line 4226
 if (!(HEAP32[$29 + -8 >> 2] | 0)) {
  HEAP32[(HEAP32[$$0$i >> 2] | 0) + 12 >> 2] = 0; //@line 4233
  $51 = HEAP32[$28 >> 2] | 0; //@line 4234
  $52 = $51 + -16 | 0; //@line 4235
  HEAP32[$28 >> 2] = $52; //@line 4236
  STACKTOP = sp; //@line 4237
  return;
 }
 HEAP32[(HEAP32[$$0$i >> 2] | 0) + 12 >> 2] = HEAP32[$29 + -16 >> 2]; //@line 4243
 $41 = HEAP32[(HEAP32[$28 >> 2] | 0) + -16 >> 2] | 0; //@line 4246
 if (!(HEAP8[$41 + 5 >> 0] & 3)) {
  $51 = HEAP32[$28 >> 2] | 0; //@line 4252
  $52 = $51 + -16 | 0; //@line 4253
  HEAP32[$28 >> 2] = $52; //@line 4254
  STACKTOP = sp; //@line 4255
  return;
 }
 $46 = HEAP32[$$0$i >> 2] | 0; //@line 4257
 if (!(HEAP8[$46 + 5 >> 0] & 4)) {
  $51 = HEAP32[$28 >> 2] | 0; //@line 4263
  $52 = $51 + -16 | 0; //@line 4264
  HEAP32[$28 >> 2] = $52; //@line 4265
  STACKTOP = sp; //@line 4266
  return;
 }
 _luaC_barrier_($L, $46, $41); //@line 4268
 $51 = HEAP32[$28 >> 2] | 0; //@line 4269
 $52 = $51 + -16 | 0; //@line 4270
 HEAP32[$28 >> 2] = $52; //@line 4271
 STACKTOP = sp; //@line 4272
 return;
}
function _str_rep($L) {
 $L = $L | 0;
 var $$0 = 0, $$in = 0, $0 = 0, $1 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $26 = 0, $4 = 0, $5 = 0, $6 = 0, $l = 0, $lsep = 0, $p$0$be = 0, $p$01 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 14519
 STACKTOP = STACKTOP + 1056 | 0; //@line 14520
 $vararg_buffer = sp; //@line 14521
 $l = sp + 1044 | 0; //@line 14522
 $lsep = sp + 1040 | 0; //@line 14523
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 14524
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 14525
 $2 = _luaL_optlstring($L, 3, 9896, $lsep) | 0; //@line 14526
 if (($1 | 0) < 1) {
  _lua_pushlstring($L, 9896, 0) | 0; //@line 14529
  $$0 = 1; //@line 14530
  STACKTOP = sp; //@line 14531
  return $$0 | 0; //@line 14531
 }
 $4 = HEAP32[$l >> 2] | 0; //@line 14533
 $5 = HEAP32[$lsep >> 2] | 0; //@line 14534
 $6 = $5 + $4 | 0; //@line 14535
 if ($6 >>> 0 >= $4 >>> 0) if ($6 >>> 0 < (2147483647 / ($1 >>> 0) | 0) >>> 0) {
  $14 = (Math_imul($5, $1 + -1 | 0) | 0) + (Math_imul($4, $1) | 0) | 0; //@line 14544
  $15 = _luaL_buffinitsize($L, $vararg_buffer, $14) | 0; //@line 14545
  _memcpy($15 | 0, $0 | 0, HEAP32[$l >> 2] | 0) | 0; //@line 14548
  if (($1 | 0) > 1) {
   $$in = $1; //@line 14550
   $p$01 = $15; //@line 14550
   while (1) {
    $$in = $$in + -1 | 0; //@line 14552
    $19 = HEAP32[$l >> 2] | 0; //@line 14553
    $20 = $p$01 + $19 | 0; //@line 14554
    $21 = HEAP32[$lsep >> 2] | 0; //@line 14555
    if (!$21) {
     $26 = $19; //@line 14558
     $p$0$be = $20; //@line 14558
    } else {
     _memcpy($20 | 0, $2 | 0, $21 | 0) | 0; //@line 14560
     $26 = HEAP32[$l >> 2] | 0; //@line 14565
     $p$0$be = $p$01 + ((HEAP32[$lsep >> 2] | 0) + $19) | 0; //@line 14565
    }
    _memcpy($p$0$be | 0, $0 | 0, $26 | 0) | 0; //@line 14568
    if (($$in | 0) <= 1) break; else $p$01 = $p$0$be; //@line 14570
   }
  }
  _luaL_pushresultsize($vararg_buffer, $14); //@line 14576
  $$0 = 1; //@line 14577
  STACKTOP = sp; //@line 14578
  return $$0 | 0; //@line 14578
 }
 $$0 = _luaL_error($L, 10024, $vararg_buffer) | 0; //@line 14582
 STACKTOP = sp; //@line 14583
 return $$0 | 0; //@line 14583
}
function ___strchrnul($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$02$lcssa = 0, $$026 = 0, $$1 = 0, $0 = 0, $12 = 0, $15 = 0, $16 = 0, $23 = 0, $29 = 0, $30 = 0, $36 = 0, $37 = 0, $5 = 0, $9 = 0, $w$0$lcssa = 0, $w$03 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5527
 $0 = $c & 255; //@line 5528
 if (!$0) {
  $$0 = $s + (_strlen($s | 0) | 0) | 0; //@line 5533
  STACKTOP = sp; //@line 5534
  return $$0 | 0; //@line 5534
 }
 L5 : do if (!($s & 3)) $$02$lcssa = $s; //@line 5541
 else {
  $5 = $c & 255; //@line 5543
  $$026 = $s; //@line 5544
  while (1) {
   $12 = HEAP8[$$026 >> 0] | 0; //@line 5546
   if (!($12 << 24 >> 24)) {
    $$0 = $$026; //@line 5549
    label = 13; //@line 5550
    break;
   }
   $9 = $$026 + 1 | 0; //@line 5554
   if ($12 << 24 >> 24 == $5 << 24 >> 24) {
    $$0 = $$026; //@line 5556
    label = 13; //@line 5557
    break;
   }
   if (!($9 & 3)) {
    $$02$lcssa = $9; //@line 5564
    break L5;
   } else $$026 = $9; //@line 5567
  }
  if ((label | 0) == 13) {
   STACKTOP = sp; //@line 5571
   return $$0 | 0; //@line 5571
  }
 } while (0);
 $15 = Math_imul($0, 16843009) | 0; //@line 5575
 $16 = HEAP32[$$02$lcssa >> 2] | 0; //@line 5576
 L15 : do if (!(($16 & -2139062144 ^ -2139062144) & $16 + -16843009)) {
  $30 = $16; //@line 5584
  $w$03 = $$02$lcssa; //@line 5584
  while (1) {
   $29 = $30 ^ $15; //@line 5586
   $23 = $w$03 + 4 | 0; //@line 5592
   if (($29 & -2139062144 ^ -2139062144) & $29 + -16843009) {
    $w$0$lcssa = $w$03; //@line 5594
    break L15;
   }
   $30 = HEAP32[$23 >> 2] | 0; //@line 5597
   if (($30 & -2139062144 ^ -2139062144) & $30 + -16843009) {
    $w$0$lcssa = $23; //@line 5606
    break;
   } else $w$03 = $23; //@line 5604
  }
 } else $w$0$lcssa = $$02$lcssa; //@line 5611
 while (0);
 $36 = $c & 255; //@line 5614
 $$1 = $w$0$lcssa; //@line 5615
 while (1) {
  $37 = HEAP8[$$1 >> 0] | 0; //@line 5617
  if ($37 << 24 >> 24 == 0 ? 1 : $37 << 24 >> 24 == $36 << 24 >> 24) {
   $$0 = $$1; //@line 5623
   break;
  } else $$1 = $$1 + 1 | 0; //@line 5626
 }
 STACKTOP = sp; //@line 5629
 return $$0 | 0; //@line 5629
}
function _f_parser($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var $0 = 0, $1 = 0, $11 = 0, $13 = 0, $14 = 0, $30 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $cl$0 = 0, $i$02 = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP; //@line 17443
 STACKTOP = STACKTOP + 16 | 0; //@line 17444
 $vararg_buffer2 = sp; //@line 17445
 $0 = HEAP32[$ud >> 2] | 0; //@line 17446
 $1 = HEAP32[$0 >> 2] | 0; //@line 17447
 HEAP32[$0 >> 2] = $1 + -1; //@line 17449
 if (!$1) $11 = _luaZ_fill($0) | 0; //@line 17453
 else {
  $4 = $0 + 4 | 0; //@line 17455
  $5 = HEAP32[$4 >> 2] | 0; //@line 17456
  HEAP32[$4 >> 2] = $5 + 1; //@line 17458
  $11 = HEAPU8[$5 >> 0] | 0; //@line 17461
 }
 $13 = HEAP32[$ud + 52 >> 2] | 0; //@line 17465
 $14 = ($13 | 0) == 0; //@line 17466
 if (($11 | 0) == 27) {
  if (!$14) if (!(_strchr($13, 98) | 0)) {
   HEAP32[$vararg_buffer2 >> 2] = 4400; //@line 17472
   HEAP32[$vararg_buffer2 + 4 >> 2] = $13; //@line 17474
   _luaO_pushfstring($L, 4416, $vararg_buffer2) | 0; //@line 17475
   _luaD_throw($L, 3); //@line 17476
  }
  $cl$0 = _luaU_undump($L, HEAP32[$ud >> 2] | 0, $ud + 4 | 0, HEAP32[$ud + 56 >> 2] | 0) | 0; //@line 17485
 } else {
  if (!$14) if (!(_strchr($13, 116) | 0)) {
   HEAP32[$vararg_buffer2 >> 2] = 4408; //@line 17491
   HEAP32[$vararg_buffer2 + 4 >> 2] = $13; //@line 17493
   _luaO_pushfstring($L, 4416, $vararg_buffer2) | 0; //@line 17494
   _luaD_throw($L, 3); //@line 17495
  }
  $cl$0 = _luaY_parser($L, HEAP32[$ud >> 2] | 0, $ud + 4 | 0, $ud + 16 | 0, HEAP32[$ud + 56 >> 2] | 0, $11) | 0; //@line 17505
 }
 $30 = $cl$0 + 6 | 0; //@line 17507
 if (!(HEAP8[$30 >> 0] | 0)) {
  STACKTOP = sp; //@line 17511
  return;
 }
 $33 = $cl$0 + 16 | 0; //@line 17513
 $34 = $cl$0 + 5 | 0; //@line 17514
 $i$02 = 0; //@line 17515
 do {
  $35 = _luaF_newupval($L) | 0; //@line 17517
  HEAP32[$33 + ($i$02 << 2) >> 2] = $35; //@line 17519
  if (HEAP8[$35 + 5 >> 0] & 3) if (HEAP8[$34 >> 0] & 4) _luaC_barrier_($L, $cl$0, $35); //@line 17529
  $i$02 = $i$02 + 1 | 0; //@line 17532
 } while (($i$02 | 0) < (HEAPU8[$30 >> 0] | 0));
 STACKTOP = sp; //@line 17542
 return;
}
function _lua_remove($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$lcssa1 = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $30 = 0, $32 = 0, $33 = 0, $38 = 0, $39 = 0, $4 = 0, $46 = 0, $47 = 0, $49 = 0, $p$0$ph = 0, $p$02 = 0, $p$02$phi = 0, sp = 0;
 sp = STACKTOP; //@line 289
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 291
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 296
  $p$0$ph = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 301
 } else {
  if (($idx | 0) >= -1000999) {
   $p$0$ph = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 308
   break;
  }
  if (($idx | 0) == -1001e3) {
   $p$0$ph = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 316
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 319
  $17 = HEAP32[$1 >> 2] | 0; //@line 320
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $p$0$ph = 8048; //@line 325
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 327
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $p$0$ph = 8048; //@line 333
 else $p$0$ph = $21 + ($16 + -1 << 4) + 16 | 0; //@line 337
  }
 } while (0);
 $28 = $p$0$ph + 16 | 0; //@line 342
 $29 = $L + 8 | 0; //@line 343
 $30 = HEAP32[$29 >> 2] | 0; //@line 344
 if ($28 >>> 0 < $30 >>> 0) {
  $33 = $28; //@line 347
  $p$02 = $p$0$ph; //@line 347
 } else {
  $$lcssa1 = $30; //@line 349
  $49 = $$lcssa1 + -16 | 0; //@line 350
  HEAP32[$29 >> 2] = $49; //@line 351
  STACKTOP = sp; //@line 352
  return;
 }
 while (1) {
  $32 = $33; //@line 355
  $38 = HEAP32[$32 + 4 >> 2] | 0; //@line 360
  $39 = $p$02; //@line 361
  HEAP32[$39 >> 2] = HEAP32[$32 >> 2]; //@line 363
  HEAP32[$39 + 4 >> 2] = $38; //@line 366
  HEAP32[$p$02 + 8 >> 2] = HEAP32[$p$02 + 24 >> 2]; //@line 370
  $46 = $33 + 16 | 0; //@line 371
  $47 = HEAP32[$29 >> 2] | 0; //@line 372
  if ($46 >>> 0 < $47 >>> 0) {
   $p$02$phi = $33; //@line 375
   $33 = $46; //@line 375
   $p$02 = $p$02$phi; //@line 375
  } else {
   $$lcssa1 = $47; //@line 377
   break;
  }
 }
 $49 = $$lcssa1 + -16 | 0; //@line 381
 HEAP32[$29 >> 2] = $49; //@line 382
 STACKTOP = sp; //@line 383
 return;
}
function _strspn($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$026 = 0, $$03 = 0, $$1$lcssa = 0, $$14 = 0, $0 = 0, $11 = 0, $13 = 0, $14 = 0, $18 = 0, $25 = 0, $27 = 0, $28 = 0, $byteset = 0, sp = 0;
 sp = STACKTOP; //@line 5742
 STACKTOP = STACKTOP + 32 | 0; //@line 5743
 $byteset = sp; //@line 5744
 HEAP32[$byteset + 0 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 4 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 8 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 12 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 16 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 20 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 24 >> 2] = 0; //@line 5745
 HEAP32[$byteset + 28 >> 2] = 0; //@line 5745
 $0 = HEAP8[$c >> 0] | 0; //@line 5746
 if (!($0 << 24 >> 24)) {
  $$0 = 0; //@line 5749
  STACKTOP = sp; //@line 5750
  return $$0 | 0; //@line 5750
 }
 if (!(HEAP8[$c + 1 >> 0] | 0)) {
  $$03 = $s; //@line 5756
  while (1) if ((HEAP8[$$03 >> 0] | 0) == $0 << 24 >> 24) $$03 = $$03 + 1 | 0; //@line 5762
 else break;
  $$0 = $$03 - $s | 0; //@line 5770
  STACKTOP = sp; //@line 5771
  return $$0 | 0; //@line 5771
 } else {
  $$026 = $c; //@line 5773
  $14 = $0; //@line 5773
 }
 do {
  $13 = $14 & 255; //@line 5776
  $18 = $byteset + ($13 >>> 5 << 2) | 0; //@line 5780
  HEAP32[$18 >> 2] = HEAP32[$18 >> 2] | 1 << ($13 & 31); //@line 5783
  $$026 = $$026 + 1 | 0; //@line 5784
  $14 = HEAP8[$$026 >> 0] | 0; //@line 5785
 } while ($14 << 24 >> 24 != 0);
 $11 = HEAP8[$s >> 0] | 0; //@line 5793
 L12 : do if (!($11 << 24 >> 24)) $$1$lcssa = $s; //@line 5797
 else {
  $$14 = $s; //@line 5799
  $28 = $11; //@line 5799
  while (1) {
   $27 = $28 & 255; //@line 5801
   $25 = $$14 + 1 | 0; //@line 5809
   if (!(HEAP32[$byteset + ($27 >>> 5 << 2) >> 2] & 1 << ($27 & 31))) {
    $$1$lcssa = $$14; //@line 5811
    break L12;
   }
   $28 = HEAP8[$25 >> 0] | 0; //@line 5814
   if (!($28 << 24 >> 24)) {
    $$1$lcssa = $25; //@line 5817
    break;
   } else $$14 = $25; //@line 5820
  }
 } while (0);
 $$0 = $$1$lcssa - $s | 0; //@line 5828
 STACKTOP = sp; //@line 5829
 return $$0 | 0; //@line 5829
}
function _luaF_close($L, $level) {
 $L = $L | 0;
 $level = $level | 0;
 var $1 = 0, $2 = 0, $24 = 0, $26 = 0, $3 = 0, $33 = 0, $35 = 0, $42 = 0, $43 = 0, $44 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 18459
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 18461
 $2 = $L + 56 | 0; //@line 18462
 $3 = HEAP32[$2 >> 2] | 0; //@line 18463
 if (!$3) {
  STACKTOP = sp; //@line 18466
  return;
 }
 $5 = $1 + 60 | 0; //@line 18468
 $6 = $1 + 68 | 0; //@line 18469
 $8 = $3; //@line 18470
 while (1) {
  $7 = $8 + 8 | 0; //@line 18472
  if ((HEAP32[$7 >> 2] | 0) >>> 0 < $level >>> 0) {
   label = 10; //@line 18476
   break;
  }
  HEAP32[$2 >> 2] = HEAP32[$8 >> 2]; //@line 18480
  if (!(((HEAPU8[$5 >> 0] | 0) ^ 3) & ((HEAPU8[$8 + 5 >> 0] | 0) ^ 3))) {
   if ((HEAP32[$7 >> 2] | 0) != ($8 + 16 | 0)) {
    $24 = $8 + 16 | 0; //@line 18495
    $26 = $24 + 4 | 0; //@line 18497
    HEAP32[(HEAP32[$26 >> 2] | 0) + 16 >> 2] = HEAP32[$24 >> 2]; //@line 18500
    HEAP32[(HEAP32[$24 >> 2] | 0) + 20 >> 2] = HEAP32[$26 >> 2]; //@line 18505
   }
   _luaM_realloc_($L, $8, 32, 0) | 0; //@line 18507
  } else {
   $33 = $8 + 16 | 0; //@line 18509
   $35 = $33 + 4 | 0; //@line 18511
   HEAP32[(HEAP32[$35 >> 2] | 0) + 16 >> 2] = HEAP32[$33 >> 2]; //@line 18514
   HEAP32[(HEAP32[$33 >> 2] | 0) + 20 >> 2] = HEAP32[$35 >> 2]; //@line 18519
   $42 = HEAP32[$7 >> 2] | 0; //@line 18520
   $43 = $8 + 16 | 0; //@line 18521
   $44 = $42; //@line 18522
   $49 = HEAP32[$44 + 4 >> 2] | 0; //@line 18527
   $50 = $43; //@line 18528
   HEAP32[$50 >> 2] = HEAP32[$44 >> 2]; //@line 18530
   HEAP32[$50 + 4 >> 2] = $49; //@line 18533
   HEAP32[$8 + 24 >> 2] = HEAP32[$42 + 8 >> 2]; //@line 18537
   HEAP32[$7 >> 2] = $43; //@line 18538
   HEAP32[$8 >> 2] = HEAP32[$6 >> 2]; //@line 18540
   HEAP32[$6 >> 2] = $8; //@line 18541
   _luaC_checkupvalcolor($1, $8); //@line 18542
  }
  $8 = HEAP32[$2 >> 2] | 0; //@line 18544
  if (!$8) {
   label = 10; //@line 18547
   break;
  }
 }
 if ((label | 0) == 10) {
  STACKTOP = sp; //@line 18554
  return;
 }
}
function _MUSL_vfprintf($f, $fmt, $ap) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$ = 0, $$0 = 0, $11 = 0, $12 = 0, $2 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ap2 = 0, $internal_buf = 0, $nl_arg = 0, $nl_type = 0, $ret$1 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP; //@line 13543
 STACKTOP = STACKTOP + 224 | 0; //@line 13544
 $ap2 = sp + 120 | 0; //@line 13545
 $nl_type = sp + 80 | 0; //@line 13546
 $nl_arg = sp; //@line 13547
 $internal_buf = sp + 136 | 0; //@line 13548
 dest = $nl_type + 0 | 0; //@line 13549
 stop = dest + 40 | 0; //@line 13549
 do {
  HEAP32[dest >> 2] = 0; //@line 13549
  dest = dest + 4 | 0; //@line 13549
 } while ((dest | 0) < (stop | 0));
 HEAP32[$ap2 >> 2] = HEAP32[$ap >> 2]; //@line 13551
 if ((_printf_core(0, $fmt, $ap2, $nl_arg, $nl_type) | 0) < 0) {
  $$0 = -1; //@line 13555
  STACKTOP = sp; //@line 13556
  return $$0 | 0; //@line 13556
 }
 $2 = $f + 48 | 0; //@line 13558
 if (!(HEAP32[$2 >> 2] | 0)) {
  $6 = $f + 44 | 0; //@line 13562
  $7 = HEAP32[$6 >> 2] | 0; //@line 13563
  HEAP32[$6 >> 2] = $internal_buf; //@line 13564
  $8 = $f + 28 | 0; //@line 13565
  HEAP32[$8 >> 2] = $internal_buf; //@line 13566
  $9 = $f + 20 | 0; //@line 13567
  HEAP32[$9 >> 2] = $internal_buf; //@line 13568
  HEAP32[$2 >> 2] = 80; //@line 13569
  $11 = $f + 16 | 0; //@line 13571
  HEAP32[$11 >> 2] = $internal_buf + 80; //@line 13572
  $12 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0; //@line 13573
  if (!$7) $ret$1 = $12; //@line 13576
 else {
   FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 31]($f, 0, 0) | 0; //@line 13580
   $$ = (HEAP32[$9 >> 2] | 0) == 0 ? -1 : $12; //@line 13583
   HEAP32[$6 >> 2] = $7; //@line 13584
   HEAP32[$2 >> 2] = 0; //@line 13585
   HEAP32[$11 >> 2] = 0; //@line 13586
   HEAP32[$8 >> 2] = 0; //@line 13587
   HEAP32[$9 >> 2] = 0; //@line 13588
   $ret$1 = $$; //@line 13589
  }
 } else $ret$1 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0; //@line 13593
 $$0 = $ret$1; //@line 13595
 STACKTOP = sp; //@line 13596
 return $$0 | 0; //@line 13596
}
function _ll_require($L) {
 $L = $L | 0;
 var $0 = 0, $7 = 0, $i$0$i = 0, $msg$i = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 6562
 STACKTOP = STACKTOP + 1056 | 0; //@line 6563
 $vararg_buffer1 = sp; //@line 6564
 $msg$i = sp + 8 | 0; //@line 6565
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6566
 _lua_settop($L, 1); //@line 6567
 _lua_getfield($L, -1001e3, 7432); //@line 6568
 _lua_getfield($L, 2, $0); //@line 6569
 if (_lua_toboolean($L, -1) | 0) {
  STACKTOP = sp; //@line 6573
  return 1; //@line 6573
 }
 _lua_settop($L, -2); //@line 6575
 _luaL_buffinit($L, $msg$i); //@line 6576
 _lua_getfield($L, -1001001, 7096); //@line 6577
 if ((_lua_type($L, 3) | 0) == 5) $i$0$i = 1; //@line 6581
 else {
  _luaL_error($L, 7512, $vararg_buffer1) | 0; //@line 6583
  $i$0$i = 1; //@line 6584
 }
 while (1) {
  _lua_rawgeti($L, 3, $i$0$i); //@line 6587
  if (!(_lua_type($L, -1) | 0)) {
   _lua_settop($L, -2); //@line 6591
   _luaL_pushresult($msg$i); //@line 6592
   $7 = _lua_tolstring($L, -1, 0) | 0; //@line 6593
   HEAP32[$vararg_buffer1 >> 2] = $0; //@line 6594
   HEAP32[$vararg_buffer1 + 4 >> 2] = $7; //@line 6596
   _luaL_error($L, 7552, $vararg_buffer1) | 0; //@line 6597
  }
  _lua_pushstring($L, $0) | 0; //@line 6599
  _lua_callk($L, 1, 2, 0, 0); //@line 6600
  if ((_lua_type($L, -2) | 0) == 6) break;
  if (!(_lua_isstring($L, -2) | 0)) _lua_settop($L, -3); //@line 6609
 else {
   _lua_settop($L, -2); //@line 6611
   _luaL_addvalue($msg$i); //@line 6612
  }
  $i$0$i = $i$0$i + 1 | 0; //@line 6615
 }
 _lua_pushstring($L, $0) | 0; //@line 6617
 _lua_insert($L, -2); //@line 6618
 _lua_callk($L, 2, 1, 0, 0); //@line 6619
 if (_lua_type($L, -1) | 0) _lua_setfield($L, 2, $0); //@line 6623
 _lua_getfield($L, 2, $0); //@line 6625
 if (_lua_type($L, -1) | 0) {
  STACKTOP = sp; //@line 6629
  return 1; //@line 6629
 }
 _lua_pushboolean($L, 1); //@line 6631
 _lua_pushvalue($L, -1); //@line 6632
 _lua_setfield($L, 2, $0); //@line 6633
 STACKTOP = sp; //@line 6634
 return 1; //@line 6634
}
function _f_luaopen($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var $1 = 0, $11 = 0, $2 = 0, $20 = 0, $23 = 0, $25 = 0, $27 = 0, $4 = 0, $i$01$i = 0, $mt$i = 0, sp = 0;
 sp = STACKTOP; //@line 12938
 STACKTOP = STACKTOP + 16 | 0; //@line 12939
 $mt$i = sp; //@line 12940
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 12942
 $2 = _luaM_realloc_($L, 0, 0, 640) | 0; //@line 12943
 HEAP32[$L + 28 >> 2] = $2; //@line 12945
 $4 = $L + 32 | 0; //@line 12946
 HEAP32[$4 >> 2] = 40; //@line 12947
 $i$01$i = 0; //@line 12948
 do {
  HEAP32[$2 + ($i$01$i << 4) + 8 >> 2] = 0; //@line 12951
  $i$01$i = $i$01$i + 1 | 0; //@line 12952
 } while (($i$01$i | 0) != 40);
 HEAP32[$L + 24 >> 2] = $2 + ((HEAP32[$4 >> 2] | 0) + -5 << 4); //@line 12965
 $11 = $L + 72 | 0; //@line 12966
 HEAP32[$L + 80 >> 2] = 0; //@line 12968
 HEAP32[$L + 84 >> 2] = 0; //@line 12970
 HEAP8[$L + 90 >> 0] = 0; //@line 12972
 HEAP32[$11 >> 2] = $2; //@line 12973
 HEAP32[$L + 8 >> 2] = $2 + 16; //@line 12975
 HEAP32[$2 + 8 >> 2] = 0; //@line 12977
 HEAP32[$L + 76 >> 2] = $2 + 336; //@line 12980
 HEAP32[$L + 16 >> 2] = $11; //@line 12982
 $20 = _luaH_new($L) | 0; //@line 12983
 HEAP32[$1 + 40 >> 2] = $20; //@line 12985
 HEAP32[$1 + 48 >> 2] = 69; //@line 12987
 _luaH_resize($L, $20, 2, 0); //@line 12988
 HEAP32[$mt$i >> 2] = $L; //@line 12989
 $23 = $mt$i + 8 | 0; //@line 12990
 HEAP32[$23 >> 2] = 72; //@line 12991
 _luaH_setint($L, $20, 1, $mt$i); //@line 12992
 HEAP32[$mt$i >> 2] = _luaH_new($L) | 0; //@line 12994
 HEAP32[$23 >> 2] = 69; //@line 12995
 _luaH_setint($L, $20, 2, $mt$i); //@line 12996
 _luaS_resize($L, 32); //@line 12997
 _luaT_init($L); //@line 12998
 _luaX_init($L); //@line 12999
 $25 = _luaS_newlstr($L, 9752, 17) | 0; //@line 13000
 HEAP32[$1 + 180 >> 2] = $25; //@line 13002
 $27 = $25 + 5 | 0; //@line 13003
 HEAP8[$27 >> 0] = HEAPU8[$27 >> 0] | 0 | 32; //@line 13008
 HEAP8[$1 + 63 >> 0] = 1; //@line 13010
 HEAP32[$1 + 176 >> 2] = _lua_version(0) | 0; //@line 13013
 STACKTOP = sp; //@line 13014
 return;
}
function _str_byte($L) {
 $L = $L | 0;
 var $$ = 0, $$0 = 0, $$0$i = 0, $$0$i1 = 0, $0 = 0, $1 = 0, $19 = 0, $2 = 0, $23 = 0, $24 = 0, $25 = 0, $29 = 0, $8 = 0, $9 = 0, $i$03 = 0, $l = 0, $pose$0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 13546
 STACKTOP = STACKTOP + 16 | 0; //@line 13547
 $vararg_buffer = sp; //@line 13548
 $l = sp + 4 | 0; //@line 13549
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 13550
 $1 = _luaL_optinteger($L, 2, 1) | 0; //@line 13551
 $2 = HEAP32[$l >> 2] | 0; //@line 13552
 if (($1 | 0) > -1) $$0$i = $1; //@line 13555
 else if ($2 >>> 0 < (0 - $1 | 0) >>> 0) $$0$i = 0; //@line 13560
 else $$0$i = $1 + 1 + $2 | 0; //@line 13564
 $8 = _luaL_optinteger($L, 3, $$0$i) | 0; //@line 13567
 $9 = HEAP32[$l >> 2] | 0; //@line 13568
 if (($8 | 0) > -1) $$0$i1 = $8; //@line 13571
 else if ($9 >>> 0 < (0 - $8 | 0) >>> 0) $$0$i1 = 0; //@line 13576
 else $$0$i1 = $8 + 1 + $9 | 0; //@line 13580
 $$ = ($$0$i | 0) == 0 ? 1 : $$0$i; //@line 13584
 $pose$0 = $$0$i1 >>> 0 > $9 >>> 0 ? $9 : $$0$i1; //@line 13586
 if ($$ >>> 0 > $pose$0 >>> 0) {
  $$0 = 0; //@line 13589
  STACKTOP = sp; //@line 13590
  return $$0 | 0; //@line 13590
 }
 $19 = $pose$0 - $$ + 1 | 0; //@line 13593
 if (($pose$0 | 0) == -1) {
  $$0 = _luaL_error($L, 10800, $vararg_buffer) | 0; //@line 13597
  STACKTOP = sp; //@line 13598
  return $$0 | 0; //@line 13598
 }
 _luaL_checkstack($L, $19, 10800); //@line 13600
 if (($19 | 0) <= 0) {
  $$0 = $19; //@line 13603
  STACKTOP = sp; //@line 13604
  return $$0 | 0; //@line 13604
 }
 $23 = $$ + -1 | 0; //@line 13606
 $24 = ~$$0$i1; //@line 13607
 $25 = ~$9; //@line 13608
 $29 = 0 - ($24 >>> 0 > $25 >>> 0 ? $24 : $25) - ($$0$i >>> 0 > 1 ? $$0$i : 1) | 0; //@line 13614
 $i$03 = 0; //@line 13615
 do {
  _lua_pushinteger($L, HEAPU8[$0 + ($23 + $i$03) >> 0] | 0); //@line 13621
  $i$03 = $i$03 + 1 | 0; //@line 13622
 } while (($i$03 | 0) != ($29 | 0));
 $$0 = $19; //@line 13625
 STACKTOP = sp; //@line 13631
 return $$0 | 0; //@line 13631
}
function _lua_rawseti($L, $idx, $n) {
 $L = $L | 0;
 $idx = $idx | 0;
 $n = $n | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $32 = 0, $4 = 0, $43 = 0, $48 = 0, $49 = 0, sp = 0;
 sp = STACKTOP; //@line 3790
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3792
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3797
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3802
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3809
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3817
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3820
  $17 = HEAP32[$1 >> 2] | 0; //@line 3821
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3826
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3828
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3834
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3838
  }
 } while (0);
 $29 = $L + 8 | 0; //@line 3844
 _luaH_setint($L, HEAP32[$$0$i >> 2] | 0, $n, (HEAP32[$29 >> 2] | 0) + -16 | 0); //@line 3847
 $32 = HEAP32[$29 >> 2] | 0; //@line 3848
 if (!(HEAP32[$32 + -8 >> 2] & 64)) {
  $49 = $32; //@line 3854
  $48 = $49 + -16 | 0; //@line 3855
  HEAP32[$29 >> 2] = $48; //@line 3856
  STACKTOP = sp; //@line 3857
  return;
 }
 if (!(HEAP8[(HEAP32[$32 + -16 >> 2] | 0) + 5 >> 0] & 3)) {
  $49 = $32; //@line 3866
  $48 = $49 + -16 | 0; //@line 3867
  HEAP32[$29 >> 2] = $48; //@line 3868
  STACKTOP = sp; //@line 3869
  return;
 }
 $43 = HEAP32[$$0$i >> 2] | 0; //@line 3871
 if (!(HEAP8[$43 + 5 >> 0] & 4)) {
  $49 = $32; //@line 3877
  $48 = $49 + -16 | 0; //@line 3878
  HEAP32[$29 >> 2] = $48; //@line 3879
  STACKTOP = sp; //@line 3880
  return;
 }
 _luaC_barrierback_($L, $43); //@line 3882
 $49 = HEAP32[$29 >> 2] | 0; //@line 3884
 $48 = $49 + -16 | 0; //@line 3885
 HEAP32[$29 >> 2] = $48; //@line 3886
 STACKTOP = sp; //@line 3887
 return;
}
function _db_sethook($L) {
 $L = $L | 0;
 var $$$i = 0, $$0$i = 0, $10 = 0, $13 = 0, $16 = 0, $3 = 0, $4 = 0, $8 = 0, $count$0 = 0, $func$0 = 0, $mask$0 = 0, $mask$1$$i = 0, $mask$1$i = 0, sp = 0;
 sp = STACKTOP; //@line 13644
 if ((_lua_type($L, 1) | 0) == 8) {
  $$0$i = _lua_tothread($L, 1) | 0; //@line 13649
  $4 = 1; //@line 13649
 } else {
  $$0$i = $L; //@line 13651
  $4 = 0; //@line 13651
 }
 $3 = $4 + 1 | 0; //@line 13653
 if ((_lua_type($L, $3) | 0) < 1) {
  _lua_settop($L, $3); //@line 13657
  $count$0 = 0; //@line 13658
  $func$0 = 0; //@line 13658
  $mask$0 = 0; //@line 13658
 } else {
  $8 = _luaL_checklstring($L, $4 | 2, 0) | 0; //@line 13661
  _luaL_checktype($L, $3, 6); //@line 13662
  $10 = _luaL_optinteger($L, $4 + 3 | 0, 0) | 0; //@line 13664
  $$$i = (_strchr($8, 99) | 0) != 0 & 1; //@line 13667
  $13 = (_strchr($8, 114) | 0) == 0; //@line 13669
  $mask$1$i = $13 ? $$$i : $$$i | 2; //@line 13671
  $16 = (_strchr($8, 108) | 0) == 0; //@line 13673
  $mask$1$$i = $16 ? $mask$1$i : $mask$1$i | 4; //@line 13675
  $count$0 = $10; //@line 13679
  $func$0 = 20; //@line 13679
  $mask$0 = ($10 | 0) > 0 ? $mask$1$$i | 8 : $mask$1$$i; //@line 13679
 }
 if (_luaL_getsubtable($L, -1001e3, 3368) | 0) {
  _lua_pushthread($$0$i) | 0; //@line 13684
  _lua_xmove($$0$i, $L, 1); //@line 13685
  _lua_pushvalue($L, $3); //@line 13686
  _lua_rawset($L, -3); //@line 13687
  _lua_sethook($$0$i, $func$0, $mask$0, $count$0) | 0; //@line 13688
  STACKTOP = sp; //@line 13689
  return 0; //@line 13689
 }
 _lua_pushstring($L, 3376) | 0; //@line 13691
 _lua_setfield($L, -2, 3384); //@line 13692
 _lua_pushvalue($L, -1); //@line 13693
 _lua_setmetatable($L, -2) | 0; //@line 13694
 _lua_pushthread($$0$i) | 0; //@line 13695
 _lua_xmove($$0$i, $L, 1); //@line 13696
 _lua_pushvalue($L, $3); //@line 13697
 _lua_rawset($L, -3); //@line 13698
 _lua_sethook($$0$i, $func$0, $mask$0, $count$0) | 0; //@line 13699
 STACKTOP = sp; //@line 13700
 return 0; //@line 13700
}
function _lua_insert($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $32 = 0, $37 = 0, $38 = 0, $4 = 0, $46 = 0, $47 = 0, $52 = 0, $53 = 0, $q$01 = 0, sp = 0, $q$01$looptemp = 0;
 sp = STACKTOP; //@line 392
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 394
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 399
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 404
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 411
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 419
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 422
  $17 = HEAP32[$1 >> 2] | 0; //@line 423
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 428
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 430
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 436
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 440
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 445
 $29 = HEAP32[$28 >> 2] | 0; //@line 446
 if ($29 >>> 0 > $$0$i >>> 0) {
  $q$01 = $29; //@line 449
  do {
   $q$01$looptemp = $q$01;
   $q$01 = $q$01 + -16 | 0; //@line 451
   $32 = $q$01; //@line 452
   $37 = HEAP32[$32 + 4 >> 2] | 0; //@line 457
   $38 = $q$01$looptemp; //@line 458
   HEAP32[$38 >> 2] = HEAP32[$32 >> 2]; //@line 460
   HEAP32[$38 + 4 >> 2] = $37; //@line 463
   HEAP32[$q$01$looptemp + 8 >> 2] = HEAP32[$q$01$looptemp + -8 >> 2]; //@line 467
  } while ($q$01 >>> 0 > $$0$i >>> 0);
  $47 = HEAP32[$28 >> 2] | 0; //@line 476
 } else $47 = $29; //@line 478
 $46 = $47; //@line 480
 $52 = HEAP32[$46 + 4 >> 2] | 0; //@line 485
 $53 = $$0$i; //@line 486
 HEAP32[$53 >> 2] = HEAP32[$46 >> 2]; //@line 488
 HEAP32[$53 + 4 >> 2] = $52; //@line 491
 HEAP32[$$0$i + 8 >> 2] = HEAP32[$47 + 8 >> 2]; //@line 495
 STACKTOP = sp; //@line 496
 return;
}
function _luaK_dischargevars($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $1 = 0, $15 = 0, $21 = 0, $26 = 0, $38 = 0, $52 = 0, $6 = 0, $8 = 0, $op$0 = 0, sp = 0;
 sp = STACKTOP; //@line 9732
 switch (HEAP32[$e >> 2] | 0) {
 case 9:
  {
   $6 = $e + 8 | 0; //@line 9736
   $8 = HEAP16[$6 >> 1] | 0; //@line 9738
   if (!($8 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0) <= ($8 | 0)) {
    $15 = $fs + 48 | 0; //@line 9747
    HEAP8[$15 >> 0] = (HEAP8[$15 >> 0] | 0) + -1 << 24 >> 24; //@line 9750
   }
   $21 = $6 + 2 | 0; //@line 9756
   if ((HEAP8[$6 + 3 >> 0] | 0) == 7) if ((HEAPU8[$fs + 46 >> 0] | 0) > (HEAPU8[$21 >> 0] | 0)) $op$0 = 7; //@line 9763
 else {
    $26 = $fs + 48 | 0; //@line 9765
    HEAP8[$26 >> 0] = (HEAP8[$26 >> 0] | 0) + -1 << 24 >> 24; //@line 9768
    $op$0 = 7; //@line 9769
   } else $op$0 = 6; //@line 9772
   HEAP32[$6 >> 2] = _luaK_code($fs, HEAPU8[$21 >> 0] << 23 | $op$0 | HEAP16[$6 >> 1] << 14) | 0; //@line 9783
   HEAP32[$e >> 2] = 11; //@line 9784
   STACKTOP = sp; //@line 9785
   return;
  }
 case 12:
  {
   HEAP32[$e >> 2] = 6; //@line 9789
   $38 = $e + 8 | 0; //@line 9790
   HEAP32[$38 >> 2] = (HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$38 >> 2] << 2) >> 2] | 0) >>> 6 & 255; //@line 9799
   STACKTOP = sp; //@line 9800
   return;
  }
 case 7:
  {
   HEAP32[$e >> 2] = 6; //@line 9804
   STACKTOP = sp; //@line 9805
   return;
  }
 case 8:
  {
   $1 = $e + 8 | 0; //@line 9809
   HEAP32[$1 >> 2] = _luaK_code($fs, HEAP32[$1 >> 2] << 23 | 5) | 0; //@line 9814
   HEAP32[$e >> 2] = 11; //@line 9815
   STACKTOP = sp; //@line 9816
   return;
  }
 case 13:
  {
   $52 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$e + 8 >> 2] << 2) | 0; //@line 9825
   HEAP32[$52 >> 2] = HEAP32[$52 >> 2] & 8388607 | 16777216; //@line 9829
   HEAP32[$e >> 2] = 11; //@line 9830
   STACKTOP = sp; //@line 9831
   return;
  }
 default:
  {
   STACKTOP = sp; //@line 9835
   return;
  }
 }
}
function _lua_tounsignedx($L, $idx, $isnum) {
 $L = $L | 0;
 $idx = $idx | 0;
 $isnum = $isnum | 0;
 var $$0 = 0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $31 = 0, $35 = 0, $4 = 0, $n = 0, $o$0 = 0, $u$sroa$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1750
 STACKTOP = STACKTOP + 32 | 0; //@line 1751
 $n = sp + 8 | 0; //@line 1752
 $u$sroa$0 = sp; //@line 1753
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1755
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1760
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1765
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1772
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1780
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1783
  $17 = HEAP32[$1 >> 2] | 0; //@line 1784
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1789
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1791
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1797
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1801
  }
 } while (0);
 if ((HEAP32[$$0$i + 8 >> 2] | 0) == 3) $o$0 = $$0$i; //@line 1810
 else {
  $31 = _luaV_tonumber($$0$i, $n) | 0; //@line 1812
  if (!$31) {
   if (!$isnum) {
    $$0 = 0; //@line 1817
    STACKTOP = sp; //@line 1818
    return $$0 | 0; //@line 1818
   }
   HEAP32[$isnum >> 2] = 0; //@line 1820
   $$0 = 0; //@line 1821
   STACKTOP = sp; //@line 1822
   return $$0 | 0; //@line 1822
  } else $o$0 = $31; //@line 1824
 }
 HEAPF64[$u$sroa$0 >> 3] = +HEAPF64[$o$0 >> 3] + 6755399441055744.0; //@line 1829
 $35 = HEAP32[$u$sroa$0 >> 2] | 0; //@line 1830
 if (!$isnum) {
  $$0 = $35; //@line 1833
  STACKTOP = sp; //@line 1834
  return $$0 | 0; //@line 1834
 }
 HEAP32[$isnum >> 2] = 1; //@line 1836
 $$0 = $35; //@line 1837
 STACKTOP = sp; //@line 1838
 return $$0 | 0; //@line 1838
}
function _findlocal($L, $ci, $n, $pos) {
 $L = $L | 0;
 $ci = $ci | 0;
 $n = $n | 0;
 $pos = $pos | 0;
 var $$0 = 0, $$in = 0, $12 = 0, $25 = 0, $29 = 0, $37 = 0, $6 = 0, $base$03 = 0, $base$04 = 0, $name$1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 14016
 do if (!(HEAP8[$ci + 18 >> 0] & 1)) {
  $base$03 = (HEAP32[$ci >> 2] | 0) + 16 | 0; //@line 14025
  label = 7; //@line 14026
 } else {
  if (($n | 0) >= 0) {
   $25 = HEAP32[$ci + 24 >> 2] | 0; //@line 14031
   $29 = HEAP32[(HEAP32[HEAP32[$ci >> 2] >> 2] | 0) + 12 >> 2] | 0; //@line 14035
   $37 = _luaF_getlocalname($29, $n, ((HEAP32[$ci + 28 >> 2] | 0) - (HEAP32[$29 + 12 >> 2] | 0) >> 2) + -1 | 0) | 0; //@line 14045
   if (!$37) {
    $base$03 = $25; //@line 14048
    label = 7; //@line 14049
    break;
   } else {
    $base$04 = $25; //@line 14052
    $name$1 = $37; //@line 14052
    break;
   }
  }
  $6 = HEAP32[$ci >> 2] | 0; //@line 14057
  $12 = HEAPU8[(HEAP32[(HEAP32[$6 >> 2] | 0) + 12 >> 2] | 0) + 76 >> 0] | 0; //@line 14063
  if ((((HEAP32[$ci + 24 >> 2] | 0) - $6 >> 4) - $12 | 0) <= (0 - $n | 0)) {
   $$0 = 0; //@line 14073
   STACKTOP = sp; //@line 14074
   return $$0 | 0; //@line 14074
  }
  HEAP32[$pos >> 2] = $6 + ($12 - $n << 4); //@line 14078
  $$0 = 4248; //@line 14079
  STACKTOP = sp; //@line 14080
  return $$0 | 0; //@line 14080
 } while (0);
 if ((label | 0) == 7) {
  if ((HEAP32[$L + 16 >> 2] | 0) == ($ci | 0)) $$in = $L + 8 | 0; //@line 14089
 else $$in = HEAP32[$ci + 12 >> 2] | 0; //@line 14093
  if (($n | 0) > 0 ? ((HEAP32[$$in >> 2] | 0) - $base$03 >> 4 | 0) >= ($n | 0) : 0) {
   $base$04 = $base$03; //@line 14104
   $name$1 = 4232; //@line 14104
  } else {
   $$0 = 0; //@line 14106
   STACKTOP = sp; //@line 14107
   return $$0 | 0; //@line 14107
  }
 }
 HEAP32[$pos >> 2] = $base$04 + ($n + -1 << 4); //@line 14112
 $$0 = $name$1; //@line 14113
 STACKTOP = sp; //@line 14114
 return $$0 | 0; //@line 14114
}
function _strcspn($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$025 = 0, $$03$lcssa = 0, $$034 = 0, $0 = 0, $10 = 0, $12 = 0, $13 = 0, $17 = 0, $24 = 0, $26 = 0, $27 = 0, $byteset = 0, sp = 0;
 sp = STACKTOP; //@line 5637
 STACKTOP = STACKTOP + 32 | 0; //@line 5638
 $byteset = sp; //@line 5639
 $0 = HEAP8[$c >> 0] | 0; //@line 5640
 if ($0 << 24 >> 24) if (HEAP8[$c + 1 >> 0] | 0) {
  HEAP32[$byteset + 0 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 4 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 8 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 12 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 16 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 20 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 24 >> 2] = 0; //@line 5647
  HEAP32[$byteset + 28 >> 2] = 0; //@line 5647
  $$025 = $c; //@line 5648
  $13 = $0; //@line 5648
  do {
   $12 = $13 & 255; //@line 5650
   $17 = $byteset + ($12 >>> 5 << 2) | 0; //@line 5654
   HEAP32[$17 >> 2] = HEAP32[$17 >> 2] | 1 << ($12 & 31); //@line 5657
   $$025 = $$025 + 1 | 0; //@line 5658
   $13 = HEAP8[$$025 >> 0] | 0; //@line 5659
  } while ($13 << 24 >> 24 != 0);
  $10 = HEAP8[$s >> 0] | 0; //@line 5667
  L7 : do if (!($10 << 24 >> 24)) $$03$lcssa = $s; //@line 5671
 else {
   $$034 = $s; //@line 5673
   $27 = $10; //@line 5673
   while (1) {
    $26 = $27 & 255; //@line 5675
    $24 = $$034 + 1 | 0; //@line 5683
    if (HEAP32[$byteset + ($26 >>> 5 << 2) >> 2] & 1 << ($26 & 31)) {
     $$03$lcssa = $$034; //@line 5685
     break L7;
    }
    $27 = HEAP8[$24 >> 0] | 0; //@line 5688
    if (!($27 << 24 >> 24)) {
     $$03$lcssa = $24; //@line 5691
     break;
    } else $$034 = $24; //@line 5694
   }
  } while (0);
  $$0 = $$03$lcssa - $s | 0; //@line 5702
  STACKTOP = sp; //@line 5703
  return $$0 | 0; //@line 5703
 }
 $$0 = (___strchrnul($s, $0 << 24 >> 24) | 0) - $s | 0; //@line 5711
 STACKTOP = sp; //@line 5712
 return $$0 | 0; //@line 5712
}
function _searchpath($L, $name, $path, $sep, $dirsep) {
 $L = $L | 0;
 $name = $name | 0;
 $path = $path | 0;
 $sep = $sep | 0;
 $dirsep = $dirsep | 0;
 var $$0 = 0, $$0$i = 0, $$01$ph = 0, $14 = 0, $15 = 0, $3 = 0, $5 = 0, $l$0$i = 0, $msg = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 6868
 STACKTOP = STACKTOP + 1056 | 0; //@line 6869
 $vararg_buffer = sp; //@line 6870
 $msg = sp + 8 | 0; //@line 6871
 _luaL_buffinit($L, $msg); //@line 6872
 if (!(HEAP8[$sep >> 0] | 0)) $$01$ph = $name; //@line 6876
 else $$01$ph = _luaL_gsub($L, $name, $sep, $dirsep) | 0; //@line 6879
 $$0$i = $path; //@line 6881
 while (1) {
  $3 = HEAP8[$$0$i >> 0] | 0; //@line 6883
  if ($3 << 24 >> 24 == 59) {
   $$0$i = $$0$i + 1 | 0; //@line 6886
   continue;
  } else if (!($3 << 24 >> 24)) {
   label = 12; //@line 6889
   break;
  }
  $5 = _strchr($$0$i, 59) | 0; //@line 6892
  if (!$5) $l$0$i = $$0$i + (_strlen($$0$i | 0) | 0) | 0; //@line 6897
 else $l$0$i = $5; //@line 6899
  _lua_pushlstring($L, $$0$i, $l$0$i - $$0$i | 0) | 0; //@line 6904
  if (!$l$0$i) {
   label = 12; //@line 6907
   break;
  }
  $14 = _luaL_gsub($L, _lua_tolstring($L, -1, 0) | 0, 7920, $$01$ph) | 0; //@line 6911
  _lua_remove($L, -2); //@line 6912
  $15 = _fopen($14 | 0, 7944) | 0; //@line 6913
  if ($15) {
   label = 10; //@line 6916
   break;
  }
  HEAP32[$vararg_buffer >> 2] = $14; //@line 6919
  _lua_pushfstring($L, 7928, $vararg_buffer) | 0; //@line 6920
  _lua_remove($L, -2); //@line 6921
  _luaL_addvalue($msg); //@line 6922
  $$0$i = $l$0$i; //@line 6923
 }
 if ((label | 0) == 10) {
  _fclose($15 | 0) | 0; //@line 6926
  $$0 = $14; //@line 6927
  STACKTOP = sp; //@line 6928
  return $$0 | 0; //@line 6928
 } else if ((label | 0) == 12) {
  _luaL_pushresult($msg); //@line 6931
  $$0 = 0; //@line 6932
  STACKTOP = sp; //@line 6933
  return $$0 | 0; //@line 6933
 }
 return 0; //@line 6935
}
function _close_state($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $19 = 0, $2 = 0, $20 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $4 = 0, $next$01$i$i = 0, sp = 0, $next$01$i$i$looptemp = 0;
 sp = STACKTOP; //@line 13020
 $0 = $L + 12 | 0; //@line 13021
 $1 = HEAP32[$0 >> 2] | 0; //@line 13022
 $2 = $L + 28 | 0; //@line 13023
 _luaF_close($L, HEAP32[$2 >> 2] | 0); //@line 13025
 _luaC_freeallobjects($L); //@line 13026
 $4 = HEAP32[$0 >> 2] | 0; //@line 13027
 _luaM_realloc_($L, HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 32 >> 2] << 2, 0) | 0; //@line 13033
 $10 = $1 + 144 | 0; //@line 13034
 $12 = $1 + 152 | 0; //@line 13036
 HEAP32[$10 >> 2] = _luaM_realloc_($L, HEAP32[$10 >> 2] | 0, HEAP32[$12 >> 2] | 0, 0) | 0; //@line 13039
 HEAP32[$12 >> 2] = 0; //@line 13040
 $15 = HEAP32[$2 >> 2] | 0; //@line 13041
 if (!$15) {
  $29 = HEAP32[$1 >> 2] | 0; //@line 13044
  $30 = $1 + 4 | 0; //@line 13045
  $31 = HEAP32[$30 >> 2] | 0; //@line 13046
  FUNCTION_TABLE_iiiii[$29 & 31]($31, $L, 400, 0) | 0; //@line 13047
  STACKTOP = sp; //@line 13048
  return;
 }
 HEAP32[$L + 16 >> 2] = $L + 72; //@line 13052
 $19 = $L + 84 | 0; //@line 13053
 $20 = HEAP32[$19 >> 2] | 0; //@line 13054
 HEAP32[$19 >> 2] = 0; //@line 13055
 if (!$20) $28 = $15; //@line 13058
 else {
  $next$01$i$i = $20; //@line 13060
  do {
   $next$01$i$i$looptemp = $next$01$i$i;
   $next$01$i$i = HEAP32[$next$01$i$i + 12 >> 2] | 0; //@line 13063
   _luaM_realloc_($L, $next$01$i$i$looptemp, 40, 0) | 0; //@line 13064
  } while (($next$01$i$i | 0) != 0);
  $28 = HEAP32[$2 >> 2] | 0; //@line 13073
 }
 _luaM_realloc_($L, $28, HEAP32[$L + 32 >> 2] << 4, 0) | 0; //@line 13078
 $29 = HEAP32[$1 >> 2] | 0; //@line 13079
 $30 = $1 + 4 | 0; //@line 13080
 $31 = HEAP32[$30 >> 2] | 0; //@line 13081
 FUNCTION_TABLE_iiiii[$29 & 31]($31, $L, 400, 0) | 0; //@line 13082
 STACKTOP = sp; //@line 13083
 return;
}
function _setnodevector($L, $t, $size) {
 $L = $L | 0;
 $t = $t | 0;
 $size = $size | 0;
 var $$0 = 0, $$pre = 0, $$pre$pre = 0, $12 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $4 = 0, $8 = 0, $9 = 0, $i$01 = 0, $lsize$0 = 0, sp = 0;
 sp = STACKTOP; //@line 16660
 STACKTOP = STACKTOP + 16 | 0; //@line 16661
 if (!$size) {
  HEAP32[$t + 16 >> 2] = 10872; //@line 16666
  $$0 = 0; //@line 16667
  $18 = 10872; //@line 16667
  $lsize$0 = 0; //@line 16667
  $16 = $t + 7 | 0; //@line 16668
  HEAP8[$16 >> 0] = $lsize$0; //@line 16669
  $17 = $18 + ($$0 << 5) | 0; //@line 16670
  $19 = $t + 20 | 0; //@line 16671
  HEAP32[$19 >> 2] = $17; //@line 16672
  STACKTOP = sp; //@line 16673
  return;
 }
 $2 = _luaO_ceillog2($size) | 0; //@line 16675
 if (($2 | 0) > 30) _luaG_runerror($L, 10904, sp); //@line 16678
 $4 = 1 << $2; //@line 16681
 if (($4 + 1 | 0) >>> 0 > 134217727) _luaM_toobig($L); //@line 16685
 $8 = _luaM_realloc_($L, 0, 0, $4 << 5) | 0; //@line 16689
 $9 = $t + 16 | 0; //@line 16690
 HEAP32[$9 >> 2] = $8; //@line 16691
 if (($4 | 0) > 0) {
  $12 = $8; //@line 16694
  $i$01 = 0; //@line 16694
  while (1) {
   HEAP32[$12 + ($i$01 << 5) + 28 >> 2] = 0; //@line 16697
   HEAP32[$12 + ($i$01 << 5) + 24 >> 2] = 0; //@line 16699
   HEAP32[$12 + ($i$01 << 5) + 8 >> 2] = 0; //@line 16701
   $i$01 = $i$01 + 1 | 0; //@line 16702
   $$pre$pre = HEAP32[$9 >> 2] | 0; //@line 16704
   if (($i$01 | 0) == ($4 | 0)) {
    $$pre = $$pre$pre; //@line 16706
    break;
   } else $12 = $$pre$pre; //@line 16709
  }
 } else $$pre = $8; //@line 16713
 $$0 = $4; //@line 16716
 $18 = $$pre; //@line 16716
 $lsize$0 = $2 & 255; //@line 16716
 $16 = $t + 7 | 0; //@line 16717
 HEAP8[$16 >> 0] = $lsize$0; //@line 16718
 $17 = $18 + ($$0 << 5) | 0; //@line 16719
 $19 = $t + 20 | 0; //@line 16720
 HEAP32[$19 >> 2] = $17; //@line 16721
 STACKTOP = sp; //@line 16722
 return;
}
function ___fwritex($s, $l, $f) {
 $s = $s | 0;
 $l = $l | 0;
 $f = $f | 0;
 var $$0 = 0, $$01 = 0, $$02 = 0, $0 = 0, $1 = 0, $19 = 0, $29 = 0, $5 = 0, $6 = 0, $8 = 0, $i$0 = 0, $i$1 = 0, sp = 0;
 sp = STACKTOP; //@line 13444
 $0 = $f + 16 | 0; //@line 13445
 $1 = HEAP32[$0 >> 2] | 0; //@line 13446
 do if (!$1) if (!(___towrite($f) | 0)) {
  $8 = HEAP32[$0 >> 2] | 0; //@line 13454
  break;
 } else {
  $$0 = 0; //@line 13457
  STACKTOP = sp; //@line 13458
  return $$0 | 0; //@line 13458
 } else $8 = $1; //@line 13461
 while (0);
 $5 = $f + 20 | 0; //@line 13464
 $6 = HEAP32[$5 >> 2] | 0; //@line 13465
 if (($8 - $6 | 0) >>> 0 < $l >>> 0) {
  $$0 = FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 31]($f, $s, $l) | 0; //@line 13474
  STACKTOP = sp; //@line 13475
  return $$0 | 0; //@line 13475
 }
 L11 : do if ((HEAP8[$f + 75 >> 0] | 0) > -1) {
  $i$0 = $l; //@line 13482
  while (1) {
   if (!$i$0) {
    $$01 = $l; //@line 13486
    $$02 = $s; //@line 13486
    $29 = $6; //@line 13486
    $i$1 = 0; //@line 13486
    break L11;
   }
   $19 = $i$0 + -1 | 0; //@line 13489
   if ((HEAP8[$s + $19 >> 0] | 0) == 10) break; else $i$0 = $19; //@line 13496
  }
  if ((FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 31]($f, $s, $i$0) | 0) >>> 0 < $i$0 >>> 0) {
   $$0 = $i$0; //@line 13504
   STACKTOP = sp; //@line 13505
   return $$0 | 0; //@line 13505
  } else {
   $$01 = $l - $i$0 | 0; //@line 13510
   $$02 = $s + $i$0 | 0; //@line 13510
   $29 = HEAP32[$5 >> 2] | 0; //@line 13510
   $i$1 = $i$0; //@line 13510
   break;
  }
 } else {
  $$01 = $l; //@line 13514
  $$02 = $s; //@line 13514
  $29 = $6; //@line 13514
  $i$1 = 0; //@line 13514
 } while (0);
 _memcpy($29 | 0, $$02 | 0, $$01 | 0) | 0; //@line 13517
 HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + $$01; //@line 13520
 $$0 = $i$1 + $$01 | 0; //@line 13522
 STACKTOP = sp; //@line 13523
 return $$0 | 0; //@line 13523
}
function _searcher_Croot($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $13 = 0, $6 = 0, $7 = 0, $9 = 0, $vararg_buffer6 = 0, sp = 0;
 sp = STACKTOP; //@line 6738
 STACKTOP = STACKTOP + 16 | 0; //@line 6739
 $vararg_buffer6 = sp; //@line 6740
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6741
 $1 = _strchr($0, 46) | 0; //@line 6742
 if (!$1) {
  $$0 = 0; //@line 6745
  STACKTOP = sp; //@line 6746
  return $$0 | 0; //@line 6746
 }
 _lua_pushlstring($L, $0, $1 - $0 | 0) | 0; //@line 6751
 $6 = _lua_tolstring($L, -1, 0) | 0; //@line 6752
 _lua_getfield($L, -1001001, 7296); //@line 6753
 $7 = _lua_tolstring($L, -1, 0) | 0; //@line 6754
 if (!$7) {
  HEAP32[$vararg_buffer6 >> 2] = 7296; //@line 6757
  _luaL_error($L, 7888, $vararg_buffer6) | 0; //@line 6758
 }
 $9 = _searchpath($L, $6, $7, 7792, 7704) | 0; //@line 6760
 if (!$9) {
  $$0 = 1; //@line 6763
  STACKTOP = sp; //@line 6764
  return $$0 | 0; //@line 6764
 }
 $11 = _loadfunc($L, $9, $0) | 0; //@line 6766
 if (!$11) {
  _lua_pushstring($L, $9) | 0; //@line 6768
  $$0 = 2; //@line 6769
  STACKTOP = sp; //@line 6770
  return $$0 | 0; //@line 6770
 } else if (($11 | 0) == 2) {
  HEAP32[$vararg_buffer6 >> 2] = $0; //@line 6772
  HEAP32[$vararg_buffer6 + 4 >> 2] = $9; //@line 6774
  _lua_pushfstring($L, 7712, $vararg_buffer6) | 0; //@line 6775
  $$0 = 1; //@line 6776
  STACKTOP = sp; //@line 6777
  return $$0 | 0; //@line 6777
 } else {
  $12 = _lua_tolstring($L, 1, 0) | 0; //@line 6779
  $13 = _lua_tolstring($L, -1, 0) | 0; //@line 6780
  HEAP32[$vararg_buffer6 >> 2] = $12; //@line 6781
  HEAP32[$vararg_buffer6 + 4 >> 2] = $9; //@line 6783
  HEAP32[$vararg_buffer6 + 8 >> 2] = $13; //@line 6785
  $$0 = _luaL_error($L, 7744, $vararg_buffer6) | 0; //@line 6787
  STACKTOP = sp; //@line 6788
  return $$0 | 0; //@line 6788
 }
 return 0; //@line 6790
}
function _luaZ_read($z, $b, $n) {
 $z = $z | 0;
 $b = $b | 0;
 $n = $n | 0;
 var $$$01 = 0, $$0 = 0, $$014 = 0, $$023 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $6 = 0, $size$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5286
 STACKTOP = STACKTOP + 16 | 0; //@line 5287
 $size$i = sp; //@line 5288
 if (!$n) {
  $$0 = 0; //@line 5291
  STACKTOP = sp; //@line 5292
  return $$0 | 0; //@line 5292
 }
 $1 = $z + 16 | 0; //@line 5294
 $2 = $z + 8 | 0; //@line 5295
 $3 = $z + 12 | 0; //@line 5296
 $4 = $z + 4 | 0; //@line 5297
 $$014 = $n; //@line 5299
 $$023 = $b; //@line 5299
 $6 = HEAP32[$z >> 2] | 0; //@line 5299
 while (1) {
  if (!$6) {
   $10 = FUNCTION_TABLE_iiii[HEAP32[$2 >> 2] & 31](HEAP32[$1 >> 2] | 0, HEAP32[$3 >> 2] | 0, $size$i) | 0; //@line 5306
   if (!$10) {
    $$0 = $$014; //@line 5309
    label = 9; //@line 5310
    break;
   }
   $12 = HEAP32[$size$i >> 2] | 0; //@line 5313
   if (!$12) {
    $$0 = $$014; //@line 5316
    label = 9; //@line 5317
    break;
   }
   HEAP32[$z >> 2] = $12; //@line 5320
   HEAP32[$4 >> 2] = $10; //@line 5321
   $15 = $12; //@line 5322
   $16 = $10; //@line 5322
  } else {
   $15 = $6; //@line 5325
   $16 = HEAP32[$4 >> 2] | 0; //@line 5325
  }
  $$$01 = $$014 >>> 0 > $15 >>> 0 ? $15 : $$014; //@line 5328
  _memcpy($$023 | 0, $16 | 0, $$$01 | 0) | 0; //@line 5329
  $6 = (HEAP32[$z >> 2] | 0) - $$$01 | 0; //@line 5331
  HEAP32[$z >> 2] = $6; //@line 5332
  HEAP32[$4 >> 2] = (HEAP32[$4 >> 2] | 0) + $$$01; //@line 5335
  if (($$014 | 0) == ($$$01 | 0)) {
   $$0 = 0; //@line 5340
   label = 9; //@line 5341
   break;
  } else {
   $$014 = $$014 - $$$01 | 0; //@line 5344
   $$023 = $$023 + $$$01 | 0; //@line 5344
  }
 }
 if ((label | 0) == 9) {
  STACKTOP = sp; //@line 5348
  return $$0 | 0; //@line 5348
 }
 return 0; //@line 5350
}
function _lua_tointegerx($L, $idx, $isnum) {
 $L = $L | 0;
 $idx = $idx | 0;
 $isnum = $isnum | 0;
 var $$0 = 0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $31 = 0, $34 = 0, $4 = 0, $n = 0, $o$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1656
 STACKTOP = STACKTOP + 16 | 0; //@line 1657
 $n = sp; //@line 1658
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1660
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1665
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1670
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1677
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1685
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1688
  $17 = HEAP32[$1 >> 2] | 0; //@line 1689
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1694
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1696
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1702
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1706
  }
 } while (0);
 if ((HEAP32[$$0$i + 8 >> 2] | 0) == 3) $o$0 = $$0$i; //@line 1715
 else {
  $31 = _luaV_tonumber($$0$i, $n) | 0; //@line 1717
  if (!$31) {
   if (!$isnum) {
    $$0 = 0; //@line 1722
    STACKTOP = sp; //@line 1723
    return $$0 | 0; //@line 1723
   }
   HEAP32[$isnum >> 2] = 0; //@line 1725
   $$0 = 0; //@line 1726
   STACKTOP = sp; //@line 1727
   return $$0 | 0; //@line 1727
  } else $o$0 = $31; //@line 1729
 }
 $34 = ~~+HEAPF64[$o$0 >> 3]; //@line 1733
 if (!$isnum) {
  $$0 = $34; //@line 1736
  STACKTOP = sp; //@line 1737
  return $$0 | 0; //@line 1737
 }
 HEAP32[$isnum >> 2] = 1; //@line 1739
 $$0 = $34; //@line 1740
 STACKTOP = sp; //@line 1741
 return $$0 | 0; //@line 1741
}
function _lua_getmetatable($L, $objindex) {
 $L = $L | 0;
 $objindex = $objindex | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, $42 = 0, $43 = 0, $mt$0 = 0, $res$0 = 0, sp = 0;
 sp = STACKTOP; //@line 3304
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3306
 do if (($objindex | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($objindex << 4) | 0; //@line 3311
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3316
 } else {
  if (($objindex | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($objindex << 4) | 0; //@line 3323
   break;
  }
  if (($objindex | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3331
   break;
  }
  $16 = -1001e3 - $objindex | 0; //@line 3334
  $17 = HEAP32[$1 >> 2] | 0; //@line 3335
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3340
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3342
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3348
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3352
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 15; //@line 3359
 if (($30 | 0) == 5) $mt$0 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 8 >> 2] | 0; //@line 3364
 else if (($30 | 0) == 7) $mt$0 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 8 >> 2] | 0; //@line 3369
 else $mt$0 = HEAP32[(HEAP32[$L + 12 >> 2] | 0) + ($30 << 2) + 252 >> 2] | 0; //@line 3375
 if (!$mt$0) {
  $res$0 = 0; //@line 3379
  STACKTOP = sp; //@line 3380
  return $res$0 | 0; //@line 3380
 }
 $42 = $L + 8 | 0; //@line 3382
 $43 = HEAP32[$42 >> 2] | 0; //@line 3383
 HEAP32[$43 >> 2] = $mt$0; //@line 3384
 HEAP32[$43 + 8 >> 2] = 69; //@line 3386
 HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + 16; //@line 3389
 $res$0 = 1; //@line 3390
 STACKTOP = sp; //@line 3391
 return $res$0 | 0; //@line 3391
}
function _luaD_protectedparser($L, $z, $name, $mode) {
 $L = $L | 0;
 $z = $z | 0;
 $name = $name | 0;
 $mode = $mode | 0;
 var $0 = 0, $10 = 0, $11 = 0, $12 = 0, $22 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $p = 0, sp = 0;
 sp = STACKTOP; //@line 17377
 STACKTOP = STACKTOP + 64 | 0; //@line 17378
 $p = sp; //@line 17379
 $0 = $L + 36 | 0; //@line 17380
 HEAP16[$0 >> 1] = (HEAP16[$0 >> 1] | 0) + 1 << 16 >> 16; //@line 17383
 HEAP32[$p >> 2] = $z; //@line 17384
 HEAP32[$p + 56 >> 2] = $name; //@line 17386
 HEAP32[$p + 52 >> 2] = $mode; //@line 17388
 $5 = $p + 16 | 0; //@line 17389
 HEAP32[$5 >> 2] = 0; //@line 17390
 $6 = $p + 24 | 0; //@line 17391
 HEAP32[$6 >> 2] = 0; //@line 17392
 $7 = $p + 28 | 0; //@line 17393
 HEAP32[$7 >> 2] = 0; //@line 17394
 $8 = $p + 36 | 0; //@line 17395
 HEAP32[$8 >> 2] = 0; //@line 17396
 $9 = $p + 40 | 0; //@line 17397
 HEAP32[$9 >> 2] = 0; //@line 17398
 $10 = $p + 48 | 0; //@line 17399
 HEAP32[$10 >> 2] = 0; //@line 17400
 $11 = $p + 4 | 0; //@line 17401
 HEAP32[$11 >> 2] = 0; //@line 17402
 $12 = $p + 12 | 0; //@line 17403
 HEAP32[$12 >> 2] = 0; //@line 17404
 $22 = _luaD_pcall($L, 23, $p, (HEAP32[$L + 8 >> 2] | 0) - (HEAP32[$L + 28 >> 2] | 0) | 0, HEAP32[$L + 68 >> 2] | 0) | 0; //@line 17414
 HEAP32[$11 >> 2] = _luaM_realloc_($L, HEAP32[$11 >> 2] | 0, HEAP32[$12 >> 2] | 0, 0) | 0; //@line 17418
 HEAP32[$12 >> 2] = 0; //@line 17419
 _luaM_realloc_($L, HEAP32[$5 >> 2] | 0, HEAP32[$6 >> 2] << 1, 0) | 0; //@line 17423
 _luaM_realloc_($L, HEAP32[$7 >> 2] | 0, HEAP32[$8 >> 2] << 4, 0) | 0; //@line 17427
 _luaM_realloc_($L, HEAP32[$9 >> 2] | 0, HEAP32[$10 >> 2] << 4, 0) | 0; //@line 17431
 HEAP16[$0 >> 1] = (HEAP16[$0 >> 1] | 0) + -1 << 16 >> 16; //@line 17434
 STACKTOP = sp; //@line 17435
 return $22 | 0; //@line 17435
}
function _ll_module($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $3 = 0, $4 = 0, $ar$i = 0, $i$01$i = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 6484
 STACKTOP = STACKTOP + 112 | 0; //@line 6485
 $vararg_buffer = sp; //@line 6486
 $ar$i = sp + 4 | 0; //@line 6487
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6488
 $1 = _lua_gettop($L) | 0; //@line 6489
 _luaL_pushmodule($L, $0, 1); //@line 6490
 _lua_getfield($L, -1, 7584); //@line 6491
 $3 = (_lua_type($L, -1) | 0) == 0; //@line 6493
 _lua_settop($L, -2); //@line 6494
 if ($3) {
  _lua_pushvalue($L, -1); //@line 6496
  _lua_setfield($L, -2, 7640); //@line 6497
  _lua_pushstring($L, $0) | 0; //@line 6498
  _lua_setfield($L, -2, 7584); //@line 6499
  $4 = _strrchr($0, 46) | 0; //@line 6500
  _lua_pushlstring($L, $0, (($4 | 0) == 0 ? $0 : $4 + 1 | 0) - $0 | 0) | 0; //@line 6507
  _lua_setfield($L, -2, 7648); //@line 6508
 }
 _lua_pushvalue($L, -1); //@line 6510
 if (!(_lua_getstack($L, 1, $ar$i) | 0)) label = 6; //@line 6514
 else if (!(_lua_getinfo($L, 7592, $ar$i) | 0)) label = 6; //@line 6519
 else if (_lua_iscfunction($L, -1) | 0) label = 6; //@line 6524
 if ((label | 0) == 6) _luaL_error($L, 7600, $vararg_buffer) | 0; //@line 6529
 _lua_pushvalue($L, -2); //@line 6531
 _lua_setupvalue($L, -2, 1) | 0; //@line 6532
 _lua_settop($L, -2); //@line 6533
 if (($1 | 0) < 2) {
  STACKTOP = sp; //@line 6536
  return 1; //@line 6536
 } else $i$01$i = 2; //@line 6538
 while (1) {
  if ((_lua_type($L, $i$01$i) | 0) == 6) {
   _lua_pushvalue($L, $i$01$i); //@line 6544
   _lua_pushvalue($L, -2); //@line 6545
   _lua_callk($L, 1, 0, 0, 0); //@line 6546
  }
  if (($i$01$i | 0) == ($1 | 0)) break; else $i$01$i = $i$01$i + 1 | 0; //@line 6553
 }
 STACKTOP = sp; //@line 6556
 return 1; //@line 6556
}
function _luaF_findupval($L, $level) {
 $L = $L | 0;
 $level = $level | 0;
 var $$0 = 0, $1 = 0, $12 = 0, $15 = 0, $2 = 0, $23 = 0, $26 = 0, $28 = 0, $29 = 0, $3 = 0, $5 = 0, $6 = 0, $9 = 0, $pp$0$lcssa = 0, $pp$03 = 0, $pp$03$phi = 0, sp = 0;
 sp = STACKTOP; //@line 18356
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 18358
 $2 = $L + 56 | 0; //@line 18359
 $3 = HEAP32[$2 >> 2] | 0; //@line 18360
 L1 : do if (!$3) $pp$0$lcssa = $2; //@line 18364
 else {
  $6 = $3; //@line 18366
  $pp$03 = $2; //@line 18366
  while (1) {
   $9 = HEAP32[$6 + 8 >> 2] | 0; //@line 18369
   if ($9 >>> 0 < $level >>> 0) {
    $pp$0$lcssa = $pp$03; //@line 18372
    break L1;
   }
   if (($9 | 0) == ($level | 0)) break;
   $5 = HEAP32[$6 >> 2] | 0; //@line 18379
   if (!$5) {
    $pp$0$lcssa = $6; //@line 18382
    break L1;
   } else {
    $pp$03$phi = $6; //@line 18385
    $6 = $5; //@line 18385
    $pp$03 = $pp$03$phi; //@line 18385
   }
  }
  $12 = $6 + 5 | 0; //@line 18388
  $15 = (HEAPU8[$12 >> 0] | 0) ^ 3; //@line 18391
  if (((HEAPU8[$1 + 60 >> 0] | 0) ^ 3) & $15) {
   $$0 = $6; //@line 18399
   STACKTOP = sp; //@line 18400
   return $$0 | 0; //@line 18400
  }
  HEAP8[$12 >> 0] = $15; //@line 18403
  $$0 = $6; //@line 18404
  STACKTOP = sp; //@line 18405
  return $$0 | 0; //@line 18405
 } while (0);
 $23 = _luaC_newobj($L, 10, 32, $pp$0$lcssa, 0) | 0; //@line 18408
 HEAP32[$23 + 8 >> 2] = $level; //@line 18410
 $26 = $23 + 16 | 0; //@line 18412
 HEAP32[$26 >> 2] = $1 + 112; //@line 18413
 $28 = $1 + 132 | 0; //@line 18415
 $29 = HEAP32[$28 >> 2] | 0; //@line 18416
 HEAP32[$26 + 4 >> 2] = $29; //@line 18418
 HEAP32[$29 + 16 >> 2] = $23; //@line 18420
 HEAP32[$28 >> 2] = $23; //@line 18421
 $$0 = $23; //@line 18422
 STACKTOP = sp; //@line 18423
 return $$0 | 0; //@line 18423
}
function _vsnprintf($s, $n, $fmt, $ap) {
 $s = $s | 0;
 $n = $n | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$$02 = 0, $$0 = 0, $$01 = 0, $$02 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $5 = 0, $8 = 0, $b = 0, $f = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP; //@line 16607
 STACKTOP = STACKTOP + 128 | 0; //@line 16608
 $b = sp + 112 | 0; //@line 16609
 $f = sp; //@line 16610
 dest = $f + 0 | 0; //@line 16611
 src = 13136 | 0; //@line 16611
 stop = dest + 112 | 0; //@line 16611
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2]; //@line 16611
  dest = dest + 4 | 0; //@line 16611
  src = src + 4 | 0; //@line 16611
 } while ((dest | 0) < (stop | 0));
 if (($n + -1 | 0) >>> 0 > 2147483646) if (!$n) {
  $$01 = $b; //@line 16617
  $$02 = 1; //@line 16617
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 75; //@line 16620
  $$0 = -1; //@line 16621
  STACKTOP = sp; //@line 16622
  return $$0 | 0; //@line 16622
 } else {
  $$01 = $s; //@line 16625
  $$02 = $n; //@line 16625
 }
 $5 = -2 - $$01 | 0; //@line 16628
 $$$02 = $$02 >>> 0 > $5 >>> 0 ? $5 : $$02; //@line 16630
 HEAP32[$f + 48 >> 2] = $$$02; //@line 16632
 $8 = $f + 20 | 0; //@line 16633
 HEAP32[$8 >> 2] = $$01; //@line 16634
 HEAP32[$f + 44 >> 2] = $$01; //@line 16636
 $10 = $$01 + $$$02 | 0; //@line 16637
 $11 = $f + 16 | 0; //@line 16638
 HEAP32[$11 >> 2] = $10; //@line 16639
 HEAP32[$f + 28 >> 2] = $10; //@line 16641
 $13 = _MUSL_vfprintf($f, $fmt, $ap) | 0; //@line 16642
 if (!$$$02) {
  $$0 = $13; //@line 16645
  STACKTOP = sp; //@line 16646
  return $$0 | 0; //@line 16646
 }
 $15 = HEAP32[$8 >> 2] | 0; //@line 16648
 HEAP8[$15 + ((($15 | 0) == (HEAP32[$11 >> 2] | 0)) << 31 >> 31) >> 0] = 0; //@line 16653
 $$0 = $13; //@line 16654
 STACKTOP = sp; //@line 16655
 return $$0 | 0; //@line 16655
}
function _lua_replace($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, $15 = 0, $16 = 0, $2 = 0, $20 = 0, $27 = 0, $3 = 0, $32 = 0, $33 = 0, $37 = 0, $4 = 0, $44 = 0, $51 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 505
 $0 = $L + 8 | 0; //@line 506
 $1 = HEAP32[$0 >> 2] | 0; //@line 507
 $2 = $1 + -16 | 0; //@line 508
 $3 = $L + 16 | 0; //@line 509
 $4 = HEAP32[$3 >> 2] | 0; //@line 510
 do if (($idx | 0) > 0) {
  $7 = (HEAP32[$4 >> 2] | 0) + ($idx << 4) | 0; //@line 515
  $$0$i = $7 >>> 0 < $1 >>> 0 ? $7 : 8048; //@line 518
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = $1 + ($idx << 4) | 0; //@line 523
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 531
   break;
  }
  $15 = -1001e3 - $idx | 0; //@line 534
  $16 = HEAP32[$4 >> 2] | 0; //@line 535
  if ((HEAP32[$16 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 540
 else {
   $20 = HEAP32[$16 >> 2] | 0; //@line 542
   if (($15 | 0) > (HEAPU8[$20 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 548
 else $$0$i = $20 + ($15 + -1 << 4) + 16 | 0; //@line 552
  }
 } while (0);
 $27 = $2; //@line 557
 $32 = HEAP32[$27 + 4 >> 2] | 0; //@line 562
 $33 = $$0$i; //@line 563
 HEAP32[$33 >> 2] = HEAP32[$27 >> 2]; //@line 565
 HEAP32[$33 + 4 >> 2] = $32; //@line 568
 $37 = $1 + -8 | 0; //@line 569
 HEAP32[$$0$i + 8 >> 2] = HEAP32[$37 >> 2]; //@line 572
 if (($idx | 0) < -1001e3) if (HEAP32[$37 >> 2] & 64) {
  $44 = HEAP32[$2 >> 2] | 0; //@line 579
  if (HEAP8[$44 + 5 >> 0] & 3) {
   $51 = HEAP32[HEAP32[HEAP32[$3 >> 2] >> 2] >> 2] | 0; //@line 587
   if (HEAP8[$51 + 5 >> 0] & 4) _luaC_barrier_($L, $51, $44); //@line 593
  }
 }
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -16; //@line 600
 STACKTOP = sp; //@line 601
 return;
}
function _tconcat($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $7 = 0, $b = 0, $i$02 = 0, $lsep = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP; //@line 18021
 STACKTOP = STACKTOP + 1056 | 0; //@line 18022
 $vararg_buffer2 = sp; //@line 18023
 $b = sp + 16 | 0; //@line 18024
 $lsep = sp + 8 | 0; //@line 18025
 $0 = _luaL_optlstring($L, 2, 11064, $lsep) | 0; //@line 18026
 _luaL_checktype($L, 1, 5); //@line 18027
 $1 = _luaL_optinteger($L, 3, 1) | 0; //@line 18028
 if ((_lua_type($L, 4) | 0) < 1) $7 = _luaL_len($L, 1) | 0; //@line 18033
 else $7 = _luaL_checkinteger($L, 4) | 0; //@line 18036
 _luaL_buffinit($L, $b); //@line 18038
 if (($1 | 0) < ($7 | 0)) {
  $i$02 = $1; //@line 18041
  do {
   _lua_rawgeti($L, 1, $i$02); //@line 18043
   if (!(_lua_isstring($L, -1) | 0)) {
    HEAP32[$vararg_buffer2 >> 2] = _lua_typename($L, _lua_type($L, -1) | 0) | 0; //@line 18049
    HEAP32[$vararg_buffer2 + 4 >> 2] = $i$02; //@line 18051
    _luaL_error($L, 11216, $vararg_buffer2) | 0; //@line 18052
   }
   _luaL_addvalue($b); //@line 18054
   _luaL_addlstring($b, $0, HEAP32[$lsep >> 2] | 0); //@line 18056
   $i$02 = $i$02 + 1 | 0; //@line 18057
  } while (($i$02 | 0) != ($7 | 0));
 } else if (($1 | 0) != ($7 | 0)) {
  _luaL_pushresult($b); //@line 18068
  STACKTOP = sp; //@line 18069
  return 1; //@line 18069
 }
 _lua_rawgeti($L, 1, $7); //@line 18072
 if (!(_lua_isstring($L, -1) | 0)) {
  HEAP32[$vararg_buffer2 >> 2] = _lua_typename($L, _lua_type($L, -1) | 0) | 0; //@line 18078
  HEAP32[$vararg_buffer2 + 4 >> 2] = $7; //@line 18080
  _luaL_error($L, 11216, $vararg_buffer2) | 0; //@line 18081
 }
 _luaL_addvalue($b); //@line 18083
 _luaL_pushresult($b); //@line 18084
 STACKTOP = sp; //@line 18085
 return 1; //@line 18085
}
function _lua_load($L, $reader, $data, $chunkname, $mode) {
 $L = $L | 0;
 $reader = $reader | 0;
 $data = $data | 0;
 $chunkname = $chunkname | 0;
 $mode = $mode | 0;
 var $1 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $24 = 0, $25 = 0, $29 = 0, $35 = 0, $40 = 0, $6 = 0, $z = 0, sp = 0;
 sp = STACKTOP; //@line 4534
 STACKTOP = STACKTOP + 32 | 0; //@line 4535
 $z = sp; //@line 4536
 _luaZ_init($L, $z, $reader, $data); //@line 4539
 $1 = _luaD_protectedparser($L, $z, ($chunkname | 0) == 0 ? 16 : $chunkname, $mode) | 0; //@line 4540
 if ($1) {
  STACKTOP = sp; //@line 4543
  return $1 | 0; //@line 4543
 }
 $6 = HEAP32[(HEAP32[$L + 8 >> 2] | 0) + -16 >> 2] | 0; //@line 4548
 if ((HEAP8[$6 + 6 >> 0] | 0) != 1) {
  STACKTOP = sp; //@line 4553
  return $1 | 0; //@line 4553
 }
 $14 = _luaH_getint(HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 40 >> 2] | 0, 2) | 0; //@line 4559
 $15 = $6 + 16 | 0; //@line 4560
 $18 = HEAP32[(HEAP32[$15 >> 2] | 0) + 8 >> 2] | 0; //@line 4563
 $19 = $14; //@line 4564
 $24 = HEAP32[$19 + 4 >> 2] | 0; //@line 4569
 $25 = $18; //@line 4570
 HEAP32[$25 >> 2] = HEAP32[$19 >> 2]; //@line 4572
 HEAP32[$25 + 4 >> 2] = $24; //@line 4575
 $29 = $14 + 8 | 0; //@line 4576
 HEAP32[$18 + 8 >> 2] = HEAP32[$29 >> 2]; //@line 4579
 if (!(HEAP32[$29 >> 2] & 64)) {
  STACKTOP = sp; //@line 4584
  return $1 | 0; //@line 4584
 }
 $35 = HEAP32[$14 >> 2] | 0; //@line 4586
 if (!(HEAP8[$35 + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 4592
  return $1 | 0; //@line 4592
 }
 $40 = HEAP32[$15 >> 2] | 0; //@line 4594
 if (!(HEAP8[$40 + 5 >> 0] & 4)) {
  STACKTOP = sp; //@line 4600
  return $1 | 0; //@line 4600
 }
 _luaC_barrier_($L, $40, $35); //@line 4602
 STACKTOP = sp; //@line 4603
 return $1 | 0; //@line 4603
}
function _luaL_argerror($L, $narg, $extramsg) {
 $L = $L | 0;
 $narg = $narg | 0;
 $extramsg = $extramsg | 0;
 var $$0 = 0, $$01 = 0, $12 = 0, $13 = 0, $18 = 0, $19 = 0, $7 = 0, $ar = 0, $vararg_buffer6 = 0, sp = 0;
 sp = STACKTOP; //@line 5765
 STACKTOP = STACKTOP + 112 | 0; //@line 5766
 $vararg_buffer6 = sp; //@line 5767
 $ar = sp + 12 | 0; //@line 5768
 if (!(_lua_getstack($L, 0, $ar) | 0)) {
  HEAP32[$vararg_buffer6 >> 2] = $narg; //@line 5772
  HEAP32[$vararg_buffer6 + 4 >> 2] = $extramsg; //@line 5774
  $$0 = _luaL_error($L, 128, $vararg_buffer6) | 0; //@line 5776
  STACKTOP = sp; //@line 5777
  return $$0 | 0; //@line 5777
 }
 _lua_getinfo($L, 152, $ar) | 0; //@line 5779
 if (!(_strcmp(HEAP32[$ar + 8 >> 2] | 0, 160) | 0)) {
  $7 = $narg + -1 | 0; //@line 5785
  if (!$7) {
   HEAP32[$vararg_buffer6 >> 2] = HEAP32[$ar + 4 >> 2]; //@line 5790
   HEAP32[$vararg_buffer6 + 4 >> 2] = $extramsg; //@line 5792
   $$0 = _luaL_error($L, 168, $vararg_buffer6) | 0; //@line 5794
   STACKTOP = sp; //@line 5795
   return $$0 | 0; //@line 5795
  } else $$01 = $7; //@line 5797
 } else $$01 = $narg; //@line 5800
 $12 = $ar + 4 | 0; //@line 5802
 $13 = HEAP32[$12 >> 2] | 0; //@line 5803
 if (!$13) {
  if (!(_pushglobalfuncname($L, $ar) | 0)) $18 = 200; //@line 5809
 else $18 = _lua_tolstring($L, -1, 0) | 0; //@line 5812
  HEAP32[$12 >> 2] = $18; //@line 5814
  $19 = $18; //@line 5815
 } else $19 = $13; //@line 5817
 HEAP32[$vararg_buffer6 >> 2] = $$01; //@line 5819
 HEAP32[$vararg_buffer6 + 4 >> 2] = $19; //@line 5821
 HEAP32[$vararg_buffer6 + 8 >> 2] = $extramsg; //@line 5823
 $$0 = _luaL_error($L, 208, $vararg_buffer6) | 0; //@line 5825
 STACKTOP = sp; //@line 5826
 return $$0 | 0; //@line 5826
}
function _g_write($L, $f, $arg) {
 $L = $L | 0;
 $f = $f | 0;
 $arg = $arg | 0;
 var $$0 = 0, $$012 = 0, $$in = 0, $$sink = 0, $0 = 0, $10 = 0, $13 = 0, $7 = 0.0, $l = 0, $status$03 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 2135
 STACKTOP = STACKTOP + 16 | 0; //@line 2136
 $vararg_buffer = sp; //@line 2137
 $l = sp + 8 | 0; //@line 2138
 $0 = _lua_gettop($L) | 0; //@line 2139
 if (($0 | 0) == ($arg | 0)) {
  $$0 = 1; //@line 2142
  STACKTOP = sp; //@line 2143
  return $$0 | 0; //@line 2143
 }
 $$012 = $arg; //@line 2146
 $$in = $0 - $arg | 0; //@line 2146
 $status$03 = 1; //@line 2146
 while (1) {
  $$in = $$in + -1 | 0; //@line 2148
  if ((_lua_type($L, $$012) | 0) == 3) if (!$status$03) $$sink = 0; //@line 2154
 else {
   $7 = +_lua_tonumberx($L, $$012, 0); //@line 2156
   HEAPF64[tempDoublePtr >> 3] = $7; //@line 2157
   HEAP32[$vararg_buffer >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 2157
   HEAP32[$vararg_buffer + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 2157
   $$sink = (_fprintf($f | 0, 5112, $vararg_buffer | 0) | 0) > 0; //@line 2160
  } else {
   $10 = _luaL_checklstring($L, $$012, $l) | 0; //@line 2163
   if (!$status$03) $$sink = 0; //@line 2166
 else {
    $13 = _fwrite($10 | 0, 1, HEAP32[$l >> 2] | 0, $f | 0) | 0; //@line 2169
    $$sink = ($13 | 0) == (HEAP32[$l >> 2] | 0); //@line 2172
   }
  }
  if (!$$in) break; else {
   $$012 = $$012 + 1 | 0; //@line 2181
   $status$03 = $$sink & 1; //@line 2181
  }
 }
 if ($$sink) {
  $$0 = 1; //@line 2185
  STACKTOP = sp; //@line 2186
  return $$0 | 0; //@line 2186
 }
 $$0 = _luaL_fileresult($L, 0, 0) | 0; //@line 2189
 STACKTOP = sp; //@line 2190
 return $$0 | 0; //@line 2190
}
function _io_readline($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $21 = 0, $22 = 0, $i$01 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 2453
 STACKTOP = STACKTOP + 16 | 0; //@line 2454
 $vararg_buffer1 = sp; //@line 2455
 $0 = _lua_touserdata($L, -1001001) | 0; //@line 2456
 $1 = _lua_tointegerx($L, -1001002, 0) | 0; //@line 2457
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  $$0 = _luaL_error($L, 5384, $vararg_buffer1) | 0; //@line 2463
  STACKTOP = sp; //@line 2464
  return $$0 | 0; //@line 2464
 }
 _lua_settop($L, 1); //@line 2466
 if (($1 | 0) >= 1) {
  $i$01 = 1; //@line 2469
  while (1) {
   _lua_pushvalue($L, -1001003 - $i$01 | 0); //@line 2472
   if (($i$01 | 0) == ($1 | 0)) break; else $i$01 = $i$01 + 1 | 0; //@line 2478
  }
 }
 $10 = _g_read($L, HEAP32[$0 >> 2] | 0, 2) | 0; //@line 2483
 if (_lua_type($L, 0 - $10 | 0) | 0) {
  $$0 = $10; //@line 2488
  STACKTOP = sp; //@line 2489
  return $$0 | 0; //@line 2489
 }
 if (($10 | 0) > 1) {
  HEAP32[$vararg_buffer1 >> 2] = _lua_tolstring($L, 1 - $10 | 0, 0) | 0; //@line 2495
  $$0 = _luaL_error($L, 5408, $vararg_buffer1) | 0; //@line 2497
  STACKTOP = sp; //@line 2498
  return $$0 | 0; //@line 2498
 }
 if (!(_lua_toboolean($L, -1001003) | 0)) {
  $$0 = 0; //@line 2503
  STACKTOP = sp; //@line 2504
  return $$0 | 0; //@line 2504
 }
 _lua_settop($L, 0); //@line 2506
 _lua_pushvalue($L, -1001001); //@line 2507
 $21 = (_luaL_checkudata($L, 1, 4872) | 0) + 4 | 0; //@line 2509
 $22 = HEAP32[$21 >> 2] | 0; //@line 2510
 HEAP32[$21 >> 2] = 0; //@line 2511
 FUNCTION_TABLE_ii[$22 & 255]($L) | 0; //@line 2512
 $$0 = 0; //@line 2513
 STACKTOP = sp; //@line 2514
 return $$0 | 0; //@line 2514
}
function _findlabel($ls, $g) {
 $ls = $ls | 0;
 $g = $g | 0;
 var $$0 = 0, $0 = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $20 = 0, $28 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $i$04 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 8893
 $0 = $ls + 48 | 0; //@line 8894
 $3 = HEAP32[(HEAP32[$0 >> 2] | 0) + 16 >> 2] | 0; //@line 8897
 $5 = HEAP32[$ls + 64 >> 2] | 0; //@line 8899
 $7 = HEAP32[$5 + 12 >> 2] | 0; //@line 8901
 $8 = $3 + 4 | 0; //@line 8902
 $10 = HEAP16[$8 >> 1] | 0; //@line 8904
 $11 = $5 + 28 | 0; //@line 8905
 if (($10 | 0) >= (HEAP32[$11 >> 2] | 0)) {
  $$0 = 0; //@line 8909
  STACKTOP = sp; //@line 8910
  return $$0 | 0; //@line 8910
 }
 $14 = $5 + 24 | 0; //@line 8912
 $15 = $7 + ($g << 4) | 0; //@line 8913
 $i$04 = $10; //@line 8914
 while (1) {
  $19 = HEAP32[$14 >> 2] | 0; //@line 8916
  $20 = $19 + ($i$04 << 4) | 0; //@line 8917
  $18 = $i$04 + 1 | 0; //@line 8922
  if (_luaS_eqstr(HEAP32[$20 >> 2] | 0, HEAP32[$15 >> 2] | 0) | 0) break;
  if (($18 | 0) < (HEAP32[$11 >> 2] | 0)) $i$04 = $18; //@line 8929
 else {
   $$0 = 0; //@line 8931
   label = 10; //@line 8932
   break;
  }
 }
 if ((label | 0) == 10) {
  STACKTOP = sp; //@line 8937
  return $$0 | 0; //@line 8937
 }
 $28 = HEAP8[$19 + ($i$04 << 4) + 12 >> 0] | 0; //@line 8942
 do if ((HEAPU8[$7 + ($g << 4) + 12 >> 0] | 0) > ($28 & 255)) {
  if (!(HEAP8[$3 + 9 >> 0] | 0)) if ((HEAP32[$11 >> 2] | 0) <= (HEAP16[$8 >> 1] | 0)) break;
  _luaK_patchclose(HEAP32[$0 >> 2] | 0, HEAP32[$7 + ($g << 4) + 4 >> 2] | 0, $28 & 255); //@line 8962
 } while (0);
 _closegoto($ls, $g, $20); //@line 8965
 $$0 = 1; //@line 8966
 STACKTOP = sp; //@line 8967
 return $$0 | 0; //@line 8967
}
function _lua_rawgetp($L, $idx, $p) {
 $L = $L | 0;
 $idx = $idx | 0;
 $p = $p | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $38 = 0, $39 = 0, $4 = 0, $k = 0, sp = 0;
 sp = STACKTOP; //@line 3183
 STACKTOP = STACKTOP + 16 | 0; //@line 3184
 $k = sp; //@line 3185
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3187
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3192
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3197
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3204
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3212
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3215
  $17 = HEAP32[$1 >> 2] | 0; //@line 3216
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3221
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3223
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3229
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3233
  }
 } while (0);
 HEAP32[$k >> 2] = $p; //@line 3238
 HEAP32[$k + 8 >> 2] = 2; //@line 3240
 $30 = _luaH_get(HEAP32[$$0$i >> 2] | 0, $k) | 0; //@line 3242
 $31 = $L + 8 | 0; //@line 3243
 $32 = HEAP32[$31 >> 2] | 0; //@line 3244
 $33 = $30; //@line 3245
 $38 = HEAP32[$33 + 4 >> 2] | 0; //@line 3250
 $39 = $32; //@line 3251
 HEAP32[$39 >> 2] = HEAP32[$33 >> 2]; //@line 3253
 HEAP32[$39 + 4 >> 2] = $38; //@line 3256
 HEAP32[$32 + 8 >> 2] = HEAP32[$30 + 8 >> 2]; //@line 3260
 HEAP32[$31 >> 2] = (HEAP32[$31 >> 2] | 0) + 16; //@line 3263
 STACKTOP = sp; //@line 3264
 return;
}
function _luaopen_package($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6380
 _luaL_getsubtable($L, -1001e3, 7040) | 0; //@line 6381
 _lua_createtable($L, 0, 1); //@line 6382
 _lua_pushcclosure($L, 177, 0); //@line 6383
 _lua_setfield($L, -2, 7048); //@line 6384
 _lua_setmetatable($L, -2) | 0; //@line 6385
 _lua_createtable($L, 0, 3); //@line 6386
 _luaL_setfuncs($L, 7056, 0); //@line 6387
 _lua_createtable($L, 4, 0); //@line 6388
 _lua_pushvalue($L, -2); //@line 6389
 _lua_pushcclosure($L, 178, 1); //@line 6390
 _lua_rawseti($L, -2, 1); //@line 6391
 _lua_pushvalue($L, -2); //@line 6392
 _lua_pushcclosure($L, 179, 1); //@line 6393
 _lua_rawseti($L, -2, 2); //@line 6394
 _lua_pushvalue($L, -2); //@line 6395
 _lua_pushcclosure($L, 180, 1); //@line 6396
 _lua_rawseti($L, -2, 3); //@line 6397
 _lua_pushvalue($L, -2); //@line 6398
 _lua_pushcclosure($L, 181, 1); //@line 6399
 _lua_rawseti($L, -2, 4); //@line 6400
 _lua_pushvalue($L, -1); //@line 6401
 _lua_setfield($L, -3, 7088); //@line 6402
 _lua_setfield($L, -2, 7096); //@line 6403
 _setpath($L, 7112, 7120, 7136, 7152); //@line 6404
 _setpath($L, 7296, 7304, 7320, 7336); //@line 6405
 _lua_pushlstring($L, 7408, 10) | 0; //@line 6406
 _lua_setfield($L, -2, 7424); //@line 6407
 _luaL_getsubtable($L, -1001e3, 7432) | 0; //@line 6408
 _lua_setfield($L, -2, 7440); //@line 6409
 _luaL_getsubtable($L, -1001e3, 7448) | 0; //@line 6410
 _lua_setfield($L, -2, 7464); //@line 6411
 _lua_rawgeti($L, -1001e3, 2); //@line 6412
 _lua_pushvalue($L, -2); //@line 6413
 _luaL_setfuncs($L, 7472, 1); //@line 6414
 _lua_settop($L, -2); //@line 6415
 STACKTOP = sp; //@line 6416
 return 1; //@line 6416
}
function _io_lines($L) {
 $L = $L | 0;
 var $10 = 0, $11 = 0, $15 = 0, $8 = 0, $9 = 0, $toclose$0 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 2549
 STACKTOP = STACKTOP + 16 | 0; //@line 2550
 $vararg_buffer1 = sp; //@line 2551
 if ((_lua_type($L, 1) | 0) == -1) _lua_pushnil($L); //@line 2555
 if (!(_lua_type($L, 1) | 0)) {
  _lua_getfield($L, -1001e3, 4816); //@line 2560
  _lua_replace($L, 1); //@line 2561
  if (HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) + 4 >> 2] | 0) {
   $toclose$0 = 0; //@line 2567
   _aux_lines($L, $toclose$0); //@line 2568
   STACKTOP = sp; //@line 2569
   return 1; //@line 2569
  }
  _luaL_error($L, 5120, $vararg_buffer1) | 0; //@line 2571
  $toclose$0 = 0; //@line 2572
  _aux_lines($L, $toclose$0); //@line 2573
  STACKTOP = sp; //@line 2574
  return 1; //@line 2574
 } else {
  $8 = _luaL_checklstring($L, 1, 0) | 0; //@line 2576
  $9 = _lua_newuserdata($L, 8) | 0; //@line 2577
  $10 = $9 + 4 | 0; //@line 2578
  HEAP32[$10 >> 2] = 0; //@line 2579
  _luaL_setmetatable($L, 4872); //@line 2580
  HEAP32[$9 >> 2] = 0; //@line 2581
  HEAP32[$10 >> 2] = 175; //@line 2582
  $11 = _fopen($8 | 0, 5520) | 0; //@line 2583
  HEAP32[$9 >> 2] = $11; //@line 2584
  if (!$11) {
   $15 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 2589
   HEAP32[$vararg_buffer1 >> 2] = $8; //@line 2590
   HEAP32[$vararg_buffer1 + 4 >> 2] = $15; //@line 2592
   _luaL_error($L, 5560, $vararg_buffer1) | 0; //@line 2593
  }
  _lua_replace($L, 1); //@line 2595
  $toclose$0 = 1; //@line 2596
  _aux_lines($L, $toclose$0); //@line 2597
  STACKTOP = sp; //@line 2598
  return 1; //@line 2598
 }
 return 0; //@line 2600
}
function _luaopen_io($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 1876
 _lua_createtable($L, 0, 11); //@line 1877
 _luaL_setfuncs($L, 4720, 0); //@line 1878
 _luaL_newmetatable($L, 4872) | 0; //@line 1879
 _lua_pushvalue($L, -1); //@line 1880
 _lua_setfield($L, -2, 4912); //@line 1881
 _luaL_setfuncs($L, 4920, 0); //@line 1882
 _lua_settop($L, -2); //@line 1883
 $0 = HEAP32[_stdin >> 2] | 0; //@line 1884
 $1 = _lua_newuserdata($L, 8) | 0; //@line 1885
 $2 = $1 + 4 | 0; //@line 1886
 HEAP32[$2 >> 2] = 0; //@line 1887
 _luaL_setmetatable($L, 4872); //@line 1888
 HEAP32[$1 >> 2] = $0; //@line 1889
 HEAP32[$2 >> 2] = 173; //@line 1890
 _lua_pushvalue($L, -1); //@line 1891
 _lua_setfield($L, -1001e3, 4816); //@line 1892
 _lua_setfield($L, -2, 4832); //@line 1893
 $3 = HEAP32[_stdout >> 2] | 0; //@line 1894
 $4 = _lua_newuserdata($L, 8) | 0; //@line 1895
 $5 = $4 + 4 | 0; //@line 1896
 HEAP32[$5 >> 2] = 0; //@line 1897
 _luaL_setmetatable($L, 4872); //@line 1898
 HEAP32[$4 >> 2] = $3; //@line 1899
 HEAP32[$5 >> 2] = 173; //@line 1900
 _lua_pushvalue($L, -1); //@line 1901
 _lua_setfield($L, -1001e3, 4840); //@line 1902
 _lua_setfield($L, -2, 4856); //@line 1903
 $6 = HEAP32[_stderr >> 2] | 0; //@line 1904
 $7 = _lua_newuserdata($L, 8) | 0; //@line 1905
 $8 = $7 + 4 | 0; //@line 1906
 HEAP32[$8 >> 2] = 0; //@line 1907
 _luaL_setmetatable($L, 4872); //@line 1908
 HEAP32[$7 >> 2] = $6; //@line 1909
 HEAP32[$8 >> 2] = 173; //@line 1910
 _lua_setfield($L, -2, 4864); //@line 1911
 STACKTOP = sp; //@line 1912
 return 1; //@line 1912
}
function _lua_pushcclosure($L, $fn, $n) {
 $L = $L | 0;
 $fn = $fn | 0;
 $n = $n | 0;
 var $$in = 0, $11 = 0, $14 = 0, $17 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $35 = 0, $36 = 0, $37 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 2721
 if (!$n) {
  $2 = HEAP32[$L + 8 >> 2] | 0; //@line 2725
  HEAP32[$2 >> 2] = $fn; //@line 2726
  HEAP32[$2 + 8 >> 2] = 22; //@line 2728
  $35 = $L + 8 | 0; //@line 2729
  $36 = HEAP32[$35 >> 2] | 0; //@line 2730
  $37 = $36 + 16 | 0; //@line 2731
  HEAP32[$35 >> 2] = $37; //@line 2732
  STACKTOP = sp; //@line 2733
  return;
 }
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2741
 $9 = _luaF_newCclosure($L, $n) | 0; //@line 2743
 HEAP32[$9 + 12 >> 2] = $fn; //@line 2745
 $11 = $L + 8 | 0; //@line 2746
 $14 = (HEAP32[$11 >> 2] | 0) + (0 - $n << 4) | 0; //@line 2749
 HEAP32[$11 >> 2] = $14; //@line 2750
 $$in = $n; //@line 2751
 $17 = $14; //@line 2751
 do {
  $$in = $$in + -1 | 0; //@line 2753
  $19 = $17 + ($$in << 4) | 0; //@line 2756
  $24 = HEAP32[$19 + 4 >> 2] | 0; //@line 2761
  $25 = $9 + ($$in << 4) + 16 | 0; //@line 2762
  HEAP32[$25 >> 2] = HEAP32[$19 >> 2]; //@line 2764
  HEAP32[$25 + 4 >> 2] = $24; //@line 2767
  HEAP32[$9 + ($$in << 4) + 24 >> 2] = HEAP32[$17 + ($$in << 4) + 8 >> 2]; //@line 2771
  $17 = HEAP32[$11 >> 2] | 0; //@line 2773
 } while (($$in | 0) != 0);
 HEAP32[$17 >> 2] = $9; //@line 2780
 HEAP32[$17 + 8 >> 2] = 102; //@line 2782
 $35 = $L + 8 | 0; //@line 2783
 $36 = HEAP32[$35 >> 2] | 0; //@line 2784
 $37 = $36 + 16 | 0; //@line 2785
 HEAP32[$35 >> 2] = $37; //@line 2786
 STACKTOP = sp; //@line 2787
 return;
}
function _lua_tonumberx($L, $idx, $isnum) {
 $L = $L | 0;
 $idx = $idx | 0;
 $isnum = $isnum | 0;
 var $$0 = 0.0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $31 = 0, $4 = 0, $n = 0, $o$0 = 0, sp = 0;
 sp = STACKTOP; //@line 1565
 STACKTOP = STACKTOP + 16 | 0; //@line 1566
 $n = sp; //@line 1567
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1569
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1574
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1579
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1586
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1594
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1597
  $17 = HEAP32[$1 >> 2] | 0; //@line 1598
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1603
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1605
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1611
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1615
  }
 } while (0);
 if ((HEAP32[$$0$i + 8 >> 2] | 0) == 3) $o$0 = $$0$i; //@line 1624
 else {
  $31 = _luaV_tonumber($$0$i, $n) | 0; //@line 1626
  if (!$31) {
   if (!$isnum) {
    $$0 = 0.0; //@line 1631
    STACKTOP = sp; //@line 1632
    return +$$0;
   }
   HEAP32[$isnum >> 2] = 0; //@line 1634
   $$0 = 0.0; //@line 1635
   STACKTOP = sp; //@line 1636
   return +$$0;
  } else $o$0 = $31; //@line 1638
 }
 if ($isnum) HEAP32[$isnum >> 2] = 1; //@line 1643
 $$0 = +HEAPF64[$o$0 >> 3]; //@line 1646
 STACKTOP = sp; //@line 1647
 return +$$0;
}
function _lua_rawlen($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0 = 0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2073
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2075
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2080
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2085
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2092
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2100
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2103
  $17 = HEAP32[$1 >> 2] | 0; //@line 2104
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2109
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2111
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2117
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2121
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 15; //@line 2128
 if (($30 | 0) == 4) {
  $$0 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 12 >> 2] | 0; //@line 2133
  STACKTOP = sp; //@line 2134
  return $$0 | 0; //@line 2134
 } else if (($30 | 0) == 7) {
  $$0 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 16 >> 2] | 0; //@line 2139
  STACKTOP = sp; //@line 2140
  return $$0 | 0; //@line 2140
 } else if (($30 | 0) == 5) {
  $$0 = _luaH_getn(HEAP32[$$0$i >> 2] | 0) | 0; //@line 2144
  STACKTOP = sp; //@line 2145
  return $$0 | 0; //@line 2145
 } else {
  $$0 = 0; //@line 2147
  STACKTOP = sp; //@line 2148
  return $$0 | 0; //@line 2148
 }
 return 0; //@line 2150
}
function _luaL_addlstring($B, $s, $l) {
 $B = $B | 0;
 $s = $s | 0;
 $l = $l | 0;
 var $$$i = 0, $1 = 0, $15 = 0, $2 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 6424
 STACKTOP = STACKTOP + 16 | 0; //@line 6425
 $1 = HEAP32[$B + 12 >> 2] | 0; //@line 6428
 $2 = $B + 4 | 0; //@line 6429
 $3 = HEAP32[$2 >> 2] | 0; //@line 6430
 $4 = $B + 8 | 0; //@line 6431
 $5 = HEAP32[$4 >> 2] | 0; //@line 6432
 if (($3 - $5 | 0) >>> 0 >= $l >>> 0) {
  $22 = HEAP32[$B >> 2] | 0; //@line 6437
  $23 = $5; //@line 6437
  $21 = $22 + $23 | 0; //@line 6438
  _memcpy($21 | 0, $s | 0, $l | 0) | 0; //@line 6439
  $24 = HEAP32[$4 >> 2] | 0; //@line 6440
  $25 = $24 + $l | 0; //@line 6441
  HEAP32[$4 >> 2] = $25; //@line 6442
  STACKTOP = sp; //@line 6443
  return;
 }
 $8 = $3 << 1; //@line 6445
 $$$i = ($8 - $5 | 0) >>> 0 < $l >>> 0 ? $5 + $l | 0 : $8; //@line 6449
 if ($$$i >>> 0 < $5 >>> 0 | ($$$i - $5 | 0) >>> 0 < $l >>> 0) _luaL_error($1, 360, sp) | 0; //@line 6455
 $15 = _lua_newuserdata($1, $$$i) | 0; //@line 6457
 _memcpy($15 | 0, HEAP32[$B >> 2] | 0, HEAP32[$4 >> 2] | 0) | 0; //@line 6460
 if ((HEAP32[$B >> 2] | 0) != ($B + 16 | 0)) _lua_remove($1, -2); //@line 6465
 HEAP32[$B >> 2] = $15; //@line 6467
 HEAP32[$2 >> 2] = $$$i; //@line 6468
 $22 = $15; //@line 6470
 $23 = HEAP32[$4 >> 2] | 0; //@line 6470
 $21 = $22 + $23 | 0; //@line 6471
 _memcpy($21 | 0, $s | 0, $l | 0) | 0; //@line 6472
 $24 = HEAP32[$4 >> 2] | 0; //@line 6473
 $25 = $24 + $l | 0; //@line 6474
 HEAP32[$4 >> 2] = $25; //@line 6475
 STACKTOP = sp; //@line 6476
 return;
}
function _lua_getuservalue($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $32 = 0, $33 = 0, $36 = 0, $37 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 3399
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3401
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3406
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3411
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3418
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3426
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3429
  $17 = HEAP32[$1 >> 2] | 0; //@line 3430
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3435
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3437
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3443
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3447
  }
 } while (0);
 $30 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 12 >> 2] | 0; //@line 3454
 $32 = $L + 8 | 0; //@line 3456
 $33 = HEAP32[$32 >> 2] | 0; //@line 3457
 if (!$30) {
  HEAP32[$33 + 8 >> 2] = 0; //@line 3460
  $37 = $33; //@line 3461
  $36 = $37 + 16 | 0; //@line 3462
  HEAP32[$32 >> 2] = $36; //@line 3463
  STACKTOP = sp; //@line 3464
  return;
 } else {
  HEAP32[$33 >> 2] = $30; //@line 3466
  HEAP32[$33 + 8 >> 2] = 69; //@line 3468
  $37 = HEAP32[$32 >> 2] | 0; //@line 3470
  $36 = $37 + 16 | 0; //@line 3471
  HEAP32[$32 >> 2] = $36; //@line 3472
  STACKTOP = sp; //@line 3473
  return;
 }
}
function _luaK_setreturns($fs, $e, $nresults) {
 $fs = $fs | 0;
 $e = $e | 0;
 $nresults = $nresults | 0;
 var $0 = 0, $13 = 0, $15 = 0, $17 = 0, $18 = 0, $25 = 0, $28 = 0, $33 = 0, $35 = 0, $36 = 0, $45 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 9614
 $0 = HEAP32[$e >> 2] | 0; //@line 9615
 if (($0 | 0) == 13) {
  $13 = $e + 8 | 0; //@line 9617
  $15 = HEAP32[$fs >> 2] | 0; //@line 9619
  $17 = HEAP32[$15 + 12 >> 2] | 0; //@line 9621
  $18 = $17 + (HEAP32[$13 >> 2] << 2) | 0; //@line 9622
  HEAP32[$18 >> 2] = HEAP32[$18 >> 2] & 8388607 | ($nresults << 23) + 8388608; //@line 9628
  $25 = $17 + (HEAP32[$13 >> 2] << 2) | 0; //@line 9630
  $28 = $fs + 48 | 0; //@line 9633
  HEAP32[$25 >> 2] = (HEAPU8[$28 >> 0] | 0) << 6 | HEAP32[$25 >> 2] & -16321; //@line 9638
  $33 = HEAP8[$28 >> 0] | 0; //@line 9639
  $35 = ($33 & 255) + 1 | 0; //@line 9641
  $36 = $15 + 78 | 0; //@line 9642
  do if ($35 >>> 0 > (HEAPU8[$36 >> 0] | 0) >>> 0) if ($35 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 9652
 else {
   HEAP8[$36 >> 0] = $35; //@line 9656
   $45 = HEAP8[$28 >> 0] | 0; //@line 9658
   break;
  } else $45 = $33; //@line 9662
 while (0);
  HEAP8[$28 >> 0] = ($45 & 255) + 1; //@line 9668
  STACKTOP = sp; //@line 9669
  return;
 } else if (($0 | 0) == 12) {
  $6 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$e + 8 >> 2] << 2) | 0; //@line 9676
  HEAP32[$6 >> 2] = HEAP32[$6 >> 2] & -8372225 | ($nresults << 14) + 16384 & 8372224; //@line 9683
  STACKTOP = sp; //@line 9684
  return;
 } else {
  STACKTOP = sp; //@line 9686
  return;
 }
}
function _luaL_setfuncs($L, $l, $nup) {
 $L = $L | 0;
 $l = $l | 0;
 $nup = $nup | 0;
 var $17 = 0, $23 = 0, $6 = 0, $7 = 0, $9 = 0, $i$01$us = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7232
 STACKTOP = STACKTOP + 16 | 0; //@line 7233
 $vararg_buffer = sp; //@line 7234
 _luaL_checkversion_($L, 502.0); //@line 7235
 if (!(_lua_checkstack($L, $nup + 20 | 0) | 0)) {
  HEAP32[$vararg_buffer >> 2] = 560; //@line 7240
  _luaL_error($L, 304, $vararg_buffer) | 0; //@line 7241
 }
 if (!(HEAP32[$l >> 2] | 0)) {
  $23 = ~$nup; //@line 7246
  _lua_settop($L, $23); //@line 7247
  STACKTOP = sp; //@line 7248
  return;
 }
 $6 = -2 - $nup | 0; //@line 7251
 $7 = 0 - $nup | 0; //@line 7252
 if (($nup | 0) > 0) $9 = $l; //@line 7254
 else {
  $17 = $l; //@line 7256
  do {
   _lua_pushcclosure($L, HEAP32[$17 + 4 >> 2] | 0, $nup); //@line 7260
   _lua_setfield($L, $6, HEAP32[$17 >> 2] | 0); //@line 7262
   $17 = $17 + 8 | 0; //@line 7263
  } while ((HEAP32[$17 >> 2] | 0) != 0);
  $23 = ~$nup; //@line 7272
  _lua_settop($L, $23); //@line 7273
  STACKTOP = sp; //@line 7274
  return;
 }
 do {
  $i$01$us = 0; //@line 7277
  do {
   _lua_pushvalue($L, $7); //@line 7279
   $i$01$us = $i$01$us + 1 | 0; //@line 7280
  } while (($i$01$us | 0) != ($nup | 0));
  _lua_pushcclosure($L, HEAP32[$9 + 4 >> 2] | 0, $nup); //@line 7290
  _lua_setfield($L, $6, HEAP32[$9 >> 2] | 0); //@line 7292
  $9 = $9 + 8 | 0; //@line 7293
 } while ((HEAP32[$9 >> 2] | 0) != 0);
 $23 = ~$nup; //@line 7302
 _lua_settop($L, $23); //@line 7303
 STACKTOP = sp; //@line 7304
 return;
}
function ___shgetc($f) {
 $f = $f | 0;
 var $$0 = 0, $$pre = 0, $$pre3 = 0, $0 = 0, $1 = 0, $12 = 0, $19 = 0, $27 = 0, $32 = 0, $6 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 12991
 $0 = $f + 104 | 0; //@line 12992
 $1 = HEAP32[$0 >> 2] | 0; //@line 12993
 if (!$1) label = 3; //@line 12996
 else if ((HEAP32[$f + 108 >> 2] | 0) < ($1 | 0)) label = 3; //@line 13002
 if ((label | 0) == 3) {
  $6 = ___uflow($f) | 0; //@line 13006
  if (($6 | 0) >= 0) {
   $9 = HEAP32[$0 >> 2] | 0; //@line 13009
   $$pre = HEAP32[$f + 8 >> 2] | 0; //@line 13012
   if (!$9) label = 8; //@line 13014
 else {
    $12 = HEAP32[$f + 4 >> 2] | 0; //@line 13017
    $19 = $9 - (HEAP32[$f + 108 >> 2] | 0) + -1 | 0; //@line 13024
    if (($$pre - $12 | 0) > ($19 | 0)) HEAP32[$f + 100 >> 2] = $12 + $19; //@line 13029
 else label = 8; //@line 13031
   }
   if ((label | 0) == 8) HEAP32[$f + 100 >> 2] = $$pre; //@line 13036
   $$pre3 = HEAP32[$f + 4 >> 2] | 0; //@line 13040
   if ($$pre) {
    $27 = $f + 108 | 0; //@line 13044
    HEAP32[$27 >> 2] = $$pre + 1 - $$pre3 + (HEAP32[$27 >> 2] | 0); //@line 13049
   }
   $32 = $$pre3 + -1 | 0; //@line 13051
   if ((HEAPU8[$32 >> 0] | 0 | 0) == ($6 | 0)) {
    $$0 = $6; //@line 13056
    STACKTOP = sp; //@line 13057
    return $$0 | 0; //@line 13057
   }
   HEAP8[$32 >> 0] = $6; //@line 13060
   $$0 = $6; //@line 13061
   STACKTOP = sp; //@line 13062
   return $$0 | 0; //@line 13062
  }
 }
 HEAP32[$f + 100 >> 2] = 0; //@line 13066
 $$0 = -1; //@line 13067
 STACKTOP = sp; //@line 13068
 return $$0 | 0; //@line 13068
}
function _condjump($fs, $op, $A, $B, $C) {
 $fs = $fs | 0;
 $op = $op | 0;
 $A = $A | 0;
 $B = $B | 0;
 $C = $C | 0;
 var $11 = 0, $12 = 0, $14 = 0, $17 = 0, $19 = 0, $28 = 0, $6 = 0, $7 = 0, $8 = 0, $fs$idx$val$idx$val$i$i = 0, $list$0$i$i = 0, sp = 0;
 sp = STACKTOP; //@line 12688
 _luaK_code($fs, $A << 6 | $op | $B << 23 | $C << 14) | 0; //@line 12695
 $6 = $fs + 28 | 0; //@line 12696
 $7 = HEAP32[$6 >> 2] | 0; //@line 12697
 HEAP32[$6 >> 2] = -1; //@line 12698
 $8 = _luaK_code($fs, 2147450903) | 0; //@line 12699
 if (($7 | 0) == -1) {
  $28 = $8; //@line 12702
  STACKTOP = sp; //@line 12703
  return $28 | 0; //@line 12703
 }
 if (($8 | 0) == -1) {
  $28 = $7; //@line 12707
  STACKTOP = sp; //@line 12708
  return $28 | 0; //@line 12708
 }
 $fs$idx$val$idx$val$i$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 12712
 $list$0$i$i = $8; //@line 12713
 while (1) {
  $11 = $fs$idx$val$idx$val$i$i + ($list$0$i$i << 2) | 0; //@line 12715
  $12 = HEAP32[$11 >> 2] | 0; //@line 12716
  $14 = ($12 >>> 14) + -131071 | 0; //@line 12718
  if (($14 | 0) == -1) break;
  $17 = $list$0$i$i + 1 + $14 | 0; //@line 12724
  if (($17 | 0) == -1) break; else $list$0$i$i = $17; //@line 12729
 }
 $19 = $7 + ~$list$0$i$i | 0; //@line 12733
 if (((($19 | 0) > -1 ? $19 : 0 - $19 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 12741
 HEAP32[$11 >> 2] = ($19 << 14) + 2147467264 | $12 & 16383; //@line 12748
 $28 = $8; //@line 12749
 STACKTOP = sp; //@line 12750
 return $28 | 0; //@line 12750
}
function _lua_rawgeti($L, $idx, $n) {
 $L = $L | 0;
 $idx = $idx | 0;
 $n = $n | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $37 = 0, $38 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 3098
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3100
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3105
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3110
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3117
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3125
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3128
  $17 = HEAP32[$1 >> 2] | 0; //@line 3129
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3134
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3136
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3142
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3146
  }
 } while (0);
 $29 = _luaH_getint(HEAP32[$$0$i >> 2] | 0, $n) | 0; //@line 3152
 $30 = $L + 8 | 0; //@line 3153
 $31 = HEAP32[$30 >> 2] | 0; //@line 3154
 $32 = $29; //@line 3155
 $37 = HEAP32[$32 + 4 >> 2] | 0; //@line 3160
 $38 = $31; //@line 3161
 HEAP32[$38 >> 2] = HEAP32[$32 >> 2]; //@line 3163
 HEAP32[$38 + 4 >> 2] = $37; //@line 3166
 HEAP32[$31 + 8 >> 2] = HEAP32[$29 + 8 >> 2]; //@line 3170
 HEAP32[$30 >> 2] = (HEAP32[$30 >> 2] | 0) + 16; //@line 3173
 STACKTOP = sp; //@line 3174
 return;
}
function _lua_isstring($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $32 = 0, $33 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 1070
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1072
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1077
  $$0$i$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1082
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1089
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1097
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1100
  $17 = HEAP32[$1 >> 2] | 0; //@line 1101
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) {
   $33 = 0; //@line 1106
   $32 = $33 & 1; //@line 1107
   STACKTOP = sp; //@line 1108
   return $32 | 0; //@line 1108
  }
  $21 = HEAP32[$17 >> 2] | 0; //@line 1110
  if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) {
   $33 = 0; //@line 1116
   $32 = $33 & 1; //@line 1117
   STACKTOP = sp; //@line 1118
   return $32 | 0; //@line 1118
  } else {
   $$0$i$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1122
   break;
  }
 } while (0);
 if (($$0$i$i | 0) == 8048) {
  $33 = 0; //@line 1129
  $32 = $33 & 1; //@line 1130
  STACKTOP = sp; //@line 1131
  return $32 | 0; //@line 1131
 }
 $33 = ((HEAP32[$$0$i$i + 8 >> 2] & 15) + -3 | 0) >>> 0 < 2; //@line 1138
 $32 = $33 & 1; //@line 1139
 STACKTOP = sp; //@line 1140
 return $32 | 0; //@line 1140
}
function _lua_setfield($L, $idx, $k) {
 $L = $L | 0;
 $idx = $idx | 0;
 $k = $k | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $31 = 0, $37 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 3583
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3585
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3590
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3595
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3602
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3610
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3613
  $17 = HEAP32[$1 >> 2] | 0; //@line 3614
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3619
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3621
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3627
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3631
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 3636
 $29 = HEAP32[$28 >> 2] | 0; //@line 3637
 HEAP32[$28 >> 2] = $29 + 16; //@line 3639
 $31 = _luaS_new($L, $k) | 0; //@line 3640
 HEAP32[$29 >> 2] = $31; //@line 3641
 HEAP32[$29 + 8 >> 2] = HEAPU8[$31 + 4 >> 0] | 0 | 64; //@line 3647
 $37 = HEAP32[$28 >> 2] | 0; //@line 3648
 _luaV_settable($L, $$0$i, $37 + -16 | 0, $37 + -32 | 0); //@line 3651
 HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + -32; //@line 3654
 STACKTOP = sp; //@line 3655
 return;
}
function _luaK_exp2nextreg($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $10 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, sp = 0;
 sp = STACKTOP; //@line 9844
 _luaK_dischargevars($fs, $e); //@line 9845
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $3 = HEAP32[$e + 8 >> 2] | 0; //@line 9850
  if (!($3 & 256)) if ((HEAPU8[$fs + 46 >> 0] | 0 | 0) <= ($3 | 0)) {
   $10 = $fs + 48 | 0; //@line 9859
   HEAP8[$10 >> 0] = (HEAP8[$10 >> 0] | 0) + -1 << 24 >> 24; //@line 9862
  }
 }
 $13 = $fs + 48 | 0; //@line 9866
 $14 = HEAP8[$13 >> 0] | 0; //@line 9867
 $16 = ($14 & 255) + 1 | 0; //@line 9869
 $18 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 9871
 if ($16 >>> 0 <= (HEAPU8[$18 >> 0] | 0) >>> 0) {
  $27 = $14; //@line 9876
  $26 = $27 & 255; //@line 9877
  $28 = $26 + 1 | 0; //@line 9878
  $29 = $28 & 255; //@line 9879
  HEAP8[$13 >> 0] = $29; //@line 9880
  $30 = $28 & 255; //@line 9881
  $31 = $30 + -1 | 0; //@line 9882
  _exp2reg($fs, $e, $31); //@line 9883
  STACKTOP = sp; //@line 9884
  return;
 }
 if ($16 >>> 0 > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 9890
 HEAP8[$18 >> 0] = $16; //@line 9894
 $27 = HEAP8[$13 >> 0] | 0; //@line 9896
 $26 = $27 & 255; //@line 9897
 $28 = $26 + 1 | 0; //@line 9898
 $29 = $28 & 255; //@line 9899
 HEAP8[$13 >> 0] = $29; //@line 9900
 $30 = $28 & 255; //@line 9901
 $31 = $30 + -1 | 0; //@line 9902
 _exp2reg($fs, $e, $31); //@line 9903
 STACKTOP = sp; //@line 9904
 return;
}
function _lua_getlocal($L, $ar, $n) {
 $L = $L | 0;
 $ar = $ar | 0;
 $n = $n | 0;
 var $13 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $23 = 0, $24 = 0, $name$0 = 0, $pos = 0, sp = 0;
 sp = STACKTOP; //@line 13949
 STACKTOP = STACKTOP + 16 | 0; //@line 13950
 $pos = sp; //@line 13951
 if (!$ar) {
  $2 = HEAP32[$L + 8 >> 2] | 0; //@line 13955
  if ((HEAP32[$2 + -8 >> 2] | 0) != 70) {
   $name$0 = 0; //@line 13960
   STACKTOP = sp; //@line 13961
   return $name$0 | 0; //@line 13961
  }
  $name$0 = _luaF_getlocalname(HEAP32[(HEAP32[$2 + -16 >> 2] | 0) + 12 >> 2] | 0, $n, 0) | 0; //@line 13968
  STACKTOP = sp; //@line 13969
  return $name$0 | 0; //@line 13969
 } else {
  HEAP32[$pos >> 2] = 0; //@line 13971
  $13 = _findlocal($L, HEAP32[$ar + 96 >> 2] | 0, $n, $pos) | 0; //@line 13974
  if (!$13) {
   $name$0 = 0; //@line 13977
   STACKTOP = sp; //@line 13978
   return $name$0 | 0; //@line 13978
  }
  $15 = HEAP32[$pos >> 2] | 0; //@line 13980
  $16 = $L + 8 | 0; //@line 13981
  $17 = HEAP32[$16 >> 2] | 0; //@line 13982
  $18 = $15; //@line 13983
  $23 = HEAP32[$18 + 4 >> 2] | 0; //@line 13988
  $24 = $17; //@line 13989
  HEAP32[$24 >> 2] = HEAP32[$18 >> 2]; //@line 13991
  HEAP32[$24 + 4 >> 2] = $23; //@line 13994
  HEAP32[$17 + 8 >> 2] = HEAP32[$15 + 8 >> 2]; //@line 13998
  HEAP32[$16 >> 2] = (HEAP32[$16 >> 2] | 0) + 16; //@line 14001
  $name$0 = $13; //@line 14002
  STACKTOP = sp; //@line 14003
  return $name$0 | 0; //@line 14003
 }
 return 0; //@line 14005
}
function _luaC_checkfinalizer($L, $o, $mt) {
 $L = $L | 0;
 $o = $o | 0;
 $mt = $mt | 0;
 var $1 = 0, $13 = 0, $14 = 0, $16 = 0, $19 = 0, $2 = 0, $22 = 0, $26 = 0, $p$0 = 0, sp = 0;
 sp = STACKTOP; //@line 19069
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 19071
 $2 = $o + 5 | 0; //@line 19072
 if ((HEAP8[$2 >> 0] & 24) != 0 | ($mt | 0) == 0) {
  STACKTOP = sp; //@line 19079
  return;
 }
 if (HEAP8[$mt + 6 >> 0] & 4) {
  STACKTOP = sp; //@line 19086
  return;
 }
 if (!(_luaT_gettm($mt, 2, HEAP32[$1 + 192 >> 2] | 0) | 0)) {
  STACKTOP = sp; //@line 19093
  return;
 }
 $13 = $1 + 76 | 0; //@line 19095
 $14 = HEAP32[$13 >> 2] | 0; //@line 19096
 if (($14 | 0) == ($o | 0)) {
  do $16 = _sweeplist($L, $14, 1) | 0; //@line 19100
 while (($16 | 0) == ($14 | 0));
  HEAP32[$13 >> 2] = $16; //@line 19106
 }
 $p$0 = $1 + 68 | 0; //@line 19109
 while (1) {
  $19 = HEAP32[$p$0 >> 2] | 0; //@line 19111
  if (($19 | 0) == ($o | 0)) break; else $p$0 = $19; //@line 19116
 }
 HEAP32[$p$0 >> 2] = HEAP32[$o >> 2]; //@line 19120
 $22 = $1 + 72 | 0; //@line 19121
 HEAP32[$o >> 2] = HEAP32[$22 >> 2]; //@line 19123
 HEAP32[$22 >> 2] = $o; //@line 19124
 $26 = HEAPU8[$2 >> 0] | 0 | 16; //@line 19127
 HEAP8[$2 >> 0] = $26; //@line 19129
 if ((HEAPU8[$1 + 61 >> 0] | 0) < 2) {
  HEAP8[$2 >> 0] = $26 & 191; //@line 19136
  STACKTOP = sp; //@line 19137
  return;
 } else {
  HEAP8[$2 >> 0] = (HEAPU8[$1 + 60 >> 0] | 0) & 3 | $26 & 184; //@line 19146
  STACKTOP = sp; //@line 19147
  return;
 }
}
function _luaC_changemode($L, $mode) {
 $L = $L | 0;
 $mode = $mode | 0;
 var $0 = 0, $1 = 0, $18 = 0, $2 = 0, $21 = 0, $22 = 0, $25 = 0, $26 = 0, $30 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 19156
 $0 = $L + 12 | 0; //@line 19157
 $1 = HEAP32[$0 >> 2] | 0; //@line 19158
 $2 = $1 + 62 | 0; //@line 19159
 if ((HEAPU8[$2 >> 0] | 0) == ($mode | 0)) {
  STACKTOP = sp; //@line 19164
  return;
 }
 if (($mode | 0) == 2) {
  $7 = $1 + 61 | 0; //@line 19168
  if (HEAP8[$7 >> 0] | 0) do _singlestep($L) | 0; //@line 19173
 while ((HEAP8[$7 >> 0] | 0) != 0);
  HEAP32[$1 + 20 >> 2] = (HEAP32[$1 + 12 >> 2] | 0) + (HEAP32[$1 + 8 >> 2] | 0); //@line 19187
  HEAP8[$2 >> 0] = 2; //@line 19188
  STACKTOP = sp; //@line 19189
  return;
 }
 HEAP8[$2 >> 0] = 0; //@line 19191
 $18 = HEAP32[$0 >> 2] | 0; //@line 19192
 HEAP8[$18 + 61 >> 0] = 2; //@line 19194
 HEAP32[$18 + 64 >> 2] = 0; //@line 19196
 $21 = $18 + 72 | 0; //@line 19197
 do $22 = _sweeplist($L, $21, 1) | 0; //@line 19199
 while (($22 | 0) == ($21 | 0));
 HEAP32[$18 + 80 >> 2] = $22; //@line 19206
 $25 = $18 + 68 | 0; //@line 19207
 do $26 = _sweeplist($L, $25, 1) | 0; //@line 19209
 while (($26 | 0) == ($25 | 0));
 HEAP32[$18 + 76 >> 2] = $26; //@line 19216
 $30 = (HEAP32[$0 >> 2] | 0) + 61 | 0; //@line 19218
 if (1 << HEAPU8[$30 >> 0] & -29) {
  STACKTOP = sp; //@line 19225
  return;
 }
 do _singlestep($L) | 0; //@line 19228
 while ((1 << HEAPU8[$30 >> 0] & -29 | 0) == 0);
 STACKTOP = sp; //@line 19238
 return;
}
function _lua_rawget($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $32 = 0, $33 = 0, $35 = 0, $4 = 0, $40 = 0, $41 = 0, sp = 0;
 sp = STACKTOP; //@line 3013
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3015
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3020
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3025
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3032
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3040
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3043
  $17 = HEAP32[$1 >> 2] | 0; //@line 3044
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3049
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3051
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3057
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3061
  }
 } while (0);
 $29 = $L + 8 | 0; //@line 3067
 $32 = _luaH_get(HEAP32[$$0$i >> 2] | 0, (HEAP32[$29 >> 2] | 0) + -16 | 0) | 0; //@line 3070
 $33 = HEAP32[$29 >> 2] | 0; //@line 3071
 $35 = $32; //@line 3073
 $40 = HEAP32[$35 + 4 >> 2] | 0; //@line 3078
 $41 = $33 + -16 | 0; //@line 3079
 HEAP32[$41 >> 2] = HEAP32[$35 >> 2]; //@line 3081
 HEAP32[$41 + 4 >> 2] = $40; //@line 3084
 HEAP32[$33 + -8 >> 2] = HEAP32[$32 + 8 >> 2]; //@line 3088
 STACKTOP = sp; //@line 3089
 return;
}
function _luaL_checkoption($L, $narg, $def, $lst) {
 $L = $L | 0;
 $narg = $narg | 0;
 $def = $def | 0;
 $lst = $lst | 0;
 var $$0 = 0, $14 = 0, $15 = 0, $2 = 0, $4 = 0, $6 = 0, $8 = 0, $i$02 = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP; //@line 6065
 STACKTOP = STACKTOP + 16 | 0; //@line 6066
 $vararg_buffer2 = sp; //@line 6067
 if (!$def) {
  $2 = _lua_tolstring($L, $narg, 0) | 0; //@line 6070
  if (!$2) {
   $4 = _lua_typename($L, 4) | 0; //@line 6073
   $6 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6075
   HEAP32[$vararg_buffer2 >> 2] = $4; //@line 6076
   HEAP32[$vararg_buffer2 + 4 >> 2] = $6; //@line 6078
   _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer2) | 0) | 0; //@line 6080
   $15 = 0; //@line 6081
  } else $15 = $2; //@line 6083
 } else $15 = _luaL_optlstring($L, $narg, $def, 0) | 0; //@line 6087
 $8 = HEAP32[$lst >> 2] | 0; //@line 6089
 L6 : do if ($8) {
  $14 = $8; //@line 6093
  $i$02 = 0; //@line 6093
  while (1) {
   if (!(_strcmp($14, $15) | 0)) {
    $$0 = $i$02; //@line 6099
    break;
   }
   $i$02 = $i$02 + 1 | 0; //@line 6097
   $14 = HEAP32[$lst + ($i$02 << 2) >> 2] | 0; //@line 6103
   if (!$14) break L6;
  }
  STACKTOP = sp; //@line 6111
  return $$0 | 0; //@line 6111
 } while (0);
 HEAP32[$vararg_buffer2 >> 2] = $15; //@line 6114
 $$0 = _luaL_argerror($L, $narg, _lua_pushfstring($L, 280, $vararg_buffer2) | 0) | 0; //@line 6117
 STACKTOP = sp; //@line 6118
 return $$0 | 0; //@line 6118
}
function _wcrtomb($s, $wc, $st) {
 $s = $s | 0;
 $wc = $wc | 0;
 $st = $st | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 13191
 if (!$s) {
  $$0 = 1; //@line 13194
  STACKTOP = sp; //@line 13195
  return $$0 | 0; //@line 13195
 }
 if ($wc >>> 0 < 128) {
  HEAP8[$s >> 0] = $wc; //@line 13200
  $$0 = 1; //@line 13201
  STACKTOP = sp; //@line 13202
  return $$0 | 0; //@line 13202
 }
 if ($wc >>> 0 < 2048) {
  HEAP8[$s >> 0] = $wc >>> 6 | 192; //@line 13210
  HEAP8[$s + 1 >> 0] = $wc & 63 | 128; //@line 13214
  $$0 = 2; //@line 13215
  STACKTOP = sp; //@line 13216
  return $$0 | 0; //@line 13216
 }
 if ($wc >>> 0 < 55296 | ($wc + -57344 | 0) >>> 0 < 8192) {
  HEAP8[$s >> 0] = $wc >>> 12 | 224; //@line 13227
  HEAP8[$s + 1 >> 0] = $wc >>> 6 & 63 | 128; //@line 13233
  HEAP8[$s + 2 >> 0] = $wc & 63 | 128; //@line 13237
  $$0 = 3; //@line 13238
  STACKTOP = sp; //@line 13239
  return $$0 | 0; //@line 13239
 }
 if (($wc + -65536 | 0) >>> 0 < 1048576) {
  HEAP8[$s >> 0] = $wc >>> 18 | 240; //@line 13248
  HEAP8[$s + 1 >> 0] = $wc >>> 12 & 63 | 128; //@line 13254
  HEAP8[$s + 2 >> 0] = $wc >>> 6 & 63 | 128; //@line 13260
  HEAP8[$s + 3 >> 0] = $wc & 63 | 128; //@line 13264
  $$0 = 4; //@line 13265
  STACKTOP = sp; //@line 13266
  return $$0 | 0; //@line 13266
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 84; //@line 13269
  $$0 = -1; //@line 13270
  STACKTOP = sp; //@line 13271
  return $$0 | 0; //@line 13271
 }
 return 0; //@line 13273
}
function _lua_checkstack($L, $size) {
 $L = $L | 0;
 $size = $size | 0;
 var $0 = 0, $2 = 0, $21 = 0, $23 = 0, $25 = 0, $26 = 0, $27 = 0, $5 = 0, $6 = 0, $8 = 0, $res$01 = 0, $res$03 = 0, sp = 0;
 sp = STACKTOP; //@line 56
 STACKTOP = STACKTOP + 16 | 0; //@line 57
 $0 = sp; //@line 58
 HEAP32[$0 >> 2] = $size; //@line 59
 $2 = HEAP32[$L + 16 >> 2] | 0; //@line 61
 $5 = $L + 8 | 0; //@line 64
 $6 = HEAP32[$5 >> 2] | 0; //@line 65
 $8 = $6; //@line 67
 do if (((HEAP32[$L + 24 >> 2] | 0) - $8 >> 4 | 0) > ($size | 0)) {
  $26 = $6; //@line 73
  $27 = $size; //@line 73
  $res$03 = 1; //@line 73
 } else {
  if ((($8 - (HEAP32[$L + 28 >> 2] | 0) >> 4) + 5 | 0) > (1e6 - $size | 0)) {
   $res$01 = 0; //@line 84
   STACKTOP = sp; //@line 85
   return $res$01 | 0; //@line 85
  }
  $21 = (_luaD_rawrunprotected($L, 18, $0) | 0) == 0; //@line 88
  if ($21) {
   $26 = HEAP32[$5 >> 2] | 0; //@line 93
   $27 = HEAP32[$0 >> 2] | 0; //@line 93
   $res$03 = $21 & 1; //@line 93
   break;
  } else {
   $res$01 = 0; //@line 96
   STACKTOP = sp; //@line 97
   return $res$01 | 0; //@line 97
  }
 } while (0);
 $23 = $2 + 4 | 0; //@line 101
 $25 = $26 + ($27 << 4) | 0; //@line 103
 if ((HEAP32[$23 >> 2] | 0) >>> 0 >= $25 >>> 0) {
  $res$01 = $res$03; //@line 106
  STACKTOP = sp; //@line 107
  return $res$01 | 0; //@line 107
 }
 HEAP32[$23 >> 2] = $25; //@line 109
 $res$01 = $res$03; //@line 110
 STACKTOP = sp; //@line 111
 return $res$01 | 0; //@line 111
}
function _lua_toboolean($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $33 = 0, $34 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 1845
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1847
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1852
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1857
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1864
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1872
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1875
  $17 = HEAP32[$1 >> 2] | 0; //@line 1876
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1881
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1883
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1889
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1893
  }
 } while (0);
 $29 = HEAP32[$$0$i + 8 >> 2] | 0; //@line 1899
 if (!$29) {
  $34 = 0; //@line 1902
  $33 = $34 & 1; //@line 1903
  STACKTOP = sp; //@line 1904
  return $33 | 0; //@line 1904
 }
 if (($29 | 0) != 1) {
  $34 = 1; //@line 1908
  $33 = $34 & 1; //@line 1909
  STACKTOP = sp; //@line 1910
  return $33 | 0; //@line 1910
 }
 $34 = (HEAP32[$$0$i >> 2] | 0) != 0; //@line 1914
 $33 = $34 & 1; //@line 1915
 STACKTOP = sp; //@line 1916
 return $33 | 0; //@line 1916
}
function _lua_tocfunction($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0 = 0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2157
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2159
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2164
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2169
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2176
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2184
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2187
  $17 = HEAP32[$1 >> 2] | 0; //@line 2188
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2193
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2195
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2201
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2205
  }
 } while (0);
 $29 = HEAP32[$$0$i + 8 >> 2] | 0; //@line 2211
 if (($29 | 0) == 22) {
  $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2214
  STACKTOP = sp; //@line 2215
  return $$0 | 0; //@line 2215
 } else if (($29 | 0) == 102) {
  $$0 = HEAP32[(HEAP32[$$0$i >> 2] | 0) + 12 >> 2] | 0; //@line 2220
  STACKTOP = sp; //@line 2221
  return $$0 | 0; //@line 2221
 } else {
  $$0 = 0; //@line 2223
  STACKTOP = sp; //@line 2224
  return $$0 | 0; //@line 2224
 }
 return 0; //@line 2226
}
function _lua_touserdata($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0 = 0, $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2233
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2235
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2240
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2245
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2252
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2260
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2263
  $17 = HEAP32[$1 >> 2] | 0; //@line 2264
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2269
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2271
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2277
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2281
  }
 } while (0);
 $30 = HEAP32[$$0$i + 8 >> 2] & 15; //@line 2288
 if (($30 | 0) == 7) {
  $$0 = (HEAP32[$$0$i >> 2] | 0) + 24 | 0; //@line 2292
  STACKTOP = sp; //@line 2293
  return $$0 | 0; //@line 2293
 } else if (($30 | 0) == 2) {
  $$0 = HEAP32[$$0$i >> 2] | 0; //@line 2296
  STACKTOP = sp; //@line 2297
  return $$0 | 0; //@line 2297
 } else {
  $$0 = 0; //@line 2299
  STACKTOP = sp; //@line 2300
  return $$0 | 0; //@line 2300
 }
 return 0; //@line 2302
}
function _lua_arith($L, $op) {
 $L = $L | 0;
 $op = $op | 0;
 var $1 = 0, $10 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $33 = 0, $34 = 0, $4 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 1349
 $1 = $L + 8 | 0; //@line 1351
 $2 = HEAP32[$1 >> 2] | 0; //@line 1352
 if (($op | 0) == 6) {
  $4 = $2 + -16 | 0; //@line 1355
  $9 = HEAP32[$4 + 4 >> 2] | 0; //@line 1360
  $10 = $2; //@line 1361
  HEAP32[$10 >> 2] = HEAP32[$4 >> 2]; //@line 1363
  HEAP32[$10 + 4 >> 2] = $9; //@line 1366
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + -8 >> 2]; //@line 1370
  $18 = (HEAP32[$1 >> 2] | 0) + 16 | 0; //@line 1372
  HEAP32[$1 >> 2] = $18; //@line 1373
  $21 = $18; //@line 1374
 } else $21 = $2; //@line 1376
 $19 = $L + 8 | 0; //@line 1378
 $20 = $21 + -32 | 0; //@line 1379
 $22 = $21 + -16 | 0; //@line 1380
 $23 = $21 + -24 | 0; //@line 1381
 if ((HEAP32[$23 >> 2] | 0) == 3) if ((HEAP32[$21 + -8 >> 2] | 0) == 3) {
  HEAPF64[$20 >> 3] = +_luaO_arith($op, +HEAPF64[$20 >> 3], +HEAPF64[$22 >> 3]); //@line 1392
  HEAP32[$23 >> 2] = 3; //@line 1393
  $33 = HEAP32[$19 >> 2] | 0; //@line 1394
  $34 = $33 + -16 | 0; //@line 1395
  HEAP32[$19 >> 2] = $34; //@line 1396
  STACKTOP = sp; //@line 1397
  return;
 }
 _luaV_arith($L, $20, $20, $22, $op + 6 | 0); //@line 1401
 $33 = HEAP32[$19 >> 2] | 0; //@line 1402
 $34 = $33 + -16 | 0; //@line 1403
 HEAP32[$19 >> 2] = $34; //@line 1404
 STACKTOP = sp; //@line 1405
 return;
}
function _markmt($g) {
 $g = $g | 0;
 var $1 = 0, $15 = 0, $22 = 0, $29 = 0, $36 = 0, $43 = 0, $50 = 0, $57 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 1369
 $1 = HEAP32[$g + 252 >> 2] | 0; //@line 1371
 if ($1) if (HEAP8[$1 + 5 >> 0] & 3) _reallymarkobject($g, $1); //@line 1379
 $8 = HEAP32[$g + 256 >> 2] | 0; //@line 1383
 if ($8) if (HEAP8[$8 + 5 >> 0] & 3) _reallymarkobject($g, $8); //@line 1391
 $15 = HEAP32[$g + 260 >> 2] | 0; //@line 1395
 if ($15) if (HEAP8[$15 + 5 >> 0] & 3) _reallymarkobject($g, $15); //@line 1403
 $22 = HEAP32[$g + 264 >> 2] | 0; //@line 1407
 if ($22) if (HEAP8[$22 + 5 >> 0] & 3) _reallymarkobject($g, $22); //@line 1415
 $29 = HEAP32[$g + 268 >> 2] | 0; //@line 1419
 if ($29) if (HEAP8[$29 + 5 >> 0] & 3) _reallymarkobject($g, $29); //@line 1427
 $36 = HEAP32[$g + 272 >> 2] | 0; //@line 1431
 if ($36) if (HEAP8[$36 + 5 >> 0] & 3) _reallymarkobject($g, $36); //@line 1439
 $43 = HEAP32[$g + 276 >> 2] | 0; //@line 1443
 if ($43) if (HEAP8[$43 + 5 >> 0] & 3) _reallymarkobject($g, $43); //@line 1451
 $50 = HEAP32[$g + 280 >> 2] | 0; //@line 1455
 if ($50) if (HEAP8[$50 + 5 >> 0] & 3) _reallymarkobject($g, $50); //@line 1463
 $57 = HEAP32[$g + 284 >> 2] | 0; //@line 1467
 if (!$57) {
  STACKTOP = sp; //@line 1470
  return;
 }
 if (!(HEAP8[$57 + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 1477
  return;
 }
 _reallymarkobject($g, $57); //@line 1479
 STACKTOP = sp; //@line 1480
 return;
}
function _skipcomment($lf, $cp) {
 $lf = $lf | 0;
 $cp = $cp | 0;
 var $$0 = 0, $$0$i = 0, $0 = 0, $18 = 0, $2 = 0, $9 = 0, $p$0$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 6784
 HEAP32[$lf >> 2] = 0; //@line 6785
 $0 = $lf + 4 | 0; //@line 6786
 $p$0$i = 800; //@line 6787
 while (1) {
  $2 = _getc(HEAP32[$0 >> 2] | 0) | 0; //@line 6790
  if (($2 | 0) == -1) {
   label = 3; //@line 6793
   break;
  }
  if (($2 | 0) != (HEAPU8[$p$0$i >> 0] | 0)) {
   $$0$i = $2; //@line 6801
   break;
  }
  $p$0$i = $p$0$i + 1 | 0; //@line 6796
  $9 = HEAP32[$lf >> 2] | 0; //@line 6805
  HEAP32[$lf >> 2] = $9 + 1; //@line 6807
  HEAP8[$lf + $9 + 8 >> 0] = $2; //@line 6809
  if (!(HEAP8[$p$0$i >> 0] | 0)) {
   label = 6; //@line 6813
   break;
  }
 }
 if ((label | 0) == 3) {
  HEAP32[$cp >> 2] = -1; //@line 6820
  $$0 = 0; //@line 6821
  STACKTOP = sp; //@line 6822
  return $$0 | 0; //@line 6822
 } else if ((label | 0) == 6) {
  HEAP32[$lf >> 2] = 0; //@line 6825
  $$0$i = _getc(HEAP32[$0 >> 2] | 0) | 0; //@line 6828
 }
 HEAP32[$cp >> 2] = $$0$i; //@line 6830
 if (($$0$i | 0) != 35) {
  $$0 = 0; //@line 6833
  STACKTOP = sp; //@line 6834
  return $$0 | 0; //@line 6834
 }
 do $18 = _getc(HEAP32[$0 >> 2] | 0) | 0; //@line 6838
 while (!(($18 | 0) == 10 | ($18 | 0) == -1));
 HEAP32[$cp >> 2] = _getc(HEAP32[$0 >> 2] | 0) | 0; //@line 6845
 $$0 = 1; //@line 6846
 STACKTOP = sp; //@line 6847
 return $$0 | 0; //@line 6847
}
function _luaH_getint($t, $key) {
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $0 = 0, $12 = 0, $14 = 0, $34 = 0, $7 = 0.0, $i$1$i = 0, $n$0 = 0, $u$sroa$0$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 17426
 STACKTOP = STACKTOP + 16 | 0; //@line 17427
 $u$sroa$0$i = sp; //@line 17428
 $0 = $key + -1 | 0; //@line 17429
 if ($0 >>> 0 < (HEAP32[$t + 28 >> 2] | 0) >>> 0) {
  $$0 = (HEAP32[$t + 12 >> 2] | 0) + ($0 << 4) | 0; //@line 17437
  STACKTOP = sp; //@line 17438
  return $$0 | 0; //@line 17438
 }
 $7 = +($key | 0); //@line 17440
 HEAPF64[$u$sroa$0$i >> 3] = $7 + 1.0; //@line 17442
 $12 = (HEAP32[$u$sroa$0$i + 4 >> 2] | 0) + (HEAP32[$u$sroa$0$i >> 2] | 0) | 0; //@line 17446
 if (($12 | 0) < 0) {
  $14 = 0 - $12 | 0; //@line 17449
  $i$1$i = ($12 | 0) == ($14 | 0) ? 0 : $14; //@line 17452
 } else $i$1$i = $12; //@line 17454
 $n$0 = (HEAP32[$t + 16 >> 2] | 0) + ((($i$1$i | 0) % ((1 << (HEAPU8[$t + 7 >> 0] | 0)) + -1 | 1 | 0) | 0) << 5) | 0; //@line 17466
 while (1) {
  if ((HEAP32[$n$0 + 24 >> 2] | 0) == 3) if (+HEAPF64[$n$0 + 16 >> 3] == $7) break;
  $34 = HEAP32[$n$0 + 28 >> 2] | 0; //@line 17480
  if (!$34) {
   $$0 = 8048; //@line 17483
   label = 10; //@line 17484
   break;
  } else $n$0 = $34; //@line 17487
 }
 if ((label | 0) == 10) {
  STACKTOP = sp; //@line 17491
  return $$0 | 0; //@line 17491
 }
 $$0 = $n$0; //@line 17493
 STACKTOP = sp; //@line 17494
 return $$0 | 0; //@line 17494
}
function _lua_getfield($L, $idx, $k) {
 $L = $L | 0;
 $idx = $idx | 0;
 $k = $k | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $30 = 0, $36 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2938
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2940
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2945
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2950
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2957
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2965
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2968
  $17 = HEAP32[$1 >> 2] | 0; //@line 2969
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2974
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2976
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2982
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2986
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 2991
 $29 = HEAP32[$28 >> 2] | 0; //@line 2992
 $30 = _luaS_new($L, $k) | 0; //@line 2993
 HEAP32[$29 >> 2] = $30; //@line 2994
 HEAP32[$29 + 8 >> 2] = HEAPU8[$30 + 4 >> 0] | 0 | 64; //@line 3000
 $36 = HEAP32[$28 >> 2] | 0; //@line 3001
 HEAP32[$28 >> 2] = $36 + 16; //@line 3003
 _luaV_gettable($L, $$0$i, $36, $36); //@line 3004
 STACKTOP = sp; //@line 3005
 return;
}
function _lua_pushvalue($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $30 = 0, $35 = 0, $36 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 768
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 770
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 775
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 780
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 787
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 795
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 798
  $17 = HEAP32[$1 >> 2] | 0; //@line 799
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 804
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 806
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 812
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 816
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 821
 $29 = HEAP32[$28 >> 2] | 0; //@line 822
 $30 = $$0$i; //@line 823
 $35 = HEAP32[$30 + 4 >> 2] | 0; //@line 828
 $36 = $29; //@line 829
 HEAP32[$36 >> 2] = HEAP32[$30 >> 2]; //@line 831
 HEAP32[$36 + 4 >> 2] = $35; //@line 834
 HEAP32[$29 + 8 >> 2] = HEAP32[$$0$i + 8 >> 2]; //@line 838
 HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + 16; //@line 841
 STACKTOP = sp; //@line 842
 return;
}
function _lua_yieldk($L, $nresults, $ctx, $k) {
 $L = $L | 0;
 $nresults = $nresults | 0;
 $ctx = $ctx | 0;
 $k = $k | 0;
 var $$sum = 0, $1 = 0, $25 = 0, $26 = 0, $27 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 17178
 STACKTOP = STACKTOP + 16 | 0; //@line 17179
 $vararg_buffer1 = sp; //@line 17180
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 17182
 if (HEAP16[$L + 36 >> 1] | 0) if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 172 >> 2] | 0) == ($L | 0)) _luaG_runerror($L, 4352, $vararg_buffer1); //@line 17193
 else _luaG_runerror($L, 4304, $vararg_buffer1); //@line 17196
 HEAP8[$L + 6 >> 0] = 1; //@line 17201
 HEAP32[$1 + 20 >> 2] = (HEAP32[$1 >> 2] | 0) - (HEAP32[$L + 28 >> 2] | 0); //@line 17209
 if (HEAP8[$1 + 18 >> 0] & 1) {
  STACKTOP = sp; //@line 17215
  return 0; //@line 17215
 }
 HEAP32[$1 + 28 >> 2] = $k; //@line 17218
 if (!$k) {
  $25 = $L + 8 | 0; //@line 17221
  $26 = HEAP32[$25 >> 2] | 0; //@line 17222
  $$sum = ~$nresults; //@line 17223
  $27 = $26 + ($$sum << 4) | 0; //@line 17224
  HEAP32[$1 >> 2] = $27; //@line 17225
  _luaD_throw($L, 1); //@line 17226
 }
 HEAP32[$1 + 24 >> 2] = $ctx; //@line 17230
 $25 = $L + 8 | 0; //@line 17231
 $26 = HEAP32[$25 >> 2] | 0; //@line 17232
 $$sum = ~$nresults; //@line 17233
 $27 = $26 + ($$sum << 4) | 0; //@line 17234
 HEAP32[$1 >> 2] = $27; //@line 17235
 _luaD_throw($L, 1); //@line 17236
 return 0; //@line 17238
}
function _db_gethook($L) {
 $L = $L | 0;
 var $$0$i = 0, $3 = 0, $4 = 0, $buff = 0, $i$0$i = 0, $i$1$i = 0, $i$2$i = 0, sp = 0;
 sp = STACKTOP; //@line 13227
 STACKTOP = STACKTOP + 16 | 0; //@line 13228
 $buff = sp; //@line 13229
 if ((_lua_type($L, 1) | 0) == 8) $$0$i = _lua_tothread($L, 1) | 0; //@line 13234
 else $$0$i = $L; //@line 13236
 $3 = _lua_gethookmask($$0$i) | 0; //@line 13238
 $4 = _lua_gethook($$0$i) | 0; //@line 13239
 if (($4 | 0) != 0 & ($4 | 0) != 20) _lua_pushlstring($L, 3808, 13) | 0; //@line 13244
 else {
  _luaL_getsubtable($L, -1001e3, 3368) | 0; //@line 13246
  _lua_pushthread($$0$i) | 0; //@line 13247
  _lua_xmove($$0$i, $L, 1); //@line 13248
  _lua_rawget($L, -2); //@line 13249
  _lua_remove($L, -2); //@line 13250
 }
 if (!($3 & 1)) $i$0$i = 0; //@line 13255
 else {
  HEAP8[$buff >> 0] = 99; //@line 13257
  $i$0$i = 1; //@line 13258
 }
 if (!($3 & 2)) $i$1$i = $i$0$i; //@line 13263
 else {
  HEAP8[$buff + $i$0$i >> 0] = 114; //@line 13267
  $i$1$i = $i$0$i + 1 | 0; //@line 13268
 }
 if (!($3 & 4)) $i$2$i = $i$1$i; //@line 13273
 else {
  HEAP8[$buff + $i$1$i >> 0] = 108; //@line 13277
  $i$2$i = $i$1$i + 1 | 0; //@line 13278
 }
 HEAP8[$buff + $i$2$i >> 0] = 0; //@line 13281
 _lua_pushstring($L, $buff) | 0; //@line 13282
 _lua_pushinteger($L, _lua_gethookcount($$0$i) | 0); //@line 13284
 STACKTOP = sp; //@line 13285
 return 3; //@line 13285
}
function _db_debug($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $buffer = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 13156
 STACKTOP = STACKTOP + 256 | 0; //@line 13157
 $vararg_buffer = sp; //@line 13158
 $buffer = sp + 4 | 0; //@line 13159
 $0 = HEAP32[_stderr >> 2] | 0; //@line 13160
 _fwrite(3824, 11, 1, $0 | 0) | 0; //@line 13161
 _fflush($0 | 0) | 0; //@line 13162
 $1 = HEAP32[_stdin >> 2] | 0; //@line 13163
 if (!(_fgets($buffer | 0, 250, $1 | 0) | 0)) {
  STACKTOP = sp; //@line 13167
  return 0; //@line 13167
 }
 while (1) {
  if (!(_strcmp($buffer, 3840) | 0)) {
   label = 7; //@line 13173
   break;
  }
  if (!(_luaL_loadbufferx($L, $buffer, _strlen($buffer | 0) | 0, 3848, 0) | 0)) {
   if (_lua_pcallk($L, 0, 0, 0, 0, 0) | 0) label = 5; //@line 13183
  } else label = 5; //@line 13186
  if ((label | 0) == 5) {
   label = 0; //@line 13189
   HEAP32[$vararg_buffer >> 2] = _lua_tolstring($L, -1, 0) | 0; //@line 13191
   _fprintf($0 | 0, 3872, $vararg_buffer | 0) | 0; //@line 13192
   _fflush($0 | 0) | 0; //@line 13193
  }
  _lua_settop($L, 0); //@line 13195
  _fwrite(3824, 11, 1, $0 | 0) | 0; //@line 13196
  _fflush($0 | 0) | 0; //@line 13197
  if (!(_fgets($buffer | 0, 250, $1 | 0) | 0)) {
   label = 7; //@line 13201
   break;
  }
 }
 if ((label | 0) == 7) {
  STACKTOP = sp; //@line 13206
  return 0; //@line 13206
 }
 return 0; //@line 13208
}
function _luaF_getlocalname($f, $local_number, $pc) {
 $f = $f | 0;
 $local_number = $local_number | 0;
 $pc = $pc | 0;
 var $$0 = 0, $$013 = 0, $$1 = 0, $1 = 0, $11 = 0, $16 = 0, $4 = 0, $i$04 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 18654
 $1 = HEAP32[$f + 60 >> 2] | 0; //@line 18656
 if (($1 | 0) <= 0) {
  $$0 = 0; //@line 18659
  STACKTOP = sp; //@line 18660
  return $$0 | 0; //@line 18660
 }
 $4 = HEAP32[$f + 24 >> 2] | 0; //@line 18663
 $$013 = $local_number; //@line 18664
 $i$04 = 0; //@line 18664
 while (1) {
  if ((HEAP32[$4 + ($i$04 * 12 | 0) + 4 >> 2] | 0) > ($pc | 0)) {
   $$0 = 0; //@line 18670
   label = 8; //@line 18671
   break;
  }
  if ((HEAP32[$4 + ($i$04 * 12 | 0) + 8 >> 2] | 0) > ($pc | 0)) {
   $11 = $$013 + -1 | 0; //@line 18678
   if (!$11) {
    label = 6; //@line 18681
    break;
   } else $$1 = $11; //@line 18684
  } else $$1 = $$013; //@line 18687
  $16 = $i$04 + 1 | 0; //@line 18689
  if (($16 | 0) < ($1 | 0)) {
   $$013 = $$1; //@line 18692
   $i$04 = $16; //@line 18692
  } else {
   $$0 = 0; //@line 18694
   label = 8; //@line 18695
   break;
  }
 }
 if ((label | 0) == 6) {
  $$0 = (HEAP32[$4 + ($i$04 * 12 | 0) >> 2] | 0) + 16 | 0; //@line 18703
  STACKTOP = sp; //@line 18704
  return $$0 | 0; //@line 18704
 } else if ((label | 0) == 8) {
  STACKTOP = sp; //@line 18707
  return $$0 | 0; //@line 18707
 }
 return 0; //@line 18709
}
function _push_onecapture($ms, $i, $s, $e) {
 $ms = $ms | 0;
 $i = $i | 0;
 $s = $s | 0;
 $e = $e | 0;
 var $10 = 0, $12 = 0, $19 = 0, $21 = 0, $28 = 0, $29 = 0, $5 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 16044
 STACKTOP = STACKTOP + 16 | 0; //@line 16045
 $vararg_buffer1 = sp; //@line 16046
 if ((HEAP32[$ms + 20 >> 2] | 0) <= ($i | 0)) {
  $5 = HEAP32[$ms + 16 >> 2] | 0; //@line 16053
  if (!$i) {
   _lua_pushlstring($5, $s, $e - $s | 0) | 0; //@line 16058
   STACKTOP = sp; //@line 16059
   return;
  } else {
   _luaL_error($5, 10080, $vararg_buffer1) | 0; //@line 16061
   STACKTOP = sp; //@line 16062
   return;
  }
 }
 $10 = HEAP32[$ms + ($i << 3) + 28 >> 2] | 0; //@line 16066
 if (($10 | 0) == -1) {
  $12 = $ms + 16 | 0; //@line 16069
  _luaL_error(HEAP32[$12 >> 2] | 0, 10104, $vararg_buffer1) | 0; //@line 16071
  $28 = HEAP32[$12 >> 2] | 0; //@line 16075
  $29 = HEAP32[$ms + ($i << 3) + 24 >> 2] | 0; //@line 16075
 } else {
  $19 = HEAP32[$ms + 16 >> 2] | 0; //@line 16079
  $21 = HEAP32[$ms + ($i << 3) + 24 >> 2] | 0; //@line 16081
  if (($10 | 0) == -2) {
   _lua_pushinteger($19, $21 + 1 - (HEAP32[$ms + 4 >> 2] | 0) | 0); //@line 16089
   STACKTOP = sp; //@line 16090
   return;
  } else {
   $28 = $19; //@line 16092
   $29 = $21; //@line 16092
  }
 }
 _lua_pushlstring($28, $29, $10) | 0; //@line 16095
 STACKTOP = sp; //@line 16096
 return;
}
function _luaG_runerror($L, $fmt, $varargs) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $10 = 0, $12 = 0, $2 = 0, $24 = 0, $28 = 0, $argp = 0, $buff$i = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 15101
 STACKTOP = STACKTOP + 96 | 0; //@line 15102
 $vararg_buffer = sp; //@line 15103
 $buff$i = sp + 32 | 0; //@line 15104
 $argp = sp + 16 | 0; //@line 15105
 HEAP32[$argp >> 2] = $varargs; //@line 15106
 $0 = _luaO_pushvfstring($L, $fmt, $argp) | 0; //@line 15107
 $2 = HEAP32[$L + 16 >> 2] | 0; //@line 15109
 if (!(HEAP8[$2 + 18 >> 0] & 1)) _luaG_errormsg($L); //@line 15115
 $10 = HEAP32[(HEAP32[HEAP32[$2 >> 2] >> 2] | 0) + 12 >> 2] | 0; //@line 15121
 $12 = HEAP32[$10 + 20 >> 2] | 0; //@line 15123
 if (!$12) $28 = 0; //@line 15126
 else $28 = HEAP32[$12 + (((HEAP32[$2 + 28 >> 2] | 0) - (HEAP32[$10 + 12 >> 2] | 0) >> 2) + -1 << 2) >> 2] | 0; //@line 15139
 $24 = HEAP32[$10 + 36 >> 2] | 0; //@line 15142
 if (!$24) {
  HEAP8[$buff$i >> 0] = 63; //@line 15145
  HEAP8[$buff$i + 1 >> 0] = 0; //@line 15147
 } else _luaO_chunkid($buff$i, $24 + 16 | 0, 60); //@line 15150
 HEAP32[$vararg_buffer >> 2] = $buff$i; //@line 15152
 HEAP32[$vararg_buffer + 4 >> 2] = $28; //@line 15154
 HEAP32[$vararg_buffer + 8 >> 2] = $0; //@line 15156
 _luaO_pushfstring($L, 4064, $vararg_buffer) | 0; //@line 15157
 _luaG_errormsg($L); //@line 15158
}
function _inclinenumber($ls) {
 $ls = $ls | 0;
 var $0 = 0, $1 = 0, $12 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $6 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 5162
 $0 = HEAP32[$ls >> 2] | 0; //@line 5163
 $1 = $ls + 56 | 0; //@line 5164
 $2 = HEAP32[$1 >> 2] | 0; //@line 5165
 $3 = HEAP32[$2 >> 2] | 0; //@line 5166
 HEAP32[$2 >> 2] = $3 + -1; //@line 5168
 if (!$3) $12 = _luaZ_fill($2) | 0; //@line 5172
 else {
  $6 = $2 + 4 | 0; //@line 5174
  $7 = HEAP32[$6 >> 2] | 0; //@line 5175
  HEAP32[$6 >> 2] = $7 + 1; //@line 5177
  $12 = HEAPU8[$7 >> 0] | 0; //@line 5180
 }
 HEAP32[$ls >> 2] = $12; //@line 5182
 if (($12 | 0) == 13 | ($12 | 0) == 10) if (($12 | 0) != ($0 | 0)) {
  $14 = HEAP32[$1 >> 2] | 0; //@line 5186
  $15 = HEAP32[$14 >> 2] | 0; //@line 5187
  HEAP32[$14 >> 2] = $15 + -1; //@line 5189
  if (!$15) $24 = _luaZ_fill($14) | 0; //@line 5193
 else {
   $18 = $14 + 4 | 0; //@line 5195
   $19 = HEAP32[$18 >> 2] | 0; //@line 5196
   HEAP32[$18 >> 2] = $19 + 1; //@line 5198
   $24 = HEAPU8[$19 >> 0] | 0; //@line 5201
  }
  HEAP32[$ls >> 2] = $24; //@line 5203
 }
 $25 = $ls + 4 | 0; //@line 5206
 $26 = HEAP32[$25 >> 2] | 0; //@line 5207
 HEAP32[$25 >> 2] = $26 + 1; //@line 5209
 if (($26 | 0) > 2147483643) _luaX_syntaxerror($ls, 6080); //@line 5212
 else {
  STACKTOP = sp; //@line 5215
  return;
 }
}
function _luaL_findtable($L, $idx, $fname, $szhint) {
 $L = $L | 0;
 $idx = $idx | 0;
 $fname = $fname | 0;
 $szhint = $szhint | 0;
 var $$0 = 0, $$01 = 0, $1 = 0, $7 = 0, $e$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 7081
 if (!$idx) $$01 = $fname; //@line 7084
 else {
  _lua_pushvalue($L, $idx); //@line 7086
  $$01 = $fname; //@line 7087
 }
 while (1) {
  $1 = _strchr($$01, 46) | 0; //@line 7090
  if (!$1) $e$0 = $$01 + (_strlen($$01 | 0) | 0) | 0; //@line 7095
 else $e$0 = $1; //@line 7097
  $7 = $e$0 - $$01 | 0; //@line 7101
  _lua_pushlstring($L, $$01, $7) | 0; //@line 7102
  _lua_rawget($L, -2); //@line 7103
  if (!(_lua_type($L, -1) | 0)) {
   _lua_settop($L, -2); //@line 7107
   _lua_createtable($L, 0, (HEAP8[$e$0 >> 0] | 0) == 46 ? 1 : $szhint); //@line 7111
   _lua_pushlstring($L, $$01, $7) | 0; //@line 7112
   _lua_pushvalue($L, -2); //@line 7113
   _lua_settable($L, -4); //@line 7114
  } else if ((_lua_type($L, -1) | 0) != 5) break;
  _lua_remove($L, -2); //@line 7122
  if ((HEAP8[$e$0 >> 0] | 0) == 46) $$01 = $e$0 + 1 | 0; //@line 7127
 else {
   $$0 = 0; //@line 7129
   label = 10; //@line 7130
   break;
  }
 }
 if ((label | 0) == 10) {
  STACKTOP = sp; //@line 7135
  return $$0 | 0; //@line 7135
 }
 _lua_settop($L, -3); //@line 7137
 $$0 = $$01; //@line 7138
 STACKTOP = sp; //@line 7139
 return $$0 | 0; //@line 7139
}
function _db_getlocal($L) {
 $L = $L | 0;
 var $$0 = 0, $$0$i = 0, $14 = 0, $4 = 0, $5 = 0, $6 = 0, $ar = 0, sp = 0;
 sp = STACKTOP; //@line 13451
 STACKTOP = STACKTOP + 112 | 0; //@line 13452
 $ar = sp; //@line 13453
 if ((_lua_type($L, 1) | 0) == 8) {
  $$0$i = _lua_tothread($L, 1) | 0; //@line 13458
  $4 = 1; //@line 13458
 } else {
  $$0$i = $L; //@line 13460
  $4 = 0; //@line 13460
 }
 $5 = _luaL_checkinteger($L, $4 | 2) | 0; //@line 13463
 $6 = $4 + 1 | 0; //@line 13464
 if ((_lua_type($L, $6) | 0) == 6) {
  _lua_pushvalue($L, $6); //@line 13468
  _lua_pushstring($L, _lua_getlocal($L, 0, $5) | 0) | 0; //@line 13470
  $$0 = 1; //@line 13471
  STACKTOP = sp; //@line 13472
  return $$0 | 0; //@line 13472
 }
 if (!(_lua_getstack($$0$i, _luaL_checkinteger($L, $6) | 0, $ar) | 0)) {
  $$0 = _luaL_argerror($L, $6, 3344) | 0; //@line 13479
  STACKTOP = sp; //@line 13480
  return $$0 | 0; //@line 13480
 }
 $14 = _lua_getlocal($$0$i, $ar, $5) | 0; //@line 13482
 if (!$14) {
  _lua_pushnil($L); //@line 13485
  $$0 = 1; //@line 13486
  STACKTOP = sp; //@line 13487
  return $$0 | 0; //@line 13487
 } else {
  _lua_xmove($$0$i, $L, 1); //@line 13489
  _lua_pushstring($L, $14) | 0; //@line 13490
  _lua_pushvalue($L, -2); //@line 13491
  $$0 = 2; //@line 13492
  STACKTOP = sp; //@line 13493
  return $$0 | 0; //@line 13493
 }
 return 0; //@line 13495
}
function _lua_isnumber($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $33 = 0, $34 = 0, $4 = 0, $n = 0, sp = 0;
 sp = STACKTOP; //@line 996
 STACKTOP = STACKTOP + 16 | 0; //@line 997
 $n = sp; //@line 998
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1000
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1005
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1010
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1017
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1025
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1028
  $17 = HEAP32[$1 >> 2] | 0; //@line 1029
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1034
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1036
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1042
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1046
  }
 } while (0);
 if ((HEAP32[$$0$i + 8 >> 2] | 0) == 3) {
  $34 = 1; //@line 1055
  $33 = $34 & 1; //@line 1056
  STACKTOP = sp; //@line 1057
  return $33 | 0; //@line 1057
 }
 $34 = (_luaV_tonumber($$0$i, $n) | 0) != 0; //@line 1061
 $33 = $34 & 1; //@line 1062
 STACKTOP = sp; //@line 1063
 return $33 | 0; //@line 1063
}
function _luaD_call($L, $func, $nResults, $allowyield) {
 $L = $L | 0;
 $func = $func | 0;
 $nResults = $nResults | 0;
 $allowyield = $allowyield | 0;
 var $0 = 0, $12 = 0, $15 = 0, $16 = 0, $2 = 0, $6 = 0, $7 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 16494
 STACKTOP = STACKTOP + 16 | 0; //@line 16495
 $vararg_buffer = sp; //@line 16496
 $0 = $L + 38 | 0; //@line 16497
 $2 = (HEAP16[$0 >> 1] | 0) + 1 << 16 >> 16; //@line 16499
 HEAP16[$0 >> 1] = $2; //@line 16500
 if (($2 & 65535) > 199) {
  if ($2 << 16 >> 16 == 200) _luaG_runerror($L, 4280, $vararg_buffer); //@line 16505
  if (($2 & 65535) > 224) _luaD_throw($L, 6); //@line 16510
 }
 $6 = ($allowyield | 0) != 0; //@line 16514
 if (!$6) {
  $7 = $L + 36 | 0; //@line 16516
  HEAP16[$7 >> 1] = (HEAP16[$7 >> 1] | 0) + 1 << 16 >> 16; //@line 16519
 }
 if (!(_luaD_precall($L, $func, $nResults) | 0)) _luaV_execute($L); //@line 16524
 if ($6) {
  $15 = HEAP16[$0 >> 1] | 0; //@line 16527
  $16 = $15 + -1 << 16 >> 16; //@line 16528
  HEAP16[$0 >> 1] = $16; //@line 16529
  STACKTOP = sp; //@line 16530
  return;
 }
 $12 = $L + 36 | 0; //@line 16532
 HEAP16[$12 >> 1] = (HEAP16[$12 >> 1] | 0) + -1 << 16 >> 16; //@line 16535
 $15 = HEAP16[$0 >> 1] | 0; //@line 16536
 $16 = $15 + -1 << 16 >> 16; //@line 16537
 HEAP16[$0 >> 1] = $16; //@line 16538
 STACKTOP = sp; //@line 16539
 return;
}
function _db_upvaluejoin($L) {
 $L = $L | 0;
 var $0 = 0, $6 = 0, $ar$i1 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 13536
 STACKTOP = STACKTOP + 112 | 0; //@line 13537
 $ar$i1 = sp; //@line 13538
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 13539
 _luaL_checktype($L, 1, 6); //@line 13540
 _lua_pushvalue($L, 1); //@line 13541
 _lua_getinfo($L, 3512, $ar$i1) | 0; //@line 13542
 if (($0 | 0) > 0) {
  if (($0 | 0) > (HEAPU8[$ar$i1 + 32 >> 0] | 0 | 0)) label = 3; //@line 13550
 } else label = 3; //@line 13553
 if ((label | 0) == 3) _luaL_argerror($L, 2, 3520) | 0; //@line 13556
 $6 = _luaL_checkinteger($L, 4) | 0; //@line 13558
 _luaL_checktype($L, 3, 6); //@line 13559
 _lua_pushvalue($L, 3); //@line 13560
 _lua_getinfo($L, 3512, $ar$i1) | 0; //@line 13561
 if (($6 | 0) > 0) {
  if (($6 | 0) > (HEAPU8[$ar$i1 + 32 >> 0] | 0 | 0)) label = 6; //@line 13569
 } else label = 6; //@line 13572
 if ((label | 0) == 6) _luaL_argerror($L, 4, 3520) | 0; //@line 13575
 if (_lua_iscfunction($L, 1) | 0) _luaL_argerror($L, 1, 3544) | 0; //@line 13580
 if (!(_lua_iscfunction($L, 3) | 0)) {
  _lua_upvaluejoin($L, 1, $0, 3, $6); //@line 13585
  STACKTOP = sp; //@line 13586
  return 0; //@line 13586
 }
 _luaL_argerror($L, 3, 3544) | 0; //@line 13588
 _lua_upvaluejoin($L, 1, $0, 3, $6); //@line 13589
 STACKTOP = sp; //@line 13590
 return 0; //@line 13590
}
function _match_class($c, $cl) {
 $c = $c | 0;
 $cl = $cl | 0;
 var $$0 = 0, $res$0 = 0, sp = 0;
 sp = STACKTOP; //@line 16103
 do switch (_tolower($cl) | 0) {
 case 108:
  {
   $res$0 = _islower($c) | 0; //@line 16109
   break;
  }
 case 115:
  {
   $res$0 = _isspace($c) | 0; //@line 16114
   break;
  }
 case 99:
  {
   $res$0 = _iscntrl($c) | 0; //@line 16119
   break;
  }
 case 120:
  {
   $res$0 = _isxdigit($c) | 0; //@line 16124
   break;
  }
 case 100:
  {
   $res$0 = ($c + -48 | 0) >>> 0 < 10 & 1; //@line 16131
   break;
  }
 case 117:
  {
   $res$0 = _isupper($c) | 0; //@line 16136
   break;
  }
 case 97:
  {
   $res$0 = _isalpha($c) | 0; //@line 16141
   break;
  }
 case 122:
  {
   $res$0 = ($c | 0) == 0 & 1; //@line 16147
   break;
  }
 case 119:
  {
   $res$0 = _isalnum($c) | 0; //@line 16152
   break;
  }
 case 103:
  {
   $res$0 = _isgraph($c) | 0; //@line 16157
   break;
  }
 case 112:
  {
   $res$0 = _ispunct($c) | 0; //@line 16162
   break;
  }
 default:
  {
   $$0 = ($cl | 0) == ($c | 0) & 1; //@line 16168
   STACKTOP = sp; //@line 16169
   return $$0 | 0; //@line 16169
  }
 } while (0);
 if (_islower($cl) | 0) {
  $$0 = $res$0; //@line 16176
  STACKTOP = sp; //@line 16177
  return $$0 | 0; //@line 16177
 }
 $$0 = ($res$0 | 0) == 0 & 1; //@line 16181
 STACKTOP = sp; //@line 16182
 return $$0 | 0; //@line 16182
}
function _g_iofile($L, $f, $mode) {
 $L = $L | 0;
 $f = $f | 0;
 $mode = $mode | 0;
 var $10 = 0, $2 = 0, $4 = 0, $5 = 0, $6 = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP; //@line 2788
 STACKTOP = STACKTOP + 16 | 0; //@line 2789
 $vararg_buffer2 = sp; //@line 2790
 if ((_lua_type($L, 1) | 0) < 1) {
  _lua_getfield($L, -1001e3, $f); //@line 2794
  STACKTOP = sp; //@line 2795
  return;
 }
 $2 = _lua_tolstring($L, 1, 0) | 0; //@line 2797
 if (!$2) {
  if (!(HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) + 4 >> 2] | 0)) _luaL_error($L, 5120, $vararg_buffer2) | 0; //@line 2805
  _lua_pushvalue($L, 1); //@line 2807
 } else {
  $4 = _lua_newuserdata($L, 8) | 0; //@line 2809
  $5 = $4 + 4 | 0; //@line 2810
  HEAP32[$5 >> 2] = 0; //@line 2811
  _luaL_setmetatable($L, 4872); //@line 2812
  HEAP32[$4 >> 2] = 0; //@line 2813
  HEAP32[$5 >> 2] = 175; //@line 2814
  $6 = _fopen($2 | 0, $mode | 0) | 0; //@line 2815
  HEAP32[$4 >> 2] = $6; //@line 2816
  if (!$6) {
   $10 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0; //@line 2821
   HEAP32[$vararg_buffer2 >> 2] = $2; //@line 2822
   HEAP32[$vararg_buffer2 + 4 >> 2] = $10; //@line 2824
   _luaL_error($L, 5560, $vararg_buffer2) | 0; //@line 2825
  }
 }
 _lua_setfield($L, -1001e3, $f); //@line 2828
 _lua_getfield($L, -1001e3, $f); //@line 2829
 STACKTOP = sp; //@line 2830
 return;
}
function _save($ls, $c) {
 $ls = $ls | 0;
 $c = $c | 0;
 var $1 = 0, $12 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $5 = 0, $6 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 5768
 $1 = HEAP32[$ls + 60 >> 2] | 0; //@line 5770
 $2 = $1 + 4 | 0; //@line 5771
 $3 = HEAP32[$2 >> 2] | 0; //@line 5772
 $5 = $1 + 8 | 0; //@line 5774
 $6 = HEAP32[$5 >> 2] | 0; //@line 5775
 if (($3 + 1 | 0) >>> 0 <= $6 >>> 0) {
  $17 = $3; //@line 5779
  $19 = HEAP32[$1 >> 2] | 0; //@line 5779
  $15 = $c & 255; //@line 5780
  $16 = $17 + 1 | 0; //@line 5781
  HEAP32[$2 >> 2] = $16; //@line 5782
  $18 = $19 + $17 | 0; //@line 5783
  HEAP8[$18 >> 0] = $15; //@line 5784
  STACKTOP = sp; //@line 5785
  return;
 }
 if ($6 >>> 0 > 2147483645) _lexerror($ls, 5888, 0); //@line 5789
 $9 = $6 << 1; //@line 5792
 $12 = HEAP32[$ls + 52 >> 2] | 0; //@line 5795
 if (($9 | 0) == -2) _luaM_toobig($12); //@line 5797
 $14 = _luaM_realloc_($12, HEAP32[$1 >> 2] | 0, $6, $9) | 0; //@line 5801
 HEAP32[$1 >> 2] = $14; //@line 5802
 HEAP32[$5 >> 2] = $9; //@line 5803
 $17 = HEAP32[$2 >> 2] | 0; //@line 5805
 $19 = $14; //@line 5805
 $15 = $c & 255; //@line 5806
 $16 = $17 + 1 | 0; //@line 5807
 HEAP32[$2 >> 2] = $16; //@line 5808
 $18 = $19 + $17 | 0; //@line 5809
 HEAP8[$18 >> 0] = $15; //@line 5810
 STACKTOP = sp; //@line 5811
 return;
}
function _luaL_checkversion_($L, $ver) {
 $L = $L | 0;
 $ver = +$ver;
 var $0 = 0, $3 = 0.0, $vararg_buffer4 = 0, $vararg_ptr3 = 0, sp = 0;
 sp = STACKTOP; //@line 7193
 STACKTOP = STACKTOP + 16 | 0; //@line 7194
 $vararg_buffer4 = sp; //@line 7195
 $0 = _lua_version($L) | 0; //@line 7196
 if (($0 | 0) == (_lua_version(0) | 0)) {
  $3 = +HEAPF64[$0 >> 3]; //@line 7200
  if ($3 != $ver) {
   HEAPF64[tempDoublePtr >> 3] = $ver; //@line 7203
   HEAP32[$vararg_buffer4 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 7203
   HEAP32[$vararg_buffer4 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 7203
   $vararg_ptr3 = $vararg_buffer4 + 8 | 0; //@line 7204
   HEAPF64[tempDoublePtr >> 3] = $3; //@line 7205
   HEAP32[$vararg_ptr3 >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 7205
   HEAP32[$vararg_ptr3 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 7205
   _luaL_error($L, 616, $vararg_buffer4) | 0; //@line 7206
  }
 } else _luaL_error($L, 584, $vararg_buffer4) | 0; //@line 7209
 _lua_pushnumber($L, -4660.0); //@line 7211
 if ((_lua_tointegerx($L, -1, 0) | 0) == -4660) if ((_lua_tounsignedx($L, -1, 0) | 0) == -4660) {
  _lua_settop($L, -2); //@line 7218
  STACKTOP = sp; //@line 7219
  return;
 }
 _luaL_error($L, 672, $vararg_buffer4) | 0; //@line 7222
 _lua_settop($L, -2); //@line 7223
 STACKTOP = sp; //@line 7224
 return;
}
function _luaK_jump($fs) {
 $fs = $fs | 0;
 var $0 = 0, $1 = 0, $11 = 0, $13 = 0, $2 = 0, $22 = 0, $5 = 0, $6 = 0, $8 = 0, $fs$idx$val$idx$val$i = 0, $list$0$i = 0, sp = 0;
 sp = STACKTOP; //@line 8692
 $0 = $fs + 28 | 0; //@line 8693
 $1 = HEAP32[$0 >> 2] | 0; //@line 8694
 HEAP32[$0 >> 2] = -1; //@line 8695
 $2 = _luaK_code($fs, 2147450903) | 0; //@line 8696
 if (($1 | 0) == -1) {
  $22 = $2; //@line 8699
  STACKTOP = sp; //@line 8700
  return $22 | 0; //@line 8700
 }
 if (($2 | 0) == -1) {
  $22 = $1; //@line 8704
  STACKTOP = sp; //@line 8705
  return $22 | 0; //@line 8705
 }
 $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 8709
 $list$0$i = $2; //@line 8710
 while (1) {
  $5 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 8712
  $6 = HEAP32[$5 >> 2] | 0; //@line 8713
  $8 = ($6 >>> 14) + -131071 | 0; //@line 8715
  if (($8 | 0) == -1) break;
  $11 = $list$0$i + 1 + $8 | 0; //@line 8721
  if (($11 | 0) == -1) break; else $list$0$i = $11; //@line 8726
 }
 $13 = $1 + ~$list$0$i | 0; //@line 8730
 if (((($13 | 0) > -1 ? $13 : 0 - $13 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 8738
 HEAP32[$5 >> 2] = ($13 << 14) + 2147467264 | $6 & 16383; //@line 8745
 $22 = $2; //@line 8746
 STACKTOP = sp; //@line 8747
 return $22 | 0; //@line 8747
}
function _luaB_load($L) {
 $L = $L | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, $3 = 0, $6 = 0, $9 = 0, $l = 0, $status$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7792
 STACKTOP = STACKTOP + 16 | 0; //@line 7793
 $l = sp; //@line 7794
 $0 = _lua_tolstring($L, 1, $l) | 0; //@line 7795
 $1 = _luaL_optlstring($L, 3, 1656, 0) | 0; //@line 7796
 $3 = (_lua_type($L, 4) | 0) != -1; //@line 7798
 if (!$0) {
  $9 = _luaL_optlstring($L, 2, 1664, 0) | 0; //@line 7802
  _luaL_checktype($L, 1, 6); //@line 7803
  _lua_settop($L, 5); //@line 7804
  $status$0 = _lua_load($L, 21, 0, $9, $1) | 0; //@line 7806
 } else {
  $6 = _luaL_optlstring($L, 2, $0, 0) | 0; //@line 7808
  $status$0 = _luaL_loadbufferx($L, $0, HEAP32[$l >> 2] | 0, $6, $1) | 0; //@line 7811
 }
 if ($status$0) {
  _lua_pushnil($L); //@line 7815
  _lua_insert($L, -2); //@line 7816
  $$0$i = 2; //@line 7817
  STACKTOP = sp; //@line 7818
  return $$0$i | 0; //@line 7818
 }
 if (!$3) {
  $$0$i = 1; //@line 7821
  STACKTOP = sp; //@line 7822
  return $$0$i | 0; //@line 7822
 }
 _lua_pushvalue($L, $3 ? 4 : 0); //@line 7824
 if (_lua_setupvalue($L, -2, 1) | 0) {
  $$0$i = 1; //@line 7828
  STACKTOP = sp; //@line 7829
  return $$0$i | 0; //@line 7829
 }
 _lua_settop($L, -2); //@line 7831
 $$0$i = 1; //@line 7832
 STACKTOP = sp; //@line 7833
 return $$0$i | 0; //@line 7833
}
function _tinsert($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $i$01 = 0, $pos$0 = 0, $vararg_buffer = 0, label = 0, sp = 0, $i$01$looptemp = 0;
 sp = STACKTOP; //@line 18136
 STACKTOP = STACKTOP + 16 | 0; //@line 18137
 $vararg_buffer = sp; //@line 18138
 _luaL_checktype($L, 1, 5); //@line 18139
 $0 = _luaL_len($L, 1) | 0; //@line 18140
 $1 = $0 + 1 | 0; //@line 18141
 $2 = _lua_gettop($L) | 0; //@line 18142
 if (($2 | 0) == 2) $pos$0 = $1; //@line 18144
 else if (($2 | 0) == 3) label = 2; //@line 18146
 else {
  $$0 = _luaL_error($L, 11176, $vararg_buffer) | 0; //@line 18149
  STACKTOP = sp; //@line 18150
  return $$0 | 0; //@line 18150
 }
 if ((label | 0) == 2) {
  $3 = _luaL_checkinteger($L, 2) | 0; //@line 18153
  if (($3 | 0) < 1 | ($3 | 0) > ($1 | 0)) _luaL_argerror($L, 2, 11112) | 0; //@line 18158
  if (($0 | 0) < ($3 | 0)) $pos$0 = $3; //@line 18162
 else {
   $i$01 = $1; //@line 18164
   do {
    $i$01$looptemp = $i$01;
    $i$01 = $i$01 + -1 | 0; //@line 18166
    _lua_rawgeti($L, 1, $i$01); //@line 18167
    _lua_rawseti($L, 1, $i$01$looptemp); //@line 18168
   } while (($i$01 | 0) > ($3 | 0));
   $pos$0 = $3; //@line 18173
  }
 }
 _lua_rawseti($L, 1, $pos$0); //@line 18179
 $$0 = 0; //@line 18180
 STACKTOP = sp; //@line 18181
 return $$0 | 0; //@line 18181
}
function _lua_type($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $32 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 849
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 851
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 856
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 861
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 868
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 876
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 879
  $17 = HEAP32[$1 >> 2] | 0; //@line 880
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) {
   $32 = -1; //@line 885
   STACKTOP = sp; //@line 886
   return $32 | 0; //@line 886
  }
  $21 = HEAP32[$17 >> 2] | 0; //@line 888
  if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) {
   $32 = -1; //@line 894
   STACKTOP = sp; //@line 895
   return $32 | 0; //@line 895
  } else {
   $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 899
   break;
  }
 } while (0);
 if (($$0$i | 0) == 8048) {
  $32 = -1; //@line 906
  STACKTOP = sp; //@line 907
  return $32 | 0; //@line 907
 }
 $32 = HEAP32[$$0$i + 8 >> 2] & 15; //@line 912
 STACKTOP = sp; //@line 913
 return $32 | 0; //@line 913
}
function _math_random($L) {
 $L = $L | 0;
 var $$0 = 0, $10 = 0.0, $11 = 0.0, $3 = 0.0, $4 = 0, $5 = 0.0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6126
 STACKTOP = STACKTOP + 16 | 0; //@line 6127
 $vararg_buffer = sp; //@line 6128
 $3 = +((_rand() | 0) % 2147483647 | 0 | 0) / 2147483647.0; //@line 6132
 $4 = _lua_gettop($L) | 0; //@line 6133
 if (!$4) {
  _lua_pushnumber($L, $3); //@line 6135
  $$0 = 1; //@line 6136
  STACKTOP = sp; //@line 6137
  return $$0 | 0; //@line 6137
 } else if (($4 | 0) == 2) {
  $10 = +_luaL_checknumber($L, 1); //@line 6139
  $11 = +_luaL_checknumber($L, 2); //@line 6140
  if (!($10 <= $11)) _luaL_argerror($L, 2, 6912) | 0; //@line 6143
  _lua_pushnumber($L, $10 + +Math_floor(+($3 * ($11 - $10 + 1.0)))); //@line 6150
  $$0 = 1; //@line 6151
  STACKTOP = sp; //@line 6152
  return $$0 | 0; //@line 6152
 } else if (($4 | 0) == 1) {
  $5 = +_luaL_checknumber($L, 1); //@line 6154
  if (!($5 >= 1.0)) _luaL_argerror($L, 1, 6912) | 0; //@line 6157
  _lua_pushnumber($L, +Math_floor(+($3 * $5)) + 1.0); //@line 6162
  $$0 = 1; //@line 6163
  STACKTOP = sp; //@line 6164
  return $$0 | 0; //@line 6164
 } else {
  $$0 = _luaL_error($L, 6936, $vararg_buffer) | 0; //@line 6167
  STACKTOP = sp; //@line 6168
  return $$0 | 0; //@line 6168
 }
 return 0; //@line 6170
}
function _lua_next($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $32 = 0, $34 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 4787
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 4789
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 4794
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 4799
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 4806
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 4814
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 4817
  $17 = HEAP32[$1 >> 2] | 0; //@line 4818
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 4823
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 4825
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 4831
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 4835
  }
 } while (0);
 $29 = $L + 8 | 0; //@line 4841
 $32 = _luaH_next($L, HEAP32[$$0$i >> 2] | 0, (HEAP32[$29 >> 2] | 0) + -16 | 0) | 0; //@line 4844
 $34 = HEAP32[$29 >> 2] | 0; //@line 4846
 HEAP32[$29 >> 2] = ($32 | 0) == 0 ? $34 + -16 | 0 : $34 + 16 | 0; //@line 4850
 STACKTOP = sp; //@line 4851
 return $32 | 0; //@line 4851
}
function _luaL_prepbuffsize($B, $sz) {
 $B = $B | 0;
 $sz = $sz | 0;
 var $$ = 0, $1 = 0, $15 = 0, $2 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 6372
 STACKTOP = STACKTOP + 16 | 0; //@line 6373
 $1 = HEAP32[$B + 12 >> 2] | 0; //@line 6376
 $2 = $B + 4 | 0; //@line 6377
 $3 = HEAP32[$2 >> 2] | 0; //@line 6378
 $4 = $B + 8 | 0; //@line 6379
 $5 = HEAP32[$4 >> 2] | 0; //@line 6380
 if (($3 - $5 | 0) >>> 0 >= $sz >>> 0) {
  $22 = HEAP32[$B >> 2] | 0; //@line 6385
  $23 = $5; //@line 6385
  $21 = $22 + $23 | 0; //@line 6386
  STACKTOP = sp; //@line 6387
  return $21 | 0; //@line 6387
 }
 $8 = $3 << 1; //@line 6389
 $$ = ($8 - $5 | 0) >>> 0 < $sz >>> 0 ? $5 + $sz | 0 : $8; //@line 6393
 if ($$ >>> 0 < $5 >>> 0 | ($$ - $5 | 0) >>> 0 < $sz >>> 0) _luaL_error($1, 360, sp) | 0; //@line 6399
 $15 = _lua_newuserdata($1, $$) | 0; //@line 6401
 _memcpy($15 | 0, HEAP32[$B >> 2] | 0, HEAP32[$4 >> 2] | 0) | 0; //@line 6404
 if ((HEAP32[$B >> 2] | 0) != ($B + 16 | 0)) _lua_remove($1, -2); //@line 6409
 HEAP32[$B >> 2] = $15; //@line 6411
 HEAP32[$2 >> 2] = $$; //@line 6412
 $22 = $15; //@line 6414
 $23 = HEAP32[$4 >> 2] | 0; //@line 6414
 $21 = $22 + $23 | 0; //@line 6415
 STACKTOP = sp; //@line 6416
 return $21 | 0; //@line 6416
}
function _luaD_throw($L, $errcode) {
 $L = $L | 0;
 $errcode = $errcode | 0;
 var $0 = 0, $1 = 0, $11 = 0, $16 = 0, $18 = 0, $19 = 0, $21 = 0, $26 = 0, $27 = 0, $38 = 0, $8 = 0, $9 = 0;
 $0 = $L + 64 | 0; //@line 15300
 $1 = HEAP32[$0 >> 2] | 0; //@line 15301
 if ($1) {
  HEAP32[$1 + 160 >> 2] = $errcode; //@line 15305
  _longjmp((HEAP32[$0 >> 2] | 0) + 4 | 0, 1); //@line 15308
 }
 HEAP8[$L + 6 >> 0] = $errcode; //@line 15313
 $8 = $L + 12 | 0; //@line 15314
 $9 = HEAP32[$8 >> 2] | 0; //@line 15315
 $11 = HEAP32[$9 + 172 >> 2] | 0; //@line 15317
 if (HEAP32[$11 + 64 >> 2] | 0) {
  $16 = HEAP32[$L + 8 >> 2] | 0; //@line 15323
  $18 = $11 + 8 | 0; //@line 15325
  $19 = HEAP32[$18 >> 2] | 0; //@line 15326
  HEAP32[$18 >> 2] = $19 + 16; //@line 15328
  $21 = $16 + -16 | 0; //@line 15329
  $26 = HEAP32[$21 + 4 >> 2] | 0; //@line 15334
  $27 = $19; //@line 15335
  HEAP32[$27 >> 2] = HEAP32[$21 >> 2]; //@line 15337
  HEAP32[$27 + 4 >> 2] = $26; //@line 15340
  HEAP32[$19 + 8 >> 2] = HEAP32[$16 + -8 >> 2]; //@line 15344
  _luaD_throw(HEAP32[(HEAP32[$8 >> 2] | 0) + 172 >> 2] | 0, $errcode); //@line 15348
 }
 $38 = HEAP32[$9 + 168 >> 2] | 0; //@line 15352
 if (!$38) _abort(); //@line 15355
 FUNCTION_TABLE_ii[$38 & 255]($L) | 0; //@line 15358
 _abort(); //@line 15359
}
function _scalbn($x, $n) {
 $x = +$x;
 $n = $n | 0;
 var $$0 = 0, $1 = 0.0, $12 = 0, $15 = 0, $16 = 0, $18 = 0.0, $2 = 0, $5 = 0, $8 = 0.0, $9 = 0, $y$0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 13121
 if (($n | 0) > 1023) {
  $1 = $x * 8.98846567431158e+307; //@line 13124
  $2 = $n + -1023 | 0; //@line 13125
  if (($2 | 0) > 1023) {
   $5 = $n + -2046 | 0; //@line 13129
   $$0 = ($5 | 0) > 1023 ? 1023 : $5; //@line 13132
   $y$0 = $1 * 8.98846567431158e+307; //@line 13132
  } else {
   $$0 = $2; //@line 13134
   $y$0 = $1; //@line 13134
  }
 } else if (($n | 0) < -1022) {
  $8 = $x * 2.2250738585072014e-308; //@line 13139
  $9 = $n + 1022 | 0; //@line 13140
  if (($9 | 0) < -1022) {
   $12 = $n + 2044 | 0; //@line 13144
   $$0 = ($12 | 0) < -1022 ? -1022 : $12; //@line 13147
   $y$0 = $8 * 2.2250738585072014e-308; //@line 13147
  } else {
   $$0 = $9; //@line 13149
   $y$0 = $8; //@line 13149
  }
 } else {
  $$0 = $n; //@line 13152
  $y$0 = $x; //@line 13152
 }
 $15 = _bitshift64Shl($$0 + 1023 | 0, 0, 52) | 0; //@line 13156
 $16 = tempRet0; //@line 13157
 HEAP32[tempDoublePtr >> 2] = $15; //@line 13158
 HEAP32[tempDoublePtr + 4 >> 2] = $16; //@line 13158
 $18 = $y$0 * +HEAPF64[tempDoublePtr >> 3]; //@line 13159
 STACKTOP = sp; //@line 13160
 return +$18;
}
function _searcher_Lua($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $3 = 0, $7 = 0, $8 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 6657
 STACKTOP = STACKTOP + 16 | 0; //@line 6658
 $vararg_buffer1 = sp; //@line 6659
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6660
 _lua_getfield($L, -1001001, 7112); //@line 6661
 $1 = _lua_tolstring($L, -1, 0) | 0; //@line 6662
 if (!$1) {
  HEAP32[$vararg_buffer1 >> 2] = 7112; //@line 6665
  _luaL_error($L, 7888, $vararg_buffer1) | 0; //@line 6666
 }
 $3 = _searchpath($L, $0, $1, 7792, 7704) | 0; //@line 6668
 if (!$3) {
  $$0 = 1; //@line 6671
  STACKTOP = sp; //@line 6672
  return $$0 | 0; //@line 6672
 }
 if (!(_luaL_loadfilex($L, $3, 0) | 0)) {
  _lua_pushstring($L, $3) | 0; //@line 6677
  $$0 = 2; //@line 6678
  STACKTOP = sp; //@line 6679
  return $$0 | 0; //@line 6679
 } else {
  $7 = _lua_tolstring($L, 1, 0) | 0; //@line 6681
  $8 = _lua_tolstring($L, -1, 0) | 0; //@line 6682
  HEAP32[$vararg_buffer1 >> 2] = $7; //@line 6683
  HEAP32[$vararg_buffer1 + 4 >> 2] = $3; //@line 6685
  HEAP32[$vararg_buffer1 + 8 >> 2] = $8; //@line 6687
  $$0 = _luaL_error($L, 7744, $vararg_buffer1) | 0; //@line 6689
  STACKTOP = sp; //@line 6690
  return $$0 | 0; //@line 6690
 }
 return 0; //@line 6692
}
function _searcher_C($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $3 = 0, $7 = 0, $8 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 6697
 STACKTOP = STACKTOP + 16 | 0; //@line 6698
 $vararg_buffer1 = sp; //@line 6699
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6700
 _lua_getfield($L, -1001001, 7296); //@line 6701
 $1 = _lua_tolstring($L, -1, 0) | 0; //@line 6702
 if (!$1) {
  HEAP32[$vararg_buffer1 >> 2] = 7296; //@line 6705
  _luaL_error($L, 7888, $vararg_buffer1) | 0; //@line 6706
 }
 $3 = _searchpath($L, $0, $1, 7792, 7704) | 0; //@line 6708
 if (!$3) {
  $$0 = 1; //@line 6711
  STACKTOP = sp; //@line 6712
  return $$0 | 0; //@line 6712
 }
 if (!(_loadfunc($L, $3, $0) | 0)) {
  _lua_pushstring($L, $3) | 0; //@line 6717
  $$0 = 2; //@line 6718
  STACKTOP = sp; //@line 6719
  return $$0 | 0; //@line 6719
 } else {
  $7 = _lua_tolstring($L, 1, 0) | 0; //@line 6721
  $8 = _lua_tolstring($L, -1, 0) | 0; //@line 6722
  HEAP32[$vararg_buffer1 >> 2] = $7; //@line 6723
  HEAP32[$vararg_buffer1 + 4 >> 2] = $3; //@line 6725
  HEAP32[$vararg_buffer1 + 8 >> 2] = $8; //@line 6727
  $$0 = _luaL_error($L, 7744, $vararg_buffer1) | 0; //@line 6729
  STACKTOP = sp; //@line 6730
  return $$0 | 0; //@line 6730
 }
 return 0; //@line 6732
}
function _io_open($L) {
 $L = $L | 0;
 var $$ = 0, $0 = 0, $1 = 0, $17 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 2606
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 2607
 $1 = _luaL_optlstring($L, 2, 5520, 0) | 0; //@line 2608
 $2 = _lua_newuserdata($L, 8) | 0; //@line 2609
 $3 = $2 + 4 | 0; //@line 2610
 HEAP32[$3 >> 2] = 0; //@line 2611
 _luaL_setmetatable($L, 4872); //@line 2612
 HEAP32[$2 >> 2] = 0; //@line 2613
 HEAP32[$3 >> 2] = 175; //@line 2614
 $4 = HEAP8[$1 >> 0] | 0; //@line 2615
 if (!($4 << 24 >> 24)) label = 4; //@line 2618
 else {
  $7 = $1 + 1 | 0; //@line 2621
  if (!(_memchr(5592, $4 << 24 >> 24, 4) | 0)) label = 4; //@line 2625
 else {
   $$ = (HEAP8[$7 >> 0] | 0) == 43 ? $1 + 2 | 0 : $7; //@line 2630
   if (HEAP8[((HEAP8[$$ >> 0] | 0) == 98 ? $$ + 1 | 0 : $$) >> 0] | 0) label = 4; //@line 2638
  }
 }
 if ((label | 0) == 4) _luaL_argerror($L, 2, 5600) | 0; //@line 2643
 $17 = _fopen($0 | 0, $1 | 0) | 0; //@line 2645
 HEAP32[$2 >> 2] = $17; //@line 2646
 if ($17) {
  $20 = 1; //@line 2649
  STACKTOP = sp; //@line 2650
  return $20 | 0; //@line 2650
 }
 $20 = _luaL_fileresult($L, 0, $0) | 0; //@line 2653
 STACKTOP = sp; //@line 2654
 return $20 | 0; //@line 2654
}
function _luaD_shrinkstack($L) {
 $L = $L | 0;
 var $$ = 0, $$lim$0$i = 0, $1 = 0, $13 = 0, $15 = 0, $18 = 0, $5 = 0, $ci$01$i = 0, $ci$03$i = 0, $lim$0$lcssa$i = 0, $lim$02$i = 0, sp = 0;
 sp = STACKTOP; //@line 15598
 $1 = HEAP32[$L + 8 >> 2] | 0; //@line 15600
 $ci$01$i = HEAP32[$L + 16 >> 2] | 0; //@line 15602
 if (!$ci$01$i) $lim$0$lcssa$i = $1; //@line 15605
 else {
  $ci$03$i = $ci$01$i; //@line 15607
  $lim$02$i = $1; //@line 15607
  while (1) {
   $5 = HEAP32[$ci$03$i + 4 >> 2] | 0; //@line 15610
   $$lim$0$i = $lim$02$i >>> 0 < $5 >>> 0 ? $5 : $lim$02$i; //@line 15612
   $ci$03$i = HEAP32[$ci$03$i + 8 >> 2] | 0; //@line 15614
   if (!$ci$03$i) {
    $lim$0$lcssa$i = $$lim$0$i; //@line 15617
    break;
   } else $lim$02$i = $$lim$0$i; //@line 15620
  }
 }
 $13 = $lim$0$lcssa$i - (HEAP32[$L + 28 >> 2] | 0) | 0; //@line 15628
 $15 = ($13 >> 4) + 1 | 0; //@line 15630
 $18 = (($15 | 0) / 8 | 0) + 10 + $15 | 0; //@line 15633
 $$ = ($18 | 0) > 1e6 ? 1e6 : $18; //@line 15635
 if (($13 | 0) > 15999984) {
  STACKTOP = sp; //@line 15638
  return;
 }
 if (($$ | 0) >= (HEAP32[$L + 32 >> 2] | 0)) {
  STACKTOP = sp; //@line 15644
  return;
 }
 _luaD_reallocstack($L, $$); //@line 15646
 STACKTOP = sp; //@line 15647
 return;
}
function _luaG_errormsg($L) {
 $L = $L | 0;
 var $1 = 0, $10 = 0, $11 = 0, $13 = 0, $18 = 0, $19 = 0, $26 = 0, $28 = 0, $33 = 0, $34 = 0, $4 = 0, $40 = 0, $5 = 0;
 $1 = HEAP32[$L + 68 >> 2] | 0; //@line 15231
 if (!$1) _luaD_throw($L, 2); //@line 15234
 $4 = HEAP32[$L + 28 >> 2] | 0; //@line 15238
 $5 = $4 + ($1 + 8) | 0; //@line 15240
 if ((HEAP32[$5 >> 2] & 15 | 0) != 6) _luaD_throw($L, 6); //@line 15245
 $10 = $L + 8 | 0; //@line 15249
 $11 = HEAP32[$10 >> 2] | 0; //@line 15250
 $13 = $11 + -16 | 0; //@line 15252
 $18 = HEAP32[$13 + 4 >> 2] | 0; //@line 15257
 $19 = $11; //@line 15258
 HEAP32[$19 >> 2] = HEAP32[$13 >> 2]; //@line 15260
 HEAP32[$19 + 4 >> 2] = $18; //@line 15263
 HEAP32[$11 + 8 >> 2] = HEAP32[$11 + -8 >> 2]; //@line 15267
 $26 = HEAP32[$10 >> 2] | 0; //@line 15268
 $28 = $4 + $1 | 0; //@line 15270
 $33 = HEAP32[$28 + 4 >> 2] | 0; //@line 15275
 $34 = $26 + -16 | 0; //@line 15276
 HEAP32[$34 >> 2] = HEAP32[$28 >> 2]; //@line 15278
 HEAP32[$34 + 4 >> 2] = $33; //@line 15281
 HEAP32[$26 + -8 >> 2] = HEAP32[$5 >> 2]; //@line 15284
 $40 = HEAP32[$10 >> 2] | 0; //@line 15285
 HEAP32[$10 >> 2] = $40 + 16; //@line 15287
 _luaD_call($L, $40 + -16 | 0, 1, 0); //@line 15289
 _luaD_throw($L, 2); //@line 15290
}
function _unpack($L) {
 $L = $L | 0;
 var $$0 = 0, $$in = 0, $0 = 0, $6 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 18220
 STACKTOP = STACKTOP + 16 | 0; //@line 18221
 $vararg_buffer = sp; //@line 18222
 _luaL_checktype($L, 1, 5); //@line 18223
 $0 = _luaL_optinteger($L, 2, 1) | 0; //@line 18224
 if ((_lua_type($L, 3) | 0) < 1) $6 = _luaL_len($L, 1) | 0; //@line 18229
 else $6 = _luaL_checkinteger($L, 3) | 0; //@line 18232
 if (($0 | 0) > ($6 | 0)) {
  $$0 = 0; //@line 18236
  STACKTOP = sp; //@line 18237
  return $$0 | 0; //@line 18237
 }
 $7 = $6 - $0 | 0; //@line 18239
 $8 = $7 + 1 | 0; //@line 18240
 if (($7 | 0) >= 0) if (_lua_checkstack($L, $8) | 0) {
  _lua_rawgeti($L, 1, $0); //@line 18246
  if (($0 | 0) < ($6 | 0)) $$in = $0; //@line 18249
 else {
   $$0 = $8; //@line 18251
   STACKTOP = sp; //@line 18252
   return $$0 | 0; //@line 18252
  }
  do {
   $$in = $$in + 1 | 0; //@line 18255
   _lua_rawgeti($L, 1, $$in); //@line 18256
  } while (($$in | 0) != ($6 | 0));
  $$0 = $8; //@line 18259
  STACKTOP = sp; //@line 18265
  return $$0 | 0; //@line 18265
 }
 $$0 = _luaL_error($L, 11136, $vararg_buffer) | 0; //@line 18269
 STACKTOP = sp; //@line 18270
 return $$0 | 0; //@line 18270
}
function _luaK_patchtohere($fs, $list) {
 $fs = $fs | 0;
 $list = $list | 0;
 var $10 = 0, $13 = 0, $15 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $fs$idx$val$idx$val$i = 0, $list$0$i = 0, sp = 0;
 sp = STACKTOP; //@line 9027
 HEAP32[$fs + 24 >> 2] = HEAP32[$fs + 20 >> 2]; //@line 9031
 $3 = $fs + 28 | 0; //@line 9032
 if (($list | 0) == -1) {
  STACKTOP = sp; //@line 9035
  return;
 }
 $5 = HEAP32[$3 >> 2] | 0; //@line 9037
 if (($5 | 0) == -1) {
  HEAP32[$3 >> 2] = $list; //@line 9040
  STACKTOP = sp; //@line 9041
  return;
 }
 $fs$idx$val$idx$val$i = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 9045
 $list$0$i = $5; //@line 9046
 while (1) {
  $7 = $fs$idx$val$idx$val$i + ($list$0$i << 2) | 0; //@line 9048
  $8 = HEAP32[$7 >> 2] | 0; //@line 9049
  $10 = ($8 >>> 14) + -131071 | 0; //@line 9051
  if (($10 | 0) == -1) break;
  $13 = $list$0$i + 1 + $10 | 0; //@line 9057
  if (($13 | 0) == -1) break; else $list$0$i = $13; //@line 9062
 }
 $15 = ~$list$0$i + $list | 0; //@line 9066
 if (((($15 | 0) > -1 ? $15 : 0 - $15 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 9074
 HEAP32[$7 >> 2] = ($15 << 14) + 2147467264 | $8 & 16383; //@line 9081
 STACKTOP = sp; //@line 9082
 return;
}
function _str_sub($L) {
 $L = $L | 0;
 var $$ = 0, $$0$i = 0, $$0$i1 = 0, $0 = 0, $1 = 0, $2 = 0, $8 = 0, $9 = 0, $end$0 = 0, $l = 0, sp = 0;
 sp = STACKTOP; //@line 14628
 STACKTOP = STACKTOP + 16 | 0; //@line 14629
 $l = sp; //@line 14630
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 14631
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 14632
 $2 = HEAP32[$l >> 2] | 0; //@line 14633
 if (($1 | 0) > -1) $$0$i = $1; //@line 14636
 else if ($2 >>> 0 < (0 - $1 | 0) >>> 0) $$0$i = 0; //@line 14641
 else $$0$i = $1 + 1 + $2 | 0; //@line 14645
 $8 = _luaL_optinteger($L, 3, -1) | 0; //@line 14648
 $9 = HEAP32[$l >> 2] | 0; //@line 14649
 if (($8 | 0) > -1) $$0$i1 = $8; //@line 14652
 else if ($9 >>> 0 < (0 - $8 | 0) >>> 0) $$0$i1 = 0; //@line 14657
 else $$0$i1 = $8 + 1 + $9 | 0; //@line 14661
 $$ = ($$0$i | 0) == 0 ? 1 : $$0$i; //@line 14665
 $end$0 = $$0$i1 >>> 0 > $9 >>> 0 ? $9 : $$0$i1; //@line 14667
 if ($$ >>> 0 > $end$0 >>> 0) {
  _lua_pushlstring($L, 9896, 0) | 0; //@line 14670
  STACKTOP = sp; //@line 14671
  return 1; //@line 14671
 } else {
  _lua_pushlstring($L, $0 + ($$ + -1) | 0, 1 - $$ + $end$0 | 0) | 0; //@line 14677
  STACKTOP = sp; //@line 14678
  return 1; //@line 14678
 }
 return 0; //@line 14680
}
function _lua_settable($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $29 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 3513
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 3515
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 3520
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 3525
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 3532
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 3540
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 3543
  $17 = HEAP32[$1 >> 2] | 0; //@line 3544
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 3549
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 3551
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 3557
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 3561
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 3566
 $29 = HEAP32[$28 >> 2] | 0; //@line 3567
 _luaV_settable($L, $$0$i, $29 + -32 | 0, $29 + -16 | 0); //@line 3570
 HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + -32; //@line 3573
 STACKTOP = sp; //@line 3574
 return;
}
function _luaB_print($L) {
 $L = $L | 0;
 var $$0 = 0, $$pre = 0, $0 = 0, $2 = 0, $i$04 = 0, $l = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7876
 STACKTOP = STACKTOP + 16 | 0; //@line 7877
 $vararg_buffer = sp; //@line 7878
 $l = sp + 4 | 0; //@line 7879
 $0 = _lua_gettop($L) | 0; //@line 7880
 _lua_getglobal($L, 1368); //@line 7881
 $$pre = HEAP32[_stdout >> 2] | 0; //@line 7883
 L1 : do if (($0 | 0) >= 1) {
  $i$04 = 1; //@line 7886
  while (1) {
   _lua_pushvalue($L, -1); //@line 7888
   _lua_pushvalue($L, $i$04); //@line 7889
   _lua_callk($L, 1, 1, 0, 0); //@line 7890
   $2 = _lua_tolstring($L, -1, $l) | 0; //@line 7891
   if (!$2) break;
   if (($i$04 | 0) > 1) _fputc(9, $$pre | 0) | 0; //@line 7898
   _fwrite($2 | 0, 1, HEAP32[$l >> 2] | 0, $$pre | 0) | 0; //@line 7901
   _lua_settop($L, -2); //@line 7902
   if (($i$04 | 0) < ($0 | 0)) $i$04 = $i$04 + 1 | 0; //@line 7906
 else break L1;
  }
  $$0 = _luaL_error($L, 1600, $vararg_buffer) | 0; //@line 7912
  STACKTOP = sp; //@line 7913
  return $$0 | 0; //@line 7913
 } while (0);
 _fputc(10, $$pre | 0) | 0; //@line 7916
 _fflush($$pre | 0) | 0; //@line 7917
 $$0 = 0; //@line 7918
 STACKTOP = sp; //@line 7919
 return $$0 | 0; //@line 7919
}
function _findfield($L, $objidx, $level) {
 $L = $L | 0;
 $objidx = $objidx | 0;
 $level = $level | 0;
 var $$0 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 7569
 L1 : do if (!$level) $$0 = 0; //@line 7573
 else if ((_lua_type($L, -1) | 0) == 5) {
  _lua_pushnil($L); //@line 7578
  if (!(_lua_next($L, -2) | 0)) $$0 = 0; //@line 7582
 else {
   $5 = $level + -1 | 0; //@line 7584
   while (1) {
    if ((_lua_type($L, -2) | 0) == 4) {
     if (_lua_rawequal($L, $objidx, -1) | 0) {
      label = 7; //@line 7592
      break;
     }
     if (_findfield($L, $objidx, $5) | 0) {
      label = 9; //@line 7598
      break;
     }
    }
    _lua_settop($L, -2); //@line 7602
    if (!(_lua_next($L, -2) | 0)) {
     $$0 = 0; //@line 7606
     break L1;
    }
   }
   if ((label | 0) == 7) {
    _lua_settop($L, -2); //@line 7611
    $$0 = 1; //@line 7612
    break;
   } else if ((label | 0) == 9) {
    _lua_remove($L, -2); //@line 7616
    _lua_pushlstring($L, 864, 1) | 0; //@line 7617
    _lua_insert($L, -2); //@line 7618
    _lua_concat($L, 3); //@line 7619
    $$0 = 1; //@line 7620
    break;
   }
  }
 } else $$0 = 0; //@line 7625
 while (0);
 STACKTOP = sp; //@line 7629
 return $$0 | 0; //@line 7629
}
function _luaL_optlstring($L, $narg, $def, $len) {
 $L = $L | 0;
 $narg = $narg | 0;
 $def = $def | 0;
 $len = $len | 0;
 var $$0 = 0, $10 = 0, $5 = 0, $6 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6126
 STACKTOP = STACKTOP + 16 | 0; //@line 6127
 $vararg_buffer = sp; //@line 6128
 if ((_lua_type($L, $narg) | 0) >= 1) {
  $6 = _lua_tolstring($L, $narg, $len) | 0; //@line 6132
  if ($6) {
   $$0 = $6; //@line 6135
   STACKTOP = sp; //@line 6136
   return $$0 | 0; //@line 6136
  }
  $8 = _lua_typename($L, 4) | 0; //@line 6138
  $10 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6140
  HEAP32[$vararg_buffer >> 2] = $8; //@line 6141
  HEAP32[$vararg_buffer + 4 >> 2] = $10; //@line 6143
  _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6145
  $$0 = 0; //@line 6146
  STACKTOP = sp; //@line 6147
  return $$0 | 0; //@line 6147
 }
 if (!$len) {
  $$0 = $def; //@line 6151
  STACKTOP = sp; //@line 6152
  return $$0 | 0; //@line 6152
 }
 if (!$def) $5 = 0; //@line 6156
 else $5 = _strlen($def | 0) | 0; //@line 6159
 HEAP32[$len >> 2] = $5; //@line 6161
 $$0 = $def; //@line 6162
 STACKTOP = sp; //@line 6163
 return $$0 | 0; //@line 6163
}
function _frexp($x, $e) {
 $x = +$x;
 $e = $e | 0;
 var $$0 = 0.0, $$01 = 0.0, $0 = 0, $1 = 0, $2 = 0, $4 = 0, $7 = 0.0, $storemerge = 0, sp = 0;
 sp = STACKTOP; //@line 13074
 HEAPF64[tempDoublePtr >> 3] = $x; //@line 13075
 $0 = HEAP32[tempDoublePtr >> 2] | 0; //@line 13075
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0; //@line 13076
 $2 = _bitshift64Lshr($0 | 0, $1 | 0, 52) | 0; //@line 13077
 $4 = $2 & 2047; //@line 13079
 if (!$4) {
  if ($x != 0.0) {
   $7 = +_frexp($x * 18446744073709552000.0, $e); //@line 13084
   $$01 = $7; //@line 13087
   $storemerge = (HEAP32[$e >> 2] | 0) + -64 | 0; //@line 13087
  } else {
   $$01 = $x; //@line 13089
   $storemerge = 0; //@line 13089
  }
  HEAP32[$e >> 2] = $storemerge; //@line 13091
  $$0 = $$01; //@line 13092
  STACKTOP = sp; //@line 13093
  return +$$0;
 } else if (($4 | 0) == 2047) {
  $$0 = $x; //@line 13095
  STACKTOP = sp; //@line 13096
  return +$$0;
 } else {
  HEAP32[$e >> 2] = $4 + -1022; //@line 13099
  HEAP32[tempDoublePtr >> 2] = $0; //@line 13102
  HEAP32[tempDoublePtr + 4 >> 2] = $1 & -2146435073 | 1071644672; //@line 13102
  $$0 = +HEAPF64[tempDoublePtr >> 3]; //@line 13103
  STACKTOP = sp; //@line 13104
  return +$$0;
 }
 return 0.0;
}
function _lua_tothread($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $32 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2309
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2311
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2316
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2321
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2328
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2336
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2339
  $17 = HEAP32[$1 >> 2] | 0; //@line 2340
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2345
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2347
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2353
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2357
  }
 } while (0);
 if ((HEAP32[$$0$i + 8 >> 2] | 0) != 72) {
  $32 = 0; //@line 2366
  STACKTOP = sp; //@line 2367
  return $32 | 0; //@line 2367
 }
 $32 = HEAP32[$$0$i >> 2] | 0; //@line 2370
 STACKTOP = sp; //@line 2371
 return $32 | 0; //@line 2371
}
function _luaX_token2str($ls, $token) {
 $ls = $ls | 0;
 $token = $token | 0;
 var $$0 = 0, $12 = 0, $15 = 0, $7 = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP; //@line 2865
 STACKTOP = STACKTOP + 16 | 0; //@line 2866
 $vararg_buffer4 = sp; //@line 2867
 if (($token | 0) >= 257) {
  $12 = HEAP32[5616 + ($token + -257 << 2) >> 2] | 0; //@line 2872
  if (($token | 0) >= 286) {
   $$0 = $12; //@line 2875
   STACKTOP = sp; //@line 2876
   return $$0 | 0; //@line 2876
  }
  $15 = HEAP32[$ls + 52 >> 2] | 0; //@line 2879
  HEAP32[$vararg_buffer4 >> 2] = $12; //@line 2880
  $$0 = _luaO_pushfstring($15, 5776, $vararg_buffer4) | 0; //@line 2882
  STACKTOP = sp; //@line 2883
  return $$0 | 0; //@line 2883
 }
 $7 = HEAP32[$ls + 52 >> 2] | 0; //@line 2891
 if (!(HEAP8[$token + 2697 >> 0] & 4)) {
  HEAP32[$vararg_buffer4 >> 2] = $token; //@line 2893
  $$0 = _luaO_pushfstring($7, 5760, $vararg_buffer4) | 0; //@line 2895
  STACKTOP = sp; //@line 2896
  return $$0 | 0; //@line 2896
 } else {
  HEAP32[$vararg_buffer4 >> 2] = $token; //@line 2898
  $$0 = _luaO_pushfstring($7, 5752, $vararg_buffer4) | 0; //@line 2900
  STACKTOP = sp; //@line 2901
  return $$0 | 0; //@line 2901
 }
 return 0; //@line 2903
}
function _luaK_nil($fs, $from, $n) {
 $fs = $fs | 0;
 $from = $from | 0;
 $n = $n | 0;
 var $$from = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $16 = 0, $18 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 8606
 $0 = $n + $from | 0; //@line 8607
 $1 = $0 + -1 | 0; //@line 8608
 $3 = HEAP32[$fs + 20 >> 2] | 0; //@line 8610
 do if (($3 | 0) > (HEAP32[$fs + 24 >> 2] | 0)) {
  $11 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + ($3 + -1 << 2) | 0; //@line 8620
  $12 = HEAP32[$11 >> 2] | 0; //@line 8621
  if (($12 & 63 | 0) == 4) {
   $16 = $12 >>> 6 & 255; //@line 8626
   $18 = $16 + ($12 >>> 23) | 0; //@line 8628
   if (($16 | 0) > ($from | 0)) label = 5; //@line 8631
 else if (($18 + 1 | 0) < ($from | 0)) label = 5; //@line 8636
   if ((label | 0) == 5) if (($16 | 0) < ($from | 0) | ($16 | 0) > ($0 | 0)) break;
   $$from = ($16 | 0) < ($from | 0) ? $16 : $from; //@line 8648
   HEAP32[$11 >> 2] = (($18 | 0) > ($1 | 0) ? $18 : $1) - $$from << 23 | $$from << 6 & 16320 | $12 & 8372287; //@line 8658
   STACKTOP = sp; //@line 8659
   return;
  }
 } while (0);
 _luaK_code($fs, $from << 6 | ($n << 23) + -8388608 | 4) | 0; //@line 8668
 STACKTOP = sp; //@line 8669
 return;
}
function _luaX_setinput($L, $ls, $z, $source, $firstchar) {
 $L = $L | 0;
 $ls = $ls | 0;
 $z = $z | 0;
 $source = $source | 0;
 $firstchar = $firstchar | 0;
 var $1 = 0, $10 = 0, $16 = 0, $17 = 0, $21 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 3100
 HEAP8[$ls + 76 >> 0] = 46; //@line 3102
 $1 = $ls + 52 | 0; //@line 3103
 HEAP32[$1 >> 2] = $L; //@line 3104
 HEAP32[$ls >> 2] = $firstchar; //@line 3105
 HEAP32[$ls + 32 >> 2] = 286; //@line 3107
 HEAP32[$ls + 56 >> 2] = $z; //@line 3109
 HEAP32[$ls + 48 >> 2] = 0; //@line 3111
 HEAP32[$ls + 4 >> 2] = 1; //@line 3113
 HEAP32[$ls + 8 >> 2] = 1; //@line 3115
 HEAP32[$ls + 68 >> 2] = $source; //@line 3117
 $8 = _luaS_new($L, 5784) | 0; //@line 3118
 HEAP32[$ls + 72 >> 2] = $8; //@line 3120
 $10 = $8 + 5 | 0; //@line 3121
 HEAP8[$10 >> 0] = HEAPU8[$10 >> 0] | 0 | 32; //@line 3126
 $16 = $ls + 60 | 0; //@line 3128
 $17 = HEAP32[$16 >> 2] | 0; //@line 3129
 $21 = _luaM_realloc_(HEAP32[$1 >> 2] | 0, HEAP32[$17 >> 2] | 0, HEAP32[$17 + 8 >> 2] | 0, 32) | 0; //@line 3133
 HEAP32[HEAP32[$16 >> 2] >> 2] = $21; //@line 3135
 HEAP32[(HEAP32[$16 >> 2] | 0) + 8 >> 2] = 32; //@line 3138
 STACKTOP = sp; //@line 3139
 return;
}
function _lua_setlocal($L, $ar, $n) {
 $L = $L | 0;
 $ar = $ar | 0;
 $n = $n | 0;
 var $$pre = 0, $12 = 0, $13 = 0, $2 = 0, $20 = 0, $21 = 0, $4 = 0, $6 = 0, $7 = 0, $pos = 0, sp = 0;
 sp = STACKTOP; //@line 14122
 STACKTOP = STACKTOP + 16 | 0; //@line 14123
 $pos = sp; //@line 14124
 HEAP32[$pos >> 2] = 0; //@line 14125
 $2 = _findlocal($L, HEAP32[$ar + 96 >> 2] | 0, $n, $pos) | 0; //@line 14128
 $$pre = $L + 8 | 0; //@line 14130
 if (!$2) {
  $20 = HEAP32[$$pre >> 2] | 0; //@line 14132
  $21 = $20 + -16 | 0; //@line 14133
  HEAP32[$$pre >> 2] = $21; //@line 14134
  STACKTOP = sp; //@line 14135
  return $2 | 0; //@line 14135
 }
 $4 = HEAP32[$$pre >> 2] | 0; //@line 14137
 $6 = HEAP32[$pos >> 2] | 0; //@line 14139
 $7 = $4 + -16 | 0; //@line 14140
 $12 = HEAP32[$7 + 4 >> 2] | 0; //@line 14145
 $13 = $6; //@line 14146
 HEAP32[$13 >> 2] = HEAP32[$7 >> 2]; //@line 14148
 HEAP32[$13 + 4 >> 2] = $12; //@line 14151
 HEAP32[$6 + 8 >> 2] = HEAP32[$4 + -8 >> 2]; //@line 14155
 $20 = HEAP32[$$pre >> 2] | 0; //@line 14156
 $21 = $20 + -16 | 0; //@line 14157
 HEAP32[$$pre >> 2] = $21; //@line 14158
 STACKTOP = sp; //@line 14159
 return $2 | 0; //@line 14159
}
function _lua_len($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $28 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 4896
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 4898
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 4903
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 4908
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 4915
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 4923
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 4926
  $17 = HEAP32[$1 >> 2] | 0; //@line 4927
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 4932
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 4934
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 4940
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 4944
  }
 } while (0);
 $28 = $L + 8 | 0; //@line 4949
 _luaV_objlen($L, HEAP32[$28 >> 2] | 0, $$0$i); //@line 4951
 HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + 16; //@line 4954
 STACKTOP = sp; //@line 4955
 return;
}
function _luaK_numberK($fs, $r) {
 $fs = $fs | 0;
 $r = +$r;
 var $0 = 0, $10 = 0, $18 = 0, $4 = 0, $7 = 0, $8 = 0, $n$0 = 0, $o = 0, sp = 0;
 sp = STACKTOP; //@line 9566
 STACKTOP = STACKTOP + 32 | 0; //@line 9567
 $0 = sp + 16 | 0; //@line 9568
 $o = sp; //@line 9569
 HEAPF64[$0 >> 3] = $r; //@line 9570
 $4 = HEAP32[(HEAP32[$fs + 12 >> 2] | 0) + 52 >> 2] | 0; //@line 9574
 HEAPF64[$o >> 3] = $r; //@line 9575
 HEAP32[$o + 8 >> 2] = 3; //@line 9577
 if ($r != $r | 0.0 != 0.0 | $r == 0.0) {
  $7 = $4 + 8 | 0; //@line 9580
  $8 = HEAP32[$7 >> 2] | 0; //@line 9581
  HEAP32[$7 >> 2] = $8 + 16; //@line 9583
  $10 = _luaS_newlstr($4, $0, 8) | 0; //@line 9584
  HEAP32[$8 >> 2] = $10; //@line 9585
  HEAP32[$8 + 8 >> 2] = HEAPU8[$10 + 4 >> 0] | 0 | 64; //@line 9591
  $18 = _addk($fs, (HEAP32[$7 >> 2] | 0) + -16 | 0, $o) | 0; //@line 9594
  HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -16; //@line 9597
  $n$0 = $18; //@line 9598
  STACKTOP = sp; //@line 9599
  return $n$0 | 0; //@line 9599
 } else {
  $n$0 = _addk($fs, $o, $o) | 0; //@line 9602
  STACKTOP = sp; //@line 9603
  return $n$0 | 0; //@line 9603
 }
 return 0; //@line 9605
}
function ___remdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $rem = 0, $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $10$0 = 0, $10$1 = 0, __stackBase__ = 0;
 __stackBase__ = STACKTOP; //@line 17148
 STACKTOP = STACKTOP + 8 | 0; //@line 17149
 $rem = __stackBase__ | 0; //@line 17150
 $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1; //@line 17151
 $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1; //@line 17152
 $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1; //@line 17153
 $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1; //@line 17154
 $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0; //@line 17155
 $4$1 = tempRet0; //@line 17156
 ___udivmoddi4($4$0, $4$1, _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0, tempRet0, $rem) | 0; //@line 17158
 $10$0 = _i64Subtract(HEAP32[$rem >> 2] ^ $1$0, HEAP32[$rem + 4 >> 2] ^ $1$1, $1$0, $1$1) | 0; //@line 17159
 $10$1 = tempRet0; //@line 17160
 STACKTOP = __stackBase__; //@line 17161
 return (tempRet0 = $10$1, $10$0) | 0; //@line 17162
}
function _luaL_tolstring($L, $idx, $len) {
 $L = $L | 0;
 $idx = $idx | 0;
 $len = $len | 0;
 var $2 = 0, $4 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7010
 STACKTOP = STACKTOP + 16 | 0; //@line 7011
 $vararg_buffer = sp; //@line 7012
 do if (!(_luaL_callmeta($L, $idx, 472) | 0)) {
  $2 = _lua_type($L, $idx) | 0; //@line 7017
  if (!$2) {
   _lua_pushlstring($L, 504, 3) | 0; //@line 7019
   break;
  } else if (($2 | 0) == 4 | ($2 | 0) == 3) {
   _lua_pushvalue($L, $idx); //@line 7022
   break;
  } else if (($2 | 0) == 1) {
   $4 = (_lua_toboolean($L, $idx) | 0) != 0; //@line 7026
   _lua_pushstring($L, $4 ? 488 : 496) | 0; //@line 7028
   break;
  } else {
   $7 = _lua_typename($L, _lua_type($L, $idx) | 0) | 0; //@line 7032
   $8 = _lua_topointer($L, $idx) | 0; //@line 7033
   HEAP32[$vararg_buffer >> 2] = $7; //@line 7034
   HEAP32[$vararg_buffer + 4 >> 2] = $8; //@line 7036
   _lua_pushfstring($L, 512, $vararg_buffer) | 0; //@line 7037
   break;
  }
 } while (0);
 $9 = _lua_tolstring($L, -1, $len) | 0; //@line 7042
 STACKTOP = sp; //@line 7043
 return $9 | 0; //@line 7043
}
function _lua_gettable($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $30 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 2872
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 2874
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 2879
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 2884
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 2891
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 2899
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 2902
  $17 = HEAP32[$1 >> 2] | 0; //@line 2903
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 2908
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 2910
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 2916
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 2920
  }
 } while (0);
 $30 = (HEAP32[$L + 8 >> 2] | 0) + -16 | 0; //@line 2927
 _luaV_gettable($L, $$0$i, $30, $30); //@line 2928
 STACKTOP = sp; //@line 2929
 return;
}
function _lua_isuserdata($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 1147
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 1149
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 1154
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 1159
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 1166
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 1174
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 1177
  $17 = HEAP32[$1 >> 2] | 0; //@line 1178
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 1183
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 1185
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 1191
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 1195
  }
 } while (0);
 $29 = HEAP32[$$0$i + 8 >> 2] | 0; //@line 1201
 STACKTOP = sp; //@line 1206
 return (($29 | 0) == 71 | ($29 | 0) == 2) & 1 | 0; //@line 1206
}
function _lua_xmove($from, $to, $n) {
 $from = $from | 0;
 $to = $to | 0;
 $n = $n | 0;
 var $1 = 0, $11 = 0, $16 = 0, $17 = 0, $24 = 0, $4 = 0, $6 = 0, $8 = 0, $9 = 0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 128
 if (($from | 0) == ($to | 0)) {
  STACKTOP = sp; //@line 131
  return;
 }
 $1 = $from + 8 | 0; //@line 133
 $4 = (HEAP32[$1 >> 2] | 0) + (0 - $n << 4) | 0; //@line 136
 HEAP32[$1 >> 2] = $4; //@line 137
 if (($n | 0) <= 0) {
  STACKTOP = sp; //@line 140
  return;
 }
 $6 = $to + 8 | 0; //@line 142
 $8 = $4; //@line 143
 $i$01 = 0; //@line 143
 while (1) {
  $9 = HEAP32[$6 >> 2] | 0; //@line 146
  HEAP32[$6 >> 2] = $9 + 16; //@line 148
  $11 = $8 + ($i$01 << 4) | 0; //@line 149
  $16 = HEAP32[$11 + 4 >> 2] | 0; //@line 154
  $17 = $9; //@line 155
  HEAP32[$17 >> 2] = HEAP32[$11 >> 2]; //@line 157
  HEAP32[$17 + 4 >> 2] = $16; //@line 160
  HEAP32[$9 + 8 >> 2] = HEAP32[$8 + ($i$01 << 4) + 8 >> 2]; //@line 164
  $24 = $i$01 + 1 | 0; //@line 165
  if (($24 | 0) == ($n | 0)) break;
  $8 = HEAP32[$1 >> 2] | 0; //@line 171
  $i$01 = $24; //@line 171
 }
 STACKTOP = sp; //@line 173
 return;
}
function _luaK_concat($fs, $l1, $l2) {
 $fs = $fs | 0;
 $l1 = $l1 | 0;
 $l2 = $l2 | 0;
 var $1 = 0, $11 = 0, $3 = 0, $4 = 0, $6 = 0, $9 = 0, $fs$idx$val$idx$val = 0, $list$0 = 0, sp = 0;
 sp = STACKTOP; //@line 8769
 if (($l2 | 0) == -1) {
  STACKTOP = sp; //@line 8772
  return;
 }
 $1 = HEAP32[$l1 >> 2] | 0; //@line 8774
 if (($1 | 0) == -1) {
  HEAP32[$l1 >> 2] = $l2; //@line 8777
  STACKTOP = sp; //@line 8778
  return;
 }
 $fs$idx$val$idx$val = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 8782
 $list$0 = $1; //@line 8783
 while (1) {
  $3 = $fs$idx$val$idx$val + ($list$0 << 2) | 0; //@line 8785
  $4 = HEAP32[$3 >> 2] | 0; //@line 8786
  $6 = ($4 >>> 14) + -131071 | 0; //@line 8788
  if (($6 | 0) == -1) break;
  $9 = $list$0 + 1 + $6 | 0; //@line 8794
  if (($9 | 0) == -1) break; else $list$0 = $9; //@line 8799
 }
 $11 = ~$list$0 + $l2 | 0; //@line 8803
 if (((($11 | 0) > -1 ? $11 : 0 - $11 | 0) | 0) > 131071) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2408); //@line 8811
 HEAP32[$3 >> 2] = $4 & 16383 | ($11 << 14) + 2147467264; //@line 8818
 STACKTOP = sp; //@line 8819
 return;
}
function _luaE_freethread($L, $L1) {
 $L = $L | 0;
 $L1 = $L1 | 0;
 var $0 = 0, $15 = 0, $2 = 0, $6 = 0, $7 = 0, $next$01$i$i = 0, sp = 0, $next$01$i$i$looptemp = 0;
 sp = STACKTOP; //@line 12770
 $0 = $L1 + 28 | 0; //@line 12771
 _luaF_close($L1, HEAP32[$0 >> 2] | 0); //@line 12773
 $2 = HEAP32[$0 >> 2] | 0; //@line 12774
 if (!$2) {
  _luaM_realloc_($L, $L1, 112, 0) | 0; //@line 12777
  STACKTOP = sp; //@line 12778
  return;
 }
 HEAP32[$L1 + 16 >> 2] = $L1 + 72; //@line 12782
 $6 = $L1 + 84 | 0; //@line 12783
 $7 = HEAP32[$6 >> 2] | 0; //@line 12784
 HEAP32[$6 >> 2] = 0; //@line 12785
 if (!$7) $15 = $2; //@line 12788
 else {
  $next$01$i$i = $7; //@line 12790
  do {
   $next$01$i$i$looptemp = $next$01$i$i;
   $next$01$i$i = HEAP32[$next$01$i$i + 12 >> 2] | 0; //@line 12793
   _luaM_realloc_($L1, $next$01$i$i$looptemp, 40, 0) | 0; //@line 12794
  } while (($next$01$i$i | 0) != 0);
  $15 = HEAP32[$0 >> 2] | 0; //@line 12803
 }
 _luaM_realloc_($L1, $15, HEAP32[$L1 + 32 >> 2] << 4, 0) | 0; //@line 12808
 _luaM_realloc_($L, $L1, 112, 0) | 0; //@line 12809
 STACKTOP = sp; //@line 12810
 return;
}
function ___toread($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $15 = 0, $2 = 0, $21 = 0, $6 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 13315
 $0 = $f + 74 | 0; //@line 13316
 $2 = HEAP8[$0 >> 0] | 0; //@line 13318
 HEAP8[$0 >> 0] = $2 + 255 | $2; //@line 13322
 $6 = $f + 20 | 0; //@line 13323
 $8 = $f + 44 | 0; //@line 13325
 if ((HEAP32[$6 >> 2] | 0) >>> 0 > (HEAP32[$8 >> 2] | 0) >>> 0) FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 31]($f, 0, 0) | 0; //@line 13331
 HEAP32[$f + 16 >> 2] = 0; //@line 13334
 HEAP32[$f + 28 >> 2] = 0; //@line 13336
 HEAP32[$6 >> 2] = 0; //@line 13337
 $15 = HEAP32[$f >> 2] | 0; //@line 13338
 if (!($15 & 20)) {
  $21 = HEAP32[$8 >> 2] | 0; //@line 13342
  HEAP32[$f + 8 >> 2] = $21; //@line 13344
  HEAP32[$f + 4 >> 2] = $21; //@line 13346
  $$0 = 0; //@line 13347
  STACKTOP = sp; //@line 13348
  return $$0 | 0; //@line 13348
 }
 if (!($15 & 4)) {
  $$0 = -1; //@line 13353
  STACKTOP = sp; //@line 13354
  return $$0 | 0; //@line 13354
 }
 HEAP32[$f >> 2] = $15 | 32; //@line 13357
 $$0 = -1; //@line 13358
 STACKTOP = sp; //@line 13359
 return $$0 | 0; //@line 13359
}
function _luaL_buffinitsize($L, $B, $sz) {
 $L = $L | 0;
 $B = $B | 0;
 $sz = $sz | 0;
 var $$$i = 0, $1 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 6571
 HEAP32[$B + 12 >> 2] = $L; //@line 6573
 $1 = $B + 16 | 0; //@line 6574
 HEAP32[$B >> 2] = $1; //@line 6575
 $2 = $B + 8 | 0; //@line 6576
 HEAP32[$2 >> 2] = 0; //@line 6577
 $3 = $B + 4 | 0; //@line 6578
 HEAP32[$3 >> 2] = 1024; //@line 6579
 if ($sz >>> 0 <= 1024) {
  $12 = $1; //@line 6582
  $13 = 0; //@line 6582
  $11 = $12 + $13 | 0; //@line 6583
  STACKTOP = sp; //@line 6584
  return $11 | 0; //@line 6584
 }
 $$$i = $sz >>> 0 > 2048 ? $sz : 2048; //@line 6587
 $6 = _lua_newuserdata($L, $$$i) | 0; //@line 6588
 _memcpy($6 | 0, HEAP32[$B >> 2] | 0, HEAP32[$2 >> 2] | 0) | 0; //@line 6591
 if ((HEAP32[$B >> 2] | 0) != ($1 | 0)) _lua_remove($L, -2); //@line 6595
 HEAP32[$B >> 2] = $6; //@line 6597
 HEAP32[$3 >> 2] = $$$i; //@line 6598
 $12 = $6; //@line 6600
 $13 = HEAP32[$2 >> 2] | 0; //@line 6600
 $11 = $12 + $13 | 0; //@line 6601
 STACKTOP = sp; //@line 6602
 return $11 | 0; //@line 6602
}
function _lua_iscfunction($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $$0$i = 0, $1 = 0, $16 = 0, $17 = 0, $21 = 0, $29 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 930
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 932
 do if (($idx | 0) > 0) {
  $4 = (HEAP32[$1 >> 2] | 0) + ($idx << 4) | 0; //@line 937
  $$0$i = $4 >>> 0 < (HEAP32[$L + 8 >> 2] | 0) >>> 0 ? $4 : 8048; //@line 942
 } else {
  if (($idx | 0) >= -1000999) {
   $$0$i = (HEAP32[$L + 8 >> 2] | 0) + ($idx << 4) | 0; //@line 949
   break;
  }
  if (($idx | 0) == -1001e3) {
   $$0$i = (HEAP32[$L + 12 >> 2] | 0) + 40 | 0; //@line 957
   break;
  }
  $16 = -1001e3 - $idx | 0; //@line 960
  $17 = HEAP32[$1 >> 2] | 0; //@line 961
  if ((HEAP32[$17 + 8 >> 2] | 0) == 22) $$0$i = 8048; //@line 966
 else {
   $21 = HEAP32[$17 >> 2] | 0; //@line 968
   if (($16 | 0) > (HEAPU8[$21 + 6 >> 0] | 0 | 0)) $$0$i = 8048; //@line 974
 else $$0$i = $21 + ($16 + -1 << 4) + 16 | 0; //@line 978
  }
 } while (0);
 $29 = HEAP32[$$0$i + 8 >> 2] | 0; //@line 984
 STACKTOP = sp; //@line 989
 return (($29 | 0) == 22 | ($29 | 0) == 102) & 1 | 0; //@line 989
}
function _luaX_newstring($ls, $str, $l) {
 $ls = $ls | 0;
 $str = $str | 0;
 $l = $l | 0;
 var $1 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $ts$0 = 0, sp = 0;
 sp = STACKTOP; //@line 3043
 $1 = HEAP32[$ls + 52 >> 2] | 0; //@line 3045
 $2 = _luaS_newlstr($1, $str, $l) | 0; //@line 3046
 $3 = $1 + 8 | 0; //@line 3047
 $4 = HEAP32[$3 >> 2] | 0; //@line 3048
 HEAP32[$3 >> 2] = $4 + 16; //@line 3050
 HEAP32[$4 >> 2] = $2; //@line 3051
 HEAP32[$4 + 8 >> 2] = HEAPU8[$2 + 4 >> 0] | 0 | 64; //@line 3057
 $17 = _luaH_set($1, HEAP32[(HEAP32[$ls + 48 >> 2] | 0) + 4 >> 2] | 0, (HEAP32[$3 >> 2] | 0) + -16 | 0) | 0; //@line 3064
 $18 = $17 + 8 | 0; //@line 3065
 if (!(HEAP32[$18 >> 2] | 0)) {
  HEAP32[$17 >> 2] = 1; //@line 3069
  HEAP32[$18 >> 2] = 1; //@line 3070
  if ((HEAP32[(HEAP32[$1 + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) {
   _luaC_step($1); //@line 3077
   $ts$0 = $2; //@line 3078
  } else $ts$0 = $2; //@line 3080
 } else $ts$0 = HEAP32[$17 + 16 >> 2] | 0; //@line 3085
 HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -16; //@line 3089
 STACKTOP = sp; //@line 3090
 return $ts$0 | 0; //@line 3090
}
function _read_line($L, $f, $chop) {
 $L = $L | 0;
 $f = $f | 0;
 $chop = $chop | 0;
 var $$0 = 0, $0 = 0, $3 = 0, $7 = 0, $8 = 0, $b = 0, sp = 0;
 sp = STACKTOP; //@line 2366
 STACKTOP = STACKTOP + 1040 | 0; //@line 2367
 $b = sp; //@line 2368
 _luaL_buffinit($L, $b); //@line 2369
 $0 = _luaL_prepbuffsize($b, 1024) | 0; //@line 2370
 L1 : do if (_fgets($0 | 0, 1024, $f | 0) | 0) {
  $3 = $b + 8 | 0; //@line 2375
  $7 = $0; //@line 2376
  while (1) {
   $8 = _strlen($7 | 0) | 0; //@line 2378
   if ($8) if ((HEAP8[$7 + ($8 + -1) >> 0] | 0) == 10) break;
   HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + $8; //@line 2391
   $7 = _luaL_prepbuffsize($b, 1024) | 0; //@line 2392
   if (!(_fgets($7 | 0, 1024, $f | 0) | 0)) break L1;
  }
  HEAP32[$3 >> 2] = $8 - $chop + (HEAP32[$3 >> 2] | 0); //@line 2404
  _luaL_pushresult($b); //@line 2405
  $$0 = 1; //@line 2406
  STACKTOP = sp; //@line 2407
  return $$0 | 0; //@line 2407
 } while (0);
 _luaL_pushresult($b); //@line 2410
 $$0 = (_lua_rawlen($L, -1) | 0) != 0 & 1; //@line 2414
 STACKTOP = sp; //@line 2415
 return $$0 | 0; //@line 2415
}
function _tremove($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $pos$0$lcssa = 0, $pos$02 = 0, sp = 0, $pos$02$looptemp = 0;
 sp = STACKTOP; //@line 18275
 _luaL_checktype($L, 1, 5); //@line 18276
 $0 = _luaL_len($L, 1) | 0; //@line 18277
 $1 = _luaL_optinteger($L, 2, $0) | 0; //@line 18278
 if (($1 | 0) != ($0 | 0)) if (($1 | 0) < 1 | ($1 | 0) > ($0 + 1 | 0)) _luaL_argerror($L, 1, 11112) | 0; //@line 18286
 _lua_rawgeti($L, 1, $1); //@line 18289
 if (($1 | 0) < ($0 | 0)) $pos$02 = $1; //@line 18292
 else {
  $pos$0$lcssa = $1; //@line 18294
  _lua_pushnil($L); //@line 18295
  _lua_rawseti($L, 1, $pos$0$lcssa); //@line 18296
  STACKTOP = sp; //@line 18297
  return 1; //@line 18297
 }
 do {
  $pos$02$looptemp = $pos$02;
  $pos$02 = $pos$02 + 1 | 0; //@line 18300
  _lua_rawgeti($L, 1, $pos$02); //@line 18301
  _lua_rawseti($L, 1, $pos$02$looptemp); //@line 18302
 } while (($pos$02 | 0) != ($0 | 0));
 $pos$0$lcssa = $0; //@line 18305
 _lua_pushnil($L); //@line 18311
 _lua_rawseti($L, 1, $pos$0$lcssa); //@line 18312
 STACKTOP = sp; //@line 18313
 return 1; //@line 18313
}
function _strtod($s, $p) {
 $s = $s | 0;
 $p = $p | 0;
 var $0 = 0, $1 = 0, $12 = 0, $16 = 0, $4 = 0.0, $f$i = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP; //@line 16692
 STACKTOP = STACKTOP + 112 | 0; //@line 16693
 $f$i = sp; //@line 16694
 dest = $f$i + 0 | 0; //@line 16695
 stop = dest + 112 | 0; //@line 16695
 do {
  HEAP32[dest >> 2] = 0; //@line 16695
  dest = dest + 4 | 0; //@line 16695
 } while ((dest | 0) < (stop | 0));
 $0 = $f$i + 4 | 0; //@line 16696
 HEAP32[$0 >> 2] = $s; //@line 16697
 $1 = $f$i + 8 | 0; //@line 16698
 HEAP32[$1 >> 2] = -1; //@line 16699
 HEAP32[$f$i + 44 >> 2] = $s; //@line 16701
 HEAP32[$f$i + 76 >> 2] = -1; //@line 16703
 ___shlim($f$i, 0); //@line 16704
 $4 = +___floatscan($f$i, 1, 1); //@line 16705
 $12 = (HEAP32[$0 >> 2] | 0) - (HEAP32[$1 >> 2] | 0) + (HEAP32[$f$i + 108 >> 2] | 0) | 0; //@line 16713
 if (!$p) {
  STACKTOP = sp; //@line 16716
  return +$4;
 }
 if (!$12) $16 = $s; //@line 16720
 else $16 = $s + $12 | 0; //@line 16723
 HEAP32[$p >> 2] = $16; //@line 16725
 STACKTOP = sp; //@line 16726
 return +$4;
}
function _lua_callk($L, $nargs, $nresults, $ctx, $k) {
 $L = $L | 0;
 $nargs = $nargs | 0;
 $nresults = $nresults | 0;
 $ctx = $ctx | 0;
 $k = $k | 0;
 var $0 = 0, $16 = 0, $18 = 0, $3 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 4309
 $0 = $L + 8 | 0; //@line 4310
 $3 = (HEAP32[$0 >> 2] | 0) + (~$nargs << 4) | 0; //@line 4313
 if (!$k) label = 4; //@line 4316
 else if (!(HEAP16[$L + 36 >> 1] | 0)) {
  $8 = $L + 16 | 0; //@line 4322
  HEAP32[(HEAP32[$8 >> 2] | 0) + 28 >> 2] = $k; //@line 4325
  HEAP32[(HEAP32[$8 >> 2] | 0) + 24 >> 2] = $ctx; //@line 4328
  _luaD_call($L, $3, $nresults, 1); //@line 4329
 } else label = 4; //@line 4331
 if ((label | 0) == 4) _luaD_call($L, $3, $nresults, 0); //@line 4335
 if (($nresults | 0) != -1) {
  STACKTOP = sp; //@line 4339
  return;
 }
 $16 = (HEAP32[$L + 16 >> 2] | 0) + 4 | 0; //@line 4343
 $18 = HEAP32[$0 >> 2] | 0; //@line 4345
 if ((HEAP32[$16 >> 2] | 0) >>> 0 >= $18 >>> 0) {
  STACKTOP = sp; //@line 4348
  return;
 }
 HEAP32[$16 >> 2] = $18; //@line 4350
 STACKTOP = sp; //@line 4351
 return;
}
function _lua_getstack($L, $level, $ar) {
 $L = $L | 0;
 $level = $level | 0;
 $ar = $ar | 0;
 var $$0 = 0, $$015 = 0, $3 = 0, $ci$0$lcssa10 = 0, $ci$04 = 0, $ci$06 = 0, sp = 0;
 sp = STACKTOP; //@line 13892
 L1 : do if (($level | 0) < 0) $$0 = 0; //@line 13896
 else {
  $ci$04 = HEAP32[$L + 16 >> 2] | 0; //@line 13899
  if (($level | 0) > 0) {
   $3 = $L + 72 | 0; //@line 13902
   $$015 = $level; //@line 13903
   $ci$06 = $ci$04; //@line 13903
   do {
    if (($ci$06 | 0) == ($3 | 0)) {
     $$0 = 0; //@line 13907
     break L1;
    }
    $$015 = $$015 + -1 | 0; //@line 13910
    $ci$06 = HEAP32[$ci$06 + 8 >> 2] | 0; //@line 13912
   } while (($$015 | 0) > 0);
   if (!$$015) $ci$0$lcssa10 = $ci$06; //@line 13922
 else {
    $$0 = 0; //@line 13924
    break;
   }
  } else $ci$0$lcssa10 = $ci$04; //@line 13928
  if (($ci$0$lcssa10 | 0) == ($L + 72 | 0)) $$0 = 0; //@line 13933
 else {
   HEAP32[$ar + 96 >> 2] = $ci$0$lcssa10; //@line 13936
   $$0 = 1; //@line 13937
  }
 } while (0);
 STACKTOP = sp; //@line 13941
 return $$0 | 0; //@line 13941
}
function _realloc($oldmem, $bytes) {
 $oldmem = $oldmem | 0;
 $bytes = $bytes | 0;
 var $12 = 0, $15 = 0, $20 = 0, $8 = 0, $9 = 0, $mem$0 = 0, sp = 0;
 sp = STACKTOP; //@line 9767
 do if (!$oldmem) $mem$0 = _malloc($bytes) | 0; //@line 9772
 else {
  if ($bytes >>> 0 > 4294967231) {
   HEAP32[(___errno_location() | 0) >> 2] = 12; //@line 9777
   $mem$0 = 0; //@line 9778
   break;
  }
  if ($bytes >>> 0 < 11) $8 = 16; //@line 9783
 else $8 = $bytes + 11 & -8; //@line 9787
  $9 = _try_realloc_chunk($oldmem + -8 | 0, $8) | 0; //@line 9790
  if ($9) {
   $mem$0 = $9 + 8 | 0; //@line 9794
   break;
  }
  $12 = _malloc($bytes) | 0; //@line 9797
  if (!$12) $mem$0 = 0; //@line 9800
 else {
   $15 = HEAP32[$oldmem + -4 >> 2] | 0; //@line 9803
   $20 = ($15 & -8) - (($15 & 3 | 0) == 0 ? 8 : 4) | 0; //@line 9808
   _memcpy($12 | 0, $oldmem | 0, ($20 >>> 0 < $bytes >>> 0 ? $20 : $bytes) | 0) | 0; //@line 9811
   _free($oldmem); //@line 9812
   $mem$0 = $12; //@line 9813
  }
 } while (0);
 STACKTOP = sp; //@line 9817
 return $mem$0 | 0; //@line 9817
}
function _setpath($L, $fieldname, $envname1, $envname2, $def) {
 $L = $L | 0;
 $fieldname = $fieldname | 0;
 $envname1 = $envname1 | 0;
 $envname2 = $envname2 | 0;
 $def = $def | 0;
 var $0 = 0, $2 = 0, $4 = 0, $path$01 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 6449
 $0 = _getenv($envname1 | 0) | 0; //@line 6450
 if (!$0) {
  $2 = _getenv($envname2 | 0) | 0; //@line 6453
  if ($2) {
   $path$01 = $2; //@line 6456
   label = 3; //@line 6457
  }
 } else {
  $path$01 = $0; //@line 6460
  label = 3; //@line 6461
 }
 if ((label | 0) == 3) {
  _lua_getfield($L, -1001e3, 7688); //@line 6464
  $4 = _lua_toboolean($L, -1) | 0; //@line 6465
  _lua_settop($L, -2); //@line 6466
  if (!$4) {
   _luaL_gsub($L, _luaL_gsub($L, $path$01, 7664, 7672) | 0, 7680, $def) | 0; //@line 6470
   _lua_remove($L, -2); //@line 6471
   _lua_setfield($L, -2, $fieldname); //@line 6472
   STACKTOP = sp; //@line 6473
   return;
  }
 }
 _lua_pushstring($L, $def) | 0; //@line 6476
 _lua_setfield($L, -2, $fieldname); //@line 6477
 STACKTOP = sp; //@line 6478
 return;
}
function _luaL_error($L, $fmt, $varargs) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $3 = 0, $ar$i = 0, $argp = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 5833
 STACKTOP = STACKTOP + 128 | 0; //@line 5834
 $vararg_buffer = sp; //@line 5835
 $ar$i = sp + 24 | 0; //@line 5836
 $argp = sp + 8 | 0; //@line 5837
 HEAP32[$argp >> 2] = $varargs; //@line 5838
 if (_lua_getstack($L, 1, $ar$i) | 0) {
  _lua_getinfo($L, 240, $ar$i) | 0; //@line 5842
  $3 = HEAP32[$ar$i + 20 >> 2] | 0; //@line 5844
  if (($3 | 0) > 0) {
   HEAP32[$vararg_buffer >> 2] = $ar$i + 36; //@line 5848
   HEAP32[$vararg_buffer + 4 >> 2] = $3; //@line 5850
   _lua_pushfstring($L, 248, $vararg_buffer) | 0; //@line 5851
   _lua_pushvfstring($L, $fmt, $argp) | 0; //@line 5852
   _lua_concat($L, 2); //@line 5853
   _lua_error($L) | 0; //@line 5854
  }
 }
 _lua_pushlstring($L, 256, 0) | 0; //@line 5858
 _lua_pushvfstring($L, $fmt, $argp) | 0; //@line 5859
 _lua_concat($L, 2); //@line 5860
 _lua_error($L) | 0; //@line 5861
 return 0; //@line 5863
}
function _luaC_barrierproto_($L, $p, $c) {
 $L = $L | 0;
 $p = $p | 0;
 $c = $c | 0;
 var $12 = 0, $25 = 0, $26 = 0, $31 = 0, $7 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 18916
 if (HEAP32[$p + 32 >> 2] | 0) {
  $25 = HEAP32[$L + 12 >> 2] | 0; //@line 18922
  $26 = $p + 5 | 0; //@line 18923
  HEAP8[$26 >> 0] = (HEAPU8[$26 >> 0] | 0) & 251; //@line 18928
  $31 = $25 + 88 | 0; //@line 18929
  HEAP32[$p + 72 >> 2] = HEAP32[$31 >> 2]; //@line 18932
  HEAP32[$31 >> 2] = $p; //@line 18933
  STACKTOP = sp; //@line 18934
  return;
 }
 if (!(HEAP8[$c + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 18941
  return;
 }
 $7 = $p + 5 | 0; //@line 18943
 $8 = HEAP8[$7 >> 0] | 0; //@line 18944
 if (!($8 & 4)) {
  STACKTOP = sp; //@line 18948
  return;
 }
 $12 = HEAP32[$L + 12 >> 2] | 0; //@line 18951
 if ((HEAPU8[$12 + 61 >> 0] | 0) < 2) {
  _reallymarkobject($12, $c); //@line 18956
  STACKTOP = sp; //@line 18957
  return;
 } else {
  HEAP8[$7 >> 0] = (HEAPU8[$12 + 60 >> 0] | 0) & 3 | $8 & 184; //@line 18967
  STACKTOP = sp; //@line 18968
  return;
 }
}
function _luaM_realloc_($L, $block, $osize, $nsize) {
 $L = $L | 0;
 $block = $block | 0;
 $osize = $osize | 0;
 $nsize = $nsize | 0;
 var $1 = 0, $14 = 0, $16 = 0, $2 = 0, $4 = 0, $6 = 0, $newblock$1 = 0, sp = 0;
 sp = STACKTOP; //@line 6335
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 6337
 $2 = ($block | 0) != 0; //@line 6338
 $4 = $1 + 4 | 0; //@line 6340
 $6 = FUNCTION_TABLE_iiiii[HEAP32[$1 >> 2] & 31](HEAP32[$4 >> 2] | 0, $block, $osize, $nsize) | 0; //@line 6342
 if (($6 | 0) != 0 | ($nsize | 0) == 0) $newblock$1 = $6; //@line 6347
 else {
  if (!(HEAP8[$1 + 63 >> 0] | 0)) _luaD_throw($L, 4); //@line 6353
  _luaC_fullgc($L, 1); //@line 6356
  $14 = FUNCTION_TABLE_iiiii[HEAP32[$1 >> 2] & 31](HEAP32[$4 >> 2] | 0, $block, $osize, $nsize) | 0; //@line 6359
  if (!$14) _luaD_throw($L, 4); //@line 6362
 else $newblock$1 = $14; //@line 6365
 }
 $16 = $1 + 12 | 0; //@line 6368
 HEAP32[$16 >> 2] = ($2 ? 0 - $osize | 0 : 0) + $nsize + (HEAP32[$16 >> 2] | 0); //@line 6374
 STACKTOP = sp; //@line 6375
 return $newblock$1 | 0; //@line 6375
}
function _luaL_openlibs($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 1848
 _luaL_requiref($L, 4632, 163, 1); //@line 1849
 _lua_settop($L, -2); //@line 1850
 _luaL_requiref($L, 4640, 164, 1); //@line 1851
 _lua_settop($L, -2); //@line 1852
 _luaL_requiref($L, 4648, 165, 1); //@line 1853
 _lua_settop($L, -2); //@line 1854
 _luaL_requiref($L, 4664, 166, 1); //@line 1855
 _lua_settop($L, -2); //@line 1856
 _luaL_requiref($L, 4672, 167, 1); //@line 1857
 _lua_settop($L, -2); //@line 1858
 _luaL_requiref($L, 4680, 168, 1); //@line 1859
 _lua_settop($L, -2); //@line 1860
 _luaL_requiref($L, 4688, 169, 1); //@line 1861
 _lua_settop($L, -2); //@line 1862
 _luaL_requiref($L, 4696, 170, 1); //@line 1863
 _lua_settop($L, -2); //@line 1864
 _luaL_requiref($L, 4704, 171, 1); //@line 1865
 _lua_settop($L, -2); //@line 1866
 _luaL_requiref($L, 4712, 172, 1); //@line 1867
 _lua_settop($L, -2); //@line 1868
 _luaL_getsubtable($L, -1001e3, 4616) | 0; //@line 1869
 _lua_settop($L, -2); //@line 1870
 STACKTOP = sp; //@line 1871
 return;
}
function _str_reverse($L) {
 $L = $L | 0;
 var $$lcssa = 0, $0 = 0, $12 = 0, $2 = 0, $3 = 0, $7 = 0, $b = 0, $i$01 = 0, $l = 0, sp = 0;
 sp = STACKTOP; //@line 14588
 STACKTOP = STACKTOP + 1056 | 0; //@line 14589
 $l = sp + 1040 | 0; //@line 14590
 $b = sp; //@line 14591
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 14592
 $2 = _luaL_buffinitsize($L, $b, HEAP32[$l >> 2] | 0) | 0; //@line 14594
 $3 = HEAP32[$l >> 2] | 0; //@line 14595
 if (!$3) {
  $$lcssa = 0; //@line 14598
  _luaL_pushresultsize($b, $$lcssa); //@line 14599
  STACKTOP = sp; //@line 14600
  return 1; //@line 14600
 } else {
  $7 = $3; //@line 14602
  $i$01 = 0; //@line 14602
 }
 while (1) {
  HEAP8[$2 + $i$01 >> 0] = HEAP8[$0 + ($7 + ~$i$01) >> 0] | 0; //@line 14610
  $i$01 = $i$01 + 1 | 0; //@line 14611
  $12 = HEAP32[$l >> 2] | 0; //@line 14612
  if ($i$01 >>> 0 >= $12 >>> 0) {
   $$lcssa = $12; //@line 14617
   break;
  } else $7 = $12; //@line 14615
 }
 _luaL_pushresultsize($b, $$lcssa); //@line 14621
 STACKTOP = sp; //@line 14622
 return 1; //@line 14622
}
function _loadfunc($L, $filename, $modname) {
 $L = $L | 0;
 $filename = $filename | 0;
 $modname = $modname | 0;
 var $$0 = 0, $$01 = 0, $0 = 0, $1 = 0, $8 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 6797
 STACKTOP = STACKTOP + 16 | 0; //@line 6798
 $vararg_buffer1 = sp; //@line 6799
 $0 = _luaL_gsub($L, $modname, 7792, 7800) | 0; //@line 6800
 $1 = _strchr($0, 45) | 0; //@line 6801
 do if (!$1) $$01 = $0; //@line 6805
 else {
  HEAP32[$vararg_buffer1 >> 2] = _lua_pushlstring($L, $0, $1 - $0 | 0) | 0; //@line 6811
  $8 = _ll_loadfunc($L, $filename, _lua_pushfstring($L, 7808, $vararg_buffer1) | 0) | 0; //@line 6813
  if (($8 | 0) == 2) {
   $$01 = $1 + 1 | 0; //@line 6817
   break;
  } else {
   $$0 = $8; //@line 6820
   STACKTOP = sp; //@line 6821
   return $$0 | 0; //@line 6821
  }
 } while (0);
 HEAP32[$vararg_buffer1 >> 2] = $$01; //@line 6825
 $$0 = _ll_loadfunc($L, $filename, _lua_pushfstring($L, 7808, $vararg_buffer1) | 0) | 0; //@line 6828
 STACKTOP = sp; //@line 6829
 return $$0 | 0; //@line 6829
}
function _luaL_checkudata($L, $ud, $tname) {
 $L = $L | 0;
 $ud = $ud | 0;
 $tname = $tname | 0;
 var $$$i = 0, $$0$i1 = 0, $0 = 0, $5 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6027
 STACKTOP = STACKTOP + 16 | 0; //@line 6028
 $vararg_buffer = sp; //@line 6029
 $0 = _lua_touserdata($L, $ud) | 0; //@line 6030
 if ($0) if (_lua_getmetatable($L, $ud) | 0) {
  _lua_getfield($L, -1001e3, $tname); //@line 6036
  $5 = (_lua_rawequal($L, -1, -2) | 0) == 0; //@line 6038
  $$$i = $5 ? 0 : $0; //@line 6039
  _lua_settop($L, -3); //@line 6040
  if ($$$i) {
   $$0$i1 = $$$i; //@line 6043
   STACKTOP = sp; //@line 6044
   return $$0$i1 | 0; //@line 6044
  }
 }
 $8 = _lua_typename($L, _lua_type($L, $ud) | 0) | 0; //@line 6049
 HEAP32[$vararg_buffer >> 2] = $tname; //@line 6050
 HEAP32[$vararg_buffer + 4 >> 2] = $8; //@line 6052
 _luaL_argerror($L, $ud, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6054
 $$0$i1 = 0; //@line 6055
 STACKTOP = sp; //@line 6056
 return $$0$i1 | 0; //@line 6056
}
function _luaK_setlist($fs, $base, $nelems, $tostore) {
 $fs = $fs | 0;
 $base = $base | 0;
 $nelems = $nelems | 0;
 $tostore = $tostore | 0;
 var $2 = 0, $21 = 0, $22 = 0, $23 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 12638
 $2 = (($nelems + -1 | 0) / 50 | 0) + 1 | 0; //@line 12641
 $4 = ($tostore | 0) == -1 ? 0 : $tostore; //@line 12643
 if (($2 | 0) < 512) {
  _luaK_code($fs, $base << 6 | $4 << 23 | $2 << 14 | 36) | 0; //@line 12652
  $21 = $base + 1 | 0; //@line 12653
  $22 = $21 & 255; //@line 12654
  $23 = $fs + 48 | 0; //@line 12655
  HEAP8[$23 >> 0] = $22; //@line 12656
  STACKTOP = sp; //@line 12657
  return;
 }
 if (($2 | 0) >= 67108864) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2360); //@line 12663
 _luaK_code($fs, $base << 6 | $4 << 23 | 36) | 0; //@line 12670
 _luaK_code($fs, $2 << 6 | 39) | 0; //@line 12673
 $21 = $base + 1 | 0; //@line 12674
 $22 = $21 & 255; //@line 12675
 $23 = $fs + 48 | 0; //@line 12676
 HEAP8[$23 >> 0] = $22; //@line 12677
 STACKTOP = sp; //@line 12678
 return;
}
function _luaL_openlib($L, $libname, $l, $nup) {
 $L = $L | 0;
 $libname = $libname | 0;
 $l = $l | 0;
 $nup = $nup | 0;
 var $$01$i2 = 0, $4 = 0, $size$0$lcssa$i = 0, $size$02$i1 = 0, sp = 0;
 sp = STACKTOP; //@line 7147
 _luaL_checkversion_($L, 502.0); //@line 7148
 if ($libname) {
  if (!$l) $size$0$lcssa$i = 0; //@line 7153
 else if (!(HEAP32[$l >> 2] | 0)) $size$0$lcssa$i = 0; //@line 7158
 else {
   $$01$i2 = $l; //@line 7160
   $size$02$i1 = 0; //@line 7160
   while (1) {
    $4 = $size$02$i1 + 1 | 0; //@line 7162
    $$01$i2 = $$01$i2 + 8 | 0; //@line 7163
    if (!(HEAP32[$$01$i2 >> 2] | 0)) {
     $size$0$lcssa$i = $4; //@line 7167
     break;
    } else $size$02$i1 = $4; //@line 7170
   }
  }
  _luaL_pushmodule($L, $libname, $size$0$lcssa$i); //@line 7175
  _lua_insert($L, ~$nup); //@line 7177
 }
 if (!$l) {
  _lua_settop($L, ~$nup); //@line 7182
  STACKTOP = sp; //@line 7183
  return;
 } else {
  _luaL_setfuncs($L, $l, $nup); //@line 7185
  STACKTOP = sp; //@line 7186
  return;
 }
}
function _auxresume($L, $co, $narg) {
 $L = $L | 0;
 $co = $co | 0;
 $narg = $narg | 0;
 var $$0 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 13099
 do if (!(_lua_checkstack($co, $narg) | 0)) {
  _lua_pushlstring($L, 2544, 28) | 0; //@line 13104
  $$0 = -1; //@line 13105
 } else {
  if (!(_lua_status($co) | 0)) if (!(_lua_gettop($co) | 0)) {
   _lua_pushlstring($L, 2576, 28) | 0; //@line 13113
   $$0 = -1; //@line 13114
   break;
  }
  _lua_xmove($L, $co, $narg); //@line 13118
  if ((_lua_resume($co, $L, $narg) | 0) >>> 0 >= 2) {
   _lua_xmove($co, $L, 1); //@line 13122
   $$0 = -1; //@line 13123
   break;
  }
  $8 = _lua_gettop($co) | 0; //@line 13126
  if (!(_lua_checkstack($L, $8 + 1 | 0) | 0)) {
   _lua_settop($co, ~$8); //@line 13132
   _lua_pushlstring($L, 2608, 26) | 0; //@line 13133
   $$0 = -1; //@line 13134
   break;
  } else {
   _lua_xmove($co, $L, $8); //@line 13137
   $$0 = $8; //@line 13138
   break;
  }
 } while (0);
 STACKTOP = sp; //@line 13143
 return $$0 | 0; //@line 13143
}
function _db_setlocal($L) {
 $L = $L | 0;
 var $$0 = 0, $$0$i = 0, $3 = 0, $4 = 0, $9 = 0, $ar = 0, sp = 0;
 sp = STACKTOP; //@line 13705
 STACKTOP = STACKTOP + 112 | 0; //@line 13706
 $ar = sp; //@line 13707
 if ((_lua_type($L, 1) | 0) == 8) {
  $$0$i = _lua_tothread($L, 1) | 0; //@line 13712
  $4 = 1; //@line 13712
 } else {
  $$0$i = $L; //@line 13714
  $4 = 0; //@line 13714
 }
 $3 = $4 + 1 | 0; //@line 13716
 if (!(_lua_getstack($$0$i, _luaL_checkinteger($L, $3) | 0, $ar) | 0)) {
  $$0 = _luaL_argerror($L, $3, 3344) | 0; //@line 13722
  STACKTOP = sp; //@line 13723
  return $$0 | 0; //@line 13723
 } else {
  $9 = $4 + 3 | 0; //@line 13725
  _luaL_checkany($L, $9); //@line 13726
  _lua_settop($L, $9); //@line 13727
  _lua_xmove($L, $$0$i, 1); //@line 13728
  _lua_pushstring($L, _lua_setlocal($$0$i, $ar, _luaL_checkinteger($L, $4 | 2) | 0) | 0) | 0; //@line 13732
  $$0 = 1; //@line 13733
  STACKTOP = sp; //@line 13734
  return $$0 | 0; //@line 13734
 }
 return 0; //@line 13736
}
function _luaF_newproto($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 18561
 $0 = _luaC_newobj($L, 9, 80, 0, 0) | 0; //@line 18562
 HEAP32[$0 + 8 >> 2] = 0; //@line 18564
 HEAP32[$0 + 44 >> 2] = 0; //@line 18566
 HEAP32[$0 + 16 >> 2] = 0; //@line 18568
 HEAP32[$0 + 56 >> 2] = 0; //@line 18570
 HEAP32[$0 + 12 >> 2] = 0; //@line 18572
 HEAP32[$0 + 32 >> 2] = 0; //@line 18574
 HEAP32[$0 + 48 >> 2] = 0; //@line 18576
 HEAP32[$0 + 20 >> 2] = 0; //@line 18578
 HEAP32[$0 + 52 >> 2] = 0; //@line 18580
 HEAP32[$0 + 28 >> 2] = 0; //@line 18582
 HEAP32[$0 + 40 >> 2] = 0; //@line 18584
 HEAP8[$0 + 76 >> 0] = 0; //@line 18586
 HEAP8[$0 + 77 >> 0] = 0; //@line 18588
 HEAP8[$0 + 78 >> 0] = 0; //@line 18590
 HEAP32[$0 + 24 >> 2] = 0; //@line 18592
 HEAP32[$0 + 60 >> 2] = 0; //@line 18594
 HEAP32[$0 + 64 >> 2] = 0; //@line 18596
 HEAP32[$0 + 68 >> 2] = 0; //@line 18598
 HEAP32[$0 + 36 >> 2] = 0; //@line 18600
 STACKTOP = sp; //@line 18601
 return $0 | 0; //@line 18601
}
function _luaK_patchclose($fs, $list, $level) {
 $fs = $fs | 0;
 $list = $list | 0;
 $level = $level | 0;
 var $$01 = 0, $3 = 0, $4 = 0, $5 = 0, $7 = 0, $fs$idx$val$idx$val = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 9090
 if (($list | 0) == -1) {
  STACKTOP = sp; //@line 9093
  return;
 }
 $fs$idx$val$idx$val = HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0; //@line 9097
 $3 = ($level << 6) + 64 & 16320; //@line 9100
 $$01 = $list; //@line 9101
 while (1) {
  $4 = $fs$idx$val$idx$val + ($$01 << 2) | 0; //@line 9103
  $5 = HEAP32[$4 >> 2] | 0; //@line 9104
  $7 = ($5 >>> 14) + -131071 | 0; //@line 9106
  if (($7 | 0) == -1) break;
  $$01 = $$01 + 1 + $7 | 0; //@line 9112
  HEAP32[$4 >> 2] = $5 & -16321 | $3; //@line 9115
  if (($$01 | 0) == -1) {
   label = 6; //@line 9118
   break;
  }
 }
 if ((label | 0) == 6) {
  STACKTOP = sp; //@line 9125
  return;
 }
 HEAP32[$4 >> 2] = $5 & -16321 | $3; //@line 9129
 STACKTOP = sp; //@line 9130
 return;
}
function _luaB_costatus($L) {
 $L = $L | 0;
 var $0 = 0, $3 = 0, $ar = 0, sp = 0;
 sp = STACKTOP; //@line 13010
 STACKTOP = STACKTOP + 112 | 0; //@line 13011
 $ar = sp; //@line 13012
 $0 = _lua_tothread($L, 1) | 0; //@line 13013
 if (!$0) _luaL_argerror($L, 1, 2640) | 0; //@line 13016
 do if (($0 | 0) == ($L | 0)) _lua_pushlstring($L, 2512, 7) | 0; //@line 13021
 else {
  $3 = _lua_status($0) | 0; //@line 13023
  if (($3 | 0) == 1) {
   _lua_pushlstring($L, 2664, 9) | 0; //@line 13025
   break;
  } else if (!$3) {
   if ((_lua_getstack($0, 0, $ar) | 0) > 0) {
    _lua_pushlstring($L, 2680, 6) | 0; //@line 13031
    break;
   }
   if (!(_lua_gettop($0) | 0)) {
    _lua_pushlstring($L, 2688, 4) | 0; //@line 13037
    break;
   } else {
    _lua_pushlstring($L, 2664, 9) | 0; //@line 13040
    break;
   }
  } else {
   _lua_pushlstring($L, 2688, 4) | 0; //@line 13044
   break;
  }
 } while (0);
 STACKTOP = sp; //@line 13049
 return 1; //@line 13049
}
function _check_match($ls, $what, $who, $where) {
 $ls = $ls | 0;
 $what = $what | 0;
 $who = $who | 0;
 $where = $where | 0;
 var $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 10317
 STACKTOP = STACKTOP + 16 | 0; //@line 10318
 $vararg_buffer = sp; //@line 10319
 if ((HEAP32[$ls + 16 >> 2] | 0) == ($what | 0)) {
  _luaX_next($ls); //@line 10324
  STACKTOP = sp; //@line 10325
  return;
 }
 if ((HEAP32[$ls + 4 >> 2] | 0) == ($where | 0)) _error_expected($ls, $what); //@line 10331
 else {
  $7 = HEAP32[$ls + 52 >> 2] | 0; //@line 10335
  $8 = _luaX_token2str($ls, $what) | 0; //@line 10336
  $9 = _luaX_token2str($ls, $who) | 0; //@line 10337
  HEAP32[$vararg_buffer >> 2] = $8; //@line 10338
  HEAP32[$vararg_buffer + 4 >> 2] = $9; //@line 10340
  HEAP32[$vararg_buffer + 8 >> 2] = $where; //@line 10342
  _luaX_syntaxerror($ls, _luaO_pushfstring($7, 9696, $vararg_buffer) | 0); //@line 10344
 }
}
function _str_upper($L) {
 $L = $L | 0;
 var $$lcssa = 0, $0 = 0, $12 = 0, $2 = 0, $b = 0, $i$01 = 0, $l = 0, sp = 0;
 sp = STACKTOP; //@line 14685
 STACKTOP = STACKTOP + 1056 | 0; //@line 14686
 $l = sp + 1040 | 0; //@line 14687
 $b = sp; //@line 14688
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 14689
 $2 = _luaL_buffinitsize($L, $b, HEAP32[$l >> 2] | 0) | 0; //@line 14691
 if (!(HEAP32[$l >> 2] | 0)) {
  $$lcssa = 0; //@line 14695
  _luaL_pushresultsize($b, $$lcssa); //@line 14696
  STACKTOP = sp; //@line 14697
  return 1; //@line 14697
 } else $i$01 = 0; //@line 14699
 do {
  HEAP8[$2 + $i$01 >> 0] = _toupper(HEAPU8[$0 + $i$01 >> 0] | 0) | 0; //@line 14708
  $i$01 = $i$01 + 1 | 0; //@line 14709
  $12 = HEAP32[$l >> 2] | 0; //@line 14710
 } while ($i$01 >>> 0 < $12 >>> 0);
 $$lcssa = $12; //@line 14715
 _luaL_pushresultsize($b, $$lcssa); //@line 14719
 STACKTOP = sp; //@line 14720
 return 1; //@line 14720
}
function _str_lower($L) {
 $L = $L | 0;
 var $$lcssa = 0, $0 = 0, $12 = 0, $2 = 0, $b = 0, $i$01 = 0, $l = 0, sp = 0;
 sp = STACKTOP; //@line 14471
 STACKTOP = STACKTOP + 1056 | 0; //@line 14472
 $l = sp + 1040 | 0; //@line 14473
 $b = sp; //@line 14474
 $0 = _luaL_checklstring($L, 1, $l) | 0; //@line 14475
 $2 = _luaL_buffinitsize($L, $b, HEAP32[$l >> 2] | 0) | 0; //@line 14477
 if (!(HEAP32[$l >> 2] | 0)) {
  $$lcssa = 0; //@line 14481
  _luaL_pushresultsize($b, $$lcssa); //@line 14482
  STACKTOP = sp; //@line 14483
  return 1; //@line 14483
 } else $i$01 = 0; //@line 14485
 do {
  HEAP8[$2 + $i$01 >> 0] = _tolower(HEAPU8[$0 + $i$01 >> 0] | 0) | 0; //@line 14494
  $i$01 = $i$01 + 1 | 0; //@line 14495
  $12 = HEAP32[$l >> 2] | 0; //@line 14496
 } while ($i$01 >>> 0 < $12 >>> 0);
 $$lcssa = $12; //@line 14501
 _luaL_pushresultsize($b, $$lcssa); //@line 14505
 STACKTOP = sp; //@line 14506
 return 1; //@line 14506
}
function _luaK_exp2anyreg($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $$0 = 0, $$pre$phi2Z2D = 0, $7 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 10621
 _luaK_dischargevars($fs, $e); //@line 10622
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $7 = $e + 8 | 0; //@line 10631
  $8 = HEAP32[$7 >> 2] | 0; //@line 10632
  if ((HEAP32[$e + 16 >> 2] | 0) == (HEAP32[$e + 20 >> 2] | 0)) {
   $$0 = $8; //@line 10634
   STACKTOP = sp; //@line 10635
   return $$0 | 0; //@line 10635
  }
  if (($8 | 0) < (HEAPU8[$fs + 46 >> 0] | 0 | 0)) $$pre$phi2Z2D = $7; //@line 10642
 else {
   _exp2reg($fs, $e, $8); //@line 10644
   $$0 = HEAP32[$7 >> 2] | 0; //@line 10646
   STACKTOP = sp; //@line 10647
   return $$0 | 0; //@line 10647
  }
 } else $$pre$phi2Z2D = $e + 8 | 0; //@line 10651
 _luaK_exp2nextreg($fs, $e); //@line 10653
 $$0 = HEAP32[$$pre$phi2Z2D >> 2] | 0; //@line 10655
 STACKTOP = sp; //@line 10656
 return $$0 | 0; //@line 10656
}
function _memcpy(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((num | 0) >= 4096) return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0; //@line 17029
 ret = dest | 0; //@line 17030
 if ((dest & 3) == (src & 3)) {
  while (dest & 3) {
   if (!num) return ret | 0; //@line 17033
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0; //@line 17034
   dest = dest + 1 | 0; //@line 17035
   src = src + 1 | 0; //@line 17036
   num = num - 1 | 0; //@line 17037
  }
  while ((num | 0) >= 4) {
   HEAP32[dest >> 2] = HEAP32[src >> 2]; //@line 17040
   dest = dest + 4 | 0; //@line 17041
   src = src + 4 | 0; //@line 17042
   num = num - 4 | 0; //@line 17043
  }
 }
 while ((num | 0) > 0) {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0; //@line 17047
  dest = dest + 1 | 0; //@line 17048
  src = src + 1 | 0; //@line 17049
  num = num - 1 | 0; //@line 17050
 }
 return ret | 0; //@line 17052
}
function _luaU_header($h) {
 $h = $h | 0;
 var $8 = 0, sp = 0;
 sp = STACKTOP; //@line 716
 HEAP8[$h >> 0] = 27; //@line 717
 HEAP8[$h + 1 >> 0] = 76; //@line 717
 HEAP8[$h + 2 >> 0] = 117; //@line 717
 HEAP8[$h + 3 >> 0] = 97; //@line 717
 HEAP8[$h + 4 >> 0] = 82; //@line 720
 HEAP8[$h + 5 >> 0] = 0; //@line 722
 HEAP8[$h + 6 >> 0] = 1; //@line 724
 HEAP8[$h + 7 >> 0] = 4; //@line 726
 HEAP8[$h + 8 >> 0] = 4; //@line 728
 HEAP8[$h + 9 >> 0] = 4; //@line 730
 HEAP8[$h + 10 >> 0] = 8; //@line 732
 $8 = $h + 12 | 0; //@line 733
 HEAP8[$h + 11 >> 0] = 0; //@line 734
 HEAP8[$8 + 0 >> 0] = HEAP8[11672] | 0; //@line 735
 HEAP8[$8 + 1 >> 0] = HEAP8[11673] | 0; //@line 735
 HEAP8[$8 + 2 >> 0] = HEAP8[11674] | 0; //@line 735
 HEAP8[$8 + 3 >> 0] = HEAP8[11675] | 0; //@line 735
 HEAP8[$8 + 4 >> 0] = HEAP8[11676] | 0; //@line 735
 HEAP8[$8 + 5 >> 0] = HEAP8[11677] | 0; //@line 735
 STACKTOP = sp; //@line 736
 return;
}
function _f_seek($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 2007
 STACKTOP = STACKTOP + 16 | 0; //@line 2008
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 2010
 if (!(HEAP32[$0 + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 2015
 $4 = HEAP32[$0 >> 2] | 0; //@line 2017
 $5 = _luaL_checkoption($L, 2, 5248, 5224) | 0; //@line 2018
 $6 = +_luaL_optnumber($L, 3, 0.0); //@line 2019
 $7 = ~~$6; //@line 2020
 if (!(+($7 | 0) == $6)) _luaL_argerror($L, 3, 5264) | 0; //@line 2024
 if (!(_fseek($4 | 0, $7 | 0, HEAP32[5208 + ($5 << 2) >> 2] | 0) | 0)) {
  _lua_pushnumber($L, +(_ftell($4 | 0) | 0)); //@line 2033
  $$0 = 1; //@line 2034
  STACKTOP = sp; //@line 2035
  return $$0 | 0; //@line 2035
 } else {
  $$0 = _luaL_fileresult($L, 0, 0) | 0; //@line 2038
  STACKTOP = sp; //@line 2039
  return $$0 | 0; //@line 2039
 }
 return 0; //@line 2041
}
function ___divdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $7$0 = 0, $7$1 = 0, $10$0 = 0;
 $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1; //@line 17129
 $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1; //@line 17130
 $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1; //@line 17131
 $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1; //@line 17132
 $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0; //@line 17133
 $4$1 = tempRet0; //@line 17134
 $7$0 = $2$0 ^ $1$0; //@line 17136
 $7$1 = $2$1 ^ $1$1; //@line 17137
 $10$0 = _i64Subtract((___udivmoddi4($4$0, $4$1, _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0, tempRet0, 0) | 0) ^ $7$0, tempRet0 ^ $7$1, $7$0, $7$1) | 0; //@line 17139
 return $10$0 | 0; //@line 17140
}
function _luaL_fileresult($L, $stat, $fname) {
 $L = $L | 0;
 $stat = $stat | 0;
 $fname = $fname | 0;
 var $$0 = 0, $1 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 5920
 STACKTOP = STACKTOP + 16 | 0; //@line 5921
 $vararg_buffer = sp; //@line 5922
 $1 = HEAP32[(___errno_location() | 0) >> 2] | 0; //@line 5924
 if ($stat) {
  _lua_pushboolean($L, 1); //@line 5927
  $$0 = 1; //@line 5928
  STACKTOP = sp; //@line 5929
  return $$0 | 0; //@line 5929
 }
 _lua_pushnil($L); //@line 5931
 $4 = _strerror($1 | 0) | 0; //@line 5933
 if (!$fname) _lua_pushstring($L, $4) | 0; //@line 5935
 else {
  HEAP32[$vararg_buffer >> 2] = $fname; //@line 5937
  HEAP32[$vararg_buffer + 4 >> 2] = $4; //@line 5939
  _lua_pushfstring($L, 264, $vararg_buffer) | 0; //@line 5940
 }
 _lua_pushinteger($L, $1); //@line 5942
 $$0 = 3; //@line 5943
 STACKTOP = sp; //@line 5944
 return $$0 | 0; //@line 5944
}
function _luaV_tostring($L, $obj) {
 $L = $L | 0;
 $obj = $obj | 0;
 var $$0 = 0, $0 = 0, $5 = 0, $s = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 797
 STACKTOP = STACKTOP + 48 | 0; //@line 798
 $vararg_buffer = sp; //@line 799
 $s = sp + 8 | 0; //@line 800
 $0 = $obj + 8 | 0; //@line 801
 if ((HEAP32[$0 >> 2] | 0) != 3) {
  $$0 = 0; //@line 805
  STACKTOP = sp; //@line 806
  return $$0 | 0; //@line 806
 }
 HEAPF64[tempDoublePtr >> 3] = +HEAPF64[$obj >> 3]; //@line 809
 HEAP32[$vararg_buffer >> 2] = HEAP32[tempDoublePtr >> 2]; //@line 809
 HEAP32[$vararg_buffer + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2]; //@line 809
 $5 = _luaS_newlstr($L, $s, _sprintf($s, 11792, $vararg_buffer) | 0) | 0; //@line 811
 HEAP32[$obj >> 2] = $5; //@line 812
 HEAP32[$0 >> 2] = HEAPU8[$5 + 4 >> 0] | 0 | 64; //@line 817
 $$0 = 1; //@line 818
 STACKTOP = sp; //@line 819
 return $$0 | 0; //@line 819
}
function _luaL_pushmodule($L, $modname, $sizehint) {
 $L = $L | 0;
 $modname = $modname | 0;
 $sizehint = $sizehint | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7050
 STACKTOP = STACKTOP + 16 | 0; //@line 7051
 $vararg_buffer = sp; //@line 7052
 _luaL_findtable($L, -1001e3, 520, 1) | 0; //@line 7053
 _lua_getfield($L, -1, $modname); //@line 7054
 if ((_lua_type($L, -1) | 0) == 5) {
  _lua_remove($L, -2); //@line 7058
  STACKTOP = sp; //@line 7059
  return;
 }
 _lua_settop($L, -2); //@line 7061
 _lua_rawgeti($L, -1001e3, 2); //@line 7062
 if (_luaL_findtable($L, 0, $modname, $sizehint) | 0) {
  HEAP32[$vararg_buffer >> 2] = $modname; //@line 7066
  _luaL_error($L, 528, $vararg_buffer) | 0; //@line 7067
 }
 _lua_pushvalue($L, -1); //@line 7069
 _lua_setfield($L, -3, $modname); //@line 7070
 _lua_remove($L, -2); //@line 7071
 STACKTOP = sp; //@line 7072
 return;
}
function _luaB_collectgarbage($L) {
 $L = $L | 0;
 var $$0 = 0, $2 = 0, $4 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 7667
 $2 = HEAP32[1944 + ((_luaL_checkoption($L, 1, 1824, 1760) | 0) << 2) >> 2] | 0; //@line 7670
 $4 = _lua_gc($L, $2, _luaL_optinteger($L, 2, 0) | 0) | 0; //@line 7672
 if (($2 | 0) == 9 | ($2 | 0) == 5) {
  _lua_pushboolean($L, $4); //@line 7674
  $$0 = 1; //@line 7675
  STACKTOP = sp; //@line 7676
  return $$0 | 0; //@line 7676
 } else if (($2 | 0) == 3) {
  $5 = _lua_gc($L, 4, 0) | 0; //@line 7678
  _lua_pushnumber($L, +($4 | 0) + +($5 | 0) * .0009765625); //@line 7683
  _lua_pushinteger($L, $5); //@line 7684
  $$0 = 2; //@line 7685
  STACKTOP = sp; //@line 7686
  return $$0 | 0; //@line 7686
 } else {
  _lua_pushinteger($L, $4); //@line 7688
  $$0 = 1; //@line 7689
  STACKTOP = sp; //@line 7690
  return $$0 | 0; //@line 7690
 }
 return 0; //@line 7692
}
function _lua_pushstring($L, $s) {
 $L = $L | 0;
 $s = $s | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 2640
 if (!$s) {
  $1 = $L + 8 | 0; //@line 2643
  $2 = HEAP32[$1 >> 2] | 0; //@line 2644
  HEAP32[$2 + 8 >> 2] = 0; //@line 2646
  HEAP32[$1 >> 2] = $2 + 16; //@line 2648
  $$0 = 0; //@line 2649
  STACKTOP = sp; //@line 2650
  return $$0 | 0; //@line 2650
 }
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2658
 $10 = _luaS_new($L, $s) | 0; //@line 2660
 $11 = $L + 8 | 0; //@line 2661
 $12 = HEAP32[$11 >> 2] | 0; //@line 2662
 HEAP32[$12 >> 2] = $10; //@line 2663
 HEAP32[$12 + 8 >> 2] = HEAPU8[$10 + 4 >> 0] | 0 | 64; //@line 2669
 HEAP32[$11 >> 2] = (HEAP32[$11 >> 2] | 0) + 16; //@line 2672
 $$0 = $10 + 16 | 0; //@line 2674
 STACKTOP = sp; //@line 2675
 return $$0 | 0; //@line 2675
}
function _fieldsel($ls, $v) {
 $ls = $ls | 0;
 $v = $v | 0;
 var $0 = 0, $1 = 0, $6 = 0, $7 = 0, $key = 0, sp = 0;
 sp = STACKTOP; //@line 11906
 STACKTOP = STACKTOP + 32 | 0; //@line 11907
 $key = sp; //@line 11908
 $0 = $ls + 48 | 0; //@line 11909
 $1 = HEAP32[$0 >> 2] | 0; //@line 11910
 _luaK_exp2anyregup($1, $v); //@line 11911
 _luaX_next($ls); //@line 11912
 if ((HEAP32[$ls + 16 >> 2] | 0) == 288) {
  $6 = HEAP32[$ls + 24 >> 2] | 0; //@line 11918
  _luaX_next($ls); //@line 11919
  $7 = _luaK_stringK(HEAP32[$0 >> 2] | 0, $6) | 0; //@line 11921
  HEAP32[$key + 16 >> 2] = -1; //@line 11923
  HEAP32[$key + 20 >> 2] = -1; //@line 11925
  HEAP32[$key >> 2] = 4; //@line 11926
  HEAP32[$key + 8 >> 2] = $7; //@line 11928
  _luaK_indexed($1, $v, $key); //@line 11929
  STACKTOP = sp; //@line 11930
  return;
 } else _error_expected($ls, 288); //@line 11932
}
function _memset(ptr, value, num) {
 ptr = ptr | 0;
 value = value | 0;
 num = num | 0;
 var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
 stop = ptr + num | 0; //@line 16986
 if ((num | 0) >= 20) {
  value = value & 255; //@line 16989
  unaligned = ptr & 3; //@line 16990
  value4 = value | value << 8 | value << 16 | value << 24; //@line 16991
  stop4 = stop & ~3; //@line 16992
  if (unaligned) {
   unaligned = ptr + 4 - unaligned | 0; //@line 16994
   while ((ptr | 0) < (unaligned | 0)) {
    HEAP8[ptr >> 0] = value; //@line 16996
    ptr = ptr + 1 | 0; //@line 16997
   }
  }
  while ((ptr | 0) < (stop4 | 0)) {
   HEAP32[ptr >> 2] = value4; //@line 17001
   ptr = ptr + 4 | 0; //@line 17002
  }
 }
 while ((ptr | 0) < (stop | 0)) {
  HEAP8[ptr >> 0] = value; //@line 17006
  ptr = ptr + 1 | 0; //@line 17007
 }
 return ptr - num | 0; //@line 17009
}
function _maxn($L) {
 $L = $L | 0;
 var $4 = 0.0, $max$0$ph2 = 0.0, $max$0$ph3 = 0.0, sp = 0;
 sp = STACKTOP; //@line 18090
 _luaL_checktype($L, 1, 5); //@line 18091
 _lua_pushnil($L); //@line 18092
 L1 : do if (!(_lua_next($L, 1) | 0)) $max$0$ph2 = 0.0; //@line 18097
 else {
  $max$0$ph3 = 0.0; //@line 18099
  while (1) {
   while (1) {
    _lua_settop($L, -2); //@line 18102
    if ((_lua_type($L, -1) | 0) == 3) {
     $4 = +_lua_tonumberx($L, -1, 0); //@line 18106
     if ($4 > $max$0$ph3) break;
    }
    if (!(_lua_next($L, 1) | 0)) {
     $max$0$ph2 = $max$0$ph3; //@line 18115
     break L1;
    }
   }
   if (!(_lua_next($L, 1) | 0)) {
    $max$0$ph2 = $4; //@line 18122
    break;
   } else $max$0$ph3 = $4; //@line 18125
  }
 } while (0);
 _lua_pushnumber($L, $max$0$ph2); //@line 18130
 STACKTOP = sp; //@line 18131
 return 1; //@line 18131
}
function _strcmp($l, $r) {
 $l = $l | 0;
 $r = $r | 0;
 var $$014 = 0, $$05 = 0, $$lcssa = 0, $$lcssa2 = 0, $0 = 0, $1 = 0, $6 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 16894
 $0 = HEAP8[$l >> 0] | 0; //@line 16895
 $1 = HEAP8[$r >> 0] | 0; //@line 16896
 if ($0 << 24 >> 24 == 0 ? 1 : $0 << 24 >> 24 != $1 << 24 >> 24) {
  $$lcssa = $0; //@line 16901
  $$lcssa2 = $1; //@line 16901
 } else {
  $$014 = $l; //@line 16903
  $$05 = $r; //@line 16903
  do {
   $$014 = $$014 + 1 | 0; //@line 16905
   $$05 = $$05 + 1 | 0; //@line 16906
   $6 = HEAP8[$$014 >> 0] | 0; //@line 16907
   $7 = HEAP8[$$05 >> 0] | 0; //@line 16908
  } while (!($6 << 24 >> 24 == 0 ? 1 : $6 << 24 >> 24 != $7 << 24 >> 24));
  $$lcssa = $6; //@line 16913
  $$lcssa2 = $7; //@line 16913
 }
 STACKTOP = sp; //@line 16923
 return ($$lcssa & 255) - ($$lcssa2 & 255) | 0; //@line 16923
}
function ___towrite($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $13 = 0, $2 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 13365
 $0 = $f + 74 | 0; //@line 13366
 $2 = HEAP8[$0 >> 0] | 0; //@line 13368
 HEAP8[$0 >> 0] = $2 + 255 | $2; //@line 13372
 $6 = HEAP32[$f >> 2] | 0; //@line 13373
 if (!($6 & 8)) {
  HEAP32[$f + 8 >> 2] = 0; //@line 13378
  HEAP32[$f + 4 >> 2] = 0; //@line 13380
  $13 = HEAP32[$f + 44 >> 2] | 0; //@line 13382
  HEAP32[$f + 28 >> 2] = $13; //@line 13384
  HEAP32[$f + 20 >> 2] = $13; //@line 13386
  HEAP32[$f + 16 >> 2] = $13 + (HEAP32[$f + 48 >> 2] | 0); //@line 13391
  $$0 = 0; //@line 13392
  STACKTOP = sp; //@line 13393
  return $$0 | 0; //@line 13393
 } else {
  HEAP32[$f >> 2] = $6 | 32; //@line 13396
  $$0 = -1; //@line 13397
  STACKTOP = sp; //@line 13398
  return $$0 | 0; //@line 13398
 }
 return 0; //@line 13400
}
function _luaC_checkupvalcolor($g, $uv) {
 $g = $g | 0;
 $uv = $uv | 0;
 var $0 = 0, $15 = 0, $2 = 0, $20 = 0, sp = 0;
 sp = STACKTOP; //@line 18976
 $0 = $uv + 5 | 0; //@line 18977
 $2 = HEAPU8[$0 >> 0] | 0; //@line 18979
 if ($2 & 7) {
  STACKTOP = sp; //@line 18983
  return;
 }
 if ((HEAP8[$g + 62 >> 0] | 0) != 2) if ((HEAPU8[$g + 61 >> 0] | 0) >= 2) {
  HEAP8[$0 >> 0] = HEAPU8[$g + 60 >> 0] & 3 | $2 & 184; //@line 19000
  STACKTOP = sp; //@line 19001
  return;
 }
 HEAP8[$0 >> 0] = $2 & 187 | 4; //@line 19007
 $15 = HEAP32[$uv + 8 >> 2] | 0; //@line 19009
 if (!(HEAP32[$15 + 8 >> 2] & 64)) {
  STACKTOP = sp; //@line 19015
  return;
 }
 $20 = HEAP32[$15 >> 2] | 0; //@line 19017
 if (!(HEAP8[$20 + 5 >> 0] & 3)) {
  STACKTOP = sp; //@line 19023
  return;
 }
 _reallymarkobject($g, $20); //@line 19025
 STACKTOP = sp; //@line 19026
 return;
}
function _str_char($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $3 = 0, $b = 0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 13636
 STACKTOP = STACKTOP + 1040 | 0; //@line 13637
 $b = sp; //@line 13638
 $0 = _lua_gettop($L) | 0; //@line 13639
 $1 = _luaL_buffinitsize($L, $b, $0) | 0; //@line 13640
 if (($0 | 0) < 1) {
  _luaL_pushresultsize($b, $0); //@line 13643
  STACKTOP = sp; //@line 13644
  return 1; //@line 13644
 } else $i$01 = 1; //@line 13646
 while (1) {
  $3 = _luaL_checkinteger($L, $i$01) | 0; //@line 13649
  if (($3 & 255 | 0) != ($3 | 0)) _luaL_argerror($L, $i$01, 10776) | 0; //@line 13654
  HEAP8[$1 + ($i$01 + -1) >> 0] = $3; //@line 13658
  if (($i$01 | 0) == ($0 | 0)) break; else $i$01 = $i$01 + 1 | 0; //@line 13664
 }
 _luaL_pushresultsize($b, $0); //@line 13667
 STACKTOP = sp; //@line 13668
 return 1; //@line 13668
}
function _luaS_hash($str, $l, $seed) {
 $str = $str | 0;
 $l = $l | 0;
 $seed = $seed | 0;
 var $0 = 0, $12 = 0, $2 = 0, $h$0$lcssa = 0, $h$02 = 0, $l1$01 = 0, sp = 0;
 sp = STACKTOP; //@line 13173
 $0 = $seed ^ $l; //@line 13174
 $2 = ($l >>> 5) + 1 | 0; //@line 13176
 if ($2 >>> 0 > $l >>> 0) {
  $h$0$lcssa = $0; //@line 13179
  STACKTOP = sp; //@line 13180
  return $h$0$lcssa | 0; //@line 13180
 } else {
  $h$02 = $0; //@line 13182
  $l1$01 = $l; //@line 13182
 }
 while (1) {
  $12 = ($h$02 << 5) + ($h$02 >>> 2) + (HEAPU8[$str + ($l1$01 + -1) >> 0] | 0) ^ $h$02; //@line 13193
  $l1$01 = $l1$01 - $2 | 0; //@line 13194
  if ($l1$01 >>> 0 < $2 >>> 0) {
   $h$0$lcssa = $12; //@line 13197
   break;
  } else $h$02 = $12; //@line 13200
 }
 STACKTOP = sp; //@line 13203
 return $h$0$lcssa | 0; //@line 13203
}
function _ll_loadfunc($L, $path, $sym) {
 $L = $L | 0;
 $path = $path | 0;
 $sym = $sym | 0;
 var $$0 = 0, $0 = 0, sp = 0;
 sp = STACKTOP; //@line 6836
 _lua_getfield($L, -1001e3, 7040); //@line 6837
 _lua_getfield($L, -1, $path); //@line 6838
 $0 = _lua_touserdata($L, -1) | 0; //@line 6839
 _lua_settop($L, -3); //@line 6840
 if (!$0) {
  _lua_pushlstring($L, 7824, 58) | 0; //@line 6843
  $$0 = 1; //@line 6844
  STACKTOP = sp; //@line 6845
  return $$0 | 0; //@line 6845
 }
 if ((HEAP8[$sym >> 0] | 0) == 42) {
  _lua_pushboolean($L, 1); //@line 6850
  $$0 = 0; //@line 6851
  STACKTOP = sp; //@line 6852
  return $$0 | 0; //@line 6852
 } else {
  _lua_pushlstring($L, 7824, 58) | 0; //@line 6854
  $$0 = 2; //@line 6855
  STACKTOP = sp; //@line 6856
  return $$0 | 0; //@line 6856
 }
 return 0; //@line 6858
}
function _luaL_callmeta($L, $obj, $event) {
 $L = $L | 0;
 $obj = $obj | 0;
 $event = $event | 0;
 var $$0 = 0, $0 = 0, sp = 0;
 sp = STACKTOP; //@line 6962
 $0 = _lua_absindex($L, $obj) | 0; //@line 6963
 if (!(_lua_getmetatable($L, $0) | 0)) {
  $$0 = 0; //@line 6967
  STACKTOP = sp; //@line 6968
  return $$0 | 0; //@line 6968
 }
 _lua_pushstring($L, $event) | 0; //@line 6970
 _lua_rawget($L, -2); //@line 6971
 if (!(_lua_type($L, -1) | 0)) {
  _lua_settop($L, -3); //@line 6975
  $$0 = 0; //@line 6976
  STACKTOP = sp; //@line 6977
  return $$0 | 0; //@line 6977
 } else {
  _lua_remove($L, -2); //@line 6979
  _lua_pushvalue($L, $0); //@line 6980
  _lua_callk($L, 1, 1, 0, 0); //@line 6981
  $$0 = 1; //@line 6982
  STACKTOP = sp; //@line 6983
  return $$0 | 0; //@line 6983
 }
 return 0; //@line 6985
}
function _luaL_checkunsigned($L, $narg) {
 $L = $L | 0;
 $narg = $narg | 0;
 var $0 = 0, $3 = 0, $5 = 0, $isnum = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6315
 STACKTOP = STACKTOP + 16 | 0; //@line 6316
 $vararg_buffer = sp; //@line 6317
 $isnum = sp + 8 | 0; //@line 6318
 $0 = _lua_tounsignedx($L, $narg, $isnum) | 0; //@line 6319
 if (HEAP32[$isnum >> 2] | 0) {
  STACKTOP = sp; //@line 6323
  return $0 | 0; //@line 6323
 }
 $3 = _lua_typename($L, 3) | 0; //@line 6325
 $5 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6327
 HEAP32[$vararg_buffer >> 2] = $3; //@line 6328
 HEAP32[$vararg_buffer + 4 >> 2] = $5; //@line 6330
 _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6332
 STACKTOP = sp; //@line 6333
 return $0 | 0; //@line 6333
}
function _luaL_checkinteger($L, $narg) {
 $L = $L | 0;
 $narg = $narg | 0;
 var $0 = 0, $3 = 0, $5 = 0, $isnum = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6291
 STACKTOP = STACKTOP + 16 | 0; //@line 6292
 $vararg_buffer = sp; //@line 6293
 $isnum = sp + 8 | 0; //@line 6294
 $0 = _lua_tointegerx($L, $narg, $isnum) | 0; //@line 6295
 if (HEAP32[$isnum >> 2] | 0) {
  STACKTOP = sp; //@line 6299
  return $0 | 0; //@line 6299
 }
 $3 = _lua_typename($L, 3) | 0; //@line 6301
 $5 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6303
 HEAP32[$vararg_buffer >> 2] = $3; //@line 6304
 HEAP32[$vararg_buffer + 4 >> 2] = $5; //@line 6306
 _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6308
 STACKTOP = sp; //@line 6309
 return $0 | 0; //@line 6309
}
function _luaK_exp2val($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $0 = 0, $11 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 10706
 $0 = $e + 16 | 0; //@line 10707
 $2 = $e + 20 | 0; //@line 10709
 if ((HEAP32[$0 >> 2] | 0) == (HEAP32[$2 >> 2] | 0)) {
  _luaK_dischargevars($fs, $e); //@line 10713
  STACKTOP = sp; //@line 10714
  return;
 }
 _luaK_dischargevars($fs, $e); //@line 10716
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $11 = HEAP32[$e + 8 >> 2] | 0; //@line 10724
  if ((HEAP32[$0 >> 2] | 0) == (HEAP32[$2 >> 2] | 0)) {
   STACKTOP = sp; //@line 10726
   return;
  }
  if (($11 | 0) >= (HEAPU8[$fs + 46 >> 0] | 0 | 0)) {
   _exp2reg($fs, $e, $11); //@line 10733
   STACKTOP = sp; //@line 10734
   return;
  }
 }
 _luaK_exp2nextreg($fs, $e); //@line 10737
 STACKTOP = sp; //@line 10738
 return;
}
function _lua_settop($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $13 = 0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, sp = 0, $9$looptemp = 0;
 sp = STACKTOP; //@line 247
 if (($idx | 0) <= -1) {
  $13 = $L + 8 | 0; //@line 251
  HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + ($idx + 1 << 4); //@line 254
  STACKTOP = sp; //@line 255
  return;
 }
 $4 = $L + 8 | 0; //@line 260
 $5 = HEAP32[$4 >> 2] | 0; //@line 261
 $6 = (HEAP32[HEAP32[$L + 16 >> 2] >> 2] | 0) + ($idx + 1 << 4) | 0; //@line 263
 if ($5 >>> 0 < $6 >>> 0) {
  $9 = $5; //@line 266
  do {
   $9$looptemp = $9;
   $9 = $9 + 16 | 0; //@line 268
   HEAP32[$9$looptemp + 8 >> 2] = 0; //@line 270
  } while ($9 >>> 0 < $6 >>> 0);
  HEAP32[$4 >> 2] = $9; //@line 278
 }
 HEAP32[$4 >> 2] = $6; //@line 280
 STACKTOP = sp; //@line 281
 return;
}
function _memcmp($vl, $vr, $n) {
 $vl = $vl | 0;
 $vr = $vr | 0;
 $n = $n | 0;
 var $$03 = 0, $1 = 0, $11 = 0, $2 = 0, $l$04 = 0, $r$05 = 0, sp = 0;
 sp = STACKTOP; //@line 16856
 L1 : do if (!$n) $11 = 0; //@line 16860
 else {
  $$03 = $n; //@line 16862
  $l$04 = $vl; //@line 16862
  $r$05 = $vr; //@line 16862
  while (1) {
   $1 = HEAP8[$l$04 >> 0] | 0; //@line 16864
   $2 = HEAP8[$r$05 >> 0] | 0; //@line 16865
   if ($1 << 24 >> 24 != $2 << 24 >> 24) break;
   $$03 = $$03 + -1 | 0; //@line 16870
   if (!$$03) {
    $11 = 0; //@line 16875
    break L1;
   } else {
    $l$04 = $l$04 + 1 | 0; //@line 16878
    $r$05 = $r$05 + 1 | 0; //@line 16878
   }
  }
  $11 = ($1 & 255) - ($2 & 255) | 0; //@line 16884
 } while (0);
 STACKTOP = sp; //@line 16887
 return $11 | 0; //@line 16887
}
function _math_min($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0.0, $3 = 0.0, $dmin$0$lcssa = 0.0, $dmin$02 = 0.0, $dmin$1 = 0.0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 6065
 $0 = _lua_gettop($L) | 0; //@line 6066
 $1 = +_luaL_checknumber($L, 1); //@line 6067
 if (($0 | 0) < 2) $dmin$0$lcssa = $1; //@line 6070
 else {
  $dmin$02 = $1; //@line 6072
  $i$01 = 2; //@line 6072
  while (1) {
   $3 = +_luaL_checknumber($L, $i$01); //@line 6074
   $dmin$1 = $3 < $dmin$02 ? $3 : $dmin$02; //@line 6076
   if (($i$01 | 0) == ($0 | 0)) {
    $dmin$0$lcssa = $dmin$1; //@line 6080
    break;
   } else {
    $dmin$02 = $dmin$1; //@line 6083
    $i$01 = $i$01 + 1 | 0; //@line 6083
   }
  }
 }
 _lua_pushnumber($L, $dmin$0$lcssa); //@line 6087
 STACKTOP = sp; //@line 6088
 return 1; //@line 6088
}
function _math_max($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0.0, $3 = 0.0, $dmax$0$lcssa = 0.0, $dmax$02 = 0.0, $dmax$1 = 0.0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 6037
 $0 = _lua_gettop($L) | 0; //@line 6038
 $1 = +_luaL_checknumber($L, 1); //@line 6039
 if (($0 | 0) < 2) $dmax$0$lcssa = $1; //@line 6042
 else {
  $dmax$02 = $1; //@line 6044
  $i$01 = 2; //@line 6044
  while (1) {
   $3 = +_luaL_checknumber($L, $i$01); //@line 6046
   $dmax$1 = $3 > $dmax$02 ? $3 : $dmax$02; //@line 6048
   if (($i$01 | 0) == ($0 | 0)) {
    $dmax$0$lcssa = $dmax$1; //@line 6052
    break;
   } else {
    $dmax$02 = $dmax$1; //@line 6055
    $i$01 = $i$01 + 1 | 0; //@line 6055
   }
  }
 }
 _lua_pushnumber($L, $dmax$0$lcssa); //@line 6059
 STACKTOP = sp; //@line 6060
 return 1; //@line 6060
}
function _luaL_ref($L, $t) {
 $L = $L | 0;
 $t = $t | 0;
 var $$0 = 0, $2 = 0, $3 = 0, $ref$0 = 0, sp = 0;
 sp = STACKTOP; //@line 6608
 if (!(_lua_type($L, -1) | 0)) {
  _lua_settop($L, -2); //@line 6612
  $$0 = -1; //@line 6613
  STACKTOP = sp; //@line 6614
  return $$0 | 0; //@line 6614
 }
 $2 = _lua_absindex($L, $t) | 0; //@line 6616
 _lua_rawgeti($L, $2, 0); //@line 6617
 $3 = _lua_tointegerx($L, -1, 0) | 0; //@line 6618
 _lua_settop($L, -2); //@line 6619
 if (!$3) $ref$0 = (_lua_rawlen($L, $2) | 0) + 1 | 0; //@line 6624
 else {
  _lua_rawgeti($L, $2, $3); //@line 6626
  _lua_rawseti($L, $2, 0); //@line 6627
  $ref$0 = $3; //@line 6628
 }
 _lua_rawseti($L, $2, $ref$0); //@line 6630
 $$0 = $ref$0; //@line 6631
 STACKTOP = sp; //@line 6632
 return $$0 | 0; //@line 6632
}
function _luaK_setoneret($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $0 = 0, $1 = 0, $15 = 0, sp = 0;
 sp = STACKTOP; //@line 9694
 $0 = HEAP32[$e >> 2] | 0; //@line 9695
 if (($0 | 0) == 13) {
  $15 = (HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$e + 8 >> 2] << 2) | 0; //@line 9702
  HEAP32[$15 >> 2] = HEAP32[$15 >> 2] & 8388607 | 16777216; //@line 9706
  HEAP32[$e >> 2] = 11; //@line 9707
  STACKTOP = sp; //@line 9708
  return;
 } else if (($0 | 0) == 12) {
  HEAP32[$e >> 2] = 6; //@line 9710
  $1 = $e + 8 | 0; //@line 9711
  HEAP32[$1 >> 2] = (HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$1 >> 2] << 2) >> 2] | 0) >>> 6 & 255; //@line 9720
  STACKTOP = sp; //@line 9721
  return;
 } else {
  STACKTOP = sp; //@line 9723
  return;
 }
}
function _luaF_freeproto($L, $f) {
 $L = $L | 0;
 $f = $f | 0;
 var sp = 0;
 sp = STACKTOP; //@line 18608
 _luaM_realloc_($L, HEAP32[$f + 12 >> 2] | 0, HEAP32[$f + 48 >> 2] << 2, 0) | 0; //@line 18614
 _luaM_realloc_($L, HEAP32[$f + 16 >> 2] | 0, HEAP32[$f + 56 >> 2] << 2, 0) | 0; //@line 18620
 _luaM_realloc_($L, HEAP32[$f + 8 >> 2] | 0, HEAP32[$f + 44 >> 2] << 4, 0) | 0; //@line 18626
 _luaM_realloc_($L, HEAP32[$f + 20 >> 2] | 0, HEAP32[$f + 52 >> 2] << 2, 0) | 0; //@line 18632
 _luaM_realloc_($L, HEAP32[$f + 24 >> 2] | 0, (HEAP32[$f + 60 >> 2] | 0) * 12 | 0, 0) | 0; //@line 18638
 _luaM_realloc_($L, HEAP32[$f + 28 >> 2] | 0, HEAP32[$f + 40 >> 2] << 3, 0) | 0; //@line 18644
 _luaM_realloc_($L, $f, 80, 0) | 0; //@line 18645
 STACKTOP = sp; //@line 18646
 return;
}
function _luaL_checknumber($L, $narg) {
 $L = $L | 0;
 $narg = $narg | 0;
 var $0 = 0.0, $3 = 0, $5 = 0, $isnum = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6251
 STACKTOP = STACKTOP + 16 | 0; //@line 6252
 $vararg_buffer = sp; //@line 6253
 $isnum = sp + 8 | 0; //@line 6254
 $0 = +_lua_tonumberx($L, $narg, $isnum); //@line 6255
 if (HEAP32[$isnum >> 2] | 0) {
  STACKTOP = sp; //@line 6259
  return +$0;
 }
 $3 = _lua_typename($L, 3) | 0; //@line 6261
 $5 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6263
 HEAP32[$vararg_buffer >> 2] = $3; //@line 6264
 HEAP32[$vararg_buffer + 4 >> 2] = $5; //@line 6266
 _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6268
 STACKTOP = sp; //@line 6269
 return +$0;
}
function _luaT_gettmbyobj($L, $o, $event) {
 $L = $L | 0;
 $o = $o | 0;
 $event = $event | 0;
 var $19 = 0, $2 = 0, $mt$0 = 0, sp = 0;
 sp = STACKTOP; //@line 18576
 $2 = HEAP32[$o + 8 >> 2] & 15; //@line 18579
 if (($2 | 0) == 7) $mt$0 = HEAP32[(HEAP32[$o >> 2] | 0) + 8 >> 2] | 0; //@line 18584
 else if (($2 | 0) == 5) $mt$0 = HEAP32[(HEAP32[$o >> 2] | 0) + 8 >> 2] | 0; //@line 18589
 else $mt$0 = HEAP32[(HEAP32[$L + 12 >> 2] | 0) + ($2 << 2) + 252 >> 2] | 0; //@line 18595
 if (!$mt$0) {
  $19 = 8048; //@line 18599
  STACKTOP = sp; //@line 18600
  return $19 | 0; //@line 18600
 }
 $19 = _luaH_getstr($mt$0, HEAP32[(HEAP32[$L + 12 >> 2] | 0) + ($event << 2) + 184 >> 2] | 0) | 0; //@line 18607
 STACKTOP = sp; //@line 18608
 return $19 | 0; //@line 18608
}
function _luaL_checklstring($L, $narg, $len) {
 $L = $L | 0;
 $narg = $narg | 0;
 $len = $len | 0;
 var $0 = 0, $2 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6170
 STACKTOP = STACKTOP + 16 | 0; //@line 6171
 $vararg_buffer = sp; //@line 6172
 $0 = _lua_tolstring($L, $narg, $len) | 0; //@line 6173
 if ($0) {
  STACKTOP = sp; //@line 6176
  return $0 | 0; //@line 6176
 }
 $2 = _lua_typename($L, 4) | 0; //@line 6178
 $4 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6180
 HEAP32[$vararg_buffer >> 2] = $2; //@line 6181
 HEAP32[$vararg_buffer + 4 >> 2] = $4; //@line 6183
 _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6185
 STACKTOP = sp; //@line 6186
 return $0 | 0; //@line 6186
}
function _getF($L, $ud, $size) {
 $L = $L | 0;
 $ud = $ud | 0;
 $size = $size | 0;
 var $$0 = 0, $0 = 0, $2 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 6854
 $0 = HEAP32[$ud >> 2] | 0; //@line 6855
 if (($0 | 0) > 0) {
  HEAP32[$size >> 2] = $0; //@line 6858
  HEAP32[$ud >> 2] = 0; //@line 6859
  $$0 = $ud + 8 | 0; //@line 6861
  STACKTOP = sp; //@line 6862
  return $$0 | 0; //@line 6862
 }
 $2 = $ud + 4 | 0; //@line 6864
 if (_feof(HEAP32[$2 >> 2] | 0) | 0) {
  $$0 = 0; //@line 6869
  STACKTOP = sp; //@line 6870
  return $$0 | 0; //@line 6870
 }
 $6 = $ud + 8 | 0; //@line 6872
 HEAP32[$size >> 2] = _fread($6 | 0, 1, 1024, HEAP32[$2 >> 2] | 0) | 0; //@line 6875
 $$0 = $6; //@line 6876
 STACKTOP = sp; //@line 6877
 return $$0 | 0; //@line 6877
}
function _pack($L) {
 $L = $L | 0;
 var $0 = 0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 18186
 $0 = _lua_gettop($L) | 0; //@line 18187
 _lua_createtable($L, $0, 1); //@line 18188
 _lua_pushinteger($L, $0); //@line 18189
 _lua_setfield($L, -2, 11168); //@line 18190
 if (($0 | 0) <= 0) {
  STACKTOP = sp; //@line 18193
  return 1; //@line 18193
 }
 _lua_pushvalue($L, 1); //@line 18195
 _lua_rawseti($L, -2, 1); //@line 18196
 _lua_replace($L, 1); //@line 18197
 if (($0 | 0) > 1) $i$01 = $0; //@line 18200
 else {
  STACKTOP = sp; //@line 18202
  return 1; //@line 18202
 }
 do {
  _lua_rawseti($L, 1, $i$01); //@line 18205
  $i$01 = $i$01 + -1 | 0; //@line 18206
 } while (($i$01 | 0) > 1);
 STACKTOP = sp; //@line 18214
 return 1; //@line 18214
}
function _luaZ_fill($z) {
 $z = $z | 0;
 var $$0 = 0, $6 = 0, $8 = 0, $size = 0, sp = 0;
 sp = STACKTOP; //@line 5231
 STACKTOP = STACKTOP + 16 | 0; //@line 5232
 $size = sp; //@line 5233
 $6 = FUNCTION_TABLE_iiii[HEAP32[$z + 8 >> 2] & 31](HEAP32[$z + 16 >> 2] | 0, HEAP32[$z + 12 >> 2] | 0, $size) | 0; //@line 5240
 if (!$6) {
  $$0 = -1; //@line 5243
  STACKTOP = sp; //@line 5244
  return $$0 | 0; //@line 5244
 }
 $8 = HEAP32[$size >> 2] | 0; //@line 5246
 if (!$8) {
  $$0 = -1; //@line 5249
  STACKTOP = sp; //@line 5250
  return $$0 | 0; //@line 5250
 }
 HEAP32[$z >> 2] = $8 + -1; //@line 5253
 HEAP32[$z + 4 >> 2] = $6 + 1; //@line 5256
 $$0 = HEAPU8[$6 >> 0] | 0; //@line 5259
 STACKTOP = sp; //@line 5260
 return $$0 | 0; //@line 5260
}
function _luaB_loadfile($L) {
 $L = $L | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, $3 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 7760
 $0 = _luaL_optlstring($L, 1, 0, 0) | 0; //@line 7761
 $1 = _luaL_optlstring($L, 2, 0, 0) | 0; //@line 7762
 $3 = (_lua_type($L, 3) | 0) != -1; //@line 7764
 $4 = $3 ? 3 : 0; //@line 7765
 if (!(_luaL_loadfilex($L, $0, $1) | 0)) if ($3) {
  _lua_pushvalue($L, $4); //@line 7770
  if (!(_lua_setupvalue($L, -2, 1) | 0)) {
   _lua_settop($L, -2); //@line 7774
   $$0$i = 1; //@line 7775
  } else $$0$i = 1; //@line 7777
 } else $$0$i = 1; //@line 7780
 else {
  _lua_pushnil($L); //@line 7783
  _lua_insert($L, -2); //@line 7784
  $$0$i = 2; //@line 7785
 }
 STACKTOP = sp; //@line 7787
 return $$0$i | 0; //@line 7787
}
function _luaD_growstack($L, $n) {
 $L = $L | 0;
 $n = $n | 0;
 var $$ = 0, $$$ = 0, $1 = 0, $12 = 0, $13 = 0, sp = 0;
 sp = STACKTOP; //@line 15559
 STACKTOP = STACKTOP + 16 | 0; //@line 15560
 $1 = HEAP32[$L + 32 >> 2] | 0; //@line 15563
 if (($1 | 0) > 1e6) _luaD_throw($L, 6); //@line 15566
 $12 = $n + 5 + ((HEAP32[$L + 8 >> 2] | 0) - (HEAP32[$L + 28 >> 2] | 0) >> 4) | 0; //@line 15578
 $13 = $1 << 1; //@line 15579
 $$ = ($13 | 0) > 1e6 ? 1e6 : $13; //@line 15581
 $$$ = ($$ | 0) < ($12 | 0) ? $12 : $$; //@line 15583
 if (($$$ | 0) > 1e6) {
  _luaD_reallocstack($L, 1000200); //@line 15586
  _luaG_runerror($L, 4264, sp); //@line 15587
 } else {
  _luaD_reallocstack($L, $$$); //@line 15590
  STACKTOP = sp; //@line 15591
  return;
 }
}
function _luaU_dump($L, $f, $w, $data, $strip) {
 $L = $L | 0;
 $f = $f | 0;
 $w = $w | 0;
 $data = $data | 0;
 $strip = $strip | 0;
 var $3 = 0, $D = 0, $h$i = 0, sp = 0;
 sp = STACKTOP; //@line 17573
 STACKTOP = STACKTOP + 48 | 0; //@line 17574
 $h$i = sp + 20 | 0; //@line 17575
 $D = sp; //@line 17576
 HEAP32[$D >> 2] = $L; //@line 17577
 HEAP32[$D + 4 >> 2] = $w; //@line 17579
 HEAP32[$D + 8 >> 2] = $data; //@line 17581
 HEAP32[$D + 12 >> 2] = $strip; //@line 17583
 $3 = $D + 16 | 0; //@line 17584
 _luaU_header($h$i); //@line 17585
 HEAP32[$3 >> 2] = FUNCTION_TABLE_iiiii[$w & 31]($L, $h$i, 18, $data) | 0; //@line 17587
 _DumpFunction($f, $D); //@line 17588
 STACKTOP = sp; //@line 17590
 return HEAP32[$3 >> 2] | 0; //@line 17590
}
function _luaG_ordererror($L, $p1, $p2) {
 $L = $L | 0;
 $p1 = $p1 | 0;
 $p2 = $p2 | 0;
 var $11 = 0, $5 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 15196
 STACKTOP = STACKTOP + 16 | 0; //@line 15197
 $vararg_buffer1 = sp; //@line 15198
 $5 = HEAP32[11384 + ((HEAP32[$p1 + 8 >> 2] & 15) + 1 << 2) >> 2] | 0; //@line 15204
 $11 = HEAP32[11384 + ((HEAP32[$p2 + 8 >> 2] & 15) + 1 << 2) >> 2] | 0; //@line 15210
 if (($5 | 0) == ($11 | 0)) {
  HEAP32[$vararg_buffer1 >> 2] = $5; //@line 15213
  _luaG_runerror($L, 3992, $vararg_buffer1); //@line 15214
 } else {
  HEAP32[$vararg_buffer1 >> 2] = $5; //@line 15217
  HEAP32[$vararg_buffer1 + 4 >> 2] = $11; //@line 15219
  _luaG_runerror($L, 4032, $vararg_buffer1); //@line 15220
 }
}
function _luaO_int2fb($x) {
 $x = $x | 0;
 var $$0$lcssa = 0, $$01 = 0, $$02 = 0, $2 = 0, $e$0$lcssa = 0, $e$03 = 0, sp = 0;
 sp = STACKTOP; //@line 6995
 if ($x >>> 0 < 8) {
  $$01 = $x; //@line 6998
  STACKTOP = sp; //@line 6999
  return $$01 | 0; //@line 6999
 }
 if ($x >>> 0 > 15) {
  $$02 = $x; //@line 7003
  $e$03 = 1; //@line 7003
  do {
   $2 = $$02 + 1 | 0; //@line 7005
   $$02 = $2 >>> 1; //@line 7006
   $e$03 = $e$03 + 1 | 0; //@line 7007
  } while ($2 >>> 0 > 31);
  $$0$lcssa = $$02; //@line 7016
  $e$0$lcssa = $e$03 << 3; //@line 7016
 } else {
  $$0$lcssa = $x; //@line 7018
  $e$0$lcssa = 8; //@line 7018
 }
 $$01 = $e$0$lcssa | $$0$lcssa + -8; //@line 7022
 STACKTOP = sp; //@line 7023
 return $$01 | 0; //@line 7023
}
function _b_replace($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, sp = 0;
 sp = STACKTOP; //@line 8521
 STACKTOP = STACKTOP + 16 | 0; //@line 8522
 $0 = _luaL_checkunsigned($L, 1) | 0; //@line 8524
 $1 = _luaL_checkunsigned($L, 2) | 0; //@line 8525
 $2 = _luaL_checkinteger($L, 3) | 0; //@line 8526
 $3 = _luaL_optinteger($L, 4, 1) | 0; //@line 8527
 if (($2 | 0) <= -1) _luaL_argerror($L, 3, 2224) | 0; //@line 8530
 if (($3 | 0) <= 0) _luaL_argerror($L, 4, 2256) | 0; //@line 8534
 if (($3 + $2 | 0) > 32) _luaL_error($L, 2280, sp) | 0; //@line 8539
 $10 = ~(-2 << $3 + -1); //@line 8543
 _lua_pushunsigned($L, $0 & ~($10 << $2) | ($1 & $10) << $2); //@line 8550
 STACKTOP = sp; //@line 8551
 return 1; //@line 8551
}
function _generic_reader($L, $ud, $size) {
 $L = $L | 0;
 $ud = $ud | 0;
 $size = $size | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 8234
 STACKTOP = STACKTOP + 16 | 0; //@line 8235
 _luaL_checkstack($L, 2, 1672); //@line 8237
 _lua_pushvalue($L, 1); //@line 8238
 _lua_callk($L, 0, 1, 0, 0); //@line 8239
 if (!(_lua_type($L, -1) | 0)) {
  _lua_settop($L, -2); //@line 8243
  HEAP32[$size >> 2] = 0; //@line 8244
  $$0 = 0; //@line 8245
  STACKTOP = sp; //@line 8246
  return $$0 | 0; //@line 8246
 }
 if (!(_lua_isstring($L, -1) | 0)) _luaL_error($L, 1704, sp) | 0; //@line 8251
 _lua_replace($L, 5); //@line 8253
 $$0 = _lua_tolstring($L, 5, $size) | 0; //@line 8255
 STACKTOP = sp; //@line 8256
 return $$0 | 0; //@line 8256
}
function _luaH_getstr($t, $key) {
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $18 = 0, $n$0 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 17501
 $n$0 = (HEAP32[$t + 16 >> 2] | 0) + (((1 << (HEAPU8[$t + 7 >> 0] | 0)) + -1 & HEAP32[$key + 8 >> 2]) << 5) | 0; //@line 17513
 while (1) {
  if ((HEAP32[$n$0 + 24 >> 2] | 0) == 68) if ((HEAP32[$n$0 + 16 >> 2] | 0) == ($key | 0)) break;
  $18 = HEAP32[$n$0 + 28 >> 2] | 0; //@line 17527
  if (!$18) {
   $$0 = 8048; //@line 17530
   label = 6; //@line 17531
   break;
  } else $n$0 = $18; //@line 17534
 }
 if ((label | 0) == 6) {
  STACKTOP = sp; //@line 17538
  return $$0 | 0; //@line 17538
 }
 $$0 = $n$0; //@line 17540
 STACKTOP = sp; //@line 17541
 return $$0 | 0; //@line 17541
}
function _aux_lines($L, $toclose) {
 $L = $L | 0;
 $toclose = $toclose | 0;
 var $0 = 0, $1 = 0, $i$01 = 0, sp = 0, $i$01$looptemp = 0;
 sp = STACKTOP; //@line 2421
 $0 = _lua_gettop($L) | 0; //@line 2422
 $1 = $0 + -1 | 0; //@line 2423
 if (($0 | 0) >= 19) _luaL_argerror($L, 17, 5360) | 0; //@line 2426
 _lua_pushvalue($L, 1); //@line 2428
 _lua_pushinteger($L, $1); //@line 2429
 _lua_pushboolean($L, $toclose); //@line 2430
 if (($0 | 0) >= 2) {
  $i$01 = 1; //@line 2433
  do {
   $i$01$looptemp = $i$01;
   $i$01 = $i$01 + 1 | 0; //@line 2435
   _lua_pushvalue($L, $i$01); //@line 2436
  } while (($i$01$looptemp | 0) < ($1 | 0));
 }
 _lua_pushcclosure($L, 174, $0 + 2 | 0); //@line 2446
 STACKTOP = sp; //@line 2447
 return;
}
function _luaZ_openspace($L, $buff, $n) {
 $L = $L | 0;
 $buff = $buff | 0;
 $n = $n | 0;
 var $$n = 0, $0 = 0, $1 = 0, $7 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 5357
 $0 = $buff + 8 | 0; //@line 5358
 $1 = HEAP32[$0 >> 2] | 0; //@line 5359
 if ($1 >>> 0 >= $n >>> 0) {
  $8 = HEAP32[$buff >> 2] | 0; //@line 5363
  STACKTOP = sp; //@line 5364
  return $8 | 0; //@line 5364
 }
 $$n = $n >>> 0 < 32 ? 32 : $n; //@line 5367
 if (($$n + 1 | 0) >>> 0 > 4294967293) _luaM_toobig($L); //@line 5371
 $7 = _luaM_realloc_($L, HEAP32[$buff >> 2] | 0, $1, $$n) | 0; //@line 5375
 HEAP32[$buff >> 2] = $7; //@line 5376
 HEAP32[$0 >> 2] = $$n; //@line 5377
 $8 = $7; //@line 5378
 STACKTOP = sp; //@line 5379
 return $8 | 0; //@line 5379
}
function _luaL_where($L, $level) {
 $L = $L | 0;
 $level = $level | 0;
 var $3 = 0, $ar = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 5892
 STACKTOP = STACKTOP + 112 | 0; //@line 5893
 $vararg_buffer = sp; //@line 5894
 $ar = sp + 8 | 0; //@line 5895
 if (_lua_getstack($L, $level, $ar) | 0) {
  _lua_getinfo($L, 240, $ar) | 0; //@line 5899
  $3 = HEAP32[$ar + 20 >> 2] | 0; //@line 5901
  if (($3 | 0) > 0) {
   HEAP32[$vararg_buffer >> 2] = $ar + 36; //@line 5905
   HEAP32[$vararg_buffer + 4 >> 2] = $3; //@line 5907
   _lua_pushfstring($L, 248, $vararg_buffer) | 0; //@line 5908
   STACKTOP = sp; //@line 5909
   return;
  }
 }
 _lua_pushlstring($L, 256, 0) | 0; //@line 5912
 STACKTOP = sp; //@line 5913
 return;
}
function _luaK_exp2anyregup($fs, $e) {
 $fs = $fs | 0;
 $e = $e | 0;
 var $15 = 0, sp = 0;
 sp = STACKTOP; //@line 10663
 if ((HEAP32[$e >> 2] | 0) == 8) if ((HEAP32[$e + 16 >> 2] | 0) == (HEAP32[$e + 20 >> 2] | 0)) {
  STACKTOP = sp; //@line 10673
  return;
 }
 _luaK_dischargevars($fs, $e); //@line 10676
 if ((HEAP32[$e >> 2] | 0) == 6) {
  $15 = HEAP32[$e + 8 >> 2] | 0; //@line 10686
  if ((HEAP32[$e + 16 >> 2] | 0) == (HEAP32[$e + 20 >> 2] | 0)) {
   STACKTOP = sp; //@line 10688
   return;
  }
  if (($15 | 0) >= (HEAPU8[$fs + 46 >> 0] | 0 | 0)) {
   _exp2reg($fs, $e, $15); //@line 10695
   STACKTOP = sp; //@line 10696
   return;
  }
 }
 _luaK_exp2nextreg($fs, $e); //@line 10699
 STACKTOP = sp; //@line 10700
 return;
}
function _luaC_newobj($L, $tt, $sz, $list, $offset) {
 $L = $L | 0;
 $tt = $tt | 0;
 $sz = $sz | 0;
 $list = $list | 0;
 $offset = $offset | 0;
 var $$list = 0, $1 = 0, $3 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 19036
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 19038
 $3 = _luaM_realloc_($L, 0, $tt & 15, $sz) | 0; //@line 19040
 $4 = $3 + $offset | 0; //@line 19041
 $$list = ($list | 0) == 0 ? $1 + 68 | 0 : $list; //@line 19044
 HEAP8[$3 + ($offset + 5) >> 0] = (HEAPU8[$1 + 60 >> 0] | 0) & 3; //@line 19052
 HEAP8[$3 + ($offset + 4) >> 0] = $tt; //@line 19056
 HEAP32[$4 >> 2] = HEAP32[$$list >> 2]; //@line 19058
 HEAP32[$$list >> 2] = $4; //@line 19059
 STACKTOP = sp; //@line 19060
 return $4 | 0; //@line 19060
}
function _b_arshift($L) {
 $L = $L | 0;
 var $$1$i = 0, $0 = 0, $1 = 0, $4 = 0, $r$0 = 0, sp = 0;
 sp = STACKTOP; //@line 8292
 $0 = _luaL_checkunsigned($L, 1) | 0; //@line 8293
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 8294
 if (($1 | 0) > -1 & ($0 | 0) < 0) {
  if (($1 | 0) > 31) $r$0 = -1; //@line 8301
 else $r$0 = $0 >>> $1 | ~(-1 >>> $1); //@line 8307
  _lua_pushunsigned($L, $r$0); //@line 8309
  STACKTOP = sp; //@line 8310
  return 1; //@line 8310
 }
 $4 = 0 - $1 | 0; //@line 8312
 if (($1 | 0) > 0) $$1$i = ($1 | 0) > 31 ? 0 : $0 >>> $1; //@line 8318
 else $$1$i = ($4 | 0) > 31 ? 0 : $0 << $4; //@line 8323
 _lua_pushunsigned($L, $$1$i); //@line 8325
 STACKTOP = sp; //@line 8326
 return 1; //@line 8326
}
function _luaO_ceillog2($x) {
 $x = $x | 0;
 var $$0$lcssa = 0, $$01 = 0, $0 = 0, $2 = 0, $3 = 0, $l$0$lcssa = 0, $l$02 = 0, sp = 0;
 sp = STACKTOP; //@line 7046
 $0 = $x + -1 | 0; //@line 7047
 if ($0 >>> 0 > 255) {
  $$01 = $0; //@line 7050
  $l$02 = 0; //@line 7050
  while (1) {
   $2 = $l$02 + 8 | 0; //@line 7052
   $3 = $$01 >>> 8; //@line 7053
   if ($$01 >>> 0 > 65535) {
    $$01 = $3; //@line 7056
    $l$02 = $2; //@line 7056
   } else {
    $$0$lcssa = $3; //@line 7058
    $l$0$lcssa = $2; //@line 7058
    break;
   }
  }
 } else {
  $$0$lcssa = $0; //@line 7063
  $l$0$lcssa = 0; //@line 7063
 }
 STACKTOP = sp; //@line 7069
 return (HEAPU8[8064 + $$0$lcssa >> 0] | 0) + $l$0$lcssa | 0; //@line 7069
}
function _luaB_select($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $7 = 0, $i$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7969
 $0 = _lua_gettop($L) | 0; //@line 7970
 if ((_lua_type($L, 1) | 0) == 4) if ((HEAP8[(_lua_tolstring($L, 1, 0) | 0) >> 0] | 0) == 35) {
  _lua_pushinteger($L, $0 + -1 | 0); //@line 7979
  $$0 = 1; //@line 7980
  STACKTOP = sp; //@line 7981
  return $$0 | 0; //@line 7981
 }
 $7 = _luaL_checkinteger($L, 1) | 0; //@line 7984
 if (($7 | 0) < 0) $i$0 = $7 + $0 | 0; //@line 7988
 else $i$0 = ($7 | 0) > ($0 | 0) ? $0 : $7; //@line 7992
 if (($i$0 | 0) <= 0) _luaL_argerror($L, 1, 1544) | 0; //@line 7996
 $$0 = $0 - $i$0 | 0; //@line 7999
 STACKTOP = sp; //@line 8000
 return $$0 | 0; //@line 8000
}
function _lua_concat($L, $n) {
 $L = $L | 0;
 $n = $n | 0;
 var $7 = 0, $8 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 4857
 if (($n | 0) > 1) {
  if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 4866
  _luaV_concat($L, $n); //@line 4868
  STACKTOP = sp; //@line 4869
  return;
 } else {
  if ($n) {
   STACKTOP = sp; //@line 4873
   return;
  }
  $7 = $L + 8 | 0; //@line 4875
  $8 = HEAP32[$7 >> 2] | 0; //@line 4876
  $9 = _luaS_newlstr($L, 24, 0) | 0; //@line 4877
  HEAP32[$8 >> 2] = $9; //@line 4878
  HEAP32[$8 + 8 >> 2] = HEAPU8[$9 + 4 >> 0] | 0 | 64; //@line 4884
  HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + 16; //@line 4887
  STACKTOP = sp; //@line 4888
  return;
 }
}
function _luaK_infix($fs, $op, $v) {
 $fs = $fs | 0;
 $op = $op | 0;
 $v = $v | 0;
 var sp = 0;
 sp = STACKTOP; //@line 12226
 L1 : do switch ($op | 0) {
 case 14:
  {
   _luaK_goiffalse($fs, $v); //@line 12230
   break;
  }
 case 5:
 case 4:
 case 3:
 case 2:
 case 1:
 case 0:
  {
   if ((HEAP32[$v >> 2] | 0) == 5) if ((HEAP32[$v + 16 >> 2] | 0) == -1) if ((HEAP32[$v + 20 >> 2] | 0) == -1) break L1;
   _luaK_exp2RK($fs, $v) | 0; //@line 12249
   break;
  }
 case 6:
  {
   _luaK_exp2nextreg($fs, $v); //@line 12253
   break;
  }
 case 13:
  {
   _luaK_goiftrue($fs, $v); //@line 12257
   break;
  }
 default:
  _luaK_exp2RK($fs, $v) | 0; //@line 12261
 } while (0);
 STACKTOP = sp; //@line 12265
 return;
}
function _lua_setglobal($L, $var) {
 $L = $L | 0;
 $var = $var | 0;
 var $14 = 0, $4 = 0, $5 = 0, $6 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 3481
 $4 = _luaH_getint(HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 40 >> 2] | 0, 2) | 0; //@line 3486
 $5 = $L + 8 | 0; //@line 3487
 $6 = HEAP32[$5 >> 2] | 0; //@line 3488
 HEAP32[$5 >> 2] = $6 + 16; //@line 3490
 $8 = _luaS_new($L, $var) | 0; //@line 3491
 HEAP32[$6 >> 2] = $8; //@line 3492
 HEAP32[$6 + 8 >> 2] = HEAPU8[$8 + 4 >> 0] | 0 | 64; //@line 3498
 $14 = HEAP32[$5 >> 2] | 0; //@line 3499
 _luaV_settable($L, $4, $14 + -16 | 0, $14 + -32 | 0); //@line 3502
 HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -32; //@line 3505
 STACKTOP = sp; //@line 3506
 return;
}
function _db_upvalueid($L) {
 $L = $L | 0;
 var $0 = 0, $ar$i = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 13595
 STACKTOP = STACKTOP + 112 | 0; //@line 13596
 $ar$i = sp; //@line 13597
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 13598
 _luaL_checktype($L, 1, 6); //@line 13599
 _lua_pushvalue($L, 1); //@line 13600
 _lua_getinfo($L, 3512, $ar$i) | 0; //@line 13601
 if (($0 | 0) > 0) {
  if (($0 | 0) > (HEAPU8[$ar$i + 32 >> 0] | 0 | 0)) label = 3; //@line 13609
 } else label = 3; //@line 13612
 if ((label | 0) == 3) _luaL_argerror($L, 2, 3520) | 0; //@line 13615
 _lua_pushlightuserdata($L, _lua_upvalueid($L, 1, $0) | 0); //@line 13618
 STACKTOP = sp; //@line 13619
 return 1; //@line 13619
}
function _luaX_next($ls) {
 $ls = $ls | 0;
 var $3 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 3144
 HEAP32[$ls + 8 >> 2] = HEAP32[$ls + 4 >> 2]; //@line 3148
 $3 = $ls + 32 | 0; //@line 3149
 if ((HEAP32[$3 >> 2] | 0) == 286) {
  HEAP32[$ls + 16 >> 2] = _llex($ls, $ls + 24 | 0) | 0; //@line 3156
  STACKTOP = sp; //@line 3157
  return;
 } else {
  $6 = $ls + 16 | 0; //@line 3159
  HEAP32[$6 + 0 >> 2] = HEAP32[$3 + 0 >> 2]; //@line 3160
  HEAP32[$6 + 4 >> 2] = HEAP32[$3 + 4 >> 2]; //@line 3160
  HEAP32[$6 + 8 >> 2] = HEAP32[$3 + 8 >> 2]; //@line 3160
  HEAP32[$6 + 12 >> 2] = HEAP32[$3 + 12 >> 2]; //@line 3160
  HEAP32[$3 >> 2] = 286; //@line 3161
  STACKTOP = sp; //@line 3162
  return;
 }
}
function _luaB_coresume($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 12974
 $0 = _lua_tothread($L, 1) | 0; //@line 12975
 if (!$0) _luaL_argerror($L, 1, 2640) | 0; //@line 12978
 $4 = _auxresume($L, $0, (_lua_gettop($L) | 0) + -1 | 0) | 0; //@line 12982
 if (($4 | 0) < 0) {
  _lua_pushboolean($L, 0); //@line 12985
  _lua_insert($L, -2); //@line 12986
  $$0 = 2; //@line 12987
  STACKTOP = sp; //@line 12988
  return $$0 | 0; //@line 12988
 } else {
  _lua_pushboolean($L, 1); //@line 12990
  _lua_insert($L, ~$4); //@line 12993
  $$0 = $4 + 1 | 0; //@line 12994
  STACKTOP = sp; //@line 12995
  return $$0 | 0; //@line 12995
 }
 return 0; //@line 12997
}
function _luaO_arith($op, $v1, $v2) {
 $op = $op | 0;
 $v1 = +$v1;
 $v2 = +$v2;
 var $$0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 7076
 switch ($op | 0) {
 case 4:
  {
   $$0 = $v1 - +Math_floor(+($v1 / $v2)) * $v2; //@line 7083
   break;
  }
 case 6:
  {
   $$0 = -$v1; //@line 7088
   break;
  }
 case 2:
  {
   $$0 = $v1 * $v2; //@line 7093
   break;
  }
 case 1:
  {
   $$0 = $v1 - $v2; //@line 7098
   break;
  }
 case 3:
  {
   $$0 = $v1 / $v2; //@line 7103
   break;
  }
 case 0:
  {
   $$0 = $v1 + $v2; //@line 7108
   break;
  }
 case 5:
  {
   $$0 = +Math_pow(+$v1, +$v2); //@line 7113
   break;
  }
 default:
  $$0 = 0.0; //@line 7117
 }
 STACKTOP = sp; //@line 7120
 return +$$0;
}
function _db_traceback($L) {
 $L = $L | 0;
 var $$0$i = 0, $3 = 0, $4 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 13771
 if ((_lua_type($L, 1) | 0) == 8) {
  $$0$i = _lua_tothread($L, 1) | 0; //@line 13776
  $4 = 1; //@line 13776
 } else {
  $$0$i = $L; //@line 13778
  $4 = 0; //@line 13778
 }
 $3 = $4 + 1 | 0; //@line 13780
 $5 = _lua_tolstring($L, $3, 0) | 0; //@line 13781
 if (!$5) if ((_lua_type($L, $3) | 0) >= 1) {
  _lua_pushvalue($L, $3); //@line 13787
  STACKTOP = sp; //@line 13788
  return 1; //@line 13788
 }
 _luaL_traceback($L, $$0$i, $5, _luaL_optinteger($L, $4 | 2, ($$0$i | 0) == ($L | 0) & 1) | 0); //@line 13795
 STACKTOP = sp; //@line 13796
 return 1; //@line 13796
}
function _lua_createtable($L, $narray, $nrec) {
 $L = $L | 0;
 $narray = $narray | 0;
 $nrec = $nrec | 0;
 var $5 = 0, $6 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 3271
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 3278
 $5 = _luaH_new($L) | 0; //@line 3280
 $6 = $L + 8 | 0; //@line 3281
 $7 = HEAP32[$6 >> 2] | 0; //@line 3282
 HEAP32[$7 >> 2] = $5; //@line 3283
 HEAP32[$7 + 8 >> 2] = 69; //@line 3285
 HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + 16; //@line 3288
 if (!(($narray | 0) > 0 | ($nrec | 0) > 0)) {
  STACKTOP = sp; //@line 3293
  return;
 }
 _luaH_resize($L, $5, $narray, $nrec); //@line 3295
 STACKTOP = sp; //@line 3296
 return;
}
function _luaV_tonumber($obj, $n) {
 $obj = $obj | 0;
 $n = $n | 0;
 var $$0 = 0, $1 = 0, $5 = 0, $num = 0, sp = 0;
 sp = STACKTOP; //@line 760
 STACKTOP = STACKTOP + 16 | 0; //@line 761
 $num = sp; //@line 762
 $1 = HEAP32[$obj + 8 >> 2] | 0; //@line 764
 if (($1 | 0) == 3) $$0 = $obj; //@line 767
 else if (($1 & 15 | 0) == 4) {
  $5 = HEAP32[$obj >> 2] | 0; //@line 772
  if (!(_luaO_str2d($5 + 16 | 0, HEAP32[$5 + 12 >> 2] | 0, $num) | 0)) $$0 = 0; //@line 779
 else {
   HEAPF64[$n >> 3] = +HEAPF64[$num >> 3]; //@line 782
   HEAP32[$n + 8 >> 2] = 3; //@line 784
   $$0 = $n; //@line 785
  }
 } else $$0 = 0; //@line 788
 STACKTOP = sp; //@line 791
 return $$0 | 0; //@line 791
}
function _luaL_checktype($L, $narg, $t) {
 $L = $L | 0;
 $narg = $narg | 0;
 $t = $t | 0;
 var $2 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6217
 STACKTOP = STACKTOP + 16 | 0; //@line 6218
 $vararg_buffer = sp; //@line 6219
 if ((_lua_type($L, $narg) | 0) == ($t | 0)) {
  STACKTOP = sp; //@line 6223
  return;
 }
 $2 = _lua_typename($L, $t) | 0; //@line 6225
 $4 = _lua_typename($L, _lua_type($L, $narg) | 0) | 0; //@line 6227
 HEAP32[$vararg_buffer >> 2] = $2; //@line 6228
 HEAP32[$vararg_buffer + 4 >> 2] = $4; //@line 6230
 _luaL_argerror($L, $narg, _lua_pushfstring($L, 832, $vararg_buffer) | 0) | 0; //@line 6232
 STACKTOP = sp; //@line 6233
 return;
}
function _sort_comp($L, $a, $b) {
 $L = $L | 0;
 $a = $a | 0;
 $b = $b | 0;
 var $$0 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 18493
 if (!(_lua_type($L, 2) | 0)) {
  $$0 = _lua_compare($L, $a, $b, 1) | 0; //@line 18498
  STACKTOP = sp; //@line 18499
  return $$0 | 0; //@line 18499
 } else {
  _lua_pushvalue($L, 2); //@line 18501
  _lua_pushvalue($L, $a + -1 | 0); //@line 18503
  _lua_pushvalue($L, $b + -2 | 0); //@line 18505
  _lua_callk($L, 2, 1, 0, 0); //@line 18506
  $4 = _lua_toboolean($L, -1) | 0; //@line 18507
  _lua_settop($L, -2); //@line 18508
  $$0 = $4; //@line 18509
  STACKTOP = sp; //@line 18510
  return $$0 | 0; //@line 18510
 }
 return 0; //@line 18512
}
function _luaB_setmetatable($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, sp = 0;
 sp = STACKTOP; //@line 8005
 STACKTOP = STACKTOP + 16 | 0; //@line 8006
 $0 = _lua_type($L, 2) | 0; //@line 8008
 _luaL_checktype($L, 1, 5); //@line 8009
 if (!(($0 | 0) == 0 | ($0 | 0) == 5)) _luaL_argerror($L, 2, 1464) | 0; //@line 8011
 if (!(_luaL_getmetafield($L, 1, 1488) | 0)) {
  _lua_settop($L, 2); //@line 8016
  _lua_setmetatable($L, 1) | 0; //@line 8017
  $$0 = 1; //@line 8018
  STACKTOP = sp; //@line 8019
  return $$0 | 0; //@line 8019
 } else {
  $$0 = _luaL_error($L, 1504, sp) | 0; //@line 8022
  STACKTOP = sp; //@line 8023
  return $$0 | 0; //@line 8023
 }
 return 0; //@line 8025
}
function _luaK_reserveregs($fs, $n) {
 $fs = $fs | 0;
 $n = $n | 0;
 var $0 = 0, $1 = 0, $14 = 0, $3 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 9380
 $0 = $fs + 48 | 0; //@line 9381
 $1 = HEAP8[$0 >> 0] | 0; //@line 9382
 $3 = ($1 & 255) + $n | 0; //@line 9384
 $5 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 9386
 do if (($3 | 0) > (HEAPU8[$5 >> 0] | 0 | 0)) if (($3 | 0) > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 9396
 else {
  HEAP8[$5 >> 0] = $3; //@line 9400
  $14 = HEAP8[$0 >> 0] | 0; //@line 9402
  break;
 } else $14 = $1; //@line 9406
 while (0);
 HEAP8[$0 >> 0] = ($14 & 255) + $n; //@line 9412
 STACKTOP = sp; //@line 9413
 return;
}
function _luaS_eqstr($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $18 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 13128
 $1 = HEAP8[$a + 4 >> 0] | 0; //@line 13130
 do if ($1 << 24 >> 24 == (HEAP8[$b + 4 >> 0] | 0)) {
  if ($1 << 24 >> 24 == 4) {
   $18 = ($a | 0) == ($b | 0); //@line 13139
   break;
  }
  $8 = HEAP32[$a + 12 >> 2] | 0; //@line 13143
  if (($a | 0) == ($b | 0)) $18 = 1; //@line 13146
 else if (($8 | 0) == (HEAP32[$b + 12 >> 2] | 0)) $18 = (_memcmp($a + 16 | 0, $b + 16 | 0, $8) | 0) == 0; //@line 13156
 else $18 = 0; //@line 13158
 } else $18 = 0; //@line 13162
 while (0);
 STACKTOP = sp; //@line 13166
 return $18 & 1 | 0; //@line 13166
}
function _luaL_requiref($L, $modname, $openf, $glb) {
 $L = $L | 0;
 $modname = $modname | 0;
 $openf = $openf | 0;
 $glb = $glb | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7333
 _lua_pushcclosure($L, $openf, 0); //@line 7334
 _lua_pushstring($L, $modname) | 0; //@line 7335
 _lua_callk($L, 1, 1, 0, 0); //@line 7336
 _luaL_getsubtable($L, -1001e3, 520) | 0; //@line 7337
 _lua_pushvalue($L, -2); //@line 7338
 _lua_setfield($L, -2, $modname); //@line 7339
 _lua_settop($L, -2); //@line 7340
 if (!$glb) {
  STACKTOP = sp; //@line 7343
  return;
 }
 _lua_pushvalue($L, -1); //@line 7345
 _lua_setglobal($L, $modname); //@line 7346
 STACKTOP = sp; //@line 7347
 return;
}
function _b_and($L) {
 $L = $L | 0;
 var $0 = 0, $3 = 0, $i$01$i = 0, $r$0$lcssa$i = 0, $r$02$i = 0, sp = 0;
 sp = STACKTOP; //@line 8331
 $0 = _lua_gettop($L) | 0; //@line 8332
 if (($0 | 0) < 1) $r$0$lcssa$i = -1; //@line 8335
 else {
  $i$01$i = 1; //@line 8337
  $r$02$i = -1; //@line 8337
  while (1) {
   $3 = (_luaL_checkunsigned($L, $i$01$i) | 0) & $r$02$i; //@line 8340
   if (($i$01$i | 0) == ($0 | 0)) {
    $r$0$lcssa$i = $3; //@line 8344
    break;
   } else {
    $i$01$i = $i$01$i + 1 | 0; //@line 8347
    $r$02$i = $3; //@line 8347
   }
  }
 }
 _lua_pushunsigned($L, $r$0$lcssa$i); //@line 8351
 STACKTOP = sp; //@line 8352
 return 1; //@line 8352
}
function _pairsmeta($L, $method, $iszero, $iter) {
 $L = $L | 0;
 $method = $method | 0;
 $iszero = $iszero | 0;
 $iter = $iter | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8209
 if (_luaL_getmetafield($L, 1, $method) | 0) {
  _lua_pushvalue($L, 1); //@line 8213
  _lua_callk($L, 1, 3, 0, 0); //@line 8214
  STACKTOP = sp; //@line 8215
  return;
 }
 _luaL_checktype($L, 1, 5); //@line 8217
 _lua_pushcclosure($L, $iter, 0); //@line 8218
 _lua_pushvalue($L, 1); //@line 8219
 if (!$iszero) {
  _lua_pushnil($L); //@line 8222
  STACKTOP = sp; //@line 8223
  return;
 } else {
  _lua_pushinteger($L, 0); //@line 8225
  STACKTOP = sp; //@line 8226
  return;
 }
}
function _pushglobalfuncname($L, $ar) {
 $L = $L | 0;
 $ar = $ar | 0;
 var $$0 = 0, $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 5869
 $0 = _lua_gettop($L) | 0; //@line 5870
 _lua_getinfo($L, 856, $ar) | 0; //@line 5871
 _lua_rawgeti($L, -1001e3, 2); //@line 5872
 $1 = $0 + 1 | 0; //@line 5873
 if (!(_findfield($L, $1, 2) | 0)) {
  _lua_settop($L, $0); //@line 5877
  $$0 = 0; //@line 5878
  STACKTOP = sp; //@line 5879
  return $$0 | 0; //@line 5879
 } else {
  _lua_copy($L, -1, $1); //@line 5881
  _lua_settop($L, -3); //@line 5882
  $$0 = 1; //@line 5883
  STACKTOP = sp; //@line 5884
  return $$0 | 0; //@line 5884
 }
 return 0; //@line 5886
}
function _io_popen($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, sp = 0;
 sp = STACKTOP; //@line 2666
 STACKTOP = STACKTOP + 16 | 0; //@line 2667
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 2669
 _luaL_optlstring($L, 2, 5520, 0) | 0; //@line 2670
 $1 = _lua_newuserdata($L, 8) | 0; //@line 2671
 $2 = $1 + 4 | 0; //@line 2672
 HEAP32[$2 >> 2] = 0; //@line 2673
 _luaL_setmetatable($L, 4872); //@line 2674
 _luaL_error($L, 5528, sp) | 0; //@line 2675
 HEAP32[$1 >> 2] = 0; //@line 2676
 HEAP32[$2 >> 2] = 176; //@line 2677
 $3 = _luaL_fileresult($L, 0, $0) | 0; //@line 2678
 STACKTOP = sp; //@line 2679
 return $3 | 0; //@line 2679
}
function _luaL_execresult($L, $stat) {
 $L = $L | 0;
 $stat = $stat | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 5950
 if (($stat | 0) == -1) {
  $1 = HEAP32[(___errno_location() | 0) >> 2] | 0; //@line 5953
  _lua_pushnil($L); //@line 5954
  _lua_pushstring($L, _strerror($1 | 0) | 0) | 0; //@line 5956
  _lua_pushinteger($L, $1); //@line 5957
  STACKTOP = sp; //@line 5958
  return 3; //@line 5958
 } else if (!$stat) _lua_pushboolean($L, 1); //@line 5960
 else _lua_pushnil($L); //@line 5962
 _lua_pushstring($L, 272) | 0; //@line 5964
 _lua_pushinteger($L, $stat); //@line 5965
 STACKTOP = sp; //@line 5966
 return 3; //@line 5966
}
function _lua_getglobal($L, $var) {
 $L = $L | 0;
 $var = $var | 0;
 var $15 = 0, $4 = 0, $5 = 0, $6 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 2844
 $4 = _luaH_getint(HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 40 >> 2] | 0, 2) | 0; //@line 2849
 $5 = $L + 8 | 0; //@line 2850
 $6 = HEAP32[$5 >> 2] | 0; //@line 2851
 HEAP32[$5 >> 2] = $6 + 16; //@line 2853
 $8 = _luaS_new($L, $var) | 0; //@line 2854
 HEAP32[$6 >> 2] = $8; //@line 2855
 HEAP32[$6 + 8 >> 2] = HEAPU8[$8 + 4 >> 0] | 0 | 64; //@line 2861
 $15 = (HEAP32[$5 >> 2] | 0) + -16 | 0; //@line 2863
 _luaV_gettable($L, $4, $15, $15); //@line 2864
 STACKTOP = sp; //@line 2865
 return;
}
function _hookf($L, $ar) {
 $L = $L | 0;
 $ar = $ar | 0;
 var $6 = 0, sp = 0;
 sp = STACKTOP; //@line 13802
 _luaL_getsubtable($L, -1001e3, 3368) | 0; //@line 13803
 _lua_pushthread($L) | 0; //@line 13804
 _lua_rawget($L, -2); //@line 13805
 if ((_lua_type($L, -1) | 0) != 6) {
  STACKTOP = sp; //@line 13809
  return;
 }
 _lua_pushstring($L, HEAP32[3392 + (HEAP32[$ar >> 2] << 2) >> 2] | 0) | 0; //@line 13814
 $6 = HEAP32[$ar + 20 >> 2] | 0; //@line 13816
 if (($6 | 0) > -1) _lua_pushinteger($L, $6); //@line 13819
 else _lua_pushnil($L); //@line 13821
 _lua_callk($L, 2, 0, 0, 0); //@line 13823
 STACKTOP = sp; //@line 13824
 return;
}
function _f_setvbuf($L) {
 $L = $L | 0;
 var $0 = 0, $12 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 2046
 STACKTOP = STACKTOP + 16 | 0; //@line 2047
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 2049
 if (!(HEAP32[$0 + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 2054
 $4 = HEAP32[$0 >> 2] | 0; //@line 2056
 $5 = _luaL_checkoption($L, 2, 0, 5168) | 0; //@line 2057
 $6 = _luaL_optinteger($L, 3, 1024) | 0; //@line 2058
 $12 = _luaL_fileresult($L, (_setvbuf($4 | 0, 0, HEAP32[5152 + ($5 << 2) >> 2] | 0, $6 | 0) | 0) == 0 & 1, 0) | 0; //@line 2064
 STACKTOP = sp; //@line 2065
 return $12 | 0; //@line 2065
}
function _b_xor($L) {
 $L = $L | 0;
 var $0 = 0, $3 = 0, $i$01 = 0, $r$0$lcssa = 0, $r$02 = 0, sp = 0;
 sp = STACKTOP; //@line 8392
 $0 = _lua_gettop($L) | 0; //@line 8393
 if (($0 | 0) < 1) $r$0$lcssa = 0; //@line 8396
 else {
  $i$01 = 1; //@line 8398
  $r$02 = 0; //@line 8398
  while (1) {
   $3 = (_luaL_checkunsigned($L, $i$01) | 0) ^ $r$02; //@line 8401
   if (($i$01 | 0) == ($0 | 0)) {
    $r$0$lcssa = $3; //@line 8405
    break;
   } else {
    $i$01 = $i$01 + 1 | 0; //@line 8408
    $r$02 = $3; //@line 8408
   }
  }
 }
 _lua_pushunsigned($L, $r$0$lcssa); //@line 8412
 STACKTOP = sp; //@line 8413
 return 1; //@line 8413
}
function _b_or($L) {
 $L = $L | 0;
 var $0 = 0, $3 = 0, $i$01 = 0, $r$0$lcssa = 0, $r$02 = 0, sp = 0;
 sp = STACKTOP; //@line 8366
 $0 = _lua_gettop($L) | 0; //@line 8367
 if (($0 | 0) < 1) $r$0$lcssa = 0; //@line 8370
 else {
  $i$01 = 1; //@line 8372
  $r$02 = 0; //@line 8372
  while (1) {
   $3 = _luaL_checkunsigned($L, $i$01) | 0 | $r$02; //@line 8375
   if (($i$01 | 0) == ($0 | 0)) {
    $r$0$lcssa = $3; //@line 8379
    break;
   } else {
    $i$01 = $i$01 + 1 | 0; //@line 8382
    $r$02 = $3; //@line 8382
   }
  }
 }
 _lua_pushunsigned($L, $r$0$lcssa); //@line 8386
 STACKTOP = sp; //@line 8387
 return 1; //@line 8387
}
function _b_test($L) {
 $L = $L | 0;
 var $0 = 0, $i$01$i = 0, $r$0$lcssa$i = 0, $r$02$i = 0, sp = 0;
 sp = STACKTOP; //@line 8418
 $0 = _lua_gettop($L) | 0; //@line 8419
 if (($0 | 0) < 1) $r$0$lcssa$i = 1; //@line 8422
 else {
  $i$01$i = 1; //@line 8424
  $r$02$i = -1; //@line 8424
  while (1) {
   $r$02$i = (_luaL_checkunsigned($L, $i$01$i) | 0) & $r$02$i; //@line 8427
   if (($i$01$i | 0) == ($0 | 0)) break; else $i$01$i = $i$01$i + 1 | 0; //@line 8433
  }
  $r$0$lcssa$i = ($r$02$i | 0) != 0; //@line 8437
 }
 _lua_pushboolean($L, $r$0$lcssa$i & 1); //@line 8440
 STACKTOP = sp; //@line 8441
 return 1; //@line 8441
}
function _b_extract($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 8446
 STACKTOP = STACKTOP + 16 | 0; //@line 8447
 $0 = _luaL_checkunsigned($L, 1) | 0; //@line 8449
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 8450
 $2 = _luaL_optinteger($L, 3, 1) | 0; //@line 8451
 if (($1 | 0) <= -1) _luaL_argerror($L, 2, 2224) | 0; //@line 8454
 if (($2 | 0) <= 0) _luaL_argerror($L, 3, 2256) | 0; //@line 8458
 if (($2 + $1 | 0) > 32) _luaL_error($L, 2280, sp) | 0; //@line 8463
 _lua_pushunsigned($L, $0 >>> $1 & ~(-2 << $2 + -1)); //@line 8470
 STACKTOP = sp; //@line 8471
 return 1; //@line 8471
}
function _luaL_getsubtable($L, $idx, $fname) {
 $L = $L | 0;
 $idx = $idx | 0;
 $fname = $fname | 0;
 var $$0 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 7311
 _lua_getfield($L, $idx, $fname); //@line 7312
 if ((_lua_type($L, -1) | 0) == 5) {
  $$0 = 1; //@line 7316
  STACKTOP = sp; //@line 7317
  return $$0 | 0; //@line 7317
 }
 _lua_settop($L, -2); //@line 7319
 $2 = _lua_absindex($L, $idx) | 0; //@line 7320
 _lua_createtable($L, 0, 0); //@line 7321
 _lua_pushvalue($L, -1); //@line 7322
 _lua_setfield($L, $2, $fname); //@line 7323
 $$0 = 0; //@line 7324
 STACKTOP = sp; //@line 7325
 return $$0 | 0; //@line 7325
}
function _io_tmpfile($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $2 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 2703
 $0 = _lua_newuserdata($L, 8) | 0; //@line 2704
 $1 = $0 + 4 | 0; //@line 2705
 HEAP32[$1 >> 2] = 0; //@line 2706
 _luaL_setmetatable($L, 4872); //@line 2707
 HEAP32[$0 >> 2] = 0; //@line 2708
 HEAP32[$1 >> 2] = 175; //@line 2709
 $2 = _tmpfile() | 0; //@line 2710
 HEAP32[$0 >> 2] = $2; //@line 2711
 if ($2) {
  $5 = 1; //@line 2714
  STACKTOP = sp; //@line 2715
  return $5 | 0; //@line 2715
 }
 $5 = _luaL_fileresult($L, 0, 0) | 0; //@line 2718
 STACKTOP = sp; //@line 2719
 return $5 | 0; //@line 2719
}
function ___memrchr($m, $c, $n) {
 $m = $m | 0;
 $c = $c | 0;
 $n = $n | 0;
 var $$0 = 0, $$01 = 0, $0 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 5482
 $0 = $c & 255; //@line 5483
 $$01 = $n; //@line 5484
 while (1) {
  if (!$$01) {
   $$0 = 0; //@line 5489
   label = 4; //@line 5490
   break;
  }
  $$01 = $$01 + -1 | 0; //@line 5486
  $3 = $m + $$01 | 0; //@line 5493
  if ((HEAP8[$3 >> 0] | 0) == $0 << 24 >> 24) {
   $$0 = $3; //@line 5497
   label = 4; //@line 5498
   break;
  }
 }
 if ((label | 0) == 4) {
  STACKTOP = sp; //@line 5505
  return $$0 | 0; //@line 5505
 }
 return 0; //@line 5507
}
function _b_lshift($L) {
 $L = $L | 0;
 var $$1$i = 0, $0 = 0, $1 = 0, $3 = 0, sp = 0;
 sp = STACKTOP; //@line 8496
 $0 = _luaL_checkunsigned($L, 1) | 0; //@line 8497
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 8498
 if (($1 | 0) < 0) {
  $3 = 0 - $1 | 0; //@line 8501
  $$1$i = ($3 | 0) > 31 ? 0 : $0 >>> $3; //@line 8505
  _lua_pushunsigned($L, $$1$i); //@line 8506
  STACKTOP = sp; //@line 8507
  return 1; //@line 8507
 } else {
  $$1$i = ($1 | 0) > 31 ? 0 : $0 << $1; //@line 8512
  _lua_pushunsigned($L, $$1$i); //@line 8513
  STACKTOP = sp; //@line 8514
  return 1; //@line 8514
 }
 return 0; //@line 8516
}
function _b_rshift($L) {
 $L = $L | 0;
 var $$1$i = 0, $0 = 0, $1 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 8577
 $0 = _luaL_checkunsigned($L, 1) | 0; //@line 8578
 $1 = _luaL_checkinteger($L, 2) | 0; //@line 8579
 $2 = 0 - $1 | 0; //@line 8580
 if (($1 | 0) > 0) {
  $$1$i = ($1 | 0) > 31 ? 0 : $0 >>> $1; //@line 8586
  _lua_pushunsigned($L, $$1$i); //@line 8587
  STACKTOP = sp; //@line 8588
  return 1; //@line 8588
 } else {
  $$1$i = ($2 | 0) > 31 ? 0 : $0 << $2; //@line 8593
  _lua_pushunsigned($L, $$1$i); //@line 8594
  STACKTOP = sp; //@line 8595
  return 1; //@line 8595
 }
 return 0; //@line 8597
}
function _str_dump($L) {
 $L = $L | 0;
 var $$0 = 0, $b = 0, sp = 0;
 sp = STACKTOP; //@line 13673
 STACKTOP = STACKTOP + 1056 | 0; //@line 13674
 $b = sp + 8 | 0; //@line 13676
 _luaL_checktype($L, 1, 6); //@line 13677
 _lua_settop($L, 1); //@line 13678
 _luaL_buffinit($L, $b); //@line 13679
 if (!(_lua_dump($L, 19, $b) | 0)) {
  _luaL_pushresult($b); //@line 13683
  $$0 = 1; //@line 13684
  STACKTOP = sp; //@line 13685
  return $$0 | 0; //@line 13685
 } else {
  $$0 = _luaL_error($L, 10744, sp) | 0; //@line 13688
  STACKTOP = sp; //@line 13689
  return $$0 | 0; //@line 13689
 }
 return 0; //@line 13691
}
function _luaL_checkstack($L, $space, $msg) {
 $L = $L | 0;
 $space = $space | 0;
 $msg = $msg | 0;
 var $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP; //@line 6193
 STACKTOP = STACKTOP + 16 | 0; //@line 6194
 $vararg_buffer1 = sp; //@line 6195
 if (_lua_checkstack($L, $space + 20 | 0) | 0) {
  STACKTOP = sp; //@line 6200
  return;
 }
 if (!$msg) {
  _luaL_error($L, 328, $vararg_buffer1) | 0; //@line 6204
  STACKTOP = sp; //@line 6205
  return;
 } else {
  HEAP32[$vararg_buffer1 >> 2] = $msg; //@line 6207
  _luaL_error($L, 304, $vararg_buffer1) | 0; //@line 6208
  STACKTOP = sp; //@line 6209
  return;
 }
}
function _luaF_newLclosure($L, $n) {
 $L = $L | 0;
 $n = $n | 0;
 var $$in = 0, $2 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 18311
 $2 = _luaC_newobj($L, 6, ($n << 2) + 16 | 0, 0, 0) | 0; //@line 18314
 HEAP32[$2 + 12 >> 2] = 0; //@line 18316
 HEAP8[$2 + 6 >> 0] = $n; //@line 18319
 if (!$n) {
  STACKTOP = sp; //@line 18322
  return $2 | 0; //@line 18322
 }
 $7 = $2 + 16 | 0; //@line 18324
 $$in = $n; //@line 18325
 do {
  $$in = $$in + -1 | 0; //@line 18327
  HEAP32[$7 + ($$in << 2) >> 2] = 0; //@line 18329
 } while (($$in | 0) != 0);
 STACKTOP = sp; //@line 18337
 return $2 | 0; //@line 18337
}
function _f_tostring($L) {
 $L = $L | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 2111
 STACKTOP = STACKTOP + 16 | 0; //@line 2112
 $vararg_buffer = sp; //@line 2113
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 2114
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  _lua_pushlstring($L, 5080, 13) | 0; //@line 2119
  STACKTOP = sp; //@line 2120
  return 1; //@line 2120
 } else {
  HEAP32[$vararg_buffer >> 2] = HEAP32[$0 >> 2]; //@line 2123
  _lua_pushfstring($L, 5096, $vararg_buffer) | 0; //@line 2124
  STACKTOP = sp; //@line 2125
  return 1; //@line 2125
 }
 return 0; //@line 2127
}
function _luaT_init($L) {
 $L = $L | 0;
 var $0 = 0, $3 = 0, $9 = 0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 18517
 $0 = $L + 12 | 0; //@line 18518
 $i$01 = 0; //@line 18519
 do {
  $3 = _luaS_new($L, HEAP32[11432 + ($i$01 << 2) >> 2] | 0) | 0; //@line 18523
  HEAP32[(HEAP32[$0 >> 2] | 0) + ($i$01 << 2) + 184 >> 2] = $3; //@line 18526
  $9 = (HEAP32[(HEAP32[$0 >> 2] | 0) + ($i$01 << 2) + 184 >> 2] | 0) + 5 | 0; //@line 18530
  HEAP8[$9 >> 0] = HEAPU8[$9 >> 0] | 0 | 32; //@line 18535
  $i$01 = $i$01 + 1 | 0; //@line 18536
 } while (($i$01 | 0) != 17);
 STACKTOP = sp; //@line 18544
 return;
}
function ___muldi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0;
 $x_sroa_0_0_extract_trunc = $a$0; //@line 17170
 $y_sroa_0_0_extract_trunc = $b$0; //@line 17171
 $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0; //@line 17172
 $1$1 = tempRet0; //@line 17173
 return (tempRet0 = (Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0) + (Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $1$1 | $1$1 & 0, $1$0 | 0 | 0) | 0; //@line 17175
}
function _ll_searchpath($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 6960
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6961
 $1 = _luaL_checklstring($L, 2, 0) | 0; //@line 6962
 $2 = _luaL_optlstring($L, 3, 7792, 0) | 0; //@line 6963
 if (_searchpath($L, $0, $1, $2, _luaL_optlstring($L, 4, 7704, 0) | 0) | 0) {
  $$0 = 1; //@line 6968
  STACKTOP = sp; //@line 6969
  return $$0 | 0; //@line 6969
 }
 _lua_pushnil($L); //@line 6971
 _lua_insert($L, -2); //@line 6972
 $$0 = 2; //@line 6973
 STACKTOP = sp; //@line 6974
 return $$0 | 0; //@line 6974
}
function _luaE_freeCI($L) {
 $L = $L | 0;
 var $2 = 0, $3 = 0, $next$01 = 0, sp = 0, $next$01$looptemp = 0;
 sp = STACKTOP; //@line 12637
 $2 = (HEAP32[$L + 16 >> 2] | 0) + 12 | 0; //@line 12640
 $3 = HEAP32[$2 >> 2] | 0; //@line 12641
 HEAP32[$2 >> 2] = 0; //@line 12642
 if (!$3) {
  STACKTOP = sp; //@line 12645
  return;
 } else $next$01 = $3; //@line 12647
 do {
  $next$01$looptemp = $next$01;
  $next$01 = HEAP32[$next$01 + 12 >> 2] | 0; //@line 12651
  _luaM_realloc_($L, $next$01$looptemp, 40, 0) | 0; //@line 12652
 } while (($next$01 | 0) != 0);
 STACKTOP = sp; //@line 12660
 return;
}
function _io_close($L) {
 $L = $L | 0;
 var $7 = 0, $8 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 1928
 STACKTOP = STACKTOP + 16 | 0; //@line 1929
 if ((_lua_type($L, 1) | 0) == -1) _lua_getfield($L, -1001e3, 4840); //@line 1934
 if (!(HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 1941
 $7 = (_luaL_checkudata($L, 1, 4872) | 0) + 4 | 0; //@line 1944
 $8 = HEAP32[$7 >> 2] | 0; //@line 1945
 HEAP32[$7 >> 2] = 0; //@line 1946
 $9 = FUNCTION_TABLE_ii[$8 & 255]($L) | 0; //@line 1947
 STACKTOP = sp; //@line 1948
 return $9 | 0; //@line 1948
}
function _lua_sethook($L, $func, $mask, $count) {
 $L = $L | 0;
 $func = $func | 0;
 $mask = $mask | 0;
 $count = $count | 0;
 var $3 = 0, $or$cond = 0;
 $or$cond = ($func | 0) == 0 | ($mask | 0) == 0; //@line 13836
 $3 = HEAP32[$L + 16 >> 2] | 0; //@line 13839
 if (HEAP8[$3 + 18 >> 0] & 1) HEAP32[$L + 20 >> 2] = HEAP32[$3 + 28 >> 2]; //@line 13848
 HEAP32[$L + 52 >> 2] = $or$cond ? 0 : $func; //@line 13851
 HEAP32[$L + 44 >> 2] = $count; //@line 13853
 HEAP32[$L + 48 >> 2] = $count; //@line 13855
 HEAP8[$L + 40 >> 0] = $or$cond ? 0 : $mask & 255; //@line 13859
 return 1; //@line 13860
}
function _lua_pushlstring($L, $s, $len) {
 $L = $L | 0;
 $s = $s | 0;
 $len = $len | 0;
 var $5 = 0, $6 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 2610
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2617
 $5 = _luaS_newlstr($L, $s, $len) | 0; //@line 2619
 $6 = $L + 8 | 0; //@line 2620
 $7 = HEAP32[$6 >> 2] | 0; //@line 2621
 HEAP32[$7 >> 2] = $5; //@line 2622
 HEAP32[$7 + 8 >> 2] = HEAPU8[$5 + 4 >> 0] | 0 | 64; //@line 2628
 HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + 16; //@line 2631
 STACKTOP = sp; //@line 2633
 return $5 + 16 | 0; //@line 2633
}
function _finishpcall($L, $status) {
 $L = $L | 0;
 $status = $status | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 8185
 if (!(_lua_checkstack($L, 1) | 0)) {
  _lua_settop($L, 0); //@line 8189
  _lua_pushboolean($L, 0); //@line 8190
  _lua_pushstring($L, 1416) | 0; //@line 8191
  $$0 = 2; //@line 8192
  STACKTOP = sp; //@line 8193
  return $$0 | 0; //@line 8193
 } else {
  _lua_pushboolean($L, $status); //@line 8195
  _lua_replace($L, 1); //@line 8196
  $$0 = _lua_gettop($L) | 0; //@line 8198
  STACKTOP = sp; //@line 8199
  return $$0 | 0; //@line 8199
 }
 return 0; //@line 8201
}
function _io_flush($L) {
 $L = $L | 0;
 var $0 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 2519
 STACKTOP = STACKTOP + 16 | 0; //@line 2520
 $vararg_buffer = sp; //@line 2521
 _lua_getfield($L, -1001e3, 4840); //@line 2522
 $0 = _lua_touserdata($L, -1) | 0; //@line 2523
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  HEAP32[$vararg_buffer >> 2] = 4844; //@line 2528
  _luaL_error($L, 5464, $vararg_buffer) | 0; //@line 2529
 }
 $8 = _luaL_fileresult($L, (_fflush(HEAP32[$0 >> 2] | 0) | 0) == 0 & 1, 0) | 0; //@line 2535
 STACKTOP = sp; //@line 2536
 return $8 | 0; //@line 2536
}
function _searcher_preload($L) {
 $L = $L | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 6639
 STACKTOP = STACKTOP + 16 | 0; //@line 6640
 $vararg_buffer = sp; //@line 6641
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6642
 _lua_getfield($L, -1001e3, 7448); //@line 6643
 _lua_getfield($L, -1, $0); //@line 6644
 if (_lua_type($L, -1) | 0) {
  STACKTOP = sp; //@line 6648
  return 1; //@line 6648
 }
 HEAP32[$vararg_buffer >> 2] = $0; //@line 6650
 _lua_pushfstring($L, 7952, $vararg_buffer) | 0; //@line 6651
 STACKTOP = sp; //@line 6652
 return 1; //@line 6652
}
function _f_gc($L) {
 $L = $L | 0;
 var $0 = 0, $7 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 2088
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 2089
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  STACKTOP = sp; //@line 2094
  return 0; //@line 2094
 }
 if (!(HEAP32[$0 >> 2] | 0)) {
  STACKTOP = sp; //@line 2099
  return 0; //@line 2099
 }
 $7 = (_luaL_checkudata($L, 1, 4872) | 0) + 4 | 0; //@line 2102
 $8 = HEAP32[$7 >> 2] | 0; //@line 2103
 HEAP32[$7 >> 2] = 0; //@line 2104
 FUNCTION_TABLE_ii[$8 & 255]($L) | 0; //@line 2105
 STACKTOP = sp; //@line 2106
 return 0; //@line 2106
}
function _luaF_freeupval($L, $uv) {
 $L = $L | 0;
 $uv = $uv | 0;
 var $4 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 18429
 if ((HEAP32[$uv + 8 >> 2] | 0) == ($uv + 16 | 0)) {
  _luaM_realloc_($L, $uv, 32, 0) | 0; //@line 18435
  STACKTOP = sp; //@line 18436
  return;
 }
 $4 = $uv + 16 | 0; //@line 18438
 $6 = $4 + 4 | 0; //@line 18440
 HEAP32[(HEAP32[$6 >> 2] | 0) + 16 >> 2] = HEAP32[$4 >> 2]; //@line 18443
 HEAP32[(HEAP32[$4 >> 2] | 0) + 20 >> 2] = HEAP32[$6 >> 2]; //@line 18448
 _luaM_realloc_($L, $uv, 32, 0) | 0; //@line 18449
 STACKTOP = sp; //@line 18450
 return;
}
function ___shlim($f, $lim) {
 $f = $f | 0;
 $lim = $lim | 0;
 var $2 = 0, $4 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 12960
 HEAP32[$f + 104 >> 2] = $lim; //@line 12962
 $2 = HEAP32[$f + 8 >> 2] | 0; //@line 12964
 $4 = HEAP32[$f + 4 >> 2] | 0; //@line 12966
 $7 = $2 - $4 | 0; //@line 12969
 HEAP32[$f + 108 >> 2] = $7; //@line 12971
 if (($lim | 0) != 0 & ($7 | 0) > ($lim | 0)) {
  HEAP32[$f + 100 >> 2] = $4 + $lim; //@line 12978
  STACKTOP = sp; //@line 12979
  return;
 } else {
  HEAP32[$f + 100 >> 2] = $2; //@line 12982
  STACKTOP = sp; //@line 12983
  return;
 }
}
function _luaL_getmetafield($L, $obj, $event) {
 $L = $L | 0;
 $obj = $obj | 0;
 $event = $event | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 6933
 do if (!(_lua_getmetatable($L, $obj) | 0)) $$0 = 0; //@line 6938
 else {
  _lua_pushstring($L, $event) | 0; //@line 6940
  _lua_rawget($L, -2); //@line 6941
  if (!(_lua_type($L, -1) | 0)) {
   _lua_settop($L, -3); //@line 6945
   $$0 = 0; //@line 6946
   break;
  } else {
   _lua_remove($L, -2); //@line 6949
   $$0 = 1; //@line 6950
   break;
  }
 } while (0);
 STACKTOP = sp; //@line 6955
 return $$0 | 0; //@line 6955
}
function _luaB_assert($L) {
 $L = $L | 0;
 var $$0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7646
 STACKTOP = STACKTOP + 16 | 0; //@line 7647
 $vararg_buffer = sp; //@line 7648
 if (!(_lua_toboolean($L, 1) | 0)) {
  HEAP32[$vararg_buffer >> 2] = _luaL_optlstring($L, 2, 2e3, 0) | 0; //@line 7653
  $$0 = _luaL_error($L, 1992, $vararg_buffer) | 0; //@line 7655
  STACKTOP = sp; //@line 7656
  return $$0 | 0; //@line 7656
 } else {
  $$0 = _lua_gettop($L) | 0; //@line 7659
  STACKTOP = sp; //@line 7660
  return $$0 | 0; //@line 7660
 }
 return 0; //@line 7662
}
function _db_setupvalue($L) {
 $L = $L | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 13753
 _luaL_checkany($L, 3); //@line 13754
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 13755
 _luaL_checktype($L, 1, 6); //@line 13756
 $1 = _lua_setupvalue($L, 1, $0) | 0; //@line 13757
 if (!$1) {
  $$0$i = 0; //@line 13760
  STACKTOP = sp; //@line 13761
  return $$0$i | 0; //@line 13761
 }
 _lua_pushstring($L, $1) | 0; //@line 13763
 _lua_insert($L, -1); //@line 13764
 $$0$i = 1; //@line 13765
 STACKTOP = sp; //@line 13766
 return $$0$i | 0; //@line 13766
}
function _rand() {
 var $0 = 0, $10 = 0, $14 = 0, $6 = 0, $8 = 0, $9 = 0, sp = 0;
 sp = STACKTOP; //@line 13290
 $0 = 12560; //@line 13291
 $6 = ___muldi3(HEAP32[$0 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0, 1284865837, 1481765933) | 0; //@line 13297
 $8 = _i64Add($6 | 0, tempRet0 | 0, 1, 0) | 0; //@line 13299
 $9 = tempRet0; //@line 13300
 $10 = 12560; //@line 13301
 HEAP32[$10 >> 2] = $8; //@line 13303
 HEAP32[$10 + 4 >> 2] = $9; //@line 13306
 $14 = _bitshift64Lshr($8 | 0, $9 | 0, 33) | 0; //@line 13307
 STACKTOP = sp; //@line 13309
 return $14 | 0; //@line 13309
}
function _luaopen_string($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13528
 _lua_createtable($L, 0, 14); //@line 13529
 _luaL_setfuncs($L, 9776, 0); //@line 13530
 _lua_createtable($L, 0, 1); //@line 13531
 _lua_pushlstring($L, 9896, 0) | 0; //@line 13532
 _lua_pushvalue($L, -2); //@line 13533
 _lua_setmetatable($L, -2) | 0; //@line 13534
 _lua_settop($L, -2); //@line 13535
 _lua_pushvalue($L, -2); //@line 13536
 _lua_setfield($L, -2, 9904); //@line 13537
 _lua_settop($L, -2); //@line 13538
 STACKTOP = sp; //@line 13539
 return 1; //@line 13539
}
function _io_type($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 2724
 _luaL_checkany($L, 1); //@line 2725
 $0 = _luaL_testudata($L, 1, 4872) | 0; //@line 2726
 if (!$0) {
  _lua_pushnil($L); //@line 2729
  STACKTOP = sp; //@line 2730
  return 1; //@line 2730
 }
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  _lua_pushlstring($L, 5496, 11) | 0; //@line 2736
  STACKTOP = sp; //@line 2737
  return 1; //@line 2737
 } else {
  _lua_pushlstring($L, 5512, 4) | 0; //@line 2739
  STACKTOP = sp; //@line 2740
  return 1; //@line 2740
 }
 return 0; //@line 2742
}
function _luaL_addvalue($B) {
 $B = $B | 0;
 var $1 = 0, $2 = 0, $4 = 0, $l = 0, sp = 0;
 sp = STACKTOP; //@line 6531
 STACKTOP = STACKTOP + 16 | 0; //@line 6532
 $l = sp; //@line 6533
 $1 = HEAP32[$B + 12 >> 2] | 0; //@line 6535
 $2 = _lua_tolstring($1, -1, $l) | 0; //@line 6536
 $4 = $B + 16 | 0; //@line 6538
 if ((HEAP32[$B >> 2] | 0) != ($4 | 0)) _lua_insert($1, -2); //@line 6541
 _luaL_addlstring($B, $2, HEAP32[$l >> 2] | 0); //@line 6544
 _lua_remove($1, (HEAP32[$B >> 2] | 0) != ($4 | 0) ? -2 : -1); //@line 6548
 STACKTOP = sp; //@line 6549
 return;
}
function _luaL_testudata($L, $ud, $tname) {
 $L = $L | 0;
 $ud = $ud | 0;
 $tname = $tname | 0;
 var $$0 = 0, $0 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 6001
 $0 = _lua_touserdata($L, $ud) | 0; //@line 6002
 if (!$0) $$0 = 0; //@line 6005
 else if (!(_lua_getmetatable($L, $ud) | 0)) $$0 = 0; //@line 6010
 else {
  _lua_getfield($L, -1001e3, $tname); //@line 6012
  $5 = (_lua_rawequal($L, -1, -2) | 0) == 0; //@line 6014
  _lua_settop($L, -3); //@line 6016
  $$0 = $5 ? 0 : $0; //@line 6017
 }
 STACKTOP = sp; //@line 6020
 return $$0 | 0; //@line 6020
}
function copyTempDouble(ptr) {
 ptr = ptr | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[ptr >> 0]; //@line 34
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[ptr + 1 >> 0]; //@line 35
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[ptr + 2 >> 0]; //@line 36
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[ptr + 3 >> 0]; //@line 37
 HEAP8[tempDoublePtr + 4 >> 0] = HEAP8[ptr + 4 >> 0]; //@line 38
 HEAP8[tempDoublePtr + 5 >> 0] = HEAP8[ptr + 5 >> 0]; //@line 39
 HEAP8[tempDoublePtr + 6 >> 0] = HEAP8[ptr + 6 >> 0]; //@line 40
 HEAP8[tempDoublePtr + 7 >> 0] = HEAP8[ptr + 7 >> 0]; //@line 41
}
function _io_write($L) {
 $L = $L | 0;
 var $0 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 2747
 STACKTOP = STACKTOP + 16 | 0; //@line 2748
 $vararg_buffer = sp; //@line 2749
 _lua_getfield($L, -1001e3, 4840); //@line 2750
 $0 = _lua_touserdata($L, -1) | 0; //@line 2751
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  HEAP32[$vararg_buffer >> 2] = 4844; //@line 2756
  _luaL_error($L, 5464, $vararg_buffer) | 0; //@line 2757
 }
 $5 = _g_write($L, HEAP32[$0 >> 2] | 0, 1) | 0; //@line 2760
 STACKTOP = sp; //@line 2761
 return $5 | 0; //@line 2761
}
function _ll_loadlib($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 6940
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 6941
 $2 = _ll_loadfunc($L, $0, _luaL_checklstring($L, 2, 0) | 0) | 0; //@line 6943
 if (!$2) {
  $$0 = 1; //@line 6946
  STACKTOP = sp; //@line 6947
  return $$0 | 0; //@line 6947
 }
 _lua_pushnil($L); //@line 6949
 _lua_insert($L, -2); //@line 6950
 _lua_pushstring($L, ($2 | 0) == 1 ? 8032 : 8040) | 0; //@line 6953
 $$0 = 3; //@line 6954
 STACKTOP = sp; //@line 6955
 return $$0 | 0; //@line 6955
}
function _io_read($L) {
 $L = $L | 0;
 var $0 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 2684
 STACKTOP = STACKTOP + 16 | 0; //@line 2685
 $vararg_buffer = sp; //@line 2686
 _lua_getfield($L, -1001e3, 4816); //@line 2687
 $0 = _lua_touserdata($L, -1) | 0; //@line 2688
 if (!(HEAP32[$0 + 4 >> 2] | 0)) {
  HEAP32[$vararg_buffer >> 2] = 4820; //@line 2693
  _luaL_error($L, 5464, $vararg_buffer) | 0; //@line 2694
 }
 $5 = _g_read($L, HEAP32[$0 >> 2] | 0, 1) | 0; //@line 2697
 STACKTOP = sp; //@line 2698
 return $5 | 0; //@line 2698
}
function _luaK_codek($fs, $reg, $k) {
 $fs = $fs | 0;
 $reg = $reg | 0;
 $k = $k | 0;
 var $$0 = 0, $1 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 9327
 $1 = $reg << 6; //@line 9329
 if (($k | 0) < 262144) {
  $$0 = _luaK_code($fs, $1 | $k << 14 | 1) | 0; //@line 9335
  STACKTOP = sp; //@line 9336
  return $$0 | 0; //@line 9336
 } else {
  $7 = _luaK_code($fs, $1 | 2) | 0; //@line 9339
  _luaK_code($fs, $k << 6 | 39) | 0; //@line 9342
  $$0 = $7; //@line 9343
  STACKTOP = sp; //@line 9344
  return $$0 | 0; //@line 9344
 }
 return 0; //@line 9346
}
function _math_log($L) {
 $L = $L | 0;
 var $0 = 0.0, $4 = 0.0, $res$0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 6007
 $0 = +_luaL_checknumber($L, 1); //@line 6008
 do if ((_lua_type($L, 2) | 0) < 1) $res$0 = +Math_log(+$0); //@line 6014
 else {
  $4 = +_luaL_checknumber($L, 2); //@line 6016
  if ($4 == 10.0) {
   $res$0 = +_log10(+$0); //@line 6020
   break;
  } else {
   $res$0 = +Math_log(+$0) / +Math_log(+$4); //@line 6026
   break;
  }
 } while (0);
 _lua_pushnumber($L, $res$0); //@line 6031
 STACKTOP = sp; //@line 6032
 return 1; //@line 6032
}
function _lua_newuserdata($L, $size) {
 $L = $L | 0;
 $size = $size | 0;
 var $5 = 0, $6 = 0, $7 = 0, sp = 0;
 sp = STACKTOP; //@line 4992
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 4999
 $5 = _luaS_newudata($L, $size, 0) | 0; //@line 5001
 $6 = $L + 8 | 0; //@line 5002
 $7 = HEAP32[$6 >> 2] | 0; //@line 5003
 HEAP32[$7 >> 2] = $5; //@line 5004
 HEAP32[$7 + 8 >> 2] = 71; //@line 5006
 HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + 16; //@line 5009
 STACKTOP = sp; //@line 5011
 return $5 + 24 | 0; //@line 5011
}
function _luaT_gettm($events, $event, $ename) {
 $events = $events | 0;
 $event = $event | 0;
 $ename = $ename | 0;
 var $$0 = 0, $0 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 18551
 $0 = _luaH_getstr($events, $ename) | 0; //@line 18552
 if (HEAP32[$0 + 8 >> 2] | 0) {
  $$0 = $0; //@line 18557
  STACKTOP = sp; //@line 18558
  return $$0 | 0; //@line 18558
 }
 $5 = $events + 6 | 0; //@line 18561
 HEAP8[$5 >> 0] = HEAPU8[$5 >> 0] | 0 | 1 << $event; //@line 18566
 $$0 = 0; //@line 18567
 STACKTOP = sp; //@line 18568
 return $$0 | 0; //@line 18568
}
function ___uflow($f) {
 $f = $f | 0;
 var $$0 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP; //@line 13405
 STACKTOP = STACKTOP + 16 | 0; //@line 13406
 $c = sp; //@line 13407
 if (!(HEAP32[$f + 8 >> 2] | 0)) if (!(___toread($f) | 0)) label = 3; //@line 13415
 else $$0 = -1; //@line 13417
 else label = 3; //@line 13420
 if ((label | 0) == 3) if ((FUNCTION_TABLE_iiii[HEAP32[$f + 32 >> 2] & 31]($f, $c, 1) | 0) == 1) $$0 = HEAPU8[$c >> 0] | 0; //@line 13430
 else $$0 = -1; //@line 13432
 STACKTOP = sp; //@line 13435
 return $$0 | 0; //@line 13435
}
function ___muldsi3($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
 $1 = $a & 65535; //@line 17114
 $2 = $b & 65535; //@line 17115
 $3 = Math_imul($2, $1) | 0; //@line 17116
 $6 = $a >>> 16; //@line 17117
 $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0; //@line 17118
 $11 = $b >>> 16; //@line 17119
 $12 = Math_imul($11, $1) | 0; //@line 17120
 return (tempRet0 = ($8 >>> 16) + (Math_imul($11, $6) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, $8 + $12 << 16 | $3 & 65535 | 0) | 0; //@line 17121
}
function _luaL_newmetatable($L, $tname) {
 $L = $L | 0;
 $tname = $tname | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 5972
 _lua_getfield($L, -1001e3, $tname); //@line 5973
 if (_lua_type($L, -1) | 0) {
  $$0 = 0; //@line 5977
  STACKTOP = sp; //@line 5978
  return $$0 | 0; //@line 5978
 }
 _lua_settop($L, -2); //@line 5980
 _lua_createtable($L, 0, 0); //@line 5981
 _lua_pushvalue($L, -1); //@line 5982
 _lua_setfield($L, -1001e3, $tname); //@line 5983
 $$0 = 1; //@line 5984
 STACKTOP = sp; //@line 5985
 return $$0 | 0; //@line 5985
}
function _luaB_auxwrap($L) {
 $L = $L | 0;
 var $0 = 0, $2 = 0, sp = 0;
 sp = STACKTOP; //@line 13073
 $0 = _lua_tothread($L, -1001001) | 0; //@line 13074
 $2 = _auxresume($L, $0, _lua_gettop($L) | 0) | 0; //@line 13076
 if (($2 | 0) >= 0) {
  STACKTOP = sp; //@line 13079
  return $2 | 0; //@line 13079
 }
 if (!(_lua_isstring($L, -1) | 0)) _lua_error($L) | 0; //@line 13084
 _luaL_where($L, 1); //@line 13087
 _lua_insert($L, -2); //@line 13088
 _lua_concat($L, 2); //@line 13089
 _lua_error($L) | 0; //@line 13090
 return 0; //@line 13092
}
function _db_getupvalue($L) {
 $L = $L | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 13519
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 13520
 _luaL_checktype($L, 1, 6); //@line 13521
 $1 = _lua_getupvalue($L, 1, $0) | 0; //@line 13522
 if (!$1) {
  $$0$i = 0; //@line 13525
  STACKTOP = sp; //@line 13526
  return $$0$i | 0; //@line 13526
 }
 _lua_pushstring($L, $1) | 0; //@line 13528
 _lua_insert($L, -2); //@line 13529
 $$0$i = 2; //@line 13530
 STACKTOP = sp; //@line 13531
 return $$0$i | 0; //@line 13531
}
function _escerror($ls, $c, $n, $msg) {
 $ls = $ls | 0;
 $c = $c | 0;
 $n = $n | 0;
 $msg = $msg | 0;
 var $5 = 0, $i$01 = 0;
 HEAP32[(HEAP32[$ls + 60 >> 2] | 0) + 4 >> 2] = 0; //@line 5823
 _save($ls, 92); //@line 5824
 L1 : do if (($n | 0) > 0) {
  $i$01 = 0; //@line 5828
  do {
   $5 = HEAP32[$c + ($i$01 << 2) >> 2] | 0; //@line 5831
   if (($5 | 0) == -1) break L1;
   _save($ls, $5); //@line 5836
   $i$01 = $i$01 + 1 | 0; //@line 5837
  } while (($i$01 | 0) < ($n | 0));
 } while (0);
 _lexerror($ls, $msg, 289); //@line 5847
}
function _lua_dump($L, $writer, $data) {
 $L = $L | 0;
 $writer = $writer | 0;
 $data = $data | 0;
 var $1 = 0, $status$0 = 0, sp = 0;
 sp = STACKTOP; //@line 4610
 $1 = HEAP32[$L + 8 >> 2] | 0; //@line 4612
 if ((HEAP32[$1 + -8 >> 2] | 0) != 70) {
  $status$0 = 1; //@line 4617
  STACKTOP = sp; //@line 4618
  return $status$0 | 0; //@line 4618
 }
 $status$0 = _luaU_dump($L, HEAP32[(HEAP32[$1 + -16 >> 2] | 0) + 12 >> 2] | 0, $writer, $data, 0) | 0; //@line 4625
 STACKTOP = sp; //@line 4626
 return $status$0 | 0; //@line 4626
}
function _luaL_pushresultsize($B, $sz) {
 $B = $B | 0;
 $sz = $sz | 0;
 var $0 = 0, $2 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 6510
 $0 = $B + 8 | 0; //@line 6511
 $2 = (HEAP32[$0 >> 2] | 0) + $sz | 0; //@line 6513
 HEAP32[$0 >> 2] = $2; //@line 6514
 $4 = HEAP32[$B + 12 >> 2] | 0; //@line 6516
 _lua_pushlstring($4, HEAP32[$B >> 2] | 0, $2) | 0; //@line 6518
 if ((HEAP32[$B >> 2] | 0) == ($B + 16 | 0)) {
  STACKTOP = sp; //@line 6523
  return;
 }
 _lua_remove($4, -2); //@line 6525
 STACKTOP = sp; //@line 6526
 return;
}
function _sn_write($f, $s, $l) {
 $f = $f | 0;
 $s = $s | 0;
 $l = $l | 0;
 var $2 = 0, $3 = 0, $6 = 0, $l$ = 0, sp = 0;
 sp = STACKTOP; //@line 16662
 $2 = $f + 20 | 0; //@line 16665
 $3 = HEAP32[$2 >> 2] | 0; //@line 16666
 $6 = (HEAP32[$f + 16 >> 2] | 0) - $3 | 0; //@line 16669
 $l$ = $6 >>> 0 > $l >>> 0 ? $l : $6; //@line 16671
 _memcpy($3 | 0, $s | 0, $l$ | 0) | 0; //@line 16672
 HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + $l$; //@line 16675
 STACKTOP = sp; //@line 16676
 return $l | 0; //@line 16676
}
function _os_tmpname($L) {
 $L = $L | 0;
 var $$0 = 0, $buff = 0, sp = 0;
 sp = STACKTOP; //@line 8107
 STACKTOP = STACKTOP + 32 | 0; //@line 8108
 $buff = sp + 4 | 0; //@line 8110
 if (!(_tmpnam($buff | 0) | 0)) {
  $$0 = _luaL_error($L, 8680, sp) | 0; //@line 8115
  STACKTOP = sp; //@line 8116
  return $$0 | 0; //@line 8116
 } else {
  _lua_pushstring($L, $buff) | 0; //@line 8118
  $$0 = 1; //@line 8119
  STACKTOP = sp; //@line 8120
  return $$0 | 0; //@line 8120
 }
 return 0; //@line 8122
}
function _getS($L, $ud, $size) {
 $L = $L | 0;
 $ud = $ud | 0;
 $size = $size | 0;
 var $$0 = 0, $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 6900
 $0 = $ud + 4 | 0; //@line 6901
 $1 = HEAP32[$0 >> 2] | 0; //@line 6902
 if (!$1) {
  $$0 = 0; //@line 6905
  STACKTOP = sp; //@line 6906
  return $$0 | 0; //@line 6906
 }
 HEAP32[$size >> 2] = $1; //@line 6908
 HEAP32[$0 >> 2] = 0; //@line 6909
 $$0 = HEAP32[$ud >> 2] | 0; //@line 6911
 STACKTOP = sp; //@line 6912
 return $$0 | 0; //@line 6912
}
function _luaH_new($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 16878
 $0 = _luaC_newobj($L, 5, 32, 0, 0) | 0; //@line 16879
 HEAP32[$0 + 8 >> 2] = 0; //@line 16881
 HEAP8[$0 + 6 >> 0] = -1; //@line 16883
 HEAP32[$0 + 12 >> 2] = 0; //@line 16885
 HEAP32[$0 + 28 >> 2] = 0; //@line 16887
 HEAP32[$0 + 16 >> 2] = 10872; //@line 16889
 HEAP8[$0 + 7 >> 0] = 0; //@line 16891
 HEAP32[$0 + 20 >> 2] = 10872; //@line 16893
 STACKTOP = sp; //@line 16894
 return $0 | 0; //@line 16894
}
function _lua_pushfstring($L, $fmt, $varargs) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $5 = 0, $argp = 0, sp = 0;
 sp = STACKTOP; //@line 2699
 STACKTOP = STACKTOP + 16 | 0; //@line 2700
 $argp = sp; //@line 2701
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2708
 HEAP32[$argp >> 2] = $varargs; //@line 2710
 $5 = _luaO_pushvfstring($L, $fmt, $argp) | 0; //@line 2711
 STACKTOP = sp; //@line 2712
 return $5 | 0; //@line 2712
}
function _luaC_barrier_($L, $o, $v) {
 $L = $L | 0;
 $o = $o | 0;
 $v = $v | 0;
 var $1 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 18716
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 18718
 if ((HEAPU8[$1 + 61 >> 0] | 0) < 2) {
  _reallymarkobject($1, $v); //@line 18723
  STACKTOP = sp; //@line 18724
  return;
 } else {
  $5 = $o + 5 | 0; //@line 18726
  HEAP8[$5 >> 0] = (HEAPU8[$1 + 60 >> 0] | 0) & 3 | (HEAPU8[$5 >> 0] | 0) & 184; //@line 18736
  STACKTOP = sp; //@line 18737
  return;
 }
}
function _os_execute($L) {
 $L = $L | 0;
 var $$0 = 0, $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 7905
 $0 = _luaL_optlstring($L, 1, 0, 0) | 0; //@line 7906
 $1 = _system($0 | 0) | 0; //@line 7907
 if (!$0) {
  _lua_pushboolean($L, $1); //@line 7910
  $$0 = 1; //@line 7911
  STACKTOP = sp; //@line 7912
  return $$0 | 0; //@line 7912
 } else {
  $$0 = _luaL_execresult($L, $1) | 0; //@line 7915
  STACKTOP = sp; //@line 7916
  return $$0 | 0; //@line 7916
 }
 return 0; //@line 7918
}
function _luaL_loadbufferx($L, $buff, $size, $name, $mode) {
 $L = $L | 0;
 $buff = $buff | 0;
 $size = $size | 0;
 $name = $name | 0;
 $mode = $mode | 0;
 var $1 = 0, $ls = 0, sp = 0;
 sp = STACKTOP; //@line 6886
 STACKTOP = STACKTOP + 16 | 0; //@line 6887
 $ls = sp; //@line 6888
 HEAP32[$ls >> 2] = $buff; //@line 6889
 HEAP32[$ls + 4 >> 2] = $size; //@line 6891
 $1 = _lua_load($L, 20, $ls, $name, $mode) | 0; //@line 6892
 STACKTOP = sp; //@line 6893
 return $1 | 0; //@line 6893
}
function _luaK_checkstack($fs, $n) {
 $fs = $fs | 0;
 $n = $n | 0;
 var $3 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 9352
 $3 = (HEAPU8[$fs + 48 >> 0] | 0) + $n | 0; //@line 9356
 $5 = (HEAP32[$fs >> 2] | 0) + 78 | 0; //@line 9358
 if (($3 | 0) <= (HEAPU8[$5 >> 0] | 0 | 0)) {
  STACKTOP = sp; //@line 9363
  return;
 }
 if (($3 | 0) > 249) _luaX_syntaxerror(HEAP32[$fs + 12 >> 2] | 0, 2320); //@line 9369
 HEAP8[$5 >> 0] = $3; //@line 9373
 STACKTOP = sp; //@line 9374
 return;
}
function _luaS_newudata($L, $s, $e) {
 $L = $L | 0;
 $s = $s | 0;
 $e = $e | 0;
 var $2 = 0, sp = 0;
 sp = STACKTOP; //@line 13507
 if ($s >>> 0 > 4294967269) _luaM_toobig($L); //@line 13510
 else {
  $2 = _luaC_newobj($L, 7, $s + 24 | 0, 0, 0) | 0; //@line 13514
  HEAP32[$2 + 16 >> 2] = $s; //@line 13516
  HEAP32[$2 + 8 >> 2] = 0; //@line 13518
  HEAP32[$2 + 12 >> 2] = $e; //@line 13520
  STACKTOP = sp; //@line 13521
  return $2 | 0; //@line 13521
 }
 return 0; //@line 13523
}
function _error($S, $why) {
 $S = $S | 0;
 $why = $why | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 742
 STACKTOP = STACKTOP + 16 | 0; //@line 743
 $vararg_buffer = sp; //@line 744
 $0 = HEAP32[$S >> 2] | 0; //@line 745
 HEAP32[$vararg_buffer >> 2] = HEAP32[$S + 12 >> 2]; //@line 748
 HEAP32[$vararg_buffer + 4 >> 2] = $why; //@line 750
 _luaO_pushfstring($0, 11696, $vararg_buffer) | 0; //@line 751
 _luaD_throw(HEAP32[$S >> 2] | 0, 3); //@line 753
}
function _luaB_xpcall($L) {
 $L = $L | 0;
 var $0 = 0, $6 = 0, sp = 0;
 sp = STACKTOP; //@line 8155
 $0 = _lua_gettop($L) | 0; //@line 8156
 if (($0 | 0) <= 1) _luaL_argerror($L, 2, 1400) | 0; //@line 8159
 _lua_pushvalue($L, 1); //@line 8161
 _lua_copy($L, 2, 1); //@line 8162
 _lua_replace($L, 2); //@line 8163
 $6 = _finishpcall($L, (_lua_pcallk($L, $0 + -2 | 0, -1, 1, 0, 161) | 0) == 0 & 1) | 0; //@line 8168
 STACKTOP = sp; //@line 8169
 return $6 | 0; //@line 8169
}
function ___uremdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $rem = 0, __stackBase__ = 0;
 __stackBase__ = STACKTOP; //@line 17192
 STACKTOP = STACKTOP + 8 | 0; //@line 17193
 $rem = __stackBase__ | 0; //@line 17194
 ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) | 0; //@line 17195
 STACKTOP = __stackBase__; //@line 17196
 return (tempRet0 = HEAP32[$rem + 4 >> 2] | 0, HEAP32[$rem >> 2] | 0) | 0; //@line 17197
}
function _llvm_cttz_i32(x) {
 x = x | 0;
 var ret = 0;
 ret = HEAP8[cttz_i8 + (x & 255) >> 0] | 0; //@line 17100
 if ((ret | 0) < 8) return ret | 0; //@line 17101
 ret = HEAP8[cttz_i8 + (x >> 8 & 255) >> 0] | 0; //@line 17102
 if ((ret | 0) < 8) return ret + 8 | 0; //@line 17103
 ret = HEAP8[cttz_i8 + (x >> 16 & 255) >> 0] | 0; //@line 17104
 if ((ret | 0) < 8) return ret + 16 | 0; //@line 17105
 return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0; //@line 17106
}
function _llvm_ctlz_i32(x) {
 x = x | 0;
 var ret = 0;
 ret = HEAP8[ctlz_i8 + (x >>> 24) >> 0] | 0; //@line 17088
 if ((ret | 0) < 8) return ret | 0; //@line 17089
 ret = HEAP8[ctlz_i8 + (x >> 16 & 255) >> 0] | 0; //@line 17090
 if ((ret | 0) < 8) return ret + 8 | 0; //@line 17091
 ret = HEAP8[ctlz_i8 + (x >> 8 & 255) >> 0] | 0; //@line 17092
 if ((ret | 0) < 8) return ret + 16 | 0; //@line 17093
 return (HEAP8[ctlz_i8 + (x & 255) >> 0] | 0) + 24 | 0; //@line 17094
}
function _resume_error($L, $msg, $firstArg) {
 $L = $L | 0;
 $msg = $msg | 0;
 $firstArg = $firstArg | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 17550
 HEAP32[$0 >> 2] = $firstArg; //@line 17551
 $1 = _luaS_new($L, $msg) | 0; //@line 17552
 HEAP32[$firstArg >> 2] = $1; //@line 17553
 HEAP32[$firstArg + 8 >> 2] = HEAPU8[$1 + 4 >> 0] | 0 | 64; //@line 17559
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 16; //@line 17562
 _luaD_throw($L, -1); //@line 17563
}
function _lua_getctx($L, $ctx) {
 $L = $L | 0;
 $ctx = $ctx | 0;
 var $$0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 4278
 $1 = HEAP32[$L + 16 >> 2] | 0; //@line 4280
 if (!(HEAP8[$1 + 18 >> 0] & 8)) {
  $$0 = 0; //@line 4286
  STACKTOP = sp; //@line 4287
  return $$0 | 0; //@line 4287
 }
 if ($ctx) HEAP32[$ctx >> 2] = HEAP32[$1 + 24 >> 2]; //@line 4293
 $$0 = HEAPU8[$1 + 37 >> 0] | 0; //@line 4298
 STACKTOP = sp; //@line 4299
 return $$0 | 0; //@line 4299
}
function _luaL_len($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $0 = 0, $isnum = 0, sp = 0;
 sp = STACKTOP; //@line 6991
 STACKTOP = STACKTOP + 16 | 0; //@line 6992
 $isnum = sp + 4 | 0; //@line 6994
 _lua_len($L, $idx); //@line 6995
 $0 = _lua_tointegerx($L, -1, $isnum) | 0; //@line 6996
 if (!(HEAP32[$isnum >> 2] | 0)) _luaL_error($L, 440, sp) | 0; //@line 7000
 _lua_settop($L, -2); //@line 7002
 STACKTOP = sp; //@line 7003
 return $0 | 0; //@line 7003
}
function _f_write($L) {
 $L = $L | 0;
 var $0 = 0, $4 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 2070
 STACKTOP = STACKTOP + 16 | 0; //@line 2071
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 2073
 if (!(HEAP32[$0 + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 2078
 $4 = HEAP32[$0 >> 2] | 0; //@line 2080
 _lua_pushvalue($L, 1); //@line 2081
 $5 = _g_write($L, $4, 2) | 0; //@line 2082
 STACKTOP = sp; //@line 2083
 return $5 | 0; //@line 2083
}
function _luaX_init($L) {
 $L = $L | 0;
 var $2 = 0, $3 = 0, $i$01 = 0, sp = 0;
 sp = STACKTOP; //@line 2835
 $i$01 = 0; //@line 2836
 do {
  $2 = _luaS_new($L, HEAP32[5616 + ($i$01 << 2) >> 2] | 0) | 0; //@line 2840
  $3 = $2 + 5 | 0; //@line 2841
  HEAP8[$3 >> 0] = HEAPU8[$3 >> 0] | 0 | 32; //@line 2846
  $i$01 = $i$01 + 1 | 0; //@line 2847
  HEAP8[$2 + 6 >> 0] = $i$01; //@line 2850
 } while (($i$01 | 0) != 22);
 STACKTOP = sp; //@line 2858
 return;
}
function _panic($L) {
 $L = $L | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 7554
 STACKTOP = STACKTOP + 16 | 0; //@line 7555
 $vararg_buffer = sp; //@line 7556
 $0 = HEAP32[_stderr >> 2] | 0; //@line 7557
 HEAP32[$vararg_buffer >> 2] = _lua_tolstring($L, -1, 0) | 0; //@line 7559
 _fprintf($0 | 0, 744, $vararg_buffer | 0) | 0; //@line 7560
 _fflush($0 | 0) | 0; //@line 7561
 STACKTOP = sp; //@line 7562
 return 0; //@line 7562
}
function _luaB_dofile($L) {
 $L = $L | 0;
 var $0 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 7697
 $0 = _luaL_optlstring($L, 1, 0, 0) | 0; //@line 7698
 _lua_settop($L, 1); //@line 7699
 if (!(_luaL_loadfilex($L, $0, 0) | 0)) {
  _lua_callk($L, 0, -1, 0, 159); //@line 7703
  $4 = (_lua_gettop($L) | 0) + -1 | 0; //@line 7705
  STACKTOP = sp; //@line 7706
  return $4 | 0; //@line 7706
 } else _lua_error($L) | 0; //@line 7708
 return 0; //@line 7711
}
function _gctm($L) {
 $L = $L | 0;
 var $0 = 0, $n$01 = 0, sp = 0;
 sp = STACKTOP; //@line 6421
 $0 = _luaL_len($L, 1) | 0; //@line 6422
 if (($0 | 0) > 0) $n$01 = $0; //@line 6425
 else {
  STACKTOP = sp; //@line 6427
  return 0; //@line 6427
 }
 do {
  _lua_rawgeti($L, 1, $n$01); //@line 6430
  _lua_settop($L, -2); //@line 6431
  $n$01 = $n$01 + -1 | 0; //@line 6432
 } while (($n$01 | 0) > 0);
 STACKTOP = sp; //@line 6440
 return 0; //@line 6440
}
function _os_exit($L) {
 $L = $L | 0;
 var $status$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7923
 if ((_lua_type($L, 1) | 0) == 1) $status$0 = (_lua_toboolean($L, 1) | 0) == 0 & 1; //@line 7930
 else $status$0 = _luaL_optinteger($L, 1, 0) | 0; //@line 7933
 if (_lua_toboolean($L, 2) | 0) _lua_close($L); //@line 7938
 if (!$L) {
  STACKTOP = sp; //@line 7942
  return 0; //@line 7942
 } else _exit($status$0 | 0); //@line 7944
 return 0; //@line 7947
}
function _b_rrot($L) {
 $L = $L | 0;
 var $1 = 0, $2 = 0, $3 = 0, $r$0$i = 0, sp = 0;
 sp = STACKTOP; //@line 8556
 $1 = 0 - (_luaL_checkinteger($L, 2) | 0) | 0; //@line 8558
 $2 = _luaL_checkunsigned($L, 1) | 0; //@line 8559
 $3 = $1 & 31; //@line 8560
 if (!$3) $r$0$i = $2; //@line 8563
 else $r$0$i = $2 >>> (32 - $3 | 0) | $2 << $3; //@line 8569
 _lua_pushunsigned($L, $r$0$i); //@line 8571
 STACKTOP = sp; //@line 8572
 return 1; //@line 8572
}
function _luaL_unref($L, $t, $ref) {
 $L = $L | 0;
 $t = $t | 0;
 $ref = $ref | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 6639
 if (($ref | 0) <= -1) {
  STACKTOP = sp; //@line 6642
  return;
 }
 $1 = _lua_absindex($L, $t) | 0; //@line 6644
 _lua_rawgeti($L, $1, 0); //@line 6645
 _lua_rawseti($L, $1, $ref); //@line 6646
 _lua_pushinteger($L, $ref); //@line 6647
 _lua_rawseti($L, $1, 0); //@line 6648
 STACKTOP = sp; //@line 6649
 return;
}
function _luaH_free($L, $t) {
 $L = $L | 0;
 $t = $t | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 16900
 $1 = HEAP32[$t + 16 >> 2] | 0; //@line 16902
 if (($1 | 0) != 10872) _luaM_realloc_($L, $1, 32 << (HEAPU8[$t + 7 >> 0] | 0), 0) | 0; //@line 16909
 _luaM_realloc_($L, HEAP32[$t + 12 >> 2] | 0, HEAP32[$t + 28 >> 2] << 4, 0) | 0; //@line 16916
 _luaM_realloc_($L, $t, 32, 0) | 0; //@line 16917
 STACKTOP = sp; //@line 16918
 return;
}
function _luaL_loadstring($L, $s) {
 $L = $L | 0;
 $s = $s | 0;
 var $0 = 0, $2 = 0, $ls$i = 0, sp = 0;
 sp = STACKTOP; //@line 6918
 STACKTOP = STACKTOP + 16 | 0; //@line 6919
 $ls$i = sp; //@line 6920
 $0 = _strlen($s | 0) | 0; //@line 6921
 HEAP32[$ls$i >> 2] = $s; //@line 6922
 HEAP32[$ls$i + 4 >> 2] = $0; //@line 6924
 $2 = _lua_load($L, 20, $ls$i, $s, 0) | 0; //@line 6925
 STACKTOP = sp; //@line 6926
 return $2 | 0; //@line 6926
}
function _b_lrot($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $2 = 0, $r$0$i = 0, sp = 0;
 sp = STACKTOP; //@line 8476
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 8477
 $1 = _luaL_checkunsigned($L, 1) | 0; //@line 8478
 $2 = $0 & 31; //@line 8479
 if (!$2) $r$0$i = $1; //@line 8482
 else $r$0$i = $1 >>> (32 - $2 | 0) | $1 << $2; //@line 8488
 _lua_pushunsigned($L, $r$0$i); //@line 8490
 STACKTOP = sp; //@line 8491
 return 1; //@line 8491
}
function _error_expected($ls, $token) {
 $ls = $ls | 0;
 $token = $token | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP; //@line 9064
 STACKTOP = STACKTOP + 16 | 0; //@line 9065
 $vararg_buffer = sp; //@line 9066
 $1 = HEAP32[$ls + 52 >> 2] | 0; //@line 9068
 HEAP32[$vararg_buffer >> 2] = _luaX_token2str($ls, $token) | 0; //@line 9070
 _luaX_syntaxerror($ls, _luaO_pushfstring($1, 9184, $vararg_buffer) | 0); //@line 9072
}
function _luaC_runtilstate($L, $statesmask) {
 $L = $L | 0;
 $statesmask = $statesmask | 0;
 var $2 = 0, sp = 0;
 sp = STACKTOP; //@line 19244
 $2 = (HEAP32[$L + 12 >> 2] | 0) + 61 | 0; //@line 19247
 if (1 << (HEAPU8[$2 >> 0] | 0) & $statesmask) {
  STACKTOP = sp; //@line 19254
  return;
 }
 do _singlestep($L) | 0; //@line 19257
 while ((1 << (HEAPU8[$2 >> 0] | 0) & $statesmask | 0) == 0);
 STACKTOP = sp; //@line 19267
 return;
}
function _ll_seeall($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6979
 _luaL_checktype($L, 1, 5); //@line 6980
 if (!(_lua_getmetatable($L, 1) | 0)) {
  _lua_createtable($L, 0, 1); //@line 6984
  _lua_pushvalue($L, -1); //@line 6985
  _lua_setmetatable($L, 1) | 0; //@line 6986
 }
 _lua_rawgeti($L, -1001e3, 2); //@line 6988
 _lua_setfield($L, -2, 8024); //@line 6989
 STACKTOP = sp; //@line 6990
 return 0; //@line 6990
}
function _luaS_eqlngstr($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $11 = 0, sp = 0;
 sp = STACKTOP; //@line 13100
 $1 = HEAP32[$a + 12 >> 2] | 0; //@line 13102
 if (($a | 0) == ($b | 0)) $11 = 1; //@line 13105
 else if (($1 | 0) == (HEAP32[$b + 12 >> 2] | 0)) $11 = (_memcmp($a + 16 | 0, $b + 16 | 0, $1) | 0) == 0; //@line 13115
 else $11 = 0; //@line 13117
 STACKTOP = sp; //@line 13121
 return $11 & 1 | 0; //@line 13121
}
function _luaK_indexed($fs, $t, $k) {
 $fs = $fs | 0;
 $t = $t | 0;
 $k = $k | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 11665
 $0 = $t + 8 | 0; //@line 11666
 HEAP8[$0 + 2 >> 0] = HEAP32[$0 >> 2]; //@line 11670
 HEAP16[$0 >> 1] = _luaK_exp2RK($fs, $k) | 0; //@line 11673
 HEAP8[$0 + 3 >> 0] = (HEAP32[$t >> 2] | 0) == 8 ? 8 : 7; //@line 11678
 HEAP32[$t >> 2] = 9; //@line 11679
 STACKTOP = sp; //@line 11680
 return;
}
function _ipairsaux($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, $3 = 0, sp = 0;
 sp = STACKTOP; //@line 8261
 $0 = _luaL_checkinteger($L, 2) | 0; //@line 8262
 _luaL_checktype($L, 1, 5); //@line 8263
 $1 = $0 + 1 | 0; //@line 8264
 _lua_pushinteger($L, $1); //@line 8265
 _lua_rawgeti($L, 1, $1); //@line 8266
 $3 = (_lua_type($L, -1) | 0) == 0; //@line 8268
 STACKTOP = sp; //@line 8270
 return ($3 ? 1 : 2) | 0; //@line 8270
}
function _f_flush($L) {
 $L = $L | 0;
 var $0 = 0, $8 = 0, sp = 0;
 sp = STACKTOP; //@line 1953
 STACKTOP = STACKTOP + 16 | 0; //@line 1954
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 1956
 if (!(HEAP32[$0 + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 1961
 $8 = _luaL_fileresult($L, (_fflush(HEAP32[$0 >> 2] | 0) | 0) == 0 & 1, 0) | 0; //@line 1967
 STACKTOP = sp; //@line 1968
 return $8 | 0; //@line 1968
}
function _sort($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 18318
 _luaL_checktype($L, 1, 5); //@line 18319
 $0 = _luaL_len($L, 1) | 0; //@line 18320
 _luaL_checkstack($L, 40, 11064); //@line 18321
 if ((_lua_type($L, 2) | 0) >= 1) _luaL_checktype($L, 2, 6); //@line 18325
 _lua_settop($L, 2); //@line 18327
 _auxsort($L, 1, $0); //@line 18328
 STACKTOP = sp; //@line 18329
 return 0; //@line 18329
}
function _db_setuservalue($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13624
 if ((_lua_type($L, 1) | 0) == 2) _luaL_argerror($L, 1, 3464) | 0; //@line 13628
 _luaL_checktype($L, 1, 7); //@line 13630
 if ((_lua_type($L, 2) | 0) >= 1) _luaL_checktype($L, 2, 5); //@line 13634
 _lua_settop($L, 2); //@line 13636
 _lua_setuservalue($L, 1); //@line 13637
 STACKTOP = sp; //@line 13638
 return 1; //@line 13638
}
function _lua_absindex($L, $idx) {
 $L = $L | 0;
 $idx = $idx | 0;
 var $11 = 0, sp = 0;
 sp = STACKTOP; //@line 207
 if (($idx + 1000999 | 0) >>> 0 > 1000999) {
  $11 = $idx; //@line 211
  STACKTOP = sp; //@line 212
  return $11 | 0; //@line 212
 }
 $11 = ((HEAP32[$L + 8 >> 2] | 0) - (HEAP32[HEAP32[$L + 16 >> 2] >> 2] | 0) >> 4) + $idx | 0; //@line 224
 STACKTOP = sp; //@line 225
 return $11 | 0; //@line 225
}
function _luaE_extendCI($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0, sp = 0;
 sp = STACKTOP; //@line 12621
 $0 = _luaM_realloc_($L, 0, 0, 40) | 0; //@line 12622
 $1 = $L + 16 | 0; //@line 12623
 HEAP32[(HEAP32[$1 >> 2] | 0) + 12 >> 2] = $0; //@line 12626
 HEAP32[$0 + 8 >> 2] = HEAP32[$1 >> 2]; //@line 12629
 HEAP32[$0 + 12 >> 2] = 0; //@line 12631
 STACKTOP = sp; //@line 12632
 return $0 | 0; //@line 12632
}
function _luaopen_math($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5853
 _lua_createtable($L, 0, 28); //@line 5854
 _luaL_setfuncs($L, 6432, 0); //@line 5855
 _lua_pushnumber($L, 3.141592653589793); //@line 5856
 _lua_setfield($L, -2, 6664); //@line 5857
 _lua_pushnumber($L, inf); //@line 5858
 _lua_setfield($L, -2, 6672); //@line 5859
 STACKTOP = sp; //@line 5860
 return 1; //@line 5860
}
function _luaopen_base($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7634
 _lua_rawgeti($L, -1001e3, 2); //@line 7635
 _lua_rawgeti($L, -1001e3, 2); //@line 7636
 _lua_setfield($L, -2, 928); //@line 7637
 _luaL_setfuncs($L, 936, 0); //@line 7638
 _lua_pushlstring($L, 1128, 7) | 0; //@line 7639
 _lua_setfield($L, -2, 1136); //@line 7640
 STACKTOP = sp; //@line 7641
 return 1; //@line 7641
}
function _luaO_pushfstring($L, $fmt, $varargs) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $argp = 0, sp = 0;
 sp = STACKTOP; //@line 7639
 STACKTOP = STACKTOP + 16 | 0; //@line 7640
 $argp = sp; //@line 7641
 HEAP32[$argp >> 2] = $varargs; //@line 7642
 $0 = _luaO_pushvfstring($L, $fmt, $argp) | 0; //@line 7643
 STACKTOP = sp; //@line 7644
 return $0 | 0; //@line 7644
}
function _luaB_getmetatable($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7737
 _luaL_checkany($L, 1); //@line 7738
 if (!(_lua_getmetatable($L, 1) | 0)) {
  _lua_pushnil($L); //@line 7742
  STACKTOP = sp; //@line 7743
  return 1; //@line 7743
 } else {
  _luaL_getmetafield($L, 1, 1488) | 0; //@line 7745
  STACKTOP = sp; //@line 7746
  return 1; //@line 7746
 }
 return 0; //@line 7748
}
function _luaK_stringK($fs, $s) {
 $fs = $fs | 0;
 $s = $s | 0;
 var $5 = 0, $o = 0, sp = 0;
 sp = STACKTOP; //@line 9419
 STACKTOP = STACKTOP + 16 | 0; //@line 9420
 $o = sp; //@line 9421
 HEAP32[$o >> 2] = $s; //@line 9422
 HEAP32[$o + 8 >> 2] = HEAPU8[$s + 4 >> 0] | 0 | 64; //@line 9428
 $5 = _addk($fs, $o, $o) | 0; //@line 9429
 STACKTOP = sp; //@line 9430
 return $5 | 0; //@line 9430
}
function _luaB_error($L) {
 $L = $L | 0;
 var $0 = 0;
 $0 = _luaL_optinteger($L, 2, 1) | 0; //@line 7717
 _lua_settop($L, 1); //@line 7718
 if (!((_lua_isstring($L, 1) | 0) != 0 & ($0 | 0) > 0)) _lua_error($L) | 0; //@line 7724
 _luaL_where($L, $0); //@line 7727
 _lua_pushvalue($L, 1); //@line 7728
 _lua_concat($L, 2); //@line 7729
 _lua_error($L) | 0; //@line 7730
 return 0; //@line 7732
}
function _luaL_pushresult($B) {
 $B = $B | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 6490
 $1 = HEAP32[$B + 12 >> 2] | 0; //@line 6492
 _lua_pushlstring($1, HEAP32[$B >> 2] | 0, HEAP32[$B + 8 >> 2] | 0) | 0; //@line 6496
 if ((HEAP32[$B >> 2] | 0) == ($B + 16 | 0)) {
  STACKTOP = sp; //@line 6501
  return;
 }
 _lua_remove($1, -2); //@line 6503
 STACKTOP = sp; //@line 6504
 return;
}
function _f_read($L) {
 $L = $L | 0;
 var $0 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 1989
 STACKTOP = STACKTOP + 16 | 0; //@line 1990
 $0 = _luaL_checkudata($L, 1, 4872) | 0; //@line 1992
 if (!(HEAP32[$0 + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 1997
 $5 = _g_read($L, HEAP32[$0 >> 2] | 0, 2) | 0; //@line 2000
 STACKTOP = sp; //@line 2001
 return $5 | 0; //@line 2001
}
function _sprintf($s, $fmt, $varargs) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP; //@line 13530
 STACKTOP = STACKTOP + 16 | 0; //@line 13531
 $ap = sp; //@line 13532
 HEAP32[$ap >> 2] = $varargs; //@line 13533
 $0 = _vsprintf($s, $fmt, $ap) | 0; //@line 13534
 STACKTOP = sp; //@line 13535
 return $0 | 0; //@line 13535
}
function _math_modf($L) {
 $L = $L | 0;
 var $1 = 0.0, $ip = 0, sp = 0;
 sp = STACKTOP; //@line 6093
 STACKTOP = STACKTOP + 16 | 0; //@line 6094
 $ip = sp; //@line 6095
 $1 = +_modf(+(+_luaL_checknumber($L, 1)), $ip | 0); //@line 6097
 _lua_pushnumber($L, +HEAPF64[$ip >> 3]); //@line 6099
 _lua_pushnumber($L, $1); //@line 6100
 STACKTOP = sp; //@line 6101
 return 2; //@line 6101
}
function _lua_pushunsigned($L, $u) {
 $L = $L | 0;
 $u = $u | 0;
 var $3 = 0, $4 = 0, $5 = 0.0;
 if (($u | 0) > -1) $5 = +($u | 0); //@line 2591
 else $5 = +($u >>> 0); //@line 2594
 $3 = $L + 8 | 0; //@line 2596
 $4 = HEAP32[$3 >> 2] | 0; //@line 2597
 HEAPF64[$4 >> 3] = $5; //@line 2598
 HEAP32[$4 + 8 >> 2] = 3; //@line 2600
 HEAP32[$3 >> 2] = $4 + 16; //@line 2602
 return;
}
function _luaB_pcall($L) {
 $L = $L | 0;
 var $5 = 0, sp = 0;
 sp = STACKTOP; //@line 7861
 _luaL_checkany($L, 1); //@line 7862
 _lua_pushnil($L); //@line 7863
 _lua_insert($L, 1); //@line 7864
 $5 = _finishpcall($L, (_lua_pcallk($L, (_lua_gettop($L) | 0) + -2 | 0, -1, 0, 0, 161) | 0) == 0 & 1) | 0; //@line 7870
 STACKTOP = sp; //@line 7871
 return $5 | 0; //@line 7871
}
function _luaO_hexavalue($c) {
 $c = $c | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7125
 if (!(HEAP8[$c + 2697 >> 0] & 2)) {
  $$0 = ($c | 32) + -87 | 0; //@line 7134
  STACKTOP = sp; //@line 7135
  return $$0 | 0; //@line 7135
 } else {
  $$0 = $c + -48 | 0; //@line 7138
  STACKTOP = sp; //@line 7139
  return $$0 | 0; //@line 7139
 }
 return 0; //@line 7141
}
function _luaC_barrierback_($L, $o) {
 $L = $L | 0;
 $o = $o | 0;
 var $1 = 0, $2 = 0, $7 = 0;
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 18895
 $2 = $o + 5 | 0; //@line 18896
 HEAP8[$2 >> 0] = (HEAPU8[$2 >> 0] | 0) & 251; //@line 18901
 $7 = $1 + 88 | 0; //@line 18902
 HEAP32[$o + 24 >> 2] = HEAP32[$7 >> 2]; //@line 18906
 HEAP32[$7 >> 2] = $o; //@line 18907
 return;
}
function _lua_pushthread($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2824
 $1 = HEAP32[$0 >> 2] | 0; //@line 2825
 HEAP32[$1 >> 2] = $L; //@line 2826
 HEAP32[$1 + 8 >> 2] = 72; //@line 2828
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 16; //@line 2831
 return (HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 172 >> 2] | 0) == ($L | 0) | 0; //@line 2838
}
function _db_setmetatable($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 13741
 $0 = _lua_type($L, 2) | 0; //@line 13742
 if (!(($0 | 0) == 0 | ($0 | 0) == 5)) _luaL_argerror($L, 2, 3320) | 0; //@line 13744
 _lua_settop($L, 2); //@line 13746
 _lua_setmetatable($L, 1) | 0; //@line 13747
 STACKTOP = sp; //@line 13748
 return 1; //@line 13748
}
function _luaH_resizearray($L, $t, $nasize) {
 $L = $L | 0;
 $t = $t | 0;
 $nasize = $nasize | 0;
 var $7 = 0, sp = 0;
 sp = STACKTOP; //@line 16859
 if ((HEAP32[$t + 16 >> 2] | 0) == 10872) $7 = 0; //@line 16864
 else $7 = 1 << (HEAPU8[$t + 7 >> 0] | 0); //@line 16870
 _luaH_resize($L, $t, $nasize, $7); //@line 16872
 STACKTOP = sp; //@line 16873
 return;
}
function _l_alloc($ud, $ptr, $osize, $nsize) {
 $ud = $ud | 0;
 $ptr = $ptr | 0;
 $osize = $osize | 0;
 $nsize = $nsize | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7540
 if (!$nsize) {
  _free($ptr); //@line 7543
  $$0 = 0; //@line 7544
 } else $$0 = _realloc($ptr, $nsize) | 0; //@line 7547
 STACKTOP = sp; //@line 7549
 return $$0 | 0; //@line 7549
}
function _lua_pushvfstring($L, $fmt, $argp) {
 $L = $L | 0;
 $fmt = $fmt | 0;
 $argp = $argp | 0;
 var $5 = 0, sp = 0;
 sp = STACKTOP; //@line 2682
 if ((HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 12 >> 2] | 0) > 0) _luaC_step($L); //@line 2689
 $5 = _luaO_pushvfstring($L, $fmt, $argp) | 0; //@line 2691
 STACKTOP = sp; //@line 2692
 return $5 | 0; //@line 2692
}
function _luaB_cowrap($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 13054
 _luaL_checktype($L, 1, 6); //@line 13055
 $0 = _lua_newthread($L) | 0; //@line 13056
 _lua_pushvalue($L, 1); //@line 13057
 _lua_xmove($L, $0, 1); //@line 13058
 _lua_pushcclosure($L, 162, 1); //@line 13059
 STACKTOP = sp; //@line 13060
 return 1; //@line 13060
}
function _gmatch($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 14139
 _luaL_checklstring($L, 1, 0) | 0; //@line 14140
 _luaL_checklstring($L, 2, 0) | 0; //@line 14141
 _lua_settop($L, 2); //@line 14142
 _lua_pushinteger($L, 0); //@line 14143
 _lua_pushcclosure($L, 182, 3); //@line 14144
 STACKTOP = sp; //@line 14145
 return 1; //@line 14145
}
function _luaH_set($L, $t, $key) {
 $L = $L | 0;
 $t = $t | 0;
 $key = $key | 0;
 var $$0 = 0, $0 = 0, sp = 0;
 sp = STACKTOP; //@line 16843
 $0 = _luaH_get($t, $key) | 0; //@line 16844
 if (($0 | 0) == 8048) $$0 = _luaH_newkey($L, $t, $key) | 0; //@line 16848
 else $$0 = $0; //@line 16850
 STACKTOP = sp; //@line 16852
 return $$0 | 0; //@line 16852
}
function _luaB_next($L) {
 $L = $L | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 7838
 _luaL_checktype($L, 1, 5); //@line 7839
 _lua_settop($L, 2); //@line 7840
 if (!(_lua_next($L, 1) | 0)) {
  _lua_pushnil($L); //@line 7844
  $$0 = 1; //@line 7845
 } else $$0 = 2; //@line 7847
 STACKTOP = sp; //@line 7849
 return $$0 | 0; //@line 7849
}
function _testSetjmp(id, table) {
 id = id | 0;
 table = table | 0;
 var i = 0, curr = 0;
 while ((i | 0) < 20) {
  curr = HEAP32[table + (i << 3) >> 2] | 0; //@line 17016
  if (!curr) break;
  if ((curr | 0) == (id | 0)) return HEAP32[table + ((i << 3) + 4) >> 2] | 0; //@line 17019
  i = i + 1 | 0; //@line 17021
 }
 return 0; //@line 17023
}
function _math_frexp($L) {
 $L = $L | 0;
 var $e = 0, sp = 0;
 sp = STACKTOP; //@line 5975
 STACKTOP = STACKTOP + 16 | 0; //@line 5976
 $e = sp; //@line 5977
 _lua_pushnumber($L, +_frexp(+_luaL_checknumber($L, 1), $e)); //@line 5980
 _lua_pushinteger($L, HEAP32[$e >> 2] | 0); //@line 5982
 STACKTOP = sp; //@line 5983
 return 2; //@line 5983
}
function _os_setlocale($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 7984
 $0 = _luaL_optlstring($L, 1, 0, 0) | 0; //@line 7985
 _lua_pushstring($L, _setlocale(HEAP32[8816 + ((_luaL_checkoption($L, 2, 8872, 8840) | 0) << 2) >> 2] | 0, $0 | 0) | 0) | 0; //@line 7990
 STACKTOP = sp; //@line 7991
 return 1; //@line 7991
}
function _bitshift64Ashr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >> bits; //@line 17079
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits; //@line 17080
 }
 tempRet0 = (high | 0) < 0 ? -1 : 0; //@line 17082
 return high >> bits - 32 | 0; //@line 17083
}
function _luaC_step($L) {
 $L = $L | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 324
 $1 = HEAP32[$L + 12 >> 2] | 0; //@line 326
 if (!(HEAP8[$1 + 63 >> 0] | 0)) {
  _luaE_setdebt($1, -1600); //@line 331
  STACKTOP = sp; //@line 332
  return;
 } else {
  _luaC_forcestep($L); //@line 334
  STACKTOP = sp; //@line 335
  return;
 }
}
function _luaZ_init($L, $z, $reader, $data) {
 $L = $L | 0;
 $z = $z | 0;
 $reader = $reader | 0;
 $data = $data | 0;
 HEAP32[$z + 16 >> 2] = $L; //@line 5270
 HEAP32[$z + 8 >> 2] = $reader; //@line 5272
 HEAP32[$z + 12 >> 2] = $data; //@line 5274
 HEAP32[$z >> 2] = 0; //@line 5275
 HEAP32[$z + 4 >> 2] = 0; //@line 5277
 return;
}
function _luaL_optunsigned($L, $narg, $def) {
 $L = $L | 0;
 $narg = $narg | 0;
 $def = $def | 0;
 var $3 = 0, sp = 0;
 sp = STACKTOP; //@line 6356
 if ((_lua_type($L, $narg) | 0) < 1) $3 = $def; //@line 6360
 else $3 = _luaL_checkunsigned($L, $narg) | 0; //@line 6363
 STACKTOP = sp; //@line 6365
 return $3 | 0; //@line 6365
}
function _luaL_optinteger($L, $narg, $def) {
 $L = $L | 0;
 $narg = $narg | 0;
 $def = $def | 0;
 var $3 = 0, sp = 0;
 sp = STACKTOP; //@line 6340
 if ((_lua_type($L, $narg) | 0) < 1) $3 = $def; //@line 6344
 else $3 = _luaL_checkinteger($L, $narg) | 0; //@line 6347
 STACKTOP = sp; //@line 6349
 return $3 | 0; //@line 6349
}
function _os_rename($L) {
 $L = $L | 0;
 var $0 = 0, $5 = 0, sp = 0;
 sp = STACKTOP; //@line 7972
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 7973
 $5 = _luaL_fileresult($L, (_rename($0 | 0, _luaL_checklstring($L, 2, 0) | 0) | 0) == 0 & 1, 0) | 0; //@line 7978
 STACKTOP = sp; //@line 7979
 return $5 | 0; //@line 7979
}
function _str_len($L) {
 $L = $L | 0;
 var $l = 0, sp = 0;
 sp = STACKTOP; //@line 14460
 STACKTOP = STACKTOP + 16 | 0; //@line 14461
 $l = sp; //@line 14462
 _luaL_checklstring($L, 1, $l) | 0; //@line 14463
 _lua_pushinteger($L, HEAP32[$l >> 2] | 0); //@line 14465
 STACKTOP = sp; //@line 14466
 return 1; //@line 14466
}
function _bitshift64Shl(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high << bits | (low & (1 << bits) - 1 << 32 - bits) >>> 32 - bits; //@line 17059
  return low << bits; //@line 17060
 }
 tempRet0 = low << bits - 32; //@line 17062
 return 0; //@line 17063
}
function _luaB_rawset($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7958
 _luaL_checktype($L, 1, 5); //@line 7959
 _luaL_checkany($L, 2); //@line 7960
 _luaL_checkany($L, 3); //@line 7961
 _lua_settop($L, 3); //@line 7962
 _lua_rawset($L, 1); //@line 7963
 STACKTOP = sp; //@line 7964
 return 1; //@line 7964
}
function _f_lines($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 1973
 STACKTOP = STACKTOP + 16 | 0; //@line 1974
 if (!(HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) + 4 >> 2] | 0)) _luaL_error($L, 5120, sp) | 0; //@line 1981
 _aux_lines($L, 0); //@line 1983
 STACKTOP = sp; //@line 1984
 return 1; //@line 1984
}
function _luaopen_table($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 18010
 _lua_createtable($L, 0, 7); //@line 18011
 _luaL_setfuncs($L, 10944, 0); //@line 18012
 _lua_getfield($L, -1, 11008); //@line 18013
 _lua_setglobal($L, 11008); //@line 18014
 STACKTOP = sp; //@line 18015
 return 1; //@line 18015
}
function _bitshift64Lshr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >>> bits; //@line 16977
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits; //@line 16978
 }
 tempRet0 = 0; //@line 16980
 return high >>> bits - 32 | 0; //@line 16981
}
function _luaB_cocreate($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 12964
 _luaL_checktype($L, 1, 6); //@line 12965
 $0 = _lua_newthread($L) | 0; //@line 12966
 _lua_pushvalue($L, 1); //@line 12967
 _lua_xmove($L, $0, 1); //@line 12968
 STACKTOP = sp; //@line 12969
 return 1; //@line 12969
}
function _lua_pushlightuserdata($L, $p) {
 $L = $L | 0;
 $p = $p | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2810
 $1 = HEAP32[$0 >> 2] | 0; //@line 2811
 HEAP32[$1 >> 2] = $p; //@line 2812
 HEAP32[$1 + 8 >> 2] = 2; //@line 2814
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 16; //@line 2817
 return;
}
function _luaL_optnumber($L, $narg, $def) {
 $L = $L | 0;
 $narg = $narg | 0;
 $def = +$def;
 var $3 = 0.0, sp = 0;
 sp = STACKTOP; //@line 6276
 if ((_lua_type($L, $narg) | 0) < 1) $3 = $def; //@line 6280
 else $3 = +_luaL_checknumber($L, $narg); //@line 6283
 STACKTOP = sp; //@line 6285
 return +$3;
}
function _luaK_codeABC($fs, $o, $a, $b, $c) {
 $fs = $fs | 0;
 $o = $o | 0;
 $a = $a | 0;
 $b = $b | 0;
 $c = $c | 0;
 var $6 = 0, sp = 0;
 sp = STACKTOP; //@line 8678
 $6 = _luaK_code($fs, $a << 6 | $o | $b << 23 | $c << 14) | 0; //@line 8685
 STACKTOP = sp; //@line 8686
 return $6 | 0; //@line 8686
}
function copyTempFloat(ptr) {
 ptr = ptr | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[ptr >> 0]; //@line 27
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[ptr + 1 >> 0]; //@line 28
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[ptr + 2 >> 0]; //@line 29
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[ptr + 3 >> 0]; //@line 30
}
function _luaG_aritherror($L, $p1, $p2) {
 $L = $L | 0;
 $p1 = $p1 | 0;
 $p2 = $p2 | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 15182
 STACKTOP = STACKTOP + 16 | 0; //@line 15183
 $1 = (_luaV_tonumber($p1, sp) | 0) == 0; //@line 15186
 _luaG_typeerror($L, $1 ? $p1 : $p2, 3968); //@line 15188
}
function _luaF_newupval($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 18342
 $0 = _luaC_newobj($L, 10, 32, 0, 0) | 0; //@line 18343
 HEAP32[$0 + 8 >> 2] = $0 + 16; //@line 18346
 HEAP32[$0 + 24 >> 2] = 0; //@line 18348
 STACKTOP = sp; //@line 18349
 return $0 | 0; //@line 18349
}
function _lua_pushboolean($L, $b) {
 $L = $L | 0;
 $b = $b | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2794
 $1 = HEAP32[$0 >> 2] | 0; //@line 2795
 HEAP32[$1 >> 2] = ($b | 0) != 0 & 1; //@line 2798
 HEAP32[$1 + 8 >> 2] = 1; //@line 2800
 HEAP32[$0 >> 2] = $1 + 16; //@line 2802
 return;
}
function _luaE_setdebt($g, $debt) {
 $g = $g | 0;
 $debt = $debt | 0;
 var $0 = 0, $2 = 0;
 $0 = $g + 12 | 0; //@line 12608
 $2 = $g + 8 | 0; //@line 12610
 HEAP32[$2 >> 2] = (HEAP32[$0 >> 2] | 0) - $debt + (HEAP32[$2 >> 2] | 0); //@line 12614
 HEAP32[$0 >> 2] = $debt; //@line 12615
 return;
}
function _io_noclose($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 1917
 HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) + 4 >> 2] = 173; //@line 1920
 _lua_pushnil($L); //@line 1921
 _lua_pushlstring($L, 4880, 26) | 0; //@line 1922
 STACKTOP = sp; //@line 1923
 return 2; //@line 1923
}
function _os_remove($L) {
 $L = $L | 0;
 var $0 = 0, $4 = 0, sp = 0;
 sp = STACKTOP; //@line 7961
 $0 = _luaL_checklstring($L, 1, 0) | 0; //@line 7962
 $4 = _luaL_fileresult($L, (_remove($0 | 0) | 0) == 0 & 1, $0) | 0; //@line 7966
 STACKTOP = sp; //@line 7967
 return $4 | 0; //@line 7967
}
function _lua_pushinteger($L, $n) {
 $L = $L | 0;
 $n = $n | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2573
 $1 = HEAP32[$0 >> 2] | 0; //@line 2574
 HEAPF64[$1 >> 3] = +($n | 0); //@line 2576
 HEAP32[$1 + 8 >> 2] = 3; //@line 2578
 HEAP32[$0 >> 2] = $1 + 16; //@line 2580
 return;
}
function _luaF_newCclosure($L, $n) {
 $L = $L | 0;
 $n = $n | 0;
 var $2 = 0, sp = 0;
 sp = STACKTOP; //@line 18298
 $2 = _luaC_newobj($L, 38, ($n << 4) + 16 | 0, 0, 0) | 0; //@line 18301
 HEAP8[$2 + 6 >> 0] = $n; //@line 18304
 STACKTOP = sp; //@line 18305
 return $2 | 0; //@line 18305
}
function _luaB_rawlen($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7934
 if (((_lua_type($L, 1) | 0) & -2 | 0) != 4) _luaL_argerror($L, 1, 1568) | 0; //@line 7939
 _lua_pushinteger($L, _lua_rawlen($L, 1) | 0); //@line 7942
 STACKTOP = sp; //@line 7943
 return 1; //@line 7943
}
function _os_difftime($L) {
 $L = $L | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 7893
 $1 = ~~+_luaL_checknumber($L, 1); //@line 7895
 _lua_pushnumber($L, +_difftime($1 | 0, ~~+_luaL_optnumber($L, 2, 0.0) | 0)); //@line 7899
 STACKTOP = sp; //@line 7900
 return 1; //@line 7900
}
function _luaB_rawget($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7948
 _luaL_checktype($L, 1, 5); //@line 7949
 _luaL_checkany($L, 2); //@line 7950
 _lua_settop($L, 2); //@line 7951
 _lua_rawget($L, 1); //@line 7952
 STACKTOP = sp; //@line 7953
 return 1; //@line 7953
}
function _lua_pushnumber($L, $n) {
 $L = $L | 0;
 $n = +$n;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2559
 $1 = HEAP32[$0 >> 2] | 0; //@line 2560
 HEAPF64[$1 >> 3] = $n; //@line 2561
 HEAP32[$1 + 8 >> 2] = 3; //@line 2563
 HEAP32[$0 >> 2] = $1 + 16; //@line 2565
 return;
}
function _luaB_rawequal($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7924
 _luaL_checkany($L, 1); //@line 7925
 _luaL_checkany($L, 2); //@line 7926
 _lua_pushboolean($L, _lua_rawequal($L, 1, 2) | 0); //@line 7928
 STACKTOP = sp; //@line 7929
 return 1; //@line 7929
}
function _luaK_codeABx($fs, $o, $a, $bc) {
 $fs = $fs | 0;
 $o = $o | 0;
 $a = $a | 0;
 $bc = $bc | 0;
 var $4 = 0, sp = 0;
 sp = STACKTOP; //@line 8755
 $4 = _luaK_code($fs, $a << 6 | $o | $bc << 14) | 0; //@line 8760
 STACKTOP = sp; //@line 8761
 return $4 | 0; //@line 8761
}
function _math_atan2($L) {
 $L = $L | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 5892
 $0 = +_luaL_checknumber($L, 1); //@line 5893
 _lua_pushnumber($L, +Math_atan2(+$0, +(+_luaL_checknumber($L, 2)))); //@line 5896
 STACKTOP = sp; //@line 5897
 return 1; //@line 5897
}
function _io_fclose($L) {
 $L = $L | 0;
 var $5 = 0, sp = 0;
 sp = STACKTOP; //@line 2766
 $5 = _luaL_fileresult($L, (_fclose(HEAP32[(_luaL_checkudata($L, 1, 4872) | 0) >> 2] | 0) | 0) == 0 & 1, 0) | 0; //@line 2772
 STACKTOP = sp; //@line 2773
 return $5 | 0; //@line 2773
}
function runPostSets() {}
function _i64Subtract(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var h = 0;
 h = b - d >>> 0; //@line 16932
 h = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0; //@line 16933
 return (tempRet0 = h, a - c >>> 0 | 0) | 0; //@line 16934
}
function _math_pow($L) {
 $L = $L | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 6106
 $0 = +_luaL_checknumber($L, 1); //@line 6107
 _lua_pushnumber($L, +Math_pow(+$0, +(+_luaL_checknumber($L, 2)))); //@line 6110
 STACKTOP = sp; //@line 6111
 return 1; //@line 6111
}
function _math_ldexp($L) {
 $L = $L | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 5988
 $0 = +_luaL_checknumber($L, 1); //@line 5989
 _lua_pushnumber($L, +_ldexp($0, _luaL_checkinteger($L, 2) | 0)); //@line 5992
 STACKTOP = sp; //@line 5993
 return 1; //@line 5993
}
function _math_fmod($L) {
 $L = $L | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 5965
 $0 = +_luaL_checknumber($L, 1); //@line 5966
 _lua_pushnumber($L, +_fmod(+$0, +(+_luaL_checknumber($L, 2)))); //@line 5969
 STACKTOP = sp; //@line 5970
 return 1; //@line 5970
}
function _strchr($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 5513
 $0 = ___strchrnul($s, $c) | 0; //@line 5514
 STACKTOP = sp; //@line 5519
 return ((HEAP8[$0 >> 0] | 0) == ($c & 255) << 24 >> 24 ? $0 : 0) | 0; //@line 5519
}
function _lua_getallocf($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var $$pre = 0;
 $$pre = $L + 12 | 0; //@line 4963
 if ($ud) HEAP32[$ud >> 2] = HEAP32[(HEAP32[$$pre >> 2] | 0) + 4 >> 2]; //@line 4968
 return HEAP32[HEAP32[$$pre >> 2] >> 2] | 0; //@line 4972
}
function _lua_atpanic($L, $panicf) {
 $L = $L | 0;
 $panicf = $panicf | 0;
 var $2 = 0, $3 = 0;
 $2 = (HEAP32[$L + 12 >> 2] | 0) + 168 | 0; //@line 182
 $3 = HEAP32[$2 >> 2] | 0; //@line 183
 HEAP32[$2 >> 2] = $panicf; //@line 184
 return $3 | 0; //@line 185
}
function _vsprintf($s, $fmt, $ap) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 16683
 $0 = _vsnprintf($s, 2147483647, $fmt, $ap) | 0; //@line 16684
 STACKTOP = sp; //@line 16685
 return $0 | 0; //@line 16685
}
function _luaK_ret($fs, $first, $nret) {
 $fs = $fs | 0;
 $first = $first | 0;
 $nret = $nret | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8826
 _luaK_code($fs, $first << 6 | ($nret << 23) + 8388608 | 31) | 0; //@line 8832
 STACKTOP = sp; //@line 8833
 return;
}
function _wctomb($s, $wc) {
 $s = $s | 0;
 $wc = $wc | 0;
 var $$0 = 0, sp = 0;
 sp = STACKTOP; //@line 13174
 if (!$s) $$0 = 0; //@line 13177
 else $$0 = _wcrtomb($s, $wc, 0) | 0; //@line 13180
 STACKTOP = sp; //@line 13182
 return $$0 | 0; //@line 13182
}
function _luaB_type($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8145
 _luaL_checkany($L, 1); //@line 8146
 _lua_pushstring($L, _lua_typename($L, _lua_type($L, 1) | 0) | 0) | 0; //@line 8149
 STACKTOP = sp; //@line 8150
 return 1; //@line 8150
}
function _db_getuservalue($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13213
 if ((_lua_type($L, 1) | 0) == 7) _lua_getuservalue($L, 1); //@line 13217
 else _lua_pushnil($L); //@line 13219
 STACKTOP = sp; //@line 13221
 return 1; //@line 13221
}
function _luaL_setmetatable($L, $tname) {
 $L = $L | 0;
 $tname = $tname | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5991
 _lua_getfield($L, -1001e3, $tname); //@line 5992
 _lua_setmetatable($L, -2) | 0; //@line 5993
 STACKTOP = sp; //@line 5994
 return;
}
function _db_getmetatable($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13507
 _luaL_checkany($L, 1); //@line 13508
 if (!(_lua_getmetatable($L, 1) | 0)) _lua_pushnil($L); //@line 13512
 STACKTOP = sp; //@line 13514
 return 1; //@line 13514
}
function _strpbrk($s, $b) {
 $s = $s | 0;
 $b = $b | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 5718
 $1 = $s + (_strcspn($s, $b) | 0) | 0; //@line 5720
 STACKTOP = sp; //@line 5724
 return ((HEAP8[$1 >> 0] | 0) != 0 ? $1 : 0) | 0; //@line 5724
}
function _isalnum($c) {
 $c = $c | 0;
 var $3 = 0, sp = 0;
 sp = STACKTOP; //@line 5384
 if (!(_isalpha($c) | 0)) $3 = ($c + -48 | 0) >>> 0 < 10; //@line 5390
 else $3 = 1; //@line 5392
 STACKTOP = sp; //@line 5395
 return $3 & 1 | 0; //@line 5395
}
function _luaX_lookahead($ls) {
 $ls = $ls | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 5151
 $1 = _llex($ls, $ls + 40 | 0) | 0; //@line 5153
 HEAP32[$ls + 32 >> 2] = $1; //@line 5155
 STACKTOP = sp; //@line 5156
 return $1 | 0; //@line 5156
}
function _writer($L, $b, $size, $B) {
 $L = $L | 0;
 $b = $b | 0;
 $size = $size | 0;
 $B = $B | 0;
 var sp = 0;
 sp = STACKTOP; //@line 16281
 _luaL_addlstring($B, $b, $size); //@line 16282
 STACKTOP = sp; //@line 16283
 return 0; //@line 16283
}
function _lua_setallocf($L, $f, $ud) {
 $L = $L | 0;
 $f = $f | 0;
 $ud = $ud | 0;
 var $0 = 0;
 $0 = $L + 12 | 0; //@line 4980
 HEAP32[(HEAP32[$0 >> 2] | 0) + 4 >> 2] = $ud; //@line 4983
 HEAP32[HEAP32[$0 >> 2] >> 2] = $f; //@line 4985
 return;
}
function _luaS_new($L, $str) {
 $L = $L | 0;
 $str = $str | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 13497
 $1 = _luaS_newlstr($L, $str, _strlen($str | 0) | 0) | 0; //@line 13499
 STACKTOP = sp; //@line 13500
 return $1 | 0; //@line 13500
}
function _ispunct($c) {
 $c = $c | 0;
 var $5 = 0, sp = 0;
 sp = STACKTOP; //@line 5438
 if (!(_isgraph($c) | 0)) $5 = 0; //@line 5442
 else $5 = (_isalnum($c) | 0) == 0; //@line 5446
 STACKTOP = sp; //@line 5449
 return $5 & 1 | 0; //@line 5449
}
function _io_pclose($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 2778
 _luaL_checkudata($L, 1, 4872) | 0; //@line 2779
 $0 = _luaL_execresult($L, -1) | 0; //@line 2780
 STACKTOP = sp; //@line 2781
 return $0 | 0; //@line 2781
}
function _luaL_checkany($L, $narg) {
 $L = $L | 0;
 $narg = $narg | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6239
 if ((_lua_type($L, $narg) | 0) == -1) _luaL_argerror($L, $narg, 344) | 0; //@line 6243
 STACKTOP = sp; //@line 6245
 return;
}
function _strrchr($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $2 = 0, sp = 0;
 sp = STACKTOP; //@line 5730
 $2 = ___memrchr($s, $c, (_strlen($s | 0) | 0) + 1 | 0) | 0; //@line 5733
 STACKTOP = sp; //@line 5734
 return $2 | 0; //@line 5734
}
function _luaG_concaterror($L, $p1, $p2) {
 $L = $L | 0;
 $p1 = $p1 | 0;
 $p2 = $p2 | 0;
 var $1 = 0;
 $1 = HEAP32[$p1 + 8 >> 2] | 0; //@line 15168
 _luaG_typeerror($L, ($1 & 15 | 0) == 4 | ($1 | 0) == 3 ? $p2 : $p1, 3952); //@line 15174
}
function _luaL_buffinit($L, $B) {
 $L = $L | 0;
 $B = $B | 0;
 HEAP32[$B + 12 >> 2] = $L; //@line 6557
 HEAP32[$B >> 2] = $B + 16; //@line 6559
 HEAP32[$B + 8 >> 2] = 0; //@line 6561
 HEAP32[$B + 4 >> 2] = 1024; //@line 6563
 return;
}
function _luaopen_coroutine($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 12956
 _lua_createtable($L, 0, 6); //@line 12957
 _luaL_setfuncs($L, 2440, 0); //@line 12958
 STACKTOP = sp; //@line 12959
 return 1; //@line 12959
}
function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $1$0 = 0;
 $1$0 = ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0; //@line 17183
 return $1$0 | 0; //@line 17184
}
function _luaopen_debug($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13148
 _lua_createtable($L, 0, 16); //@line 13149
 _luaL_setfuncs($L, 2960, 0); //@line 13150
 STACKTOP = sp; //@line 13151
 return 1; //@line 13151
}
function _luaL_newstate() {
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 7526
 $0 = _lua_newstate(18, 0) | 0; //@line 7527
 if ($0) _lua_atpanic($0, 158) | 0; //@line 7530
 STACKTOP = sp; //@line 7532
 return $0 | 0; //@line 7532
}
function _luaopen_bit32($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8283
 _lua_createtable($L, 0, 12); //@line 8284
 _luaL_setfuncs($L, 2024, 0); //@line 8285
 STACKTOP = sp; //@line 8286
 return 1; //@line 8286
}
function _pcallcont($L) {
 $L = $L | 0;
 var $3 = 0, sp = 0;
 sp = STACKTOP; //@line 8174
 $3 = _finishpcall($L, (_lua_getctx($L, 0) | 0) == 1 & 1) | 0; //@line 8178
 STACKTOP = sp; //@line 8179
 return $3 | 0; //@line 8179
}
function _lua_pushnil($L) {
 $L = $L | 0;
 var $0 = 0, $1 = 0;
 $0 = $L + 8 | 0; //@line 2546
 $1 = HEAP32[$0 >> 2] | 0; //@line 2547
 HEAP32[$1 + 8 >> 2] = 0; //@line 2549
 HEAP32[$0 >> 2] = $1 + 16; //@line 2551
 return;
}
function _math_randomseed($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6175
 _srand(_luaL_checkunsigned($L, 1) | 0); //@line 6177
 _rand() | 0; //@line 6178
 STACKTOP = sp; //@line 6179
 return 0; //@line 6179
}
function _luaopen_os($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7722
 _lua_createtable($L, 0, 11); //@line 7723
 _luaL_setfuncs($L, 8480, 0); //@line 7724
 STACKTOP = sp; //@line 7725
 return 1; //@line 7725
}
function _os_getenv($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7952
 _lua_pushstring($L, _getenv(_luaL_checklstring($L, 1, 0) | 0) | 0) | 0; //@line 7955
 STACKTOP = sp; //@line 7956
 return 1; //@line 7956
}
function _luaB_tostring($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8137
 _luaL_checkany($L, 1); //@line 8138
 _luaL_tolstring($L, 1, 0) | 0; //@line 8139
 STACKTOP = sp; //@line 8140
 return 1; //@line 8140
}
function _luaB_yield($L) {
 $L = $L | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 13065
 $1 = _lua_yieldk($L, _lua_gettop($L) | 0, 0, 0) | 0; //@line 13067
 STACKTOP = sp; //@line 13068
 return $1 | 0; //@line 13068
}
function _f_call($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var sp = 0;
 sp = STACKTOP; //@line 4518
 _luaD_call($L, HEAP32[$ud >> 2] | 0, HEAP32[$ud + 4 >> 2] | 0, 0); //@line 4522
 STACKTOP = sp; //@line 4523
 return;
}
function _math_rad($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6116
 _lua_pushnumber($L, +_luaL_checknumber($L, 1) * .017453292519943295); //@line 6119
 STACKTOP = sp; //@line 6120
 return 1; //@line 6120
}
function _math_deg($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5938
 _lua_pushnumber($L, +_luaL_checknumber($L, 1) / .017453292519943295); //@line 5941
 STACKTOP = sp; //@line 5942
 return 1; //@line 5942
}
function dynCall_iiiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return FUNCTION_TABLE_iiiii[index & 31](a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17668
}
function _math_floor($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5956
 _lua_pushnumber($L, +Math_floor(+(+_luaL_checknumber($L, 1)))); //@line 5959
 STACKTOP = sp; //@line 5960
 return 1; //@line 5960
}
function _math_sqrt($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6202
 _lua_pushnumber($L, +Math_sqrt(+(+_luaL_checknumber($L, 1)))); //@line 6205
 STACKTOP = sp; //@line 6206
 return 1; //@line 6206
}
function _math_ceil($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5911
 _lua_pushnumber($L, +Math_ceil(+(+_luaL_checknumber($L, 1)))); //@line 5914
 STACKTOP = sp; //@line 5915
 return 1; //@line 5915
}
function _math_atan($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5902
 _lua_pushnumber($L, +Math_atan(+(+_luaL_checknumber($L, 1)))); //@line 5905
 STACKTOP = sp; //@line 5906
 return 1; //@line 5906
}
function _math_asin($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5883
 _lua_pushnumber($L, +Math_asin(+(+_luaL_checknumber($L, 1)))); //@line 5886
 STACKTOP = sp; //@line 5887
 return 1; //@line 5887
}
function _math_acos($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5874
 _lua_pushnumber($L, +Math_acos(+(+_luaL_checknumber($L, 1)))); //@line 5877
 STACKTOP = sp; //@line 5878
 return 1; //@line 5878
}
function _tolower($c) {
 $c = $c | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 11092
 $1 = (_isupper($c) | 0) == 0; //@line 11094
 STACKTOP = sp; //@line 11097
 return ($1 ? $c : $c | 32) | 0; //@line 11097
}
function _luaO_fb2int($x) {
 $x = $x | 0;
 var $$0 = 0, $1 = 0;
 $1 = $x >>> 3 & 31; //@line 7030
 if (!$1) $$0 = $x; //@line 7033
 else $$0 = ($x & 7 | 8) << $1 + -1; //@line 7039
 return $$0 | 0; //@line 7041
}
function _dothecall($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var sp = 0;
 sp = STACKTOP; //@line 552
 _luaD_call($L, (HEAP32[$L + 8 >> 2] | 0) + -32 | 0, 0, 0); //@line 556
 STACKTOP = sp; //@line 557
 return;
}
function _math_tan($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6220
 _lua_pushnumber($L, +Math_tan(+(+_luaL_checknumber($L, 1)))); //@line 6223
 STACKTOP = sp; //@line 6224
 return 1; //@line 6224
}
function _math_sin($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6193
 _lua_pushnumber($L, +Math_sin(+(+_luaL_checknumber($L, 1)))); //@line 6196
 STACKTOP = sp; //@line 6197
 return 1; //@line 6197
}
function _math_log10($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5998
 _lua_pushnumber($L, +_log10(+(+_luaL_checknumber($L, 1)))); //@line 6001
 STACKTOP = sp; //@line 6002
 return 1; //@line 6002
}
function _math_exp($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5947
 _lua_pushnumber($L, +Math_exp(+(+_luaL_checknumber($L, 1)))); //@line 5950
 STACKTOP = sp; //@line 5951
 return 1; //@line 5951
}
function _math_cos($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5929
 _lua_pushnumber($L, +Math_cos(+(+_luaL_checknumber($L, 1)))); //@line 5932
 STACKTOP = sp; //@line 5933
 return 1; //@line 5933
}
function _math_abs($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5865
 _lua_pushnumber($L, +Math_abs(+(+_luaL_checknumber($L, 1)))); //@line 5868
 STACKTOP = sp; //@line 5869
 return 1; //@line 5869
}
function _math_tanh($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6211
 _lua_pushnumber($L, +_tanh(+(+_luaL_checknumber($L, 1)))); //@line 6214
 STACKTOP = sp; //@line 6215
 return 1; //@line 6215
}
function _math_sinh($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6184
 _lua_pushnumber($L, +_sinh(+(+_luaL_checknumber($L, 1)))); //@line 6187
 STACKTOP = sp; //@line 6188
 return 1; //@line 6188
}
function _math_cosh($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 5920
 _lua_pushnumber($L, +_cosh(+(+_luaL_checknumber($L, 1)))); //@line 5923
 STACKTOP = sp; //@line 5924
 return 1; //@line 5924
}
function _luaK_fixline($fs, $line) {
 $fs = $fs | 0;
 $line = $line | 0;
 HEAP32[(HEAP32[(HEAP32[$fs >> 2] | 0) + 20 >> 2] | 0) + ((HEAP32[$fs + 20 >> 2] | 0) + -1 << 2) >> 2] = $line; //@line 12628
 return;
}
function _i64Add(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0;
 l = a + c >>> 0; //@line 16944
 return (tempRet0 = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0, l | 0) | 0; //@line 16946
}
function _toupper($c) {
 $c = $c | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 5454
 $1 = (_islower($c) | 0) == 0; //@line 5456
 STACKTOP = sp; //@line 5459
 return ($1 ? $c : $c & 95) | 0; //@line 5459
}
function _luaB_corunning($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13002
 _lua_pushboolean($L, _lua_pushthread($L) | 0); //@line 13004
 STACKTOP = sp; //@line 13005
 return 2; //@line 13005
}
function _strcoll($l, $r) {
 $l = $l | 0;
 $r = $r | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 5465
 $0 = _strcmp($l, $r) | 0; //@line 5466
 STACKTOP = sp; //@line 5467
 return $0 | 0; //@line 5467
}
function _luaL_addstring($B, $s) {
 $B = $B | 0;
 $s = $s | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6482
 _luaL_addlstring($B, $s, _strlen($s | 0) | 0); //@line 6484
 STACKTOP = sp; //@line 6485
 return;
}
function _b_not($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 8357
 _lua_pushunsigned($L, ~(_luaL_checkunsigned($L, 1) | 0)); //@line 8360
 STACKTOP = sp; //@line 8361
 return 1; //@line 8361
}
function _lua_close($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13088
 _close_state(HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 172 >> 2] | 0); //@line 13093
 STACKTOP = sp; //@line 13094
 return;
}
function stackAlloc(size) {
 size = size | 0;
 var ret = 0;
 ret = STACKTOP; //@line 3
 STACKTOP = STACKTOP + size | 0; //@line 4
 STACKTOP = STACKTOP + 15 & -16; //@line 5
 return ret | 0; //@line 7
}
function _dofilecont($L) {
 $L = $L | 0;
 var $1 = 0, sp = 0;
 sp = STACKTOP; //@line 8275
 $1 = (_lua_gettop($L) | 0) + -1 | 0; //@line 8277
 STACKTOP = sp; //@line 8278
 return $1 | 0; //@line 8278
}
function _isxdigit($c) {
 $c = $c | 0;
 var $4 = 0;
 if (($c + -48 | 0) >>> 0 < 10) $4 = 1; //@line 11079
 else $4 = (($c | 32) + -97 | 0) >>> 0 < 6; //@line 11084
 return $4 & 1 | 0; //@line 11087
}
function _str_match($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 14511
 $0 = _str_find_aux($L, 0) | 0; //@line 14512
 STACKTOP = sp; //@line 14513
 return $0 | 0; //@line 14513
}
function _str_find($L) {
 $L = $L | 0;
 var $0 = 0, sp = 0;
 sp = STACKTOP; //@line 13696
 $0 = _str_find_aux($L, 1) | 0; //@line 13697
 STACKTOP = sp; //@line 13698
 return $0 | 0; //@line 13698
}
function _growstack($L, $ud) {
 $L = $L | 0;
 $ud = $ud | 0;
 var sp = 0;
 sp = STACKTOP; //@line 117
 _luaD_growstack($L, HEAP32[$ud >> 2] | 0); //@line 119
 STACKTOP = sp; //@line 120
 return;
}
function _os_clock($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7730
 _lua_pushnumber($L, +(_clock() | 0) / 1.0e6); //@line 7734
 STACKTOP = sp; //@line 7735
 return 1; //@line 7735
}
function _lua_version($L) {
 $L = $L | 0;
 var $$0 = 0;
 if (!$L) $$0 = 8; //@line 193
 else $$0 = HEAP32[(HEAP32[$L + 12 >> 2] | 0) + 176 >> 2] | 0; //@line 199
 return $$0 | 0; //@line 201
}
function dynCall_iiii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return FUNCTION_TABLE_iiii[index & 31](a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17479
}
function _scalbnl($x, $n) {
 $x = +$x;
 $n = $n | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 13166
 $0 = +_scalbn($x, $n); //@line 13167
 STACKTOP = sp; //@line 13168
 return +$0;
}
function _db_getregistry($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 13500
 _lua_pushvalue($L, -1001e3); //@line 13501
 STACKTOP = sp; //@line 13502
 return 1; //@line 13502
}
function _strlen(ptr) {
 ptr = ptr | 0;
 var curr = 0;
 curr = ptr; //@line 17068
 while (HEAP8[curr >> 0] | 0) curr = curr + 1 | 0; //@line 17070
 return curr - ptr | 0; //@line 17072
}
function _frexpl($x, $e) {
 $x = +$x;
 $e = $e | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 13112
 $0 = +_frexp($x, $e); //@line 13113
 STACKTOP = sp; //@line 13114
 return +$0;
}
function _ldexp($x, $n) {
 $x = +$x;
 $n = $n | 0;
 var $0 = 0.0, sp = 0;
 sp = STACKTOP; //@line 5473
 $0 = +_scalbn($x, $n); //@line 5474
 STACKTOP = sp; //@line 5475
 return +$0;
}
function _luaB_ipairs($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7753
 _pairsmeta($L, 1744, 1, 160); //@line 7754
 STACKTOP = sp; //@line 7755
 return 3; //@line 7755
}
function _luaB_pairs($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 7854
 _pairsmeta($L, 1648, 0, 26); //@line 7855
 STACKTOP = sp; //@line 7856
 return 3; //@line 7856
}
function _isspace($c) {
 $c = $c | 0;
 var $4 = 0;
 if (($c | 0) == 32) $4 = 1; //@line 11054
 else $4 = ($c + -9 | 0) >>> 0 < 5; //@line 11058
 return $4 & 1 | 0; //@line 11061
}
function _luaK_getlabel($fs) {
 $fs = $fs | 0;
 var $1 = 0;
 $1 = HEAP32[$fs + 20 >> 2] | 0; //@line 8840
 HEAP32[$fs + 24 >> 2] = $1; //@line 8842
 return $1 | 0; //@line 8843
}
function _io_output($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 2659
 _g_iofile($L, 4840, 5552); //@line 2660
 STACKTOP = sp; //@line 2661
 return 1; //@line 2661
}
function _io_input($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 2541
 _g_iofile($L, 4816, 5520); //@line 2542
 STACKTOP = sp; //@line 2543
 return 1; //@line 2543
}
function _luaM_toobig($L) {
 $L = $L | 0;
 var sp = 0;
 sp = STACKTOP; //@line 6322
 STACKTOP = STACKTOP + 16 | 0; //@line 6323
 _luaG_runerror($L, 7e3, sp); //@line 6325
}
function jsCall_iiiii_7(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(7, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17723
}
function jsCall_iiiii_6(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(6, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17716
}
function jsCall_iiiii_5(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(5, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17709
}
function jsCall_iiiii_4(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(4, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17702
}
function jsCall_iiiii_3(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(3, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17695
}
function jsCall_iiiii_2(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(2, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17688
}
function jsCall_iiiii_1(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(1, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17681
}
function jsCall_iiiii_0(a1, a2, a3, a4) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return jsCall(0, a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0; //@line 17674
}
function _srand($s) {
 $s = $s | 0;
 var $1 = 0;
 $1 = 12560; //@line 13280
 HEAP32[$1 >> 2] = $s + -1; //@line 13282
 HEAP32[$1 + 4 >> 2] = 0; //@line 13285
 return;
}
function setThrew(threw, value) {
 threw = threw | 0;
 value = value | 0;
 if (!__THREW__) {
  __THREW__ = threw; //@line 21
  threwValue = value; //@line 22
 }
}
function dynCall_iii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 return FUNCTION_TABLE_iii[index & 31](a1 | 0, a2 | 0) | 0; //@line 17605
}
function _semerror($ls, $msg) {
 $ls = $ls | 0;
 $msg = $msg | 0;
 HEAP32[$ls + 16 >> 2] = 0; //@line 8883
 _luaX_syntaxerror($ls, $msg); //@line 8884
}
function dynCall_vii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 FUNCTION_TABLE_vii[index & 31](a1 | 0, a2 | 0); //@line 17542
}
function _lua_gettop($L) {
 $L = $L | 0;
 return (HEAP32[$L + 8 >> 2] | 0) - ((HEAP32[HEAP32[$L + 16 >> 2] >> 2] | 0) + 16) >> 4 | 0; //@line 241
}
function jsCall_iiii_7(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(7, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17534
}
function jsCall_iiii_6(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(6, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17527
}
function jsCall_iiii_5(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(5, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17520
}
function jsCall_iiii_4(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(4, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17513
}
function jsCall_iiii_3(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(3, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17506
}
function jsCall_iiii_2(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(2, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17499
}
function jsCall_iiii_1(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(1, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17492
}
function jsCall_iiii_0(a1, a2, a3) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return jsCall(0, a1 | 0, a2 | 0, a3 | 0) | 0; //@line 17485
}
function _luaX_syntaxerror($ls, $msg) {
 $ls = $ls | 0;
 $msg = $msg | 0;
 _lexerror($ls, $msg, HEAP32[$ls + 16 >> 2] | 0); //@line 2912
}
function b4(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(4); //@line 17731
 return 0; //@line 17731
}
function dynCall_ii(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 return FUNCTION_TABLE_ii[index & 255](a1 | 0) | 0; //@line 17416
}
function _lua_typename($L, $t) {
 $L = $L | 0;
 $t = $t | 0;
 return HEAP32[11384 + ($t + 1 << 2) >> 2] | 0; //@line 923
}
function b1(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(1); //@line 17728
 return 0; //@line 17728
}
function jsCall_iii_7(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(7, a1 | 0, a2 | 0) | 0; //@line 17660
}
function jsCall_iii_6(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(6, a1 | 0, a2 | 0) | 0; //@line 17653
}
function jsCall_iii_5(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(5, a1 | 0, a2 | 0) | 0; //@line 17646
}
function jsCall_iii_4(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(4, a1 | 0, a2 | 0) | 0; //@line 17639
}
function jsCall_iii_3(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(3, a1 | 0, a2 | 0) | 0; //@line 17632
}
function jsCall_iii_2(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(2, a1 | 0, a2 | 0) | 0; //@line 17625
}
function jsCall_iii_1(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(1, a1 | 0, a2 | 0) | 0; //@line 17618
}
function jsCall_iii_0(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 return jsCall(0, a1 | 0, a2 | 0) | 0; //@line 17611
}
function jsCall_vii_7(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(7, a1 | 0, a2 | 0); //@line 17597
}
function jsCall_vii_6(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(6, a1 | 0, a2 | 0); //@line 17590
}
function jsCall_vii_5(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(5, a1 | 0, a2 | 0); //@line 17583
}
function jsCall_vii_4(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(4, a1 | 0, a2 | 0); //@line 17576
}
function jsCall_vii_3(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(3, a1 | 0, a2 | 0); //@line 17569
}
function jsCall_vii_2(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(2, a1 | 0, a2 | 0); //@line 17562
}
function jsCall_vii_1(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(1, a1 | 0, a2 | 0); //@line 17555
}
function jsCall_vii_0(a1, a2) {
 a1 = a1 | 0;
 a2 = a2 | 0;
 jsCall(0, a1 | 0, a2 | 0); //@line 17548
}
function _iscntrl($c) {
 $c = $c | 0;
 return ($c >>> 0 < 32 | ($c | 0) == 127) & 1 | 0; //@line 5415
}
function b3(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(3); //@line 17730
 return 0; //@line 17730
}
function _lua_gethookmask($L) {
 $L = $L | 0;
 return HEAPU8[$L + 40 >> 0] | 0 | 0; //@line 13877
}
function _lua_error($L) {
 $L = $L | 0;
 _luaG_errormsg($L); //@line 4777
 return 0; //@line 4779
}
function _isalpha($c) {
 $c = $c | 0;
 return (($c | 32) + -97 | 0) >>> 0 < 26 | 0; //@line 5405
}
function _lua_gethookcount($L) {
 $L = $L | 0;
 return HEAP32[$L + 44 >> 2] | 0; //@line 13885
}
function _lua_status($L) {
 $L = $L | 0;
 return HEAPU8[$L + 6 >> 0] | 0 | 0; //@line 4635
}
function _isupper($c) {
 $c = $c | 0;
 return ($c + -65 | 0) >>> 0 < 26 | 0; //@line 11070
}
function _lua_gethook($L) {
 $L = $L | 0;
 return HEAP32[$L + 52 >> 2] | 0; //@line 13868
}
function _islower($c) {
 $c = $c | 0;
 return ($c + -97 | 0) >>> 0 < 26 | 0; //@line 5433
}
function _isgraph($c) {
 $c = $c | 0;
 return ($c + -33 | 0) >>> 0 < 94 | 0; //@line 5424
}
function jsCall_ii_7(a1) {
 a1 = a1 | 0;
 return jsCall(7, a1 | 0) | 0; //@line 17471
}
function jsCall_ii_6(a1) {
 a1 = a1 | 0;
 return jsCall(6, a1 | 0) | 0; //@line 17464
}
function jsCall_ii_5(a1) {
 a1 = a1 | 0;
 return jsCall(5, a1 | 0) | 0; //@line 17457
}
function jsCall_ii_4(a1) {
 a1 = a1 | 0;
 return jsCall(4, a1 | 0) | 0; //@line 17450
}
function jsCall_ii_3(a1) {
 a1 = a1 | 0;
 return jsCall(3, a1 | 0) | 0; //@line 17443
}
function jsCall_ii_2(a1) {
 a1 = a1 | 0;
 return jsCall(2, a1 | 0) | 0; //@line 17436
}
function jsCall_ii_1(a1) {
 a1 = a1 | 0;
 return jsCall(1, a1 | 0) | 0; //@line 17429
}
function jsCall_ii_0(a1) {
 a1 = a1 | 0;
 return jsCall(0, a1 | 0) | 0; //@line 17422
}
function b0(p0) {
 p0 = p0 | 0;
 abort(0); //@line 17727
 return 0; //@line 17727
}
function setTempRet0(value) {
 value = value | 0;
 tempRet0 = value; //@line 45
}
function b2(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(2); //@line 17729
}
function stackRestore(top) {
 top = top | 0;
 STACKTOP = top; //@line 14
}
function getTempRet0() {
 return tempRet0 | 0; //@line 48
}
function stackSave() {
 return STACKTOP | 0; //@line 10
}

// EMSCRIPTEN_END_FUNCS
  var FUNCTION_TABLE_ii = [b0,b0,jsCall_ii_0,b0,jsCall_ii_1,b0,jsCall_ii_2,b0,jsCall_ii_3,b0,jsCall_ii_4,b0,jsCall_ii_5,b0,jsCall_ii_6,b0,jsCall_ii_7,b0,_luaB_assert,_luaB_collectgarbage,_luaB_dofile,_luaB_error,_luaB_getmetatable,_luaB_ipairs,_luaB_loadfile,_luaB_load,_luaB_next,_luaB_pairs,_luaB_pcall
  ,_luaB_print,_luaB_rawequal,_luaB_rawlen,_luaB_rawget,_luaB_rawset,_luaB_select,_luaB_setmetatable,_luaB_tonumber,_luaB_tostring,_luaB_type,_luaB_xpcall,_b_arshift,_b_and,_b_not,_b_or,_b_xor,_b_test,_b_extract,_b_lrot,_b_lshift,_b_replace,_b_rrot,_b_rshift,_luaB_cocreate,_luaB_coresume,_luaB_corunning,_luaB_costatus,_luaB_cowrap,_luaB_yield,_db_debug
  ,_db_getuservalue,_db_gethook,_db_getinfo,_db_getlocal,_db_getregistry,_db_getmetatable,_db_getupvalue,_db_upvaluejoin,_db_upvalueid,_db_setuservalue,_db_sethook,_db_setlocal,_db_setmetatable,_db_setupvalue,_db_traceback,_io_close,_io_flush,_io_input,_io_lines,_io_open,_io_output,_io_popen,_io_read,_io_tmpfile,_io_type,_io_write,_f_flush,_f_lines,_f_read,_f_seek
  ,_f_setvbuf,_f_write,_f_gc,_f_tostring,_math_abs,_math_acos,_math_asin,_math_atan2,_math_atan,_math_ceil,_math_cosh,_math_cos,_math_deg,_math_exp,_math_floor,_math_fmod,_math_frexp,_math_ldexp,_math_log10,_math_log,_math_max,_math_min,_math_modf,_math_pow,_math_rad,_math_random,_math_randomseed,_math_sinh,_math_sin,_math_sqrt
  ,_math_tanh,_math_tan,_ll_loadlib,_ll_searchpath,_ll_seeall,_ll_module,_ll_require,_os_clock,_os_date,_os_difftime,_os_execute,_os_exit,_os_getenv,_os_remove,_os_rename,_os_setlocale,_os_time,_os_tmpname,_str_byte,_str_char,_str_dump,_str_find,_str_format,_gmatch,_str_gsub,_str_len,_str_lower,_str_match,_str_rep,_str_reverse
  ,_str_sub,_str_upper,_tconcat,_maxn,_tinsert,_pack,_unpack,_tremove,_sort,_panic,_dofilecont,_ipairsaux,_pcallcont,_luaB_auxwrap,_luaopen_base,_luaopen_package,_luaopen_coroutine,_luaopen_table,_luaopen_io,_luaopen_os,_luaopen_string,_luaopen_bit32,_luaopen_math,_luaopen_debug,_io_noclose,_io_readline,_io_fclose,_io_pclose,_gctm,_searcher_preload
  ,_searcher_Lua,_searcher_C,_searcher_Croot,_gmatch_aux,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
  ,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
  ,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0];
  var FUNCTION_TABLE_iiii = [b1,b1,jsCall_iiii_0,b1,jsCall_iiii_1,b1,jsCall_iiii_2,b1,jsCall_iiii_3,b1,jsCall_iiii_4,b1,jsCall_iiii_5,b1,jsCall_iiii_6,b1,jsCall_iiii_7,b1,_sn_write,_getF,_getS,_generic_reader,b1,b1,b1,b1,b1,b1,b1
  ,b1,b1,b1];
  var FUNCTION_TABLE_vii = [b2,b2,jsCall_vii_0,b2,jsCall_vii_1,b2,jsCall_vii_2,b2,jsCall_vii_3,b2,jsCall_vii_4,b2,jsCall_vii_5,b2,jsCall_vii_6,b2,jsCall_vii_7,b2,_growstack,_f_call,_hookf,_resume,_unroll,_f_parser,_dothecall,_f_luaopen,b2,b2,b2
  ,b2,b2,b2];
  var FUNCTION_TABLE_iii = [b3,b3,jsCall_iii_0,b3,jsCall_iii_1,b3,jsCall_iii_2,b3,jsCall_iii_3,b3,jsCall_iii_4,b3,jsCall_iii_5,b3,jsCall_iii_6,b3,jsCall_iii_7,b3,_lua_newstate,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
  ,b3,b3,b3];
  var FUNCTION_TABLE_iiiii = [b4,b4,jsCall_iiiii_0,b4,jsCall_iiiii_1,b4,jsCall_iiiii_2,b4,jsCall_iiiii_3,b4,jsCall_iiiii_4,b4,jsCall_iiiii_5,b4,jsCall_iiiii_6,b4,jsCall_iiiii_7,b4,_l_alloc,_writer,b4,b4,b4,b4,b4,b4,b4,b4,b4
  ,b4,b4,b4];

  return { _luaL_checkstack: _luaL_checkstack, _lua_setglobal: _lua_setglobal, _strlen: _strlen, _lua_gethook: _lua_gethook, _lua_pushlightuserdata: _lua_pushlightuserdata, _bitshift64Lshr: _bitshift64Lshr, _lua_copy: _lua_copy, _lua_createtable: _lua_createtable, _luaL_optinteger: _luaL_optinteger, _lua_arith: _lua_arith, _lua_pushnil: _lua_pushnil, _lua_setmetatable: _lua_setmetatable, _lua_pushthread: _lua_pushthread, _luaL_optlstring: _luaL_optlstring, _luaopen_io: _luaopen_io, _memcpy: _memcpy, _luaL_pushmodule: _luaL_pushmodule, _luaL_pushresultsize: _luaL_pushresultsize, _lua_upvalueid: _lua_upvalueid, _lua_close: _lua_close, _luaopen_math: _luaopen_math, _lua_setupvalue: _lua_setupvalue, _luaL_ref: _luaL_ref, _lua_gethookmask: _lua_gethookmask, _lua_xmove: _lua_xmove, _lua_load: _lua_load, _lua_pcallk: _lua_pcallk, _lua_touserdata: _lua_touserdata, _lua_getglobal: _lua_getglobal, _luaL_prepbuffsize: _luaL_prepbuffsize, _lua_rawget: _lua_rawget, _free: _free, _lua_pushcclosure: _lua_pushcclosure, _lua_pushstring: _lua_pushstring, _lua_upvaluejoin: _lua_upvaluejoin, _luaopen_string: _luaopen_string, _lua_isuserdata: _lua_isuserdata, _luaL_loadbufferx: _luaL_loadbufferx, _lua_resume: _lua_resume, _lua_iscfunction: _lua_iscfunction, _luaL_newstate: _luaL_newstate, _luaL_execresult: _luaL_execresult, _lua_remove: _lua_remove, _luaL_checkoption: _luaL_checkoption, _lua_rawlen: _lua_rawlen, _lua_len: _lua_len, _luaL_openlib: _luaL_openlib, _lua_pushvfstring: _lua_pushvfstring, _lua_isnumber: _lua_isnumber, _luaL_checklstring: _luaL_checklstring, _lua_isstring: _lua_isstring, _lua_pushlstring: _lua_pushlstring, _lua_setuservalue: _lua_setuservalue, _luaL_len: _luaL_len, _lua_callk: _lua_callk, _luaL_checkany: _luaL_checkany, _luaL_addstring: _luaL_addstring, _lua_pushfstring: _lua_pushfstring, _lua_insert: _lua_insert, _i64Add: _i64Add, _lua_tolstring: _lua_tolstring, _lua_rawset: _lua_rawset, _luaL_traceback: _luaL_traceback, _lua_getupvalue: _lua_getupvalue, _lua_checkstack: _lua_checkstack, _lua_pushnumber: _lua_pushnumber, _luaL_pushresult: _luaL_pushresult, _lua_topointer: _lua_topointer, _lua_error: _lua_error, _lua_gettable: _lua_gettable, _luaopen_debug: _luaopen_debug, _lua_compare: _lua_compare, _luaL_checkinteger: _luaL_checkinteger, _lua_getstack: _lua_getstack, _lua_gettop: _lua_gettop, _lua_getlocal: _lua_getlocal, _lua_gc: _lua_gc, _lua_newuserdata: _lua_newuserdata, _luaL_checkunsigned: _luaL_checkunsigned, _lua_settable: _lua_settable, _luaL_addlstring: _luaL_addlstring, _luaL_fileresult: _luaL_fileresult, _lua_toboolean: _lua_toboolean, _lua_setallocf: _lua_setallocf, _memset: _memset, _luaL_checktype: _luaL_checktype, _lua_tointegerx: _lua_tointegerx, _lua_gethookcount: _lua_gethookcount, _lua_version: _lua_version, _lua_tounsignedx: _lua_tounsignedx, _luaL_openlibs: _luaL_openlibs, _lua_setlocal: _lua_setlocal, _luaL_optunsigned: _luaL_optunsigned, _lua_tothread: _lua_tothread, _i64Subtract: _i64Subtract, _lua_rawgetp: _lua_rawgetp, _luaL_testudata: _luaL_testudata, _lua_newstate: _lua_newstate, _lua_pushvalue: _lua_pushvalue, _lua_getctx: _lua_getctx, _lua_tocfunction: _lua_tocfunction, _lua_newthread: _lua_newthread, _lua_typename: _lua_typename, _luaL_argerror: _luaL_argerror, _lua_absindex: _lua_absindex, _lua_rawgeti: _lua_rawgeti, _testSetjmp: _testSetjmp, _lua_sethook: _lua_sethook, _luaL_callmeta: _luaL_callmeta, _luaL_buffinit: _luaL_buffinit, _luaL_loadfilex: _luaL_loadfilex, _malloc: _malloc, _lua_rawequal: _lua_rawequal, _lua_yieldk: _lua_yieldk, _lua_type: _lua_type, _lua_getfield: _lua_getfield, _luaopen_os: _luaopen_os, _luaL_checkversion_: _luaL_checkversion_, _luaL_buffinitsize: _luaL_buffinitsize, _luaL_checknumber: _luaL_checknumber, _luaL_newmetatable: _luaL_newmetatable, _lua_getmetatable: _lua_getmetatable, _lua_pushunsigned: _lua_pushunsigned, _luaL_requiref: _luaL_requiref, _luaopen_base: _luaopen_base, _luaL_gsub: _luaL_gsub, _luaL_addvalue: _luaL_addvalue, _bitshift64Shl: _bitshift64Shl, _luaL_tolstring: _luaL_tolstring, _lua_atpanic: _lua_atpanic, _luaL_getmetafield: _luaL_getmetafield, _lua_getinfo: _lua_getinfo, _luaL_setmetatable: _luaL_setmetatable, _lua_settop: _lua_settop, _lua_pushboolean: _lua_pushboolean, _lua_setfield: _lua_setfield, _lua_replace: _lua_replace, _luaL_setfuncs: _luaL_setfuncs, _lua_next: _lua_next, _lua_concat: _lua_concat, _luaL_checkudata: _luaL_checkudata, _realloc: _realloc, _luaopen_table: _luaopen_table, _luaopen_coroutine: _luaopen_coroutine, _luaopen_bit32: _luaopen_bit32, _luaL_getsubtable: _luaL_getsubtable, _lua_getuservalue: _lua_getuservalue, _luaopen_package: _luaopen_package, _lua_rawseti: _lua_rawseti, _saveSetjmp: _saveSetjmp, _luaL_optnumber: _luaL_optnumber, _lua_pushinteger: _lua_pushinteger, _lua_getallocf: _lua_getallocf, _lua_dump: _lua_dump, _lua_status: _lua_status, _lua_tonumberx: _lua_tonumberx, _luaL_where: _luaL_where, _lua_rawsetp: _lua_rawsetp, _luaL_error: _luaL_error, _luaL_loadstring: _luaL_loadstring, _luaL_unref: _luaL_unref, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, setThrew: setThrew, setTempRet0: setTempRet0, getTempRet0: getTempRet0, dynCall_ii: dynCall_ii, dynCall_iiii: dynCall_iiii, dynCall_vii: dynCall_vii, dynCall_iii: dynCall_iii, dynCall_iiiii: dynCall_iiiii };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var _luaL_checkstack = Module["_luaL_checkstack"] = asm["_luaL_checkstack"];
var _lua_setglobal = Module["_lua_setglobal"] = asm["_lua_setglobal"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _lua_gethook = Module["_lua_gethook"] = asm["_lua_gethook"];
var _lua_pushlightuserdata = Module["_lua_pushlightuserdata"] = asm["_lua_pushlightuserdata"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _lua_copy = Module["_lua_copy"] = asm["_lua_copy"];
var _lua_createtable = Module["_lua_createtable"] = asm["_lua_createtable"];
var _luaL_optinteger = Module["_luaL_optinteger"] = asm["_luaL_optinteger"];
var _lua_arith = Module["_lua_arith"] = asm["_lua_arith"];
var _lua_pushnil = Module["_lua_pushnil"] = asm["_lua_pushnil"];
var _lua_setmetatable = Module["_lua_setmetatable"] = asm["_lua_setmetatable"];
var _lua_pushthread = Module["_lua_pushthread"] = asm["_lua_pushthread"];
var _luaL_optlstring = Module["_luaL_optlstring"] = asm["_luaL_optlstring"];
var _luaopen_io = Module["_luaopen_io"] = asm["_luaopen_io"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _luaL_pushmodule = Module["_luaL_pushmodule"] = asm["_luaL_pushmodule"];
var _luaL_pushresultsize = Module["_luaL_pushresultsize"] = asm["_luaL_pushresultsize"];
var _lua_upvalueid = Module["_lua_upvalueid"] = asm["_lua_upvalueid"];
var _lua_close = Module["_lua_close"] = asm["_lua_close"];
var _luaopen_math = Module["_luaopen_math"] = asm["_luaopen_math"];
var _lua_setupvalue = Module["_lua_setupvalue"] = asm["_lua_setupvalue"];
var _luaL_ref = Module["_luaL_ref"] = asm["_luaL_ref"];
var _lua_gethookmask = Module["_lua_gethookmask"] = asm["_lua_gethookmask"];
var _lua_xmove = Module["_lua_xmove"] = asm["_lua_xmove"];
var _lua_load = Module["_lua_load"] = asm["_lua_load"];
var _lua_pcallk = Module["_lua_pcallk"] = asm["_lua_pcallk"];
var _lua_touserdata = Module["_lua_touserdata"] = asm["_lua_touserdata"];
var _lua_getglobal = Module["_lua_getglobal"] = asm["_lua_getglobal"];
var _luaL_prepbuffsize = Module["_luaL_prepbuffsize"] = asm["_luaL_prepbuffsize"];
var _lua_rawget = Module["_lua_rawget"] = asm["_lua_rawget"];
var _free = Module["_free"] = asm["_free"];
var _lua_pushcclosure = Module["_lua_pushcclosure"] = asm["_lua_pushcclosure"];
var _lua_pushstring = Module["_lua_pushstring"] = asm["_lua_pushstring"];
var _lua_upvaluejoin = Module["_lua_upvaluejoin"] = asm["_lua_upvaluejoin"];
var _luaopen_string = Module["_luaopen_string"] = asm["_luaopen_string"];
var _lua_isuserdata = Module["_lua_isuserdata"] = asm["_lua_isuserdata"];
var _luaL_loadbufferx = Module["_luaL_loadbufferx"] = asm["_luaL_loadbufferx"];
var _lua_resume = Module["_lua_resume"] = asm["_lua_resume"];
var _lua_iscfunction = Module["_lua_iscfunction"] = asm["_lua_iscfunction"];
var _luaL_newstate = Module["_luaL_newstate"] = asm["_luaL_newstate"];
var _luaL_execresult = Module["_luaL_execresult"] = asm["_luaL_execresult"];
var _lua_remove = Module["_lua_remove"] = asm["_lua_remove"];
var _luaL_checkoption = Module["_luaL_checkoption"] = asm["_luaL_checkoption"];
var _lua_rawlen = Module["_lua_rawlen"] = asm["_lua_rawlen"];
var _lua_len = Module["_lua_len"] = asm["_lua_len"];
var _luaL_openlib = Module["_luaL_openlib"] = asm["_luaL_openlib"];
var _lua_pushvfstring = Module["_lua_pushvfstring"] = asm["_lua_pushvfstring"];
var _lua_isnumber = Module["_lua_isnumber"] = asm["_lua_isnumber"];
var _luaL_checklstring = Module["_luaL_checklstring"] = asm["_luaL_checklstring"];
var _lua_isstring = Module["_lua_isstring"] = asm["_lua_isstring"];
var _lua_pushlstring = Module["_lua_pushlstring"] = asm["_lua_pushlstring"];
var _lua_setuservalue = Module["_lua_setuservalue"] = asm["_lua_setuservalue"];
var _luaL_len = Module["_luaL_len"] = asm["_luaL_len"];
var _lua_callk = Module["_lua_callk"] = asm["_lua_callk"];
var _luaL_checkany = Module["_luaL_checkany"] = asm["_luaL_checkany"];
var _luaL_addstring = Module["_luaL_addstring"] = asm["_luaL_addstring"];
var _lua_pushfstring = Module["_lua_pushfstring"] = asm["_lua_pushfstring"];
var _lua_insert = Module["_lua_insert"] = asm["_lua_insert"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _lua_tolstring = Module["_lua_tolstring"] = asm["_lua_tolstring"];
var _lua_rawset = Module["_lua_rawset"] = asm["_lua_rawset"];
var _luaL_traceback = Module["_luaL_traceback"] = asm["_luaL_traceback"];
var _lua_getupvalue = Module["_lua_getupvalue"] = asm["_lua_getupvalue"];
var _lua_checkstack = Module["_lua_checkstack"] = asm["_lua_checkstack"];
var _lua_pushnumber = Module["_lua_pushnumber"] = asm["_lua_pushnumber"];
var _luaL_pushresult = Module["_luaL_pushresult"] = asm["_luaL_pushresult"];
var _lua_topointer = Module["_lua_topointer"] = asm["_lua_topointer"];
var _lua_error = Module["_lua_error"] = asm["_lua_error"];
var _lua_gettable = Module["_lua_gettable"] = asm["_lua_gettable"];
var _luaopen_debug = Module["_luaopen_debug"] = asm["_luaopen_debug"];
var _lua_compare = Module["_lua_compare"] = asm["_lua_compare"];
var _luaL_checkinteger = Module["_luaL_checkinteger"] = asm["_luaL_checkinteger"];
var _lua_getstack = Module["_lua_getstack"] = asm["_lua_getstack"];
var _lua_gettop = Module["_lua_gettop"] = asm["_lua_gettop"];
var _lua_getlocal = Module["_lua_getlocal"] = asm["_lua_getlocal"];
var _lua_gc = Module["_lua_gc"] = asm["_lua_gc"];
var _lua_newuserdata = Module["_lua_newuserdata"] = asm["_lua_newuserdata"];
var _luaL_checkunsigned = Module["_luaL_checkunsigned"] = asm["_luaL_checkunsigned"];
var _lua_settable = Module["_lua_settable"] = asm["_lua_settable"];
var _luaL_addlstring = Module["_luaL_addlstring"] = asm["_luaL_addlstring"];
var _luaL_fileresult = Module["_luaL_fileresult"] = asm["_luaL_fileresult"];
var _lua_toboolean = Module["_lua_toboolean"] = asm["_lua_toboolean"];
var _lua_setallocf = Module["_lua_setallocf"] = asm["_lua_setallocf"];
var _memset = Module["_memset"] = asm["_memset"];
var _luaL_checktype = Module["_luaL_checktype"] = asm["_luaL_checktype"];
var _lua_tointegerx = Module["_lua_tointegerx"] = asm["_lua_tointegerx"];
var _lua_gethookcount = Module["_lua_gethookcount"] = asm["_lua_gethookcount"];
var _lua_version = Module["_lua_version"] = asm["_lua_version"];
var _lua_tounsignedx = Module["_lua_tounsignedx"] = asm["_lua_tounsignedx"];
var _luaL_openlibs = Module["_luaL_openlibs"] = asm["_luaL_openlibs"];
var _lua_setlocal = Module["_lua_setlocal"] = asm["_lua_setlocal"];
var _luaL_optunsigned = Module["_luaL_optunsigned"] = asm["_luaL_optunsigned"];
var _lua_tothread = Module["_lua_tothread"] = asm["_lua_tothread"];
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _lua_rawgetp = Module["_lua_rawgetp"] = asm["_lua_rawgetp"];
var _luaL_testudata = Module["_luaL_testudata"] = asm["_luaL_testudata"];
var _lua_newstate = Module["_lua_newstate"] = asm["_lua_newstate"];
var _lua_pushvalue = Module["_lua_pushvalue"] = asm["_lua_pushvalue"];
var _lua_getctx = Module["_lua_getctx"] = asm["_lua_getctx"];
var _lua_tocfunction = Module["_lua_tocfunction"] = asm["_lua_tocfunction"];
var _lua_newthread = Module["_lua_newthread"] = asm["_lua_newthread"];
var _lua_typename = Module["_lua_typename"] = asm["_lua_typename"];
var _luaL_argerror = Module["_luaL_argerror"] = asm["_luaL_argerror"];
var _lua_absindex = Module["_lua_absindex"] = asm["_lua_absindex"];
var _lua_rawgeti = Module["_lua_rawgeti"] = asm["_lua_rawgeti"];
var _testSetjmp = Module["_testSetjmp"] = asm["_testSetjmp"];
var _lua_sethook = Module["_lua_sethook"] = asm["_lua_sethook"];
var _luaL_callmeta = Module["_luaL_callmeta"] = asm["_luaL_callmeta"];
var _luaL_buffinit = Module["_luaL_buffinit"] = asm["_luaL_buffinit"];
var _luaL_loadfilex = Module["_luaL_loadfilex"] = asm["_luaL_loadfilex"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _lua_rawequal = Module["_lua_rawequal"] = asm["_lua_rawequal"];
var _lua_yieldk = Module["_lua_yieldk"] = asm["_lua_yieldk"];
var _lua_type = Module["_lua_type"] = asm["_lua_type"];
var _lua_getfield = Module["_lua_getfield"] = asm["_lua_getfield"];
var _luaopen_os = Module["_luaopen_os"] = asm["_luaopen_os"];
var _luaL_checkversion_ = Module["_luaL_checkversion_"] = asm["_luaL_checkversion_"];
var _luaL_buffinitsize = Module["_luaL_buffinitsize"] = asm["_luaL_buffinitsize"];
var _luaL_checknumber = Module["_luaL_checknumber"] = asm["_luaL_checknumber"];
var _luaL_newmetatable = Module["_luaL_newmetatable"] = asm["_luaL_newmetatable"];
var _lua_getmetatable = Module["_lua_getmetatable"] = asm["_lua_getmetatable"];
var _lua_pushunsigned = Module["_lua_pushunsigned"] = asm["_lua_pushunsigned"];
var _luaL_requiref = Module["_luaL_requiref"] = asm["_luaL_requiref"];
var _luaopen_base = Module["_luaopen_base"] = asm["_luaopen_base"];
var _luaL_gsub = Module["_luaL_gsub"] = asm["_luaL_gsub"];
var _luaL_addvalue = Module["_luaL_addvalue"] = asm["_luaL_addvalue"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var _luaL_tolstring = Module["_luaL_tolstring"] = asm["_luaL_tolstring"];
var _lua_atpanic = Module["_lua_atpanic"] = asm["_lua_atpanic"];
var _luaL_getmetafield = Module["_luaL_getmetafield"] = asm["_luaL_getmetafield"];
var _lua_getinfo = Module["_lua_getinfo"] = asm["_lua_getinfo"];
var _luaL_setmetatable = Module["_luaL_setmetatable"] = asm["_luaL_setmetatable"];
var _lua_settop = Module["_lua_settop"] = asm["_lua_settop"];
var _lua_pushboolean = Module["_lua_pushboolean"] = asm["_lua_pushboolean"];
var _lua_setfield = Module["_lua_setfield"] = asm["_lua_setfield"];
var _lua_replace = Module["_lua_replace"] = asm["_lua_replace"];
var _luaL_setfuncs = Module["_luaL_setfuncs"] = asm["_luaL_setfuncs"];
var _lua_next = Module["_lua_next"] = asm["_lua_next"];
var _lua_concat = Module["_lua_concat"] = asm["_lua_concat"];
var _luaL_checkudata = Module["_luaL_checkudata"] = asm["_luaL_checkudata"];
var _realloc = Module["_realloc"] = asm["_realloc"];
var _luaopen_table = Module["_luaopen_table"] = asm["_luaopen_table"];
var _luaopen_coroutine = Module["_luaopen_coroutine"] = asm["_luaopen_coroutine"];
var _luaopen_bit32 = Module["_luaopen_bit32"] = asm["_luaopen_bit32"];
var _luaL_getsubtable = Module["_luaL_getsubtable"] = asm["_luaL_getsubtable"];
var _lua_getuservalue = Module["_lua_getuservalue"] = asm["_lua_getuservalue"];
var _luaopen_package = Module["_luaopen_package"] = asm["_luaopen_package"];
var _lua_rawseti = Module["_lua_rawseti"] = asm["_lua_rawseti"];
var _saveSetjmp = Module["_saveSetjmp"] = asm["_saveSetjmp"];
var _luaL_optnumber = Module["_luaL_optnumber"] = asm["_luaL_optnumber"];
var _lua_pushinteger = Module["_lua_pushinteger"] = asm["_lua_pushinteger"];
var _lua_getallocf = Module["_lua_getallocf"] = asm["_lua_getallocf"];
var _lua_dump = Module["_lua_dump"] = asm["_lua_dump"];
var _lua_status = Module["_lua_status"] = asm["_lua_status"];
var _lua_tonumberx = Module["_lua_tonumberx"] = asm["_lua_tonumberx"];
var _luaL_where = Module["_luaL_where"] = asm["_luaL_where"];
var _lua_rawsetp = Module["_lua_rawsetp"] = asm["_lua_rawsetp"];
var _luaL_error = Module["_luaL_error"] = asm["_luaL_error"];
var _luaL_loadstring = Module["_luaL_loadstring"] = asm["_luaL_loadstring"];
var _luaL_unref = Module["_luaL_unref"] = asm["_luaL_unref"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_iiiii = Module["dynCall_iiiii"] = asm["dynCall_iiiii"];

Runtime.stackAlloc = asm['stackAlloc'];
Runtime.stackSave = asm['stackSave'];
Runtime.stackRestore = asm['stackRestore'];
Runtime.setTempRet0 = asm['setTempRet0'];
Runtime.getTempRet0 = asm['getTempRet0'];


// TODO: strip out parts of this we do not need

//======= begin closure i64 code =======

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

var i64Math = (function() { // Emscripten wrapper
  var goog = { math: {} };


  /**
   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * Javascript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within Javascript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   *
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   * @constructor
   */
  goog.math.Long = function(low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0;  // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */
    this.high_ = high | 0;  // force into 32 signed bits.
  };


  // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
  // from* methods on which they depend.


  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */
  goog.math.Long.IntCache_ = {};


  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @param {number} value The 32-bit integer in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = goog.math.Long.IntCache_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      goog.math.Long.IntCache_[value] = obj;
    }
    return obj;
  };


  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @param {number} value The number in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return goog.math.Long.ZERO;
    } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MIN_VALUE;
    } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MAX_VALUE;
    } else if (value < 0) {
      return goog.math.Long.fromNumber(-value).negate();
    } else {
      return new goog.math.Long(
          (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
          (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
  };


  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromBits = function(lowBits, highBits) {
    return new goog.math.Long(lowBits, highBits);
  };


  /**
   * Returns a Long representation of the given string, written using the given
   * radix.
   * @param {string} str The textual representation of the Long.
   * @param {number=} opt_radix The radix in which the text is written.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromString = function(str, opt_radix) {
    if (str.length == 0) {
      throw Error('number format error: empty string');
    }

    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (str.charAt(0) == '-') {
      return goog.math.Long.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf('-') >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

    var result = goog.math.Long.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = goog.math.Long.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(goog.math.Long.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(goog.math.Long.fromNumber(value));
      }
    }
    return result;
  };


  // NOTE: the compiler should inline these constant values below and then remove
  // these variables, so there should be no runtime penalty for these.


  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_32_DBL_ =
      goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_31_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ / 2;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_48_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_64_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_63_DBL_ =
      goog.math.Long.TWO_PWR_64_DBL_ / 2;


  /** @type {!goog.math.Long} */
  goog.math.Long.ZERO = goog.math.Long.fromInt(0);


  /** @type {!goog.math.Long} */
  goog.math.Long.ONE = goog.math.Long.fromInt(1);


  /** @type {!goog.math.Long} */
  goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


  /** @type {!goog.math.Long} */
  goog.math.Long.MAX_VALUE =
      goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


  /** @type {!goog.math.Long} */
  goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


  /**
   * @type {!goog.math.Long}
   * @private
   */
  goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


  /** @return {number} The value, assuming it is a 32-bit integer. */
  goog.math.Long.prototype.toInt = function() {
    return this.low_;
  };


  /** @return {number} The closest floating-point representation to this value. */
  goog.math.Long.prototype.toNumber = function() {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
           this.getLowBitsUnsigned();
  };


  /**
   * @param {number=} opt_radix The radix in which the text should be written.
   * @return {string} The textual representation of this value.
   */
  goog.math.Long.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (this.isZero()) {
      return '0';
    }

    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return '-' + this.negate().toString(radix);
      }
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

    var rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);

      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = '0' + digits;
        }
        result = '' + digits + result;
      }
    }
  };


  /** @return {number} The high 32-bits as a signed value. */
  goog.math.Long.prototype.getHighBits = function() {
    return this.high_;
  };


  /** @return {number} The low 32-bits as a signed value. */
  goog.math.Long.prototype.getLowBits = function() {
    return this.low_;
  };


  /** @return {number} The low 32-bits as an unsigned value. */
  goog.math.Long.prototype.getLowBitsUnsigned = function() {
    return (this.low_ >= 0) ?
        this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };


  /**
   * @return {number} Returns the number of bits needed to represent the absolute
   *     value of this Long.
   */
  goog.math.Long.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ != 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & (1 << bit)) != 0) {
          break;
        }
      }
      return this.high_ != 0 ? bit + 33 : bit + 1;
    }
  };


  /** @return {boolean} Whether this value is zero. */
  goog.math.Long.prototype.isZero = function() {
    return this.high_ == 0 && this.low_ == 0;
  };


  /** @return {boolean} Whether this value is negative. */
  goog.math.Long.prototype.isNegative = function() {
    return this.high_ < 0;
  };


  /** @return {boolean} Whether this value is odd. */
  goog.math.Long.prototype.isOdd = function() {
    return (this.low_ & 1) == 1;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */
  goog.math.Long.prototype.equals = function(other) {
    return (this.high_ == other.high_) && (this.low_ == other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long does not equal the other.
   */
  goog.math.Long.prototype.notEquals = function(other) {
    return (this.high_ != other.high_) || (this.low_ != other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */
  goog.math.Long.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than or equal to the other.
   */
  goog.math.Long.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than the other.
   */
  goog.math.Long.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */
  goog.math.Long.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };


  /**
   * Compares this Long with the given one.
   * @param {goog.math.Long} other Long to compare against.
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */
  goog.math.Long.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }

    // at this point, the signs are the same, so subtraction will not overflow
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };


  /** @return {!goog.math.Long} The negation of this value. */
  goog.math.Long.prototype.negate = function() {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.MIN_VALUE;
    } else {
      return this.not().add(goog.math.Long.ONE);
    }
  };


  /**
   * Returns the sum of this and the given Long.
   * @param {goog.math.Long} other Long to add to this one.
   * @return {!goog.math.Long} The sum of this and the given Long.
   */
  goog.math.Long.prototype.add = function(other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns the difference of this and the given Long.
   * @param {goog.math.Long} other Long to subtract from this.
   * @return {!goog.math.Long} The difference of this and the given Long.
   */
  goog.math.Long.prototype.subtract = function(other) {
    return this.add(other.negate());
  };


  /**
   * Returns the product of this and the given long.
   * @param {goog.math.Long} other Long to multiply with this.
   * @return {!goog.math.Long} The product of this and the other.
   */
  goog.math.Long.prototype.multiply = function(other) {
    if (this.isZero()) {
      return goog.math.Long.ZERO;
    } else if (other.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }

    // If both longs are small, use float multiplication
    if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
        other.lessThan(goog.math.Long.TWO_PWR_24_)) {
      return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
    }

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns this Long divided by the given one.
   * @param {goog.math.Long} other Long by which to divide.
   * @return {!goog.math.Long} This Long divided by the given one.
   */
  goog.math.Long.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error('division by zero');
    } else if (this.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      if (other.equals(goog.math.Long.ONE) ||
          other.equals(goog.math.Long.NEG_ONE)) {
        return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      } else if (other.equals(goog.math.Long.MIN_VALUE)) {
        return goog.math.Long.ONE;
      } else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(goog.math.Long.ZERO)) {
          return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.greaterThanOrEqual(other)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      var approxRes = goog.math.Long.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = goog.math.Long.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) {
        approxRes = goog.math.Long.ONE;
      }

      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };


  /**
   * Returns this Long modulo the given one.
   * @param {goog.math.Long} other Long by which to mod.
   * @return {!goog.math.Long} This Long modulo the given one.
   */
  goog.math.Long.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };


  /** @return {!goog.math.Long} The bitwise-NOT of this value. */
  goog.math.Long.prototype.not = function() {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };


  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to AND.
   * @return {!goog.math.Long} The bitwise-AND of this and the other.
   */
  goog.math.Long.prototype.and = function(other) {
    return goog.math.Long.fromBits(this.low_ & other.low_,
                                   this.high_ & other.high_);
  };


  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to OR.
   * @return {!goog.math.Long} The bitwise-OR of this and the other.
   */
  goog.math.Long.prototype.or = function(other) {
    return goog.math.Long.fromBits(this.low_ | other.low_,
                                   this.high_ | other.high_);
  };


  /**
   * Returns the bitwise-XOR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to XOR.
   * @return {!goog.math.Long} The bitwise-XOR of this and the other.
   */
  goog.math.Long.prototype.xor = function(other) {
    return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                   this.high_ ^ other.high_);
  };


  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the left by the given amount.
   */
  goog.math.Long.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return goog.math.Long.fromBits(
            low << numBits,
            (high << numBits) | (low >>> (32 - numBits)));
      } else {
        return goog.math.Long.fromBits(0, low << (numBits - 32));
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount.
   */
  goog.math.Long.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >> numBits);
      } else {
        return goog.math.Long.fromBits(
            high >> (numBits - 32),
            high >= 0 ? 0 : -1);
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */
  goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits);
      } else if (numBits == 32) {
        return goog.math.Long.fromBits(high, 0);
      } else {
        return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
      }
    }
  };

  //======= begin jsbn =======

  var navigator = { appName: 'Modern Browser' }; // polyfill a little

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // http://www-cs-students.stanford.edu/~tjw/jsbn/

  /*
   * Copyright (c) 2003-2005  Tom Wu
   * All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   */

  // Basic JavaScript BN library - subset useful for RSA encryption.

  // Bits per digit
  var dbits;

  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary&0xffffff)==0xefcafe);

  // (public) Constructor
  function BigInteger(a,b,c) {
    if(a != null)
      if("number" == typeof a) this.fromNumber(a,b,c);
      else if(b == null && "string" != typeof a) this.fromString(a,256);
      else this.fromString(a,b);
  }

  // return new, unset BigInteger
  function nbi() { return new BigInteger(null); }

  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.

  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i,x,w,j,c,n) {
    while(--n >= 0) {
      var v = x*this[i++]+w[j]+c;
      c = Math.floor(v/0x4000000);
      w[j++] = v&0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i,x,w,j,c,n) {
    var xl = x&0x7fff, xh = x>>15;
    while(--n >= 0) {
      var l = this[i]&0x7fff;
      var h = this[i++]>>15;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
      c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
      w[j++] = l&0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i,x,w,j,c,n) {
    var xl = x&0x3fff, xh = x>>14;
    while(--n >= 0) {
      var l = this[i]&0x3fff;
      var h = this[i++]>>14;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x3fff)<<14)+w[j]+c;
      c = (l>>28)+(m>>14)+xh*h;
      w[j++] = l&0xfffffff;
    }
    return c;
  }
  if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if(j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }

  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1<<dbits)-1);
  BigInteger.prototype.DV = (1<<dbits);

  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2,BI_FP);
  BigInteger.prototype.F1 = BI_FP-dbits;
  BigInteger.prototype.F2 = 2*dbits-BI_FP;

  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr,vv;
  rr = "0".charCodeAt(0);
  for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n) { return BI_RM.charAt(n); }
  function intAt(s,i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c==null)?-1:c;
  }

  // (protected) copy this to r
  function bnpCopyTo(r) {
    for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }

  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x) {
    this.t = 1;
    this.s = (x<0)?-1:0;
    if(x > 0) this[0] = x;
    else if(x < -1) this[0] = x+DV;
    else this.t = 0;
  }

  // return bigint initialized to value
  function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

  // (protected) set from string and radix
  function bnpFromString(s,b) {
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 256) k = 8; // byte array
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else { this.fromRadix(s,b); return; }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while(--i >= 0) {
      var x = (k==8)?s[i]&0xff:intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if(sh == 0)
        this[this.t++] = x;
      else if(sh+k > this.DB) {
        this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
        this[this.t++] = (x>>(this.DB-sh));
      }
      else
        this[this.t-1] |= x<<sh;
      sh += k;
      if(sh >= this.DB) sh -= this.DB;
    }
    if(k == 8 && (s[0]&0x80) != 0) {
      this.s = -1;
      if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
    }
    this.clamp();
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) clamp off excess high words
  function bnpClamp() {
    var c = this.s&this.DM;
    while(this.t > 0 && this[this.t-1] == c) --this.t;
  }

  // (public) return string representation in given radix
  function bnToString(b) {
    if(this.s < 0) return "-"+this.negate().toString(b);
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1<<k)-1, d, m = false, r = "", i = this.t;
    var p = this.DB-(i*this.DB)%k;
    if(i-- > 0) {
      if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
      while(i >= 0) {
        if(p < k) {
          d = (this[i]&((1<<p)-1))<<(k-p);
          d |= this[--i]>>(p+=this.DB-k);
        }
        else {
          d = (this[i]>>(p-=k))&km;
          if(p <= 0) { p += this.DB; --i; }
        }
        if(d > 0) m = true;
        if(m) r += int2char(d);
      }
    }
    return m?r:"0";
  }

  // (public) -this
  function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

  // (public) |this|
  function bnAbs() { return (this.s<0)?this.negate():this; }

  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a) {
    var r = this.s-a.s;
    if(r != 0) return r;
    var i = this.t;
    r = i-a.t;
    if(r != 0) return (this.s<0)?-r:r;
    while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
    return 0;
  }

  // returns bit length of the integer x
  function nbits(x) {
    var r = 1, t;
    if((t=x>>>16) != 0) { x = t; r += 16; }
    if((t=x>>8) != 0) { x = t; r += 8; }
    if((t=x>>4) != 0) { x = t; r += 4; }
    if((t=x>>2) != 0) { x = t; r += 2; }
    if((t=x>>1) != 0) { x = t; r += 1; }
    return r;
  }

  // (public) return the number of bits in "this"
  function bnBitLength() {
    if(this.t <= 0) return 0;
    return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
  }

  // (protected) r = this << n*DB
  function bnpDLShiftTo(n,r) {
    var i;
    for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
    for(i = n-1; i >= 0; --i) r[i] = 0;
    r.t = this.t+n;
    r.s = this.s;
  }

  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n,r) {
    for(var i = n; i < this.t; ++i) r[i-n] = this[i];
    r.t = Math.max(this.t-n,0);
    r.s = this.s;
  }

  // (protected) r = this << n
  function bnpLShiftTo(n,r) {
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<cbs)-1;
    var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
    for(i = this.t-1; i >= 0; --i) {
      r[i+ds+1] = (this[i]>>cbs)|c;
      c = (this[i]&bm)<<bs;
    }
    for(i = ds-1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t+ds+1;
    r.s = this.s;
    r.clamp();
  }

  // (protected) r = this >> n
  function bnpRShiftTo(n,r) {
    r.s = this.s;
    var ds = Math.floor(n/this.DB);
    if(ds >= this.t) { r.t = 0; return; }
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<bs)-1;
    r[0] = this[ds]>>bs;
    for(var i = ds+1; i < this.t; ++i) {
      r[i-ds-1] |= (this[i]&bm)<<cbs;
      r[i-ds] = this[i]>>bs;
    }
    if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
    r.t = this.t-ds;
    r.clamp();
  }

  // (protected) r = this - a
  function bnpSubTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]-a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c -= a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c -= a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c<0)?-1:0;
    if(c < -1) r[i++] = this.DV+c;
    else if(c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }

  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a,r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i+y.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
    r.s = 0;
    r.clamp();
    if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
  }

  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2*x.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < x.t-1; ++i) {
      var c = x.am(i,x[i],r,2*i,0,1);
      if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
        r[i+x.t] -= x.DV;
        r[i+x.t+1] = 1;
      }
    }
    if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
    r.s = 0;
    r.clamp();
  }

  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m,q,r) {
    var pm = m.abs();
    if(pm.t <= 0) return;
    var pt = this.abs();
    if(pt.t < pm.t) {
      if(q != null) q.fromInt(0);
      if(r != null) this.copyTo(r);
      return;
    }
    if(r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
    if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
    else { pm.copyTo(y); pt.copyTo(r); }
    var ys = y.t;
    var y0 = y[ys-1];
    if(y0 == 0) return;
    var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
    var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
    var i = r.t, j = i-ys, t = (q==null)?nbi():q;
    y.dlShiftTo(j,t);
    if(r.compareTo(t) >= 0) {
      r[r.t++] = 1;
      r.subTo(t,r);
    }
    BigInteger.ONE.dlShiftTo(ys,t);
    t.subTo(y,y);	// "negative" y so we can replace sub with am later
    while(y.t < ys) y[y.t++] = 0;
    while(--j >= 0) {
      // Estimate quotient digit
      var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
      if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
        y.dlShiftTo(j,t);
        r.subTo(t,r);
        while(r[i] < --qd) r.subTo(t,r);
      }
    }
    if(q != null) {
      r.drShiftTo(ys,q);
      if(ts != ms) BigInteger.ZERO.subTo(q,q);
    }
    r.t = ys;
    r.clamp();
    if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
    if(ts < 0) BigInteger.ZERO.subTo(r,r);
  }

  // (public) this mod a
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a,null,r);
    if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
    return r;
  }

  // Modular reduction using "classic" algorithm
  function Classic(m) { this.m = m; }
  function cConvert(x) {
    if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }
  function cRevert(x) { return x; }
  function cReduce(x) { x.divRemTo(this.m,null,x); }
  function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
  function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;

  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit() {
    if(this.t < 1) return 0;
    var x = this[0];
    if((x&1) == 0) return 0;
    var y = x&3;		// y == 1/x mod 2^2
    y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
    y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
    y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y>0)?this.DV-y:-y;
  }

  // Montgomery reduction
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp&0x7fff;
    this.mph = this.mp>>15;
    this.um = (1<<(m.DB-15))-1;
    this.mt2 = 2*m.t;
  }

  // xR mod m
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t,r);
    r.divRemTo(this.m,null,r);
    if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
    return r;
  }

  // x/R mod m
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }

  // x = x/R mod m (HAC 14.32)
  function montReduce(x) {
    while(x.t <= this.mt2)	// pad x so am has enough room later
      x[x.t++] = 0;
    for(var i = 0; i < this.m.t; ++i) {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i]&0x7fff;
      var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i+this.m.t;
      x[j] += this.m.am(0,u0,x,i,0,this.m.t);
      // propagate carry
      while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
    }
    x.clamp();
    x.drShiftTo(this.m.t,x);
    if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
  }

  // r = "x^2/R mod m"; x != r
  function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  // r = "xy/R mod m"; x,y != r
  function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;

  // (protected) true iff this is even
  function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e,z) {
    if(e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
    g.copyTo(r);
    while(--i >= 0) {
      z.sqrTo(r,r2);
      if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
      else { var t = r; r = r2; r2 = t; }
    }
    return z.revert(r);
  }

  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e,m) {
    var z;
    if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e,z);
  }

  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;

  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;

  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);

  // jsbn2 stuff

  // (protected) convert from radix string
  function bnpFromRadix(s,b) {
    this.fromInt(0);
    if(b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
    for(var i = 0; i < s.length; ++i) {
      var x = intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b*w+x;
      if(++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w,0);
        j = 0;
        w = 0;
      }
    }
    if(j > 0) {
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum() {
    if(this.s < 0) return -1;
    else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }

  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n) {
    this[this.t] = this.am(0,n-1,this,0,0,this.t);
    ++this.t;
    this.clamp();
  }

  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n,w) {
    if(n == 0) return;
    while(this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while(this[w] >= this.DV) {
      this[w] -= this.DV;
      if(++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }

  // (protected) convert to radix string
  function bnpToRadix(b) {
    if(b == null) b = 10;
    if(this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b,cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d,y,z);
    while(y.signum() > 0) {
      r = (a+z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d,y,z);
    }
    return z.intValue().toString(b) + r;
  }

  // (public) return value as integer
  function bnIntValue() {
    if(this.s < 0) {
      if(this.t == 1) return this[0]-this.DV;
      else if(this.t == 0) return -1;
    }
    else if(this.t == 1) return this[0];
    else if(this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
  }

  // (protected) r = this + a
  function bnpAddTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]+a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c += a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c += a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c<0)?-1:0;
    if(c > 0) r[i++] = c;
    else if(c < -1) r[i++] = this.DV+c;
    r.t = i;
    r.clamp();
  }

  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.addTo = bnpAddTo;

  //======= end jsbn =======

  // Emscripten wrapper
  var Wrapper = {
    abs: function(l, h) {
      var x = new goog.math.Long(l, h);
      var ret;
      if (x.isNegative()) {
        ret = x.negate();
      } else {
        ret = x;
      }
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
    },
    ensureTemps: function() {
      if (Wrapper.ensuredTemps) return;
      Wrapper.ensuredTemps = true;
      Wrapper.two32 = new BigInteger();
      Wrapper.two32.fromString('4294967296', 10);
      Wrapper.two64 = new BigInteger();
      Wrapper.two64.fromString('18446744073709551616', 10);
      Wrapper.temp1 = new BigInteger();
      Wrapper.temp2 = new BigInteger();
    },
    lh2bignum: function(l, h) {
      var a = new BigInteger();
      a.fromString(h.toString(), 10);
      var b = new BigInteger();
      a.multiplyTo(Wrapper.two32, b);
      var c = new BigInteger();
      c.fromString(l.toString(), 10);
      var d = new BigInteger();
      c.addTo(b, d);
      return d;
    },
    stringify: function(l, h, unsigned) {
      var ret = new goog.math.Long(l, h).toString();
      if (unsigned && ret[0] == '-') {
        // unsign slowly using jsbn bignums
        Wrapper.ensureTemps();
        var bignum = new BigInteger();
        bignum.fromString(ret, 10);
        ret = new BigInteger();
        Wrapper.two64.addTo(bignum, ret);
        ret = ret.toString(10);
      }
      return ret;
    },
    fromString: function(str, base, min, max, unsigned) {
      Wrapper.ensureTemps();
      var bignum = new BigInteger();
      bignum.fromString(str, base);
      var bigmin = new BigInteger();
      bigmin.fromString(min, 10);
      var bigmax = new BigInteger();
      bigmax.fromString(max, 10);
      if (unsigned && bignum.compareTo(BigInteger.ZERO) < 0) {
        var temp = new BigInteger();
        bignum.addTo(Wrapper.two64, temp);
        bignum = temp;
      }
      var error = false;
      if (bignum.compareTo(bigmin) < 0) {
        bignum = bigmin;
        error = true;
      } else if (bignum.compareTo(bigmax) > 0) {
        bignum = bigmax;
        error = true;
      }
      var ret = goog.math.Long.fromString(bignum.toString()); // min-max checks should have clamped this to a range goog.math.Long can handle well
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
      if (error) throw 'range error';
    }
  };
  return Wrapper;
})();

//======= end closure i64 code =======



// === Auto-generated postamble setup entry stuff ===

if (memoryInitializer) {
  if (typeof Module['locateFile'] === 'function') {
    memoryInitializer = Module['locateFile'](memoryInitializer);
  } else if (Module['memoryInitializerPrefixURL']) {
    memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, STATIC_BASE);
  } else {
    addRunDependency('memory initializer');
    Browser.asyncLoad(memoryInitializer, function(data) {
      HEAPU8.set(data, STATIC_BASE);
      removeRunDependency('memory initializer');
    }, function(data) {
      throw 'could not load memory initializer ' + memoryInitializer;
    });
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun'] && shouldRunNow) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString(Module['thisProgram']), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    exit(ret);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return; 

    ensureInitRuntime();

    preMain();

    if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
      Module.printErr('pre-main prep time: ' + (Date.now() - preloadStartTime) + ' ms');
    }

    if (Module['_main'] && shouldRunNow) {
      Module['callMain'](args);
    }

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status) {
  if (Module['noExitRuntime']) {
    return;
  }

  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;

  // exit the runtime
  exitRuntime();

  if (ENVIRONMENT_IS_NODE) {
    // Work around a node.js bug where stdout buffer is not flushed at process exit:
    // Instead of process.exit() directly, wait for stdout flush event.
    // See https://github.com/joyent/node/issues/1669 and https://github.com/kripken/emscripten/issues/2582
    // Workaround is based on https://github.com/RReverser/acorn/commit/50ab143cecc9ed71a2d66f78b4aec3bb2e9844f6
    process['stdout']['once']('drain', function () {
      process['exit'](status);
    });
    console.log(' '); // Make sure to print something to force the drain event to occur, in case the stdout buffer was empty.
    // Work around another node bug where sometimes 'drain' is never fired - make another effort
    // to emit the exit status, after a significant delay (if node hasn't fired drain by then, give up)
    setTimeout(function() {
      process['exit'](status);
    }, 500);
  } else
  if (ENVIRONMENT_IS_SHELL && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

function abort(text) {
  if (text) {
    Module.print(text);
    Module.printErr(text);
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.';

  throw 'abort() at ' + stackTrace() + extra;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = false;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

Module["noExitRuntime"] = true;

run();

// {{POST_RUN_ADDITIONS}}






// {{MODULE_ADDITIONS}}






//# sourceMappingURL=lua.vm.js.map